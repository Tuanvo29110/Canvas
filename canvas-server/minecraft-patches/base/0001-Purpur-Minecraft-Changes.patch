From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Toffikk <slodkitofik@gmail.com>
Date: Sat, 12 Jul 2025 00:36:41 +0200
Subject: [PATCH] Purpur Minecraft Changes


diff --git a/io/papermc/paper/entity/activation/ActivationRange.java b/io/papermc/paper/entity/activation/ActivationRange.java
index c0d23b0b5adca79ce451da8cca16dc3aeac2c799..a5ffe54549764bdd76740c452128a124b3543e21 100644
--- a/io/papermc/paper/entity/activation/ActivationRange.java
+++ b/io/papermc/paper/entity/activation/ActivationRange.java
@@ -149,6 +149,8 @@ public final class ActivationRange {
                 continue;
             }
 
+            if (!player.level().purpurConfig.idleTimeoutTickNearbyEntities && player.isAfk()) continue; // Purpur - AFK API
+
             final int worldHeight = world.getHeight();
             final AABB maxBB = player.getBoundingBox().inflate(maxRange, worldHeight, maxRange); // Folia - threaded regions
             final AABB[] bbByType = new AABB[ActivationType.values().length]; // Folia - threaded regions
@@ -298,6 +300,7 @@ public final class ActivationRange {
      * @return
      */
     public static boolean checkIfActive(final Entity entity) {
+        if (entity.level().purpurConfig.squidImmuneToEAR && entity instanceof net.minecraft.world.entity.animal.Squid) return true; // Purpur - Squid EAR immunity
         // Never safe to skip fireworks or item gravity
         if (entity instanceof FireworkRocketEntity || (entity instanceof ItemEntity && (entity.tickCount + entity.getId()) % 4 == 0)) { // Needed for item gravity, see ItemEntity tick
             return true;
diff --git a/io/papermc/paper/threadedregions/RegionizedServer.java b/io/papermc/paper/threadedregions/RegionizedServer.java
index 8e91ec81128bdbd5f78e1f04fe17bcbd6e5dc280..9a7a326ff8b5da72705dabc6699fa8ede423d82e 100644
--- a/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -456,6 +456,13 @@ public final class RegionizedServer {
     private void tickTime(final ServerLevel world, final int tickCount) {
         if (world.tickTime) {
             if (world.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {
+                // Purpur start - Configurable daylight cycle (doesnt work on folia, todo?)
+                int incrementTicks = world.isBrightOutside() ? world.purpurConfig.daytimeTicks : world.purpurConfig.nighttimeTicks;
+                if (incrementTicks != 12000) {
+                    world.preciseTime += 12000 / (double) incrementTicks;
+                    world.setDayTime(world.preciseTime);
+                } else
+                // Purpur end - Configurable daylight cycle
                 world.setDayTime(world.levelData.getDayTime() + (long)tickCount);
             }
             world.serverLevelData.setGameTime(world.serverLevelData.getGameTime() + (long)tickCount);
@@ -465,4 +472,4 @@ public final class RegionizedServer {
     public static final record WorldLevelData(ServerLevel world, long nonRedstoneGameTime, long dayTime) {
 
     }
-}
\ No newline at end of file
+}
diff --git a/io/papermc/paper/threadedregions/RegionizedWorldData.java b/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 01ea2e7133a41f1a75169c7e3edbd528b268412b..cd4f20233966435fae930ed7edc7cfbdcd0e97a8 100644
--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -390,6 +390,7 @@ public final class RegionizedWorldData {
     // From ServerLevel
     public boolean hasPhysicsEvent = true; // Paper
     public boolean hasEntityMoveEvent = false; // Paper
+    public boolean hasRidableMoveEvent = false; // Purpur - Ridables (moved from ServerLevel too)
     // Paper start - Optimize Hoppers
     public boolean skipPullModeEventFire = false;
     public boolean skipPushModeEventFire = false;
@@ -481,6 +482,7 @@ public final class RegionizedWorldData {
         this.hasPhysicsEvent = org.bukkit.event.block.BlockPhysicsEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - BlockPhysicsEvent
         this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
         this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
+        this.hasRidableMoveEvent = org.purpurmc.purpur.event.entity.RidableMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Purpur - Ridables
         // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
         this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.TIME_BETWEEN_TICKS;
     }
diff --git a/net/minecraft/CrashReport.java b/net/minecraft/CrashReport.java
index 3e0e88afcf010d9a3d46e48bca5cbdf98fe97544..394443d00e661715439be1e56dddc129947699a4 100644
--- a/net/minecraft/CrashReport.java
+++ b/net/minecraft/CrashReport.java
@@ -30,6 +30,7 @@ public class CrashReport {
     private boolean trackingStackTrace = true;
     private StackTraceElement[] uncategorizedStackTrace = new StackTraceElement[0];
     private final SystemReport systemReport = new SystemReport();
+    private List<String> extraInfo = List.of("", "DO NOT REPORT THIS TO PAPER! REPORT TO PURPUR INSTEAD!", ""); // Purpur - Rebrand
 
     public CrashReport(String title, Throwable exception) {
         io.papermc.paper.util.StacktraceDeobfuscator.INSTANCE.deobfuscateThrowable(exception); // Paper
@@ -130,7 +131,7 @@ public class CrashReport {
     }
 
     public String getFriendlyReport(ReportType type) {
-        return this.getFriendlyReport(type, List.of());
+        return this.getFriendlyReport(type, extraInfo); // Purpur - Rebrand
     }
 
     @Nullable
@@ -161,7 +162,7 @@ public class CrashReport {
     }
 
     public boolean saveToFile(Path path, ReportType type) {
-        return this.saveToFile(path, type, List.of());
+        return this.saveToFile(path, type, extraInfo); // Purpur - Rebrand
     }
 
     public SystemReport getSystemReport() {
diff --git a/net/minecraft/commands/CommandSourceStack.java b/net/minecraft/commands/CommandSourceStack.java
index 8c005a7b9480da7c124c5bd5bfccd5ca83abbcb1..f075b9f266e3198cd898443421f03e165384a041 100644
--- a/net/minecraft/commands/CommandSourceStack.java
+++ b/net/minecraft/commands/CommandSourceStack.java
@@ -447,6 +447,19 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
     }
     // CraftBukkit end
 
+    // Purpur start - Gamemode extra permissions
+    public boolean testPermission(int i, String bukkitPermission) {
+        if (hasPermission(i, bukkitPermission)) {
+            return true;
+        }
+        net.kyori.adventure.text.Component permissionMessage = getLevel().getServer().server.permissionMessage();
+        if (!permissionMessage.equals(net.kyori.adventure.text.Component.empty())) {
+            sendFailure(io.papermc.paper.adventure.PaperAdventure.asVanilla(permissionMessage.replaceText(net.kyori.adventure.text.TextReplacementConfig.builder().matchLiteral("<permission>").replacement(bukkitPermission).build())));
+        }
+        return false;
+    }
+    // Purpur end - Gamemode extra permissions
+
     public Vec3 getPosition() {
         return this.worldPosition;
     }
@@ -532,6 +545,30 @@ public class CommandSourceStack implements ExecutionCommandSource<CommandSourceS
         }
     }
 
+    // Purpur start - Purpur config files
+    public void sendSuccess(@Nullable String message) {
+        sendSuccess(message, false);
+    }
+
+    public void sendSuccess(@Nullable String message, boolean broadcastToOps) {
+        if (message == null) {
+            return;
+        }
+        sendSuccess(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message), broadcastToOps);
+    }
+
+    public void sendSuccess(@Nullable net.kyori.adventure.text.Component message) {
+        sendSuccess(message, false);
+    }
+
+    public void sendSuccess(@Nullable net.kyori.adventure.text.Component message, boolean broadcastToOps) {
+        if (message == null) {
+            return;
+        }
+        sendSuccess(() -> io.papermc.paper.adventure.PaperAdventure.asVanilla(message), broadcastToOps);
+    }
+    // Purpur end - Purpur config files
+
     public void sendSuccess(Supplier<Component> messageSupplier, boolean allowLogging) {
         boolean flag = this.source.acceptsSuccess() && !this.silent;
         boolean flag1 = allowLogging && this.source.shouldInformAdmins() && !this.silent;
diff --git a/net/minecraft/commands/Commands.java b/net/minecraft/commands/Commands.java
index ad19e9e599b26dfdb53929d9410860cb1b97698c..bb49742b07aad9d1cbcfc5f18d5bd6750c593fc8 100644
--- a/net/minecraft/commands/Commands.java
+++ b/net/minecraft/commands/Commands.java
@@ -252,7 +252,7 @@ public class Commands {
             JfrCommand.register(this.dispatcher);
         }
 
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands || SharedConstants.IS_RUNNING_IN_IDE) { // Purpur - register minecraft debug commands
             RaidCommand.register(this.dispatcher, context);
             DebugPathCommand.register(this.dispatcher);
             DebugMobSpawningCommand.register(this.dispatcher);
@@ -264,6 +264,12 @@ public class Commands {
             }
         }
 
+        // Purpur start - register disabled minecraft commands
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDisabledCommands) {
+            net.minecraft.server.commands.ChaseCommand.register(this.dispatcher);
+        }
+        // Purpur end - register disabled minecraft commands
+
         if (selection.includeDedicated) {
             BanIpCommands.register(this.dispatcher);
             BanListCommands.register(this.dispatcher);
@@ -280,6 +286,14 @@ public class Commands {
             StopCommand.register(this.dispatcher);
             TransferCommand.register(this.dispatcher);
             WhitelistCommand.register(this.dispatcher);
+            org.purpurmc.purpur.command.CreditsCommand.register(this.dispatcher); // Purpur - Add credits command
+            org.purpurmc.purpur.command.DemoCommand.register(this.dispatcher); // Purpur - Add demo command
+            org.purpurmc.purpur.command.PingCommand.register(this.dispatcher); // Purpur - Add ping command
+            org.purpurmc.purpur.command.UptimeCommand.register(this.dispatcher); // Purpur - Add uptime command
+            org.purpurmc.purpur.command.TPSBarCommand.register(this.dispatcher); // Purpur - Implement TPSBar
+            org.purpurmc.purpur.command.CompassCommand.register(this.dispatcher); // Purpur - Add compass command
+            org.purpurmc.purpur.command.RamBarCommand.register(this.dispatcher); // Purpur - Add rambar command
+            org.purpurmc.purpur.command.RamCommand.register(this.dispatcher); // Purpur - Add ram command
         }
 
         if (selection.includeIntegrated) {
@@ -507,6 +521,7 @@ public class Commands {
     private void runSync(ServerPlayer player, java.util.Collection<String> bukkit, RootCommandNode<CommandSourceStack> rootCommandNode) {
         // Paper end - Perf: Async command map building
         new com.destroystokyo.paper.event.brigadier.AsyncPlayerSendCommandsEvent<CommandSourceStack>(player.getBukkitEntity(), (RootCommandNode) rootCommandNode, true).callEvent(); // Paper - Brigadier API
+        if (org.bukkit.event.player.PlayerCommandSendEvent.getHandlerList().getRegisteredListeners().length > 0) { // Purpur - Skip events if there's no listeners
         org.bukkit.event.player.PlayerCommandSendEvent event = new org.bukkit.event.player.PlayerCommandSendEvent(player.getBukkitEntity(), new java.util.LinkedHashSet<>(bukkit));
         event.getPlayer().getServer().getPluginManager().callEvent(event);
 
@@ -517,6 +532,8 @@ public class Commands {
             }
         }
         // CraftBukkit end
+        } // Purpur - Skip events if there's no listeners
+
         player.connection.send(new ClientboundCommandsPacket(rootCommandNode, COMMAND_NODE_INSPECTOR));
     }
 
diff --git a/net/minecraft/commands/arguments/selector/EntitySelector.java b/net/minecraft/commands/arguments/selector/EntitySelector.java
index 514f8fbdeb776087608665c35de95294aadf5cf0..b305ba9bab617bf4e52d0e6ddf160bacc5751a94 100644
--- a/net/minecraft/commands/arguments/selector/EntitySelector.java
+++ b/net/minecraft/commands/arguments/selector/EntitySelector.java
@@ -192,26 +192,27 @@ public class EntitySelector {
         this.checkPermissions(source);
         if (this.playerName != null) {
             ServerPlayer playerByName = source.getServer().getPlayerList().getPlayerByName(this.playerName);
-            return playerByName == null ? List.of() : List.of(playerByName);
+            return playerByName == null || !canSee(source, playerByName) ? List.of() : List.of(playerByName); // Purpur - Hide hidden players from entity selector
         } else if (this.entityUUID != null) {
             ServerPlayer playerByName = source.getServer().getPlayerList().getPlayer(this.entityUUID);
-            return playerByName == null ? List.of() : List.of(playerByName);
+            return playerByName == null || !canSee(source, playerByName) ? List.of() : List.of(playerByName); // Purpur - Hide hidden players from entity selector
         } else {
             Vec3 vec3 = this.position.apply(source.getPosition());
             AABB absoluteAabb = this.getAbsoluteAabb(vec3);
             Predicate<Entity> predicate = this.getPredicate(vec3, absoluteAabb, null);
             if (this.currentEntity) {
-                return source.getEntity() instanceof ServerPlayer serverPlayer && predicate.test(serverPlayer) ? List.of(serverPlayer) : List.of();
+                return source.getEntity() instanceof ServerPlayer serverPlayer && predicate.test(serverPlayer) && canSee(source, serverPlayer) ? List.of(serverPlayer) : List.of(); // Purpur - Hide hidden players from entity selector
             } else {
                 int resultLimit = this.getResultLimit();
                 List<ServerPlayer> players;
                 if (this.isWorldLimited()) {
                     players = source.getLevel().getPlayers(predicate, resultLimit);
+                    players.removeIf(entityplayer3 -> !canSee(source, entityplayer3)); // Purpur - Hide hidden players from entity selector
                 } else {
                     players = new ObjectArrayList<>();
 
                     for (ServerPlayer serverPlayer1 : source.getServer().getPlayerList().getPlayers()) {
-                        if (predicate.test(serverPlayer1)) {
+                        if (predicate.test(serverPlayer1) && canSee(source, serverPlayer1)) { // Purpur - Hide hidden players from entity selector
                             players.add(serverPlayer1);
                             if (players.size() >= resultLimit) {
                                 return players;
@@ -270,4 +271,10 @@ public class EntitySelector {
     public static Component joinNames(List<? extends Entity> names) {
         return ComponentUtils.formatList(names, Entity::getDisplayName);
     }
+
+    // Purpur start - Hide hidden players from entity selector
+    private boolean canSee(CommandSourceStack sender, ServerPlayer target) {
+        return !org.purpurmc.purpur.PurpurConfig.hideHiddenPlayersFromEntitySelector || !(sender.getEntity() instanceof ServerPlayer player) || player.getBukkitEntity().canSee(target.getBukkitEntity());
+    }
+    // Purpur end - Hide hidden players from entity selector
 }
diff --git a/net/minecraft/core/BlockPos.java b/net/minecraft/core/BlockPos.java
index a81694a22e94cca6f7110f7d5b205d1303f4e071..6518d3fff6daf331b24a7bf5b39fa1920b73711d 100644
--- a/net/minecraft/core/BlockPos.java
+++ b/net/minecraft/core/BlockPos.java
@@ -63,6 +63,12 @@ public class BlockPos extends Vec3i {
     public static final int MAX_HORIZONTAL_COORDINATE = 33554431;
     // Paper end - Optimize Bit Operations by inlining
 
+    // Purpur start - Ridables
+    public BlockPos(net.minecraft.world.entity.Entity entity) {
+        super(entity.getBlockX(), entity.getBlockY(), entity.getBlockZ());
+    }
+    // Purpur end - Ridables
+
     public BlockPos(int x, int y, int z) {
         super(x, y, z);
     }
diff --git a/net/minecraft/core/dispenser/DispenseItemBehavior.java b/net/minecraft/core/dispenser/DispenseItemBehavior.java
index 8a147ec57497318851ebabcea220bc8ac4ab3543..e08595b552ccc4124220720ce66ad5991da9f095 100644
--- a/net/minecraft/core/dispenser/DispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/DispenseItemBehavior.java
@@ -736,5 +736,22 @@ public interface DispenseItemBehavior {
         DispenserBlock.registerBehavior(Items.TNT_MINECART, new MinecartDispenseItemBehavior(EntityType.TNT_MINECART));
         DispenserBlock.registerBehavior(Items.HOPPER_MINECART, new MinecartDispenseItemBehavior(EntityType.HOPPER_MINECART));
         DispenserBlock.registerBehavior(Items.COMMAND_BLOCK_MINECART, new MinecartDispenseItemBehavior(EntityType.COMMAND_BLOCK_MINECART));
+        // Purpur start - Dispensers place anvils option
+        DispenserBlock.registerBehavior(Items.ANVIL, (new OptionalDispenseItemBehavior() {
+            @Override
+            public ItemStack execute(BlockSource dispenser, ItemStack stack) {
+                net.minecraft.world.level.Level level = dispenser.level();
+                if (!level.purpurConfig.dispenserPlaceAnvils) return super.execute(dispenser, stack);
+                Direction facing = dispenser.blockEntity().getBlockState().getValue(DispenserBlock.FACING);
+                BlockPos pos = dispenser.pos().relative(facing);
+                BlockState state = level.getBlockState(pos);
+                if (state.isAir()) {
+                    level.setBlockAndUpdate(pos, Blocks.ANVIL.defaultBlockState().setValue(net.minecraft.world.level.block.AnvilBlock.FACING, facing.getAxis() == Direction.Axis.Y ? Direction.NORTH : facing.getClockWise()));
+                    stack.shrink(1);
+                }
+                return stack;
+            }
+        }));
+        // Purpur end - Dispensers place anvils option
     }
 }
diff --git a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
index e2d169b45f1dba6559ca337b07a110f79d3db504..727d04a442053f6d0c4df3e744554e2866fa38cd 100644
--- a/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
+++ b/net/minecraft/core/dispenser/EquipmentDispenseItemBehavior.java
@@ -32,7 +32,7 @@ public class EquipmentDispenseItemBehavior extends DefaultDispenseItemBehavior {
             return false;
         } else {
             LivingEntity livingEntity = entitiesOfClass.getFirst();
-            EquipmentSlot equipmentSlotForItem = livingEntity.getEquipmentSlotForItem(item);
+            EquipmentSlot equipmentSlotForItem = blockSource.level().purpurConfig.dispenserApplyCursedArmor ? livingEntity.getEquipmentSlotForItem(item) : livingEntity.getEquipmentSlotForDispenserItem(item); if (equipmentSlotForItem == null) return false; // Purpur - Dispenser curse of binding protection
             ItemStack itemStack = item.copyWithCount(1); // Paper - shrink below and single item in event
             // CraftBukkit start
             net.minecraft.world.level.Level world = blockSource.level();
diff --git a/net/minecraft/gametest/framework/GameTestHelper.java b/net/minecraft/gametest/framework/GameTestHelper.java
index 0c3874f3bb1f0de81db81f394979bd4759542157..c7b6f4159807086b2232b93127976041683dad0a 100644
--- a/net/minecraft/gametest/framework/GameTestHelper.java
+++ b/net/minecraft/gametest/framework/GameTestHelper.java
@@ -292,6 +292,10 @@ public class GameTestHelper {
                 return gameType;
             }
 
+            public void setAfk(final boolean afk) {} // Purpur - AFK API
+
+            public void resetLastActionTime() {} // Purpur - Ridables
+
             @Override
             public boolean isClientAuthoritative() {
                 return false;
diff --git a/net/minecraft/gametest/framework/TestCommand.java b/net/minecraft/gametest/framework/TestCommand.java
index 17f33a309ead525975a3090514a6367260f0af09..f4360d9472ba344f2e7afd6d798d313d5423fcb5 100644
--- a/net/minecraft/gametest/framework/TestCommand.java
+++ b/net/minecraft/gametest/framework/TestCommand.java
@@ -449,7 +449,7 @@ public class TestCommand {
                             )
                     )
             );
-        if (SharedConstants.IS_RUNNING_IN_IDE) {
+        if (org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands || SharedConstants.IS_RUNNING_IN_IDE) { // Purpur - register minecraft debug commands
             literalArgumentBuilder = literalArgumentBuilder.then(
                     Commands.literal("export")
                         .then(
diff --git a/net/minecraft/network/Connection.java b/net/minecraft/network/Connection.java
index 2d18e9c153eabf266cfcc097613f33deb9ddb248..f2fa377a9d51e9fdcecee2404cb845257f9bdc22 100644
--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -625,6 +625,7 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
     private static final int MAX_PER_TICK = io.papermc.paper.configuration.GlobalConfiguration.get().misc.maxJoinsPerTick; // Paper - Buffer joins to world
     private static int joinAttemptsThisTick; // Paper - Buffer joins to world
     private static int currTick; // Paper - Buffer joins to world
+    private static int tickSecond; // Purpur - Max joins per second
     public void tick() {
         this.flushQueue();
         // Folia - this is broken
@@ -655,7 +656,21 @@ public class Connection extends SimpleChannelInboundHandler<Packet<?>> {
         }
         // Folia end - region threading
         if (this.packetListener instanceof TickablePacketListener tickablePacketListener) {
+         // Paper start - Buffer joins to world
+         /* todo -> folia doesnt work with this
+         if (Connection.currTick != net.minecraft.server.MinecraftServer.currentTick) {
+             Connection.currTick = net.minecraft.server.MinecraftServer.currentTick;
+            // Purpur start - Max joins per second
+            if (org.purpurmc.purpur.PurpurConfig.maxJoinsPerSecond) {
+                if (++Connection.tickSecond > 20) {
+                    Connection.tickSecond = 0;
+                    Connection.joinAttemptsThisTick = 0;
+                }
+            } else
+            // Purpur end - Max joins per second
+            */
             // Paper start - Buffer joins to world
+            // original logic for clarity purposes, currently doesnt work with folia (todo)
             if (true) { // Folia - region threading
             // Paper start - detailed watchdog information
             net.minecraft.network.protocol.PacketUtils.packetProcessing.push(this.packetListener);
diff --git a/net/minecraft/network/chat/SignedMessageChain.java b/net/minecraft/network/chat/SignedMessageChain.java
index f6eed34b2fd72ab74cc9dc4b99ca184d512c0a66..a3e211edd348c0936757de33a74b9456248b3bd2 100644
--- a/net/minecraft/network/chat/SignedMessageChain.java
+++ b/net/minecraft/network/chat/SignedMessageChain.java
@@ -45,7 +45,7 @@ public class SignedMessageChain {
                     SignedMessageLink signedMessageLink = SignedMessageChain.this.nextLink;
                     if (signedMessageLink == null) {
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.CHAIN_BROKEN);
-                    } else if (body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp)) {
+                    } else if (org.purpurmc.purpur.PurpurConfig.kickForOutOfOrderChat && body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp)) { // Purpur - Option to disable kick for out of order chat
                         this.setChainBroken();
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.OUT_OF_ORDER_CHAT, org.bukkit.event.player.PlayerKickEvent.Cause.OUT_OF_ORDER_CHAT); // Paper - kick event causes
                     } else {
diff --git a/net/minecraft/server/Main.java b/net/minecraft/server/Main.java
index fd3553bdc1c3cdbf6aa3dc00e0a4987f8eaa4fb8..b06c2c4aa77edafb374f7cf0406cf4d29c6e7f9f 100644
--- a/net/minecraft/server/Main.java
+++ b/net/minecraft/server/Main.java
@@ -109,6 +109,13 @@ public class Main {
                 JvmProfiler.INSTANCE.start(Environment.SERVER);
             }
 
+            // Purpur start - Add toggle for enchant level clamping - load config files early
+            org.bukkit.configuration.file.YamlConfiguration purpurConfiguration = io.papermc.paper.configuration.PaperConfigurations.loadLegacyConfigFile((File) optionSet.valueOf("purpur-settings"));
+            org.purpurmc.purpur.PurpurConfig.clampEnchantLevels = purpurConfiguration.getBoolean("settings.enchantment.clamp-levels", true);
+            org.purpurmc.purpur.PurpurConfig.registerMinecraftDebugCommands = purpurConfiguration.getBoolean("settings.register-minecraft-debug-commands"); // Purpur - register minecraft debug commands
+            org.purpurmc.purpur.PurpurConfig.registerMinecraftDisabledCommands = purpurConfiguration.getBoolean("settings.register-minecraft-disabled-commands"); // Purpur - register disabled minecraft commands
+            // Purpur end - Add toggle for enchant level clamping - load config files early
+
             io.papermc.paper.plugin.PluginInitializerManager.load(optionSet); // Paper
             Bootstrap.bootStrap();
             Bootstrap.validate();
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 8e69876debfdbab3965fb93fe79d1125f4f21636..76ccc886c6193ea86a544bc7df7e3785bf043930 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -283,6 +283,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public joptsimple.OptionSet options;
     public org.bukkit.command.ConsoleCommandSender console;
     //public static int currentTick; // Paper - improve tick loop // Folia - region threading
+    public static final long startTimeMillis = System.currentTimeMillis(); // Purpur - Add uptime command
     public java.util.Queue<Runnable> processQueue = new java.util.concurrent.ConcurrentLinkedQueue<Runnable>();
     public int autosavePeriod;
     // Paper - don't store the vanilla dispatcher
@@ -293,7 +294,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public static final int TICK_TIME = 1000000000 / MinecraftServer.TPS;
     private static final int SAMPLE_INTERVAL = 20; // Paper - improve server tick loop
     @Deprecated(forRemoval = true) // Paper
-    public final double[] recentTps = new double[3];
+    public final double[] recentTps = new double[4]; // Purpur - Add 5 second tps average in /tps
     // Spigot end
     public volatile boolean hasFullyShutdown; // Paper - Improved watchdog support
     public volatile boolean abnormalExit; // Paper - Improved watchdog support
@@ -302,6 +303,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public boolean isIteratingOverLevels = false; // Paper - Throw exception on world create while being ticked
     private final Set<String> pluginsBlockingSleep = new java.util.HashSet<>(); // Paper - API to allow/disallow tick sleeping
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
+    public boolean lagging = false; // Purpur - Lagging threshold
+    protected boolean upnp = false; // Purpur - UPnP Port Forwarding
 
     // Folia start - regionised ticking
     public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer();
@@ -1065,6 +1068,15 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
         LOGGER.info("Stopping server");
         Commands.COMMAND_SENDING_POOL.shutdownNow(); // Paper - Perf: Async command map building; Shutdown and don't bother finishing
+        // Purpur start - UPnP Port Forwarding
+        if (upnp) {
+            if (dev.omega24.upnp4j.UPnP4J.close(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                LOGGER.info("[UPnP] Port {} closed", this.getPort());
+            } else {
+                LOGGER.error("[UPnP] Failed to close port {}", this.getPort());
+            }
+        }
+        // Purpur end - UPnP Port Forwarding
         // CraftBukkit start
         if (this.server != null) {
             this.server.spark.disable(); // Paper - spark
@@ -1175,6 +1187,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
         this.safeShutdown(waitForServer, false);
     }
     public void safeShutdown(boolean waitForServer, boolean isRestarting) {
+        org.purpurmc.purpur.task.BossBarTask.stopAll(); // Purpur - Implement TPSBar
+        org.purpurmc.purpur.task.BeehiveTask.instance().unregister(); // Purpur - Give bee counts in beehives to Purpur clients
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper - Debugging
         if (isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread("Server stopped"); // Paper - Debugging
@@ -1195,6 +1209,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     private static final long MAX_CATCHUP_BUFFER = TICK_TIME * TPS * 60L;
     private long lastTick = 0;
     private long catchupTime = 0;
+    public final RollingAverage tps5s = new RollingAverage(5); // Purpur - Add 5 second tps average in /tps
     public final RollingAverage tps1 = new RollingAverage(60);
     public final RollingAverage tps5 = new RollingAverage(60 * 5);
     public final RollingAverage tps15 = new RollingAverage(60 * 15);
@@ -1292,6 +1307,16 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             }
             // Paper end - Add onboarding message for initial server start
 
+            // Purpur start - config for startup commands
+            if (!Boolean.getBoolean("Purpur.IReallyDontWantStartupCommands") && !org.purpurmc.purpur.PurpurConfig.startupCommands.isEmpty()) {
+                LOGGER.info("Purpur: Running startup commands specified in purpur.yml.");
+                for (final String startupCommand : org.purpurmc.purpur.PurpurConfig.startupCommands) {
+                    LOGGER.info("Purpur: Running the following command: \"{}\"", startupCommand);
+                    ((net.minecraft.server.dedicated.DedicatedServer) this).handleConsoleInput(startupCommand, this.createCommandSourceStack());
+                }
+            }
+            // Purpur end - config for startup commands
+
             while (this.running) {
                 long l;
                 if (!this.isPaused() && this.tickRateManager.isSprinting() && this.tickRateManager.checkShouldSprintThisTick()) {
@@ -1316,14 +1341,19 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                 if (false) { // Folia - region threading
                     final long diff = currentTime - tickSection;
                     final java.math.BigDecimal currentTps = TPS_BASE.divide(new java.math.BigDecimal(diff), 30, java.math.RoundingMode.HALF_UP);
+                    tps5s.add(currentTps, diff); // Purpur - Add 5 second tps average in /tps
                     tps1.add(currentTps, diff);
                     tps5.add(currentTps, diff);
                     tps15.add(currentTps, diff);
 
                     // Backwards compat with bad plugins
-                    this.recentTps[0] = tps1.getAverage();
-                    this.recentTps[1] = tps5.getAverage();
-                    this.recentTps[2] = tps15.getAverage();
+                    // Purpur start - Add 5 second tps average in /tps
+                    this.recentTps[0] = tps5s.getAverage();
+                    this.recentTps[1] = tps1.getAverage();
+                    this.recentTps[2] = tps5.getAverage();
+                    this.recentTps[3] = tps15.getAverage();
+                    // Purpur end - Add 5 second tps average in /tps
+                    lagging = recentTps[0] < org.purpurmc.purpur.PurpurConfig.laggingThreshold; // Purpur - Lagging threshold
                     tickSection = currentTime;
                 }
                 // Paper end - further improve server tick loop
@@ -1355,6 +1385,12 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
                     profilerFiller.popPush("nextTickWait");
                     this.mayHaveDelayedTasks = true;
                     this.delayedTasksMaxNextTickTimeNanos = Math.max(Util.getNanos() + l, this.nextTickTimeNanos);
+                    // Purpur start - Configurable TPS Catchup
+                    if (!org.purpurmc.purpur.PurpurConfig.tpsCatchup /*|| !gg.pufferfish.pufferfish.PufferfishConfig.tpsCatchup*/) { // Purpur - Configurable TPS Catchup
+                        this.nextTickTimeNanos = currentTime + l;
+                        this.delayedTasksMaxNextTickTimeNanos = nextTickTimeNanos;
+                    }
+                    // Purpur end - Configurable TPS Catchup
                     this.startMeasuringTaskExecutionTime();
                     this.waitUntilNextTick();
                     this.finishMeasuringTaskExecutionTime();
@@ -1800,7 +1836,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             long worldTime = level.getGameTime();
             final ClientboundSetTimePacket worldPacket = new ClientboundSetTimePacket(worldTime, dayTime, doDaylight);
             for (Player entityhuman : level.getLocalPlayers()) { // Folia - region threading
-                if (!(entityhuman instanceof ServerPlayer) || (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + entityhuman.getId()) % 20 != 0) { // Folia - region threading
+                if (!(entityhuman instanceof ServerPlayer) || (!level.isForceTime() && (io.papermc.paper.threadedregions.RegionizedServer.getCurrentTick() + entityhuman.getId()) % 20 != 0)) { // Folia - region threading // Purpur - Configurable daylight cycle
                     continue;
                 }
                 ServerPlayer entityplayer = (ServerPlayer) entityhuman;
@@ -1966,7 +2002,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
 
     @DontObfuscate
     public String getServerModName() {
-        return io.papermc.paper.ServerBuildInfo.buildInfo().brandName(); // Paper
+        return org.purpurmc.purpur.PurpurConfig.serverModName; // Paper // Purpur - Configurable server mod name
     }
 
     public SystemReport fillSystemReport(SystemReport systemReport) {
diff --git a/net/minecraft/server/PlayerAdvancements.java b/net/minecraft/server/PlayerAdvancements.java
index fdeca41d40705f28864ce4443d01cd872c9d51b0..10e5469df1800bcdfb3f8cb4045ee25a4bafc58c 100644
--- a/net/minecraft/server/PlayerAdvancements.java
+++ b/net/minecraft/server/PlayerAdvancements.java
@@ -147,6 +147,7 @@ public class PlayerAdvancements {
             AdvancementHolder advancementHolder = advancementManager.get(path);
             if (advancementHolder == null) {
                 if (!path.getNamespace().equals(ResourceLocation.DEFAULT_NAMESPACE)) return; // CraftBukkit
+                if (!org.purpurmc.purpur.PurpurConfig.loggerSuppressIgnoredAdvancementWarnings) // Purpur - Logger settings (suppressing pointless logs)
                 LOGGER.warn("Ignored advancement '{}' in progress file {} - it doesn't exist anymore?", path, this.playerSavePath);
             } else {
                 this.startProgress(advancementHolder, progress);
@@ -194,6 +195,7 @@ public class PlayerAdvancements {
                 advancement.value().display().ifPresent(displayInfo -> {
                     // Paper start - Add Adventure message to PlayerAdvancementDoneEvent
                     if (event.message() != null && this.player.level().getGameRules().getBoolean(GameRules.RULE_ANNOUNCE_ADVANCEMENTS)) {
+                        if (org.purpurmc.purpur.PurpurConfig.advancementOnlyBroadcastToAffectedPlayer) this.player.sendMessage(message); else // Purpur - Configurable broadcast settings
                         this.playerList.broadcastSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(event.message()), false);
                         // Paper end
                     }
diff --git a/net/minecraft/server/commands/EnchantCommand.java b/net/minecraft/server/commands/EnchantCommand.java
index 21781ab5ad7d31504f1bdbb4aae53a4a982e9156..fc58cda8ed78e8aad7936365735fc0c016ef8ee9 100644
--- a/net/minecraft/server/commands/EnchantCommand.java
+++ b/net/minecraft/server/commands/EnchantCommand.java
@@ -76,7 +76,7 @@ public class EnchantCommand {
 
     private static int enchant(CommandSourceStack source, Collection<? extends Entity> targets, Holder<Enchantment> enchantment, int level) throws CommandSyntaxException {
         Enchantment enchantment1 = enchantment.value();
-        if (level > enchantment1.getMaxLevel()) {
+        if (!org.purpurmc.purpur.PurpurConfig.allowUnsafeEnchantCommand && level > enchantment1.getMaxLevel()) { // Purpur - Config to allow unsafe enchants
             throw ERROR_LEVEL_TOO_HIGH.create(level, enchantment1.getMaxLevel());
         } else {
             final java.util.concurrent.atomic.AtomicInteger changed = new java.util.concurrent.atomic.AtomicInteger(0); // Folia - region threading
@@ -91,7 +91,7 @@ public class EnchantCommand {
                             ItemStack mainHandItem = livingEntity.getMainHandItem();
                             if (!mainHandItem.isEmpty()) {
                                 if (enchantment1.canEnchant(mainHandItem)
-                                    && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment)) {
+                                    && EnchantmentHelper.isEnchantmentCompatible(EnchantmentHelper.getEnchantmentsForCrafting(mainHandItem).keySet(), enchantment) || (org.purpurmc.purpur.PurpurConfig.allowUnsafeEnchantCommand && !mainHandItem.hasEnchantment(enchantment))) { // Purpur - Config to allow unsafe enchants
                                     mainHandItem.enchant(enchantment, level);
                                     possibleSingleDisplayName.set(livingEntity.getDisplayName());
                                     changed.incrementAndGet();
diff --git a/net/minecraft/server/commands/GameModeCommand.java b/net/minecraft/server/commands/GameModeCommand.java
index c7ea2441e99c3aedd403da04cbc350685b9fcc64..a8b15f3e338ca51e26b4c8a9474ae9732ec94212 100644
--- a/net/minecraft/server/commands/GameModeCommand.java
+++ b/net/minecraft/server/commands/GameModeCommand.java
@@ -53,6 +53,18 @@ public class GameModeCommand {
     }
 
     private static int setMode(CommandContext<CommandSourceStack> source, Collection<ServerPlayer> players, GameType gameType) {
+        // Purpur start - Gamemode extra permissions
+        if (org.purpurmc.purpur.PurpurConfig.commandGamemodeRequiresPermission) {
+            String gamemode = gameType.getName();
+            CommandSourceStack sender = source.getSource();
+            if (!sender.testPermission(2, "minecraft.command.gamemode." + gamemode)) {
+                return 0;
+            }
+            if (sender.getEntity() instanceof ServerPlayer player && (players.size() > 1 || !players.contains(player)) && !sender.testPermission(2, "minecraft.command.gamemode." + gamemode + ".other")) {
+                return 0;
+            }
+        }
+        // Purpur end - Gamemode extra permissions
         int i = 0;
 
         for (ServerPlayer serverPlayer : players) {
diff --git a/net/minecraft/server/commands/GiveCommand.java b/net/minecraft/server/commands/GiveCommand.java
index 5a1c21b05545a03fbb00cf734605049870d3eecb..81552ad15ee207dfdfbf200d580d2fdfa16b0f8a 100644
--- a/net/minecraft/server/commands/GiveCommand.java
+++ b/net/minecraft/server/commands/GiveCommand.java
@@ -62,6 +62,7 @@ public class GiveCommand {
             return 0;
         } else {
             for (ServerPlayer serverPlayer : targets) {
+                if (org.purpurmc.purpur.PurpurConfig.disableGiveCommandDrops) continue; // Purpur - add config option for toggling give command dropping
                 int i1 = count;
 
                 while (i1 > 0) {
diff --git a/net/minecraft/server/dedicated/DedicatedServer.java b/net/minecraft/server/dedicated/DedicatedServer.java
index d8bab0ba6e2374fb74f3fa9f7db802f442240414..f702296b9c79744109f4008abdbf31af0c8a6f6d 100644
--- a/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/net/minecraft/server/dedicated/DedicatedServer.java
@@ -105,6 +105,7 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             public void run() {
                 if (!org.bukkit.craftbukkit.Main.useConsole) return; // CraftBukkit
                 // Paper start - Use TerminalConsoleAppender
+                if (DedicatedServer.this.gui == null || System.console() != null) // Purpur - GUI Improvements - has no GUI or has console (did not double-click)
                 new com.destroystokyo.paper.console.PaperConsole(DedicatedServer.this).start();
                 /*
                 BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(System.in, StandardCharsets.UTF_8));
@@ -183,6 +184,15 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         io.papermc.paper.command.PaperCommands.registerCommands(this); // Paper - setup /paper command
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
+        // Purpur start - Purpur config files
+        try {
+            org.purpurmc.purpur.PurpurConfig.init((java.io.File) options.valueOf("purpur-settings"));
+        } catch (Exception e) {
+            DedicatedServer.LOGGER.error("Unable to load server configuration", e);
+            return false;
+        }
+        org.purpurmc.purpur.PurpurConfig.registerCommands();
+        // Purpur end - Purpur config files
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
 
         this.setPvpAllowed(properties.pvp);
@@ -230,6 +240,30 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
             if (true) throw new IllegalStateException("Failed to bind to port", var10); // Paper - Propagate failed to bind to port error
             return false;
         }
+        // Purpur start - UPnP Port Forwarding
+        if (org.purpurmc.purpur.PurpurConfig.useUPnP) {
+            LOGGER.info("[UPnP] Attempting to start UPnP port forwarding service...");
+            if (dev.omega24.upnp4j.UPnP4J.isUPnPAvailable()) {
+                if (dev.omega24.upnp4j.UPnP4J.isOpen(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                    this.upnp = false;
+                    LOGGER.info("[UPnP] Port {} is already open", this.getPort());
+                } else if (dev.omega24.upnp4j.UPnP4J.open(this.getPort(), dev.omega24.upnp4j.util.Protocol.TCP)) {
+                    this.upnp = true;
+                    LOGGER.info("[UPnP] Successfully opened port {}", this.getPort());
+                } else {
+                    this.upnp = false;
+                    LOGGER.info("[UPnP] Failed to open port {}", this.getPort());
+                }
+
+                if (upnp) {
+                    LOGGER.info("[UPnP] {}:{}", dev.omega24.upnp4j.UPnP4J.getExternalIP(), this.getPort());
+                }
+            } else {
+                this.upnp = false;
+                LOGGER.error("[UPnP] Service is unavailable");
+            }
+        }
+        // Purpur end - UPnP Port Forwarding
 
         // CraftBukkit start
         this.server.loadPlugins();
@@ -308,6 +342,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 LOGGER.info("JMX monitoring enabled");
             }
 
+            org.purpurmc.purpur.task.BossBarTask.startAll(); // Purpur - Implement TPSBar
+            if (org.purpurmc.purpur.PurpurConfig.beeCountPayload) org.purpurmc.purpur.task.BeehiveTask.instance().register(); // Purpur - Give bee counts in beehives to Purpur clients
             return true;
         }
     }
diff --git a/net/minecraft/server/dedicated/DedicatedServerProperties.java b/net/minecraft/server/dedicated/DedicatedServerProperties.java
index 4a01088da91fc6d620cb804a9ab6d6eb1630b473..b286dc17cda16fca3af9374d2a4a8bd137c24450 100644
--- a/net/minecraft/server/dedicated/DedicatedServerProperties.java
+++ b/net/minecraft/server/dedicated/DedicatedServerProperties.java
@@ -51,6 +51,7 @@ public class DedicatedServerProperties extends Settings<DedicatedServerPropertie
     public final boolean onlineMode = this.get("online-mode", true);
     public final boolean preventProxyConnections = this.get("prevent-proxy-connections", false);
     public final String serverIp = this.get("server-ip", "");
+    public final String serverName = this.get("server-name", "Unknown Server"); // Purpur - Bring back server name
     public final boolean pvp = this.get("pvp", true);
     public final boolean allowFlight = this.get("allow-flight", false);
     public final String motd = this.get("motd", "A Minecraft Server");
diff --git a/net/minecraft/server/gui/MinecraftServerGui.java b/net/minecraft/server/gui/MinecraftServerGui.java
index f262a7c5ae4e7d56f16f5c0f4f145a2e428abbe4..614c7d9f673c926562acc8fa3b3788623900db41 100644
--- a/net/minecraft/server/gui/MinecraftServerGui.java
+++ b/net/minecraft/server/gui/MinecraftServerGui.java
@@ -39,6 +39,11 @@ public class MinecraftServerGui extends JComponent {
     private Thread logAppenderThread;
     private final Collection<Runnable> finalizers = Lists.newArrayList();
     final AtomicBoolean isClosing = new AtomicBoolean();
+    // Purpur start - GUI Improvements
+    private final CommandHistory history = new CommandHistory();
+    private String currentCommand = "";
+    private int historyIndex = 0;
+    // Purpur end - GUI Improvements
 
     public static MinecraftServerGui showFrameFor(final DedicatedServer server) {
         try {
@@ -46,7 +51,7 @@ public class MinecraftServerGui extends JComponent {
         } catch (Exception var3) {
         }
 
-        final JFrame jFrame = new JFrame("Minecraft server");
+        final JFrame jFrame = new JFrame("Purpur Minecraft server"); // Purpur - Improve GUI
         final MinecraftServerGui minecraftServerGui = new MinecraftServerGui(server);
         jFrame.setDefaultCloseOperation(2);
         jFrame.add(minecraftServerGui);
@@ -54,7 +59,7 @@ public class MinecraftServerGui extends JComponent {
         jFrame.setLocationRelativeTo(null);
         jFrame.setVisible(true);
         // Paper start - Improve ServerGUI
-        jFrame.setName("Minecraft server");
+        jFrame.setName("Purpur Minecraft server"); // Purpur - Improve GUI
         try {
             jFrame.setIconImage(javax.imageio.ImageIO.read(java.util.Objects.requireNonNull(MinecraftServerGui.class.getClassLoader().getResourceAsStream("logo.png"))));
         } catch (java.io.IOException ignore) {
@@ -64,7 +69,7 @@ public class MinecraftServerGui extends JComponent {
             @Override
             public void windowClosing(WindowEvent event) {
                 if (!minecraftServerGui.isClosing.getAndSet(true)) {
-                    jFrame.setTitle("Minecraft server - shutting down!");
+                    jFrame.setTitle("Purpur Minecraft server - shutting down!"); // Purpur - Improve GUI
                     server.halt(true);
                     minecraftServerGui.runFinalizers();
                 }
@@ -112,7 +117,7 @@ public class MinecraftServerGui extends JComponent {
 
     private JComponent buildChatPanel() {
         JPanel jPanel = new JPanel(new BorderLayout());
-        JTextArea jTextArea = new JTextArea();
+        org.purpurmc.purpur.gui.JColorTextPane jTextArea = new org.purpurmc.purpur.gui.JColorTextPane(); // Purpur - GUI Improvements
         JScrollPane jScrollPane = new JScrollPane(jTextArea, 22, 30);
         jTextArea.setEditable(false);
         jTextArea.setFont(MONOSPACED);
@@ -121,10 +126,43 @@ public class MinecraftServerGui extends JComponent {
             String trimmed = jTextField.getText().trim();
             if (!trimmed.isEmpty()) {
                 this.server.handleConsoleInput(trimmed, this.server.createCommandSourceStack());
+                // Purpur start - GUI Improvements
+                history.add(trimmed);
+                historyIndex = -1;
+                // Purpur end - GUI Improvements
             }
 
             jTextField.setText("");
         });
+        // Purpur start - GUI Improvements
+        jTextField.getInputMap().put(javax.swing.KeyStroke.getKeyStroke("UP"), "up");
+        jTextField.getInputMap().put(javax.swing.KeyStroke.getKeyStroke("DOWN"), "down");
+        jTextField.getActionMap().put("up", new javax.swing.AbstractAction() {
+            @Override
+            public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
+                if (historyIndex < 0) {
+                    currentCommand = jTextField.getText();
+                }
+                if (historyIndex < history.size() - 1) {
+                    jTextField.setText(history.get(++historyIndex));
+                }
+            }
+        });
+        jTextField.getActionMap().put("down", new javax.swing.AbstractAction() {
+            @Override
+            public void actionPerformed(java.awt.event.ActionEvent actionEvent) {
+                if (historyIndex >= 0) {
+                    if (historyIndex == 0) {
+                        --historyIndex;
+                        jTextField.setText(currentCommand);
+                    } else {
+                        --historyIndex;
+                        jTextField.setText(history.get(historyIndex));
+                    }
+                }
+            }
+        });
+        // Purpur end - GUI Improvements
         jTextArea.addFocusListener(new FocusAdapter() {
             @Override
             public void focusGained(FocusEvent event) {
@@ -159,7 +197,7 @@ public class MinecraftServerGui extends JComponent {
     }
 
     private static final java.util.regex.Pattern ANSI = java.util.regex.Pattern.compile("\\e\\[[\\d;]*[^\\d;]"); // CraftBukkit // Paper
-    public void print(JTextArea textArea, JScrollPane scrollPane, String line) {
+    public void print(org.purpurmc.purpur.gui.JColorTextPane textArea, JScrollPane scrollPane, String line) { // Purpur - GUI Improvements
         if (!SwingUtilities.isEventDispatchThread()) {
             SwingUtilities.invokeLater(() -> this.print(textArea, scrollPane, line));
         } else {
@@ -170,10 +208,11 @@ public class MinecraftServerGui extends JComponent {
                 flag = verticalScrollBar.getValue() + verticalScrollBar.getSize().getHeight() + MONOSPACED.getSize() * 4 > verticalScrollBar.getMaximum();
             }
 
-            try {
+            /*try { // Purpur - GUI Improvements
                 document.insertString(document.getLength(), MinecraftServerGui.ANSI.matcher(line).replaceAll(""), null); // CraftBukkit
             } catch (BadLocationException var8) {
-            }
+            }*/ // Purpur - GUI Improvements
+            textArea.append(line); // Purpur - GUI Improvements
 
             if (flag) {
                 verticalScrollBar.setValue(Integer.MAX_VALUE);
@@ -181,6 +220,18 @@ public class MinecraftServerGui extends JComponent {
         }
     }
 
+    // Purpur start - GUI Improvements
+    public static class CommandHistory extends java.util.LinkedList<String> {
+        @Override
+        public boolean add(String command) {
+            if (size() > 1000) {
+                remove();
+            }
+            return super.offerFirst(command);
+        }
+    }
+    // Purpur end - GUI Improvements
+
     // Paper start - Add onboarding message for initial server start
     private JComponent buildOnboardingPanel() {
         String onboardingLink = "https://docs.papermc.io/paper/next-steps";
diff --git a/net/minecraft/server/gui/StatsComponent.java b/net/minecraft/server/gui/StatsComponent.java
index 35fd539eb2bfe60ad17ab1e558a01273666acc54..103ff139dae918c991413ce9df61da3e22ee458a 100644
--- a/net/minecraft/server/gui/StatsComponent.java
+++ b/net/minecraft/server/gui/StatsComponent.java
@@ -43,7 +43,7 @@ public class StatsComponent extends JComponent {
         }
         this.msgs[0] = "Memory use: " + l / 1024L / 1024L + " mb (" + Runtime.getRuntime().freeMemory() * 100L / Runtime.getRuntime().maxMemory() + "% free)";
         this.msgs[1] = "Avg tick: " + DECIMAL_FORMAT.format((double)this.server.getAverageTickTimeNanos() / TimeUtil.NANOSECONDS_PER_MILLISECOND) + " ms";
-        this.msgs[2] = "TPS from last 1m, 5m, 15m: " + String.join(", ", tpsAvg);
+        this.msgs[2] = "TPS from last 5s, 1m, 5m, 15m: " + String.join(", ", tpsAvg); // Purpur - Add 5 second tps average in /tps
         // Paper end - Improve ServerGUI
         this.values[this.vp++ & 0xFF] = (int)(l * 100L / Runtime.getRuntime().maxMemory());
         this.repaint();
diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index 5e3be75b27ed609be005e8169dc84c125518253e..43b30617cf61eb616f7aa6762b0ca0836340fb55 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -206,6 +206,8 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     private final StructureManager structureManager;
     private final StructureCheck structureCheck;
     public final boolean tickTime; // Folia - region threading
+    public double preciseTime; // Purpur - Configurable daylight cycle
+    private boolean forceTime; // Purpur - Configurable daylight cycle
     private final RandomSequences randomSequences;
 
     // CraftBukkit start
@@ -548,7 +550,24 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // CraftBukkit end
         this.tickTime = tickTime;
         this.server = server;
-        this.customSpawners = customSpawners;
+        // Purpur start - Allow toggling special MobSpawners per world
+        this.customSpawners = new ArrayList<>();
+        if (purpurConfig.phantomSpawning) {
+            this.customSpawners.add(new net.minecraft.world.level.levelgen.PhantomSpawner());
+        }
+        if (purpurConfig.patrolSpawning) {
+            this.customSpawners.add(new net.minecraft.world.level.levelgen.PatrolSpawner());
+        }
+        if (purpurConfig.catSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.npc.CatSpawner());
+        }
+        if (purpurConfig.villageSiegeSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.ai.village.VillageSiege());
+        }
+        if (purpurConfig.villagerTraderSpawning) {
+            this.customSpawners.add(new net.minecraft.world.entity.npc.WanderingTraderSpawner(serverLevelData));
+        }
+        // Purpur end - Allow toggling special MobSpawners per world
         this.serverLevelData = serverLevelData;
         ChunkGenerator chunkGenerator = levelStem.generator();
         // CraftBukkit start
@@ -634,6 +653,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.updateTickData(); // Folia - region threading - make sure it is initialised before ticked
+        this.preciseTime = this.serverLevelData.getDayTime(); // Purpur - Configurable daylight cycle
     }
 
     // Folia start - region threading
@@ -851,7 +871,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     // Folia start - region threading
     public void tickSleep() {
         int _int = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
-        if (this.sleepStatus.areEnoughSleeping(_int) && this.sleepStatus.areEnoughDeepSleeping(_int, this.players)) {
+        if (this.purpurConfig.playersSkipNight && this.sleepStatus.areEnoughSleeping(_int) && this.sleepStatus.areEnoughDeepSleeping(_int, this.players)) { // Purpur - Config for skipping night
             // Paper start - create time skip event - move up calculations
             final long newDayTime = this.levelData.getDayTime() + 24000L;
             org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(
@@ -895,6 +915,13 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             //this.serverLevelData.getScheduledEvents().tick(this.server, l); // Folia - region threading - TODO any way to bring this in?
             Profiler.get().pop();
             if (false && this.serverLevelData.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT)) {  // Folia - region threading
+                // Purpur start - Configurable daylight cycle (diff for history purposes, has been moved to RegionizedWorldData)
+                int incrementTicks = isBrightOutside() ? this.purpurConfig.daytimeTicks : this.purpurConfig.nighttimeTicks;
+                if (incrementTicks != 12000) {
+                    this.preciseTime += 12000 / (double) incrementTicks;
+                    this.setDayTime(this.preciseTime);
+                } else
+                // Purpur end - Configurable daylight cycle
                 this.setDayTime(this.levelData.getDayTime() + 1L);
             }
         }
@@ -902,7 +929,21 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
 
     public void setDayTime(long time) {
         this.serverLevelData.setDayTime(time);
+        // Purpur start - Configurable daylight cycle
+        this.preciseTime = time;
+        this.forceTime = false;
+    }
+    public void setDayTime(double i) {
+        this.serverLevelData.setDayTime((long) i);
+        this.forceTime = true;
+        // Purpur end - Configurable daylight cycle
+    }
+
+    // Purpur start - Configurable daylight cycle
+    public boolean isForceTime() {
+        return this.forceTime;
     }
+    // Purpur end - Configurable daylight cycle
 
     public void tickCustomSpawners(boolean spawnEnemies, boolean spawnFriendlies) {
         final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
@@ -1020,9 +1061,17 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                     && this.random.nextDouble() < currentDifficultyAt.getEffectiveDifficulty() * this.paperConfig().entities.spawning.skeletonHorseThunderSpawnChance.or(0.01) // Paper - Configurable spawn chances for skeleton horses
                     && !this.getBlockState(blockPos.below()).is(Blocks.LIGHTNING_ROD);
                 if (flag) {
-                    SkeletonHorse skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
+                    // Purpur start - Special mobs naturally spawn
+                    net.minecraft.world.entity.animal.horse.AbstractHorse skeletonHorse;
+                    if (purpurConfig.zombieHorseSpawnChance > 0D && random.nextDouble() <= purpurConfig.zombieHorseSpawnChance) {
+                        skeletonHorse = EntityType.ZOMBIE_HORSE.create(this, EntitySpawnReason.EVENT);
+                    } else {
+                        skeletonHorse = EntityType.SKELETON_HORSE.create(this, EntitySpawnReason.EVENT);
+                        if (skeletonHorse != null) ((SkeletonHorse) skeletonHorse).setTrap(true);
+                    }
+                    // Purpur end - Special mobs naturally spawn
                     if (skeletonHorse != null) {
-                        skeletonHorse.setTrap(true);
+                        //skeletonHorse.setTrap(true); // Purpur - Special mobs naturally spawn - moved up
                         skeletonHorse.setAge(0);
                         skeletonHorse.setPos(blockPos.getX(), blockPos.getY(), blockPos.getZ());
                         this.addFreshEntity(skeletonHorse, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.LIGHTNING); // CraftBukkit
@@ -1057,9 +1106,35 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 if (blockState.is(Blocks.SNOW)) {
                     int layersValue = blockState.getValue(SnowLayerBlock.LAYERS);
                     if (layersValue < Math.min(_int, 8)) {
+                        // Purpur start - Smooth snow accumulation
+                        boolean canSnow = true;
+                        // Ensure snow doesn't get more than N layers taller than its neighbors
+                        // We only need to check blocks that are taller than the minimum step height
+                        if (org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep > 0 && layersValue >= org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep) {
+                            int layersValueMin = layersValue - org.purpurmc.purpur.PurpurConfig.smoothSnowAccumulationStep;
+                            for (Direction direction : Direction.Plane.HORIZONTAL) {
+                                BlockPos blockPosNeighbor = heightmapPos.relative(direction);
+                                BlockState blockStateNeighbor = this.getBlockState(blockPosNeighbor);
+                                if (blockStateNeighbor.is(Blocks.SNOW)) {
+                                    // Special check for snow layers, if neighbors are too short, don't accumulate
+                                    int layersValueNeighbor = blockStateNeighbor.getValue(SnowLayerBlock.LAYERS);
+                                    if (layersValueNeighbor <= layersValueMin) {
+                                        canSnow = false;
+                                        break;
+                                    }
+                                } else if (!Block.isFaceFull(blockStateNeighbor.getCollisionShape(this, blockPosNeighbor), direction.getOpposite())) {
+                                    // Since our layer is tall enough already, if we have a non-full neighbor block, don't accumulate
+                                    canSnow = false;
+                                    break;
+                                }
+                            }
+                        }
+                        if (canSnow) {
+                        // Purpur end - Smooth snow accumulation
                         BlockState blockState1 = blockState.setValue(SnowLayerBlock.LAYERS, layersValue + 1);
                         Block.pushEntitiesUp(blockState, blockState1, this, heightmapPos);
                         org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, heightmapPos, blockState1, 3, null); // CraftBukkit
+                        } // Purpur - Smooth snow accumulation
                     }
                 } else {
                     org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockFormEvent(this, heightmapPos, Blocks.SNOW.defaultBlockState(), 3, null); // CraftBukkit
@@ -1080,7 +1155,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 pointOfInterestType -> pointOfInterestType.is(PoiTypes.LIGHTNING_ROD),
                 blockPos -> blockPos.getY() == this.getHeight(Heightmap.Types.WORLD_SURFACE, blockPos.getX(), blockPos.getZ()) - 1,
                 pos,
-                128,
+                org.purpurmc.purpur.PurpurConfig.lightningRodRange, // Purpur - Make lightning rod range configurable
                 PoiManager.Occupancy.ANY
             );
         return optional.map(blockPos -> blockPos.above(1));
@@ -1129,8 +1204,26 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
                 int _int = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
                 Component component;
                 if (this.sleepStatus.areEnoughSleeping(_int)) {
+                    // Purpur start - Customizable sleeping actionbar messages
+                    if (org.purpurmc.purpur.PurpurConfig.sleepSkippingNight.isBlank()) {
+                        return;
+                    }
+                    if (!org.purpurmc.purpur.PurpurConfig.sleepSkippingNight.equalsIgnoreCase("default")) {
+                        component = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepSkippingNight));
+                    } else
+                    // Purpur end - Customizable sleeping actionbar messages
                     component = Component.translatable("sleep.skipping_night");
                 } else {
+                    // Purpur start - Customizable sleeping actionbar messages
+                    if (org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent.isBlank()) {
+                        return;
+                    }
+                    if (!org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent.equalsIgnoreCase("default")) {
+                        component = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepingPlayersPercent,
+                            net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.parsed("count", Integer.toString(this.sleepStatus.amountSleeping())),
+                            net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.parsed("total", Integer.toString(this.sleepStatus.sleepersNeeded(_int)))));
+                    } else
+                    // Purpur end - Customizable sleeping actionbar messages
                     component = Component.translatable("sleep.players_sleeping", this.sleepStatus.amountSleeping(), this.sleepStatus.sleepersNeeded(_int));
                 }
 
@@ -1276,6 +1369,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
     @VisibleForTesting
     public void resetWeatherCycle() {
         // CraftBukkit start
+        if (this.purpurConfig.rainStopsAfterSleep) // Purpur - Option for if rain and thunder should stop on sleep
         this.serverLevelData.setRaining(false, org.bukkit.event.weather.WeatherChangeEvent.Cause.SLEEP); // Paper - Add cause to Weather/ThunderChangeEvents
         // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
         // Not that everyone ever manages to get the whole server to sleep at the same time....
@@ -1283,6 +1377,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             this.serverLevelData.setRainTime(0);
         }
         // CraftBukkit end
+        if (this.purpurConfig.thunderStopsAfterSleep) // Purpur - Option for if rain and thunder should stop on sleep
         this.serverLevelData.setThundering(false, org.bukkit.event.weather.ThunderChangeEvent.Cause.SLEEP); // Paper - Add cause to Weather/ThunderChangeEvents
         // CraftBukkit start
         // If we stop due to everyone sleeping we should reset the weather duration to some other random value.
@@ -2861,7 +2956,7 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             // Spigot start
             if (entity.getBukkitEntity() instanceof org.bukkit.inventory.InventoryHolder && (!(entity instanceof ServerPlayer) || entity.getRemovalReason() != Entity.RemovalReason.KILLED)) { // SPIGOT-6876: closeInventory clears death message
                 // Paper start - Fix merchant inventory not closing on entity removal
-                if (entity.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) {
+                if (!entity.level().purpurConfig.playerVoidTrading && entity.getBukkitEntity() instanceof org.bukkit.inventory.Merchant merchant && merchant.getTrader() != null) { // Purpur - Allow void trading
                     merchant.getTrader().closeInventory(org.bukkit.event.inventory.InventoryCloseEvent.Reason.UNLOADED);
                 }
                 // Paper end - Fix merchant inventory not closing on entity removal
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index f08289e5f9fb8bd9784191bb0a77775a15ef7f88..d2acbd99534dd53a762152d19500425f6e58f847 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -429,6 +429,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
     public boolean isRealPlayer; // Paper
     public @Nullable com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent playerNaturallySpawnedEvent; // Paper - PlayerNaturallySpawnCreaturesEvent
     public @Nullable org.bukkit.event.player.PlayerQuitEvent.QuitReason quitReason = null; // Paper - Add API for quit reason; there are a lot of changes to do if we change all methods leading to the event
+    private boolean tpsBar = false; // Purpur - Implement TPSBar
+    private boolean compassBar = false; // Purpur - Add compass command
+    private boolean ramBar = false; // Purpur - Implement rambar commands
 
     // Paper start - rewrite chunk system
     private ca.spottedleaf.moonrise.patches.chunk_system.player.RegionizedPlayerChunkLoader.PlayerChunkLoaderData chunkLoader;
@@ -709,6 +712,10 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.respawnConfig = input.read("respawn", ServerPlayer.RespawnConfig.CODEC).orElse(null);
         this.spawnExtraParticlesOnFall = input.getBooleanOr("spawn_extra_particles_on_fall", false);
         this.raidOmenPosition = input.read("raid_omen_position", BlockPos.CODEC).orElse(null);
+
+        this.tpsBar = input.getBooleanOr("Purpur.TPSBar", false); // Purpur - Implement TPSBar
+        this.compassBar = input.getBooleanOr("Purpur.CompassBar", false); // Purpur - Add compass command
+        this.ramBar = input.getBooleanOr("Purpur.RamBar", false); // Purpur - Implement rambar command
     }
 
     @Override
@@ -726,6 +733,9 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         output.storeNullable("raid_omen_position", BlockPos.CODEC, this.raidOmenPosition);
         this.saveEnderPearls(output);
         this.getBukkitEntity().setExtraData(output); // CraftBukkit
+        output.putBoolean("Purpur.TPSBar", this.tpsBar); // Purpur - Implement TPSBar
+        output.putBoolean("Purpur.CompassBar", this.compassBar); // Purpur - Add compass command
+        output.putBoolean("Purpur.RamBar", this.ramBar); // Purpur - Add rambar command
     }
 
     private void saveParentVehicle(ValueOutput output) {
@@ -959,6 +969,15 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.trackEnteredOrExitedLavaOnVehicle();
         this.updatePlayerAttributes();
         this.advancements.flushDirty(this, true);
+
+        // Purpur start - Ridables
+        if (this.level().purpurConfig.useNightVisionWhenRiding && this.getVehicle() != null && this.getVehicle().getRider() == this && this.level().getGameTime() % 100 == 0) { // 5 seconds
+            MobEffectInstance nightVision = this.getEffect(MobEffects.NIGHT_VISION);
+            if (nightVision == null || nightVision.getDuration() <= 300) { // 15 seconds
+                this.addEffect(new MobEffectInstance(MobEffects.NIGHT_VISION, 400, 0)); // 20 seconds
+            }
+        }
+        // Purpur end - Ridables
     }
 
     private void updatePlayerAttributes() {
@@ -1250,6 +1269,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
             // Paper - moved up to sendClientboundPlayerCombatKillPacket()
             sendClientboundPlayerCombatKillPacket(event.getShowDeathMessages(), deathScreenMessage); // Paper - Expand PlayerDeathEvent
             Team team = this.getTeam();
+            if (org.purpurmc.purpur.PurpurConfig.deathMessageOnlyBroadcastToAffectedPlayer) this.sendSystemMessage(deathMessage); else // Purpur - Configurable broadcast settings
             if (team == null || team.getDeathMessageVisibility() == Team.Visibility.ALWAYS) {
                 this.server.getPlayerList().broadcastSystemMessage(deathMessage, false);
             } else if (team.getDeathMessageVisibility() == Team.Visibility.HIDE_FOR_OTHER_TEAMS) {
@@ -1356,6 +1376,18 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         if (this.isInvulnerableTo(level, damageSource)) {
             return false;
         } else {
+            // Purpur start - Add boat fall damage config
+            if (damageSource.is(net.minecraft.tags.DamageTypeTags.IS_FALL)) {
+                // Purpur start - Minecart settings and WASD controls
+                if (getRootVehicle() instanceof net.minecraft.world.entity.vehicle.AbstractMinecart && level().purpurConfig.minecartControllable && !level().purpurConfig.minecartControllableFallDamage) {
+                    return false;
+                }
+                // Purpur end - Minecart settings and WASD controls
+                if (getRootVehicle() instanceof net.minecraft.world.entity.vehicle.Boat && !level().purpurConfig.boatsDoFallDamage) {
+                    return false;
+                }
+            }
+            // Purpur end - Add boat fall damage config
             Entity entity = damageSource.getEntity();
             if (!( // Paper - split the if statement. If below statement is false, hurtServer would not have been evaluated. Return false.
              !(entity instanceof Player player && !this.canHarmPlayer(player))
@@ -1913,6 +1945,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                 serverLevel.removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
                 this.unsetRemoved();
                 // CraftBukkit end
+                this.portalPos = org.bukkit.craftbukkit.util.CraftLocation.toBlockPosition(exit); // Purpur - Fix stuck in portals
                 this.setServerLevel(level);
                 this.connection.internalTeleport(PositionMoveRotation.of(teleportTransition), teleportTransition.relatives()); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition();
@@ -2029,7 +2062,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                             new AABB(vec3.x() - 8.0, vec3.y() - 5.0, vec3.z() - 8.0, vec3.x() + 8.0, vec3.y() + 5.0, vec3.z() + 8.0),
                             monster -> monster.isPreventingPlayerRest(this.level(), this)
                         );
-                    if (!entitiesOfClass.isEmpty()) {
+                    if (!this.level().purpurConfig.playerSleepNearMonsters && !entitiesOfClass.isEmpty()) { // Purpur - Config to ignore nearby mobs when sleeping
                         return Either.left(Player.BedSleepingProblem.NOT_SAFE);
                     }
                 }
@@ -2066,7 +2099,19 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
                     CriteriaTriggers.SLEPT_IN_BED.trigger(this);
                 });
                 if (!this.level().canSleepThroughNights()) {
-                    this.displayClientMessage(Component.translatable("sleep.not_possible"), true);
+                    // Purpur start - Customizable sleeping actionbar messages
+                    Component clientMessage;
+                    if (org.purpurmc.purpur.PurpurConfig.sleepNotPossible.isBlank()) {
+                        clientMessage = null;
+                    } else if (!org.purpurmc.purpur.PurpurConfig.sleepNotPossible.equalsIgnoreCase("default")) {
+                        clientMessage = io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.sleepNotPossible));
+                    } else {
+                        clientMessage = Component.translatable("sleep.not_possible");
+                    }
+                    if (clientMessage != null) {
+                        this.displayClientMessage(clientMessage, true);
+                    }
+                    // Purpur end - Customizable sleeping actionbar messages
                 }
 
                 this.level().updateSleepingPlayerList();
@@ -2158,6 +2203,7 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     @Override
     public void openTextEdit(SignBlockEntity signEntity, boolean isFrontText) {
+        if (level().purpurConfig.signAllowColors) this.connection.send(signEntity.getTranslatedUpdatePacket(textFilteringEnabled, isFrontText)); // Purpur - Signs allow color codes
         this.connection.send(new ClientboundBlockUpdatePacket(this.level(), signEntity.getBlockPos()));
         this.connection.send(new ClientboundOpenSignEditorPacket(signEntity.getBlockPos(), isFrontText));
     }
@@ -2467,6 +2513,26 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         this.lastSentExp = -1; // CraftBukkit - Added to reset
     }
 
+    // Purpur start - Component related conveniences
+    public void sendActionBarMessage(@Nullable String message) {
+        if (message != null && !message.isEmpty()) {
+            sendActionBarMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message));
+        }
+    }
+
+    public void sendActionBarMessage(@Nullable net.kyori.adventure.text.Component message) {
+        if (message != null) {
+            sendActionBarMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message));
+        }
+    }
+
+    public void sendActionBarMessage(@Nullable Component message) {
+        if (message != null) {
+            displayClientMessage(message, true);
+        }
+    }
+    // Purpur end - Component related conveniences
+
     @Override
     public void displayClientMessage(Component chatComponent, boolean actionBar) {
         this.sendSystemMessage(chatComponent, actionBar);
@@ -2685,6 +2751,20 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         );
     }
 
+    // Purpur start - Component related conveniences
+    public void sendMiniMessage(@Nullable String message) {
+        if (message != null && !message.isEmpty()) {
+            this.sendMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message));
+        }
+    }
+
+    public void sendMessage(@Nullable net.kyori.adventure.text.Component message) {
+        if (message != null) {
+            this.sendSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message));
+        }
+    }
+    // Purpur end - Component related conveniences
+
     public void sendSystemMessage(Component mesage) {
         this.sendSystemMessage(mesage, false);
     }
@@ -2823,8 +2903,68 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
 
     public void resetLastActionTime() {
         this.lastActionTime = Util.getMillis();
+        this.setAfk(false); // Purpur - AFK API
     }
 
+    // Purpur start - AFK API
+    private boolean isAfk = false;
+
+    @Override
+    public void setAfk(boolean afk) {
+        if (this.isAfk == afk) {
+            return;
+        }
+
+        String msg = afk ? org.purpurmc.purpur.PurpurConfig.afkBroadcastAway : org.purpurmc.purpur.PurpurConfig.afkBroadcastBack;
+
+        org.purpurmc.purpur.event.PlayerAFKEvent event = new org.purpurmc.purpur.event.PlayerAFKEvent(this.getBukkitEntity(), afk, this.level().purpurConfig.idleTimeoutKick, msg, !org.bukkit.Bukkit.isPrimaryThread());
+        if (!event.callEvent() || event.shouldKick()) {
+            return;
+        }
+
+        this.isAfk = afk;
+
+        if (!afk) {
+            resetLastActionTime();
+        }
+
+        msg = event.getBroadcastMsg();
+        if (msg != null && !msg.isEmpty()) {
+            String playerName = this.getGameProfile().getName();
+            if (org.purpurmc.purpur.PurpurConfig.afkBroadcastUseDisplayName) {
+                net.kyori.adventure.text.Component playerDisplayNameComponent = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(this.getBukkitEntity().getDisplayName());
+                playerName = net.kyori.adventure.text.serializer.plain.PlainTextComponentSerializer.plainText().serialize(playerDisplayNameComponent);
+            }
+            server.getPlayerList().broadcastMiniMessage(String.format(msg, playerName), false);
+        }
+
+        if (this.level().purpurConfig.idleTimeoutUpdateTabList) {
+            String scoreboardName = getScoreboardName();
+            String playerListName = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().serialize(getBukkitEntity().playerListName());
+            String[] split = playerListName.split(scoreboardName);
+            String prefix = (split.length > 0 ? split[0] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListPrefix, "");
+            String suffix = (split.length > 1 ? split[1] : "").replace(org.purpurmc.purpur.PurpurConfig.afkTabListSuffix, "");
+            if (afk) {
+                getBukkitEntity().setPlayerListName(org.purpurmc.purpur.PurpurConfig.afkTabListPrefix + prefix + scoreboardName + suffix + org.purpurmc.purpur.PurpurConfig.afkTabListSuffix, true);
+            } else {
+                getBukkitEntity().setPlayerListName(prefix + scoreboardName + suffix, true);
+            }
+        }
+
+        ((ServerLevel) this.level()).updateSleepingPlayerList();
+    }
+
+    @Override
+    public boolean isAfk() {
+        return this.isAfk;
+    }
+
+    @Override
+    public boolean canBeCollidedWith(Entity entity) {
+        return !this.isAfk() && super.canBeCollidedWith(entity);
+    }
+    // Purpur end - AFK API
+
     public ServerStatsCounter getStats() {
         return this.stats;
     }
@@ -3477,4 +3617,56 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         return (org.bukkit.craftbukkit.entity.CraftPlayer) super.getBukkitEntity();
     }
     // CraftBukkit end
+
+    // Purpur start - Add option to teleport to spawn if outside world border
+    public void teleport(org.bukkit.Location to) {
+        this.ejectPassengers();
+        this.stopRiding(true);
+
+        if (this.isSleeping()) {
+            this.stopSleepInBed(true, false);
+        }
+
+        if (this.containerMenu != this.inventoryMenu) {
+            this.closeContainer(org.bukkit.event.inventory.InventoryCloseEvent.Reason.TELEPORT);
+        }
+
+        ServerLevel toLevel = ((org.bukkit.craftbukkit.CraftWorld) to.getWorld()).getHandle();
+        if (this.level() == toLevel) {
+            this.connection.teleport(to);
+        } else {
+            this.server.getPlayerList().respawn(this, true, RemovalReason.KILLED, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.DEATH, to);
+        }
+    }
+    // Purpur end - Add option to teleport to spawn if outside world border
+
+    // Purpur start - Implement TPSBar
+    public boolean tpsBar() {
+        return this.tpsBar;
+    }
+
+    public void tpsBar(boolean tpsBar) {
+        this.tpsBar = tpsBar;
+    }
+    // Purpur end - Implement TPSBar
+
+    // Purpur start - Add compass command
+    public boolean compassBar() {
+        return this.compassBar;
+    }
+
+    public void compassBar(boolean compassBar) {
+        this.compassBar = compassBar;
+    }
+    // Purpur end - Add compass command
+
+    // Purpur start - Add rambar command
+    public boolean ramBar() {
+        return this.ramBar;
+    }
+
+    public void ramBar(boolean ramBar) {
+        this.ramBar = ramBar;
+    }
+    // Purpur end - Add rambar command
 }
diff --git a/net/minecraft/server/level/ServerPlayerGameMode.java b/net/minecraft/server/level/ServerPlayerGameMode.java
index c7747f6ac6234c2d398e272e739ca81a7ab8dfdf..a821fef972f3eddb8ea2c6dd4befd8a5a319749e 100644
--- a/net/minecraft/server/level/ServerPlayerGameMode.java
+++ b/net/minecraft/server/level/ServerPlayerGameMode.java
@@ -348,6 +348,7 @@ public class ServerPlayerGameMode {
                 }
                 return false;
             }
+            if (this.player.level().purpurConfig.slabHalfBreak && this.player.isShiftKeyDown() && blockState.getBlock() instanceof net.minecraft.world.level.block.SlabBlock && ((net.minecraft.world.level.block.SlabBlock) blockState.getBlock()).halfBreak(blockState, pos, this.player)) return true; // Purpur - Break individual slabs when sneaking
         }
         // CraftBukkit end
 
@@ -461,6 +462,7 @@ public class ServerPlayerGameMode {
     public InteractionHand interactHand;
     public ItemStack interactItemStack;
     public InteractionResult useItemOn(ServerPlayer player, Level level, ItemStack stack, InteractionHand hand, BlockHitResult hitResult) {
+        if (shiftClickMended(stack)) return InteractionResult.SUCCESS; // Purpur - Shift right click to use exp for mending
         BlockPos blockPos = hitResult.getBlockPos();
         BlockState blockState = level.getBlockState(blockPos);
         boolean cancelledBlock = false;
@@ -503,7 +505,7 @@ public class ServerPlayerGameMode {
             boolean flag = !player.getMainHandItem().isEmpty() || !player.getOffhandItem().isEmpty();
             boolean flag1 = player.isSecondaryUseActive() && flag;
             ItemStack itemStack = stack.copy();
-            if (!flag1) {
+            if (!flag1 || (player.level().purpurConfig.composterBulkProcess && blockState.is(net.minecraft.world.level.block.Blocks.COMPOSTER))) { // Purpur - Sneak to bulk process composter
                 InteractionResult interactionResult = blockState.useItemOn(player.getItemInHand(hand), level, player, hand, hitResult);
                 if (interactionResult.consumesAction()) {
                     CriteriaTriggers.ITEM_USED_ON_BLOCK.trigger(player, blockPos, itemStack);
@@ -549,4 +551,18 @@ public class ServerPlayerGameMode {
     public void setLevel(ServerLevel serverLevel) {
         this.level = serverLevel;
     }
+
+    // Purpur start - Shift right click to use exp for mending
+    public boolean shiftClickMended(ItemStack itemstack) {
+        if (this.player.level().purpurConfig.shiftRightClickRepairsMendingPoints > 0 && this.player.isShiftKeyDown() && this.player.getBukkitEntity().hasPermission("purpur.mending_shift_click")) {
+            int points = Math.min(this.player.totalExperience, this.player.level().purpurConfig.shiftRightClickRepairsMendingPoints);
+            if (points > 0 && itemstack.isDamaged() && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.MENDING, itemstack) > 0) {
+                this.player.giveExperiencePoints(itemstack.getDamageValue() == 1 ? -2 : -points);
+                this.player.level().addFreshEntity(new net.minecraft.world.entity.ExperienceOrb(this.player.level(), this.player.getX(), this.player.getY(), this.player.getZ(), points, org.bukkit.entity.ExperienceOrb.SpawnReason.UNKNOWN, this.player, this.player));
+                return true;
+            }
+        }
+        return false;
+    }
+    // Purpur end - Shift right click to use exp for mending
 }
diff --git a/net/minecraft/server/level/WorldGenRegion.java b/net/minecraft/server/level/WorldGenRegion.java
index 45d6a95196a791d366791e02d23c53b85c3aee16..2c1e32faf86e7f1d1abfc6f132d27f49fd476925 100644
--- a/net/minecraft/server/level/WorldGenRegion.java
+++ b/net/minecraft/server/level/WorldGenRegion.java
@@ -322,6 +322,7 @@ public class WorldGenRegion implements WorldGenLevel {
             return true;
         } else {
             // Paper start - Buffer OOB setBlock calls
+            if (!org.purpurmc.purpur.PurpurConfig.loggerSuppressSetBlockFarChunk) // Purpur - Logger settings (suppressing pointless logs)
             if (!hasSetFarWarned) {
             Util.logAndPauseIfInIde(
                 "Detected setBlock in a far chunk ["
diff --git a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 31101f5af05772a0842b56ecc2dd8c79eebee933..0f9870982d304e946f00407b4a8e6f1855c8da36 100644
--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -39,10 +39,11 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     public final Connection connection; // Paper
     private final boolean transferred;
     //private long keepAliveTime; // Paper - improve keepalives
-    //private boolean keepAlivePending; // Paper - improve keepalives
+    private boolean keepAlivePending; // Paper - improve keepalives // Purpur - Alternative Keepalive Handling
     //private long keepAliveChallenge; // Paper - improve keepalives
     private long closedListenerTime;
     private boolean closed = false;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList(); // Purpur - Alternative Keepalive Handling
     private volatile int latency; // Paper - improve keepalives - make volatile
     private final io.papermc.paper.util.KeepAlive keepAlive; // Paper - improve keepalives
     private volatile boolean suspendFlushingOnServerThread = false;
@@ -53,6 +54,10 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
     public final java.util.Map<java.util.UUID, net.kyori.adventure.resource.ResourcePackCallback> packCallbacks = new java.util.concurrent.ConcurrentHashMap<>(); // Paper - adventure resource pack callbacks
     private static final long KEEPALIVE_LIMIT = Long.getLong("paper.playerconnection.keepalive", 30) * 1000; // Paper - provide property to set keepalive limit
     protected static final net.minecraft.resources.ResourceLocation MINECRAFT_BRAND = net.minecraft.resources.ResourceLocation.withDefaultNamespace("brand"); // Paper - Brand support
+    // Purpur start - Purpur client support
+    protected static final net.minecraft.resources.ResourceLocation PURPUR_CLIENT = net.minecraft.resources.ResourceLocation.fromNamespaceAndPath("purpur", "client");
+    public boolean purpurClient;
+    // Purpur end - Purpur client support
     // Paper start - retain certain values
     public @Nullable String playerBrand;
     public final java.util.Set<String> pluginMessagerChannels;
@@ -115,6 +120,18 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         // Paper start - improve keepalives
         long now = System.nanoTime();
         io.papermc.paper.util.KeepAlive.PendingKeepAlive pending = this.keepAlive.pendingKeepAlives.peek();
+        // Purpur start - Alternative Keepalive Handling
+        if (org.purpurmc.purpur.PurpurConfig.useAlternateKeepAlive) {
+            if (this.keepAlivePending && !keepAlives.isEmpty() && keepAlives.contains(packet.getId())) {
+                int ping = (int) (Util.getMillis() - packet.getId());
+                int updatedLatency = (this.latency * 3 + ping) / 4;
+                this.latency = updatedLatency;
+                this.keepAlivePending = false;
+                keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
+            }
+            return;
+        } else
+        // Purpur end - Alternative Keepalive Handling
         if (pending != null && pending.challengeId() == packet.getId()) {
             this.keepAlive.pendingKeepAlives.remove(pending);
 
@@ -189,6 +206,12 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
                 return;
             }
 
+            // Purpur start - Purpur client support
+            if (identifier.equals(PURPUR_CLIENT)) {
+                this.purpurClient = true;
+            }
+            // Purpur end - Purpur client support
+
             if (identifier.equals(MINECRAFT_BRAND)) {
                 this.playerBrand = new net.minecraft.network.FriendlyByteBuf(io.netty.buffer.Unpooled.wrappedBuffer(data)).readUtf(256);
             }
@@ -268,6 +291,23 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
         Profiler.get().push("keepAlive");
         long millis = Util.getMillis();
         // Paper start - improve keepalives
+        // Purpur start - Alternative Keepalive Handling
+        if (org.purpurmc.purpur.PurpurConfig.useAlternateKeepAlive) {
+            if (this.checkIfClosed(millis) && !this.processedDisconnect) {
+                long currTime = System.nanoTime();
+                if ((currTime - this.keepAlive.lastKeepAliveTx) >= java.util.concurrent.TimeUnit.SECONDS.toNanos(1L)) { // 1 second
+                    this.keepAlive.lastKeepAliveTx = currTime;
+                    if (this.keepAlivePending && !this.processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                        this.disconnect(TIMEOUT_DISCONNECTION_MESSAGE, io.papermc.paper.connection.DisconnectionReason.TIMEOUT);
+                    } else if (this.checkIfClosed(millis)) {
+                        this.keepAlivePending = true;
+                        this.keepAlives.add(millis); // currentTime is ID
+                        this.send(new ClientboundKeepAlivePacket(millis));
+                    }
+                }
+            }
+        } else
+        // Purpur end - Alternative Keepalive Handling
         if (this.checkIfClosed(millis) && !this.processedDisconnect) {
             long currTime = System.nanoTime();
 
diff --git a/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index 95bb18d625c1cfeb494dba6b0bb0669ec19dcd57..90a6c313a6ef0d89aa5b6ac3c5825e52c5bb558b 100644
--- a/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -333,6 +333,20 @@ public class ServerGamePacketListenerImpl
         this.playerGameConnection =  new io.papermc.paper.connection.PaperPlayerGameConnection(this); // Paper
     }
 
+    // Purpur start - AFK API
+    private final com.google.common.cache.LoadingCache<org.bukkit.craftbukkit.entity.CraftPlayer, Boolean> kickPermissionCache = com.google.common.cache.CacheBuilder.newBuilder()
+        .maximumSize(1000)
+        .expireAfterWrite(1, java.util.concurrent.TimeUnit.MINUTES)
+        .build(
+            new com.google.common.cache.CacheLoader<>() {
+                @Override
+                public Boolean load(org.bukkit.craftbukkit.entity.CraftPlayer player) {
+                    return player.hasPermission("purpur.bypassIdleKick");
+                }
+            }
+        );
+    // Purpur end - AFK API
+
     @Override
     public void tick() {
         // Folia start - region threading
@@ -397,6 +411,12 @@ public class ServerGamePacketListenerImpl
         if (this.player.getLastActionTime() > 0L
             && this.server.getPlayerIdleTimeout() > 0
             && Util.getMillis() - this.player.getLastActionTime() > this.server.getPlayerIdleTimeout() * 1000L * 60L && !this.player.wonGame) { // Paper - Prevent AFK kick while watching end credits
+            // Purpur start - AFK API
+            this.player.setAfk(true);
+            if (!this.player.level().purpurConfig.idleTimeoutKick || (!Boolean.parseBoolean(System.getenv("PURPUR_FORCE_IDLE_KICK")) && kickPermissionCache.getUnchecked(this.player.getBukkitEntity()))) {
+                return;
+            }
+            // Purpur end - AFK API
             this.player.resetLastActionTime(); // CraftBukkit - SPIGOT-854
             this.disconnect(Component.translatable("multiplayer.disconnect.idling"), org.bukkit.event.player.PlayerKickEvent.Cause.IDLING); // Paper - kick event cause
         }
@@ -686,6 +706,8 @@ public class ServerGamePacketListenerImpl
                     this.lastYaw = to.getYaw();
                     this.lastPitch = to.getPitch();
 
+                    if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                     Location oldTo = to.clone();
                     PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                     this.cserver.getPluginManager().callEvent(event);
@@ -765,6 +787,7 @@ public class ServerGamePacketListenerImpl
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
         if (packet.getId() == this.awaitingTeleport) {
             if (this.awaitingPositionFromClient == null) {
+                ServerGamePacketListenerImpl.LOGGER.warn("Disconnected on accept teleport packet. Was not expecting position data from client at this time"); // Purpur - Add more logger output for invalid movement kicks
                 this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
                 return;
             }
@@ -1298,6 +1321,10 @@ public class ServerGamePacketListenerImpl
             final int maxBookPageSize = pageMax.intValue();
             final double multiplier = Math.clamp(io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.totalMultiplier, 0.3D, 1D);
             long byteAllowed = maxBookPageSize;
+            // Purpur start - PlayerBookTooLargeEvent
+            int slot = packet.slot();
+            ItemStack itemstack = Inventory.isHotbarSlot(slot) || slot == Inventory.SLOT_OFFHAND ? this.player.getInventory().getItem(slot) : ItemStack.EMPTY;
+            // Purpur end - PlayerBookTooLargeEvent
             for (final String page : pageList) {
                 final int byteLength = page.getBytes(java.nio.charset.StandardCharsets.UTF_8).length;
                 byteTotal += byteLength;
@@ -1322,7 +1349,8 @@ public class ServerGamePacketListenerImpl
             }
 
             if (byteTotal > byteAllowed) {
-                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send a book too large. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                ServerGamePacketListenerImpl.LOGGER.warn("{} tried to send too large of a book. Book size: {} - Allowed: {} - Pages: {}", this.player.getScoreboardName(), byteTotal, byteAllowed, pageList.size());
+                org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent event = new org.purpurmc.purpur.event.player.PlayerBookTooLargeEvent(player.getBukkitEntity(), itemstack.asBukkitCopy()); if (event.shouldKickPlayer()) // Purpur - PlayerBookTooLargeEvent
                 this.disconnectAsync(Component.literal("Book too large!"), org.bukkit.event.player.PlayerKickEvent.Cause.ILLEGAL_ACTION); // Paper - kick event cause // Paper - add proper async disconnect
                 return;
             }
@@ -1341,9 +1369,13 @@ public class ServerGamePacketListenerImpl
             Optional<String> optional = packet.title();
             optional.ifPresent(list::add);
             list.addAll(packet.pages());
+            // Purpur start - Allow color codes in books
+            boolean hasEditPerm = getCraftPlayer().hasPermission("purpur.book.color.edit");
+            boolean hasSignPerm = hasEditPerm || getCraftPlayer().hasPermission("purpur.book.color.sign");
+            // Purpur end - Allow color codes in books
             Consumer<List<FilteredText>> consumer = optional.isPresent()
-                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot)
-                : list1 -> this.updateBookContents(list1, slot);
+                ? texts -> this.signBook(texts.get(0), texts.subList(1, texts.size()), slot, hasSignPerm) // Purpur - Allow color codes in books
+                : list1 -> this.updateBookContents(list1, slot, hasEditPerm); // Purpur - Allow color codes in books
             // Folia start - region threading
             this.filterTextPacket(list).thenAcceptAsync(consumer, this.player::queuePacketTask).whenComplete((Object res, Throwable thr) -> {
                 if (thr != null) {
@@ -1355,23 +1387,33 @@ public class ServerGamePacketListenerImpl
     }
 
     private void updateBookContents(List<FilteredText> pages, int index) {
+    // Purpur start - Allow color codes in books
+        updateBookContents(pages, index, false);
+    }
+    private void updateBookContents(List<FilteredText> pages, int index, boolean hasPerm) {
+    // Purpur end - Allow color codes in books
         // CraftBukkit start
         ItemStack handItem = this.player.getInventory().getItem(index);
         ItemStack item = handItem.copy();
         // CraftBukkit end
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
-            List<Filterable<String>> list = pages.stream().map(this::filterableFromOutgoing).toList();
+            List<Filterable<String>> list = pages.stream().map(filteredText -> filterableFromOutgoing(filteredText).map(s -> color(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             item.set(DataComponents.WRITABLE_BOOK_CONTENT, new WritableBookContent(list));
             this.player.getInventory().setItem(index, CraftEventFactory.handleEditBookEvent(this.player, index, handItem, item)); // CraftBukkit // Paper - Don't ignore result (see other callsite for handleEditBookEvent)
         }
     }
 
     private void signBook(FilteredText title, List<FilteredText> pages, int index) {
+        // Purpur start - Allow color codes in books
+        signBook(title, pages, index, false);
+    }
+    private void signBook(FilteredText title, List<FilteredText> pages, int index, boolean hasPerm) {
+        // Purpur end - Allow color codes in books
         ItemStack item = this.player.getInventory().getItem(index);
         if (item.has(DataComponents.WRITABLE_BOOK_CONTENT)) {
             ItemStack itemStack = item.transmuteCopy(Items.WRITTEN_BOOK);
             itemStack.remove(DataComponents.WRITABLE_BOOK_CONTENT);
-            List<Filterable<Component>> list = pages.stream().map(filteredText -> this.filterableFromOutgoing(filteredText).<Component>map(Component::literal)).toList();
+            List<Filterable<Component>> list = pages.stream().map((filteredText) -> this.filterableFromOutgoing(filteredText).map(s -> hexColor(s, hasPerm))).toList(); // Purpur - Allow color codes in books
             itemStack.set(
                 DataComponents.WRITTEN_BOOK_CONTENT,
                 new WrittenBookContent(this.filterableFromOutgoing(title), this.player.getName().getString(), 0, list, true)
@@ -1385,6 +1427,16 @@ public class ServerGamePacketListenerImpl
         return this.player.isTextFilteringEnabled() ? Filterable.passThrough(filteredText.filteredOrEmpty()) : Filterable.from(filteredText);
     }
 
+    // Purpur start - Allow color codes in books
+    private Component hexColor(String str, boolean hasPerm) {
+        return hasPerm ? PaperAdventure.asVanilla(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacyAmpersand().deserialize(str)) : Component.literal(str);
+    }
+
+    private String color(String str, boolean hasPerm) {
+        return hasPerm ? org.bukkit.ChatColor.color(str, false) : str;
+    }
+    // Purpur end - Allow color codes in books
+
     @Override
     public void handleEntityTagQuery(ServerboundEntityTagQueryPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
@@ -1424,7 +1476,15 @@ public class ServerGamePacketListenerImpl
     @Override
     public void handleMovePlayer(ServerboundMovePlayerPacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
-        if (containsInvalidValues(packet.getX(0.0), packet.getY(0.0), packet.getZ(0.0), packet.getYRot(0.0F), packet.getXRot(0.0F))) {
+        // Purpur start - Add more logger output for invalid movement kicks
+        boolean invalidX = Double.isNaN(packet.getX(0.0));
+        boolean invalidY = Double.isNaN(packet.getY(0.0));
+        boolean invalidZ = Double.isNaN(packet.getZ(0.0));
+        boolean invalidYaw = !Floats.isFinite(packet.getYRot(0.0F));
+        boolean invalidPitch = !Floats.isFinite(packet.getXRot(0.0F));
+        if (invalidX || invalidY || invalidZ || invalidYaw || invalidPitch) {
+            ServerGamePacketListenerImpl.LOGGER.warn(String.format("Disconnected on move player packet. Invalid data: x=%b, y=%b, z=%b, yaw=%b, pitch=%b", invalidX, invalidY, invalidZ, invalidYaw, invalidPitch));
+        // Purpur end - Add more logger output for invalid movement kicks
             this.disconnect(Component.translatable("multiplayer.disconnect.invalid_player_movement"), org.bukkit.event.player.PlayerKickEvent.Cause.INVALID_PLAYER_MOVEMENT); // Paper - kick event cause
         } else {
             ServerLevel serverLevel = this.player.level();
@@ -1607,7 +1667,7 @@ public class ServerGamePacketListenerImpl
                                         movedWrongly = true;
                                         if (event.getLogWarning())
                                      // Paper end
-                                    LOGGER.warn("{} moved wrongly!", this.player.getName().getString());
+                                    LOGGER.warn("{} moved wrongly!, ({})", this.player.getName().getString(), verticalDelta); // Purpur - AFK API
                                     } // Paper
                                 }
 
@@ -1672,6 +1732,8 @@ public class ServerGamePacketListenerImpl
                                         this.lastYaw = to.getYaw();
                                         this.lastPitch = to.getPitch();
 
+                                        if (!to.getWorld().getUID().equals(from.getWorld().getUID()) || to.getBlockX() != from.getBlockX() || to.getBlockY() != from.getBlockY() || to.getBlockZ() != from.getBlockZ() || to.getYaw() != from.getYaw() || to.getPitch() != from.getPitch()) this.player.resetLastActionTime(); // Purpur - AFK API
+
                                         Location oldTo = to.clone();
                                         PlayerMoveEvent event = new PlayerMoveEvent(player, from, to);
                                         this.cserver.getPluginManager().callEvent(event);
@@ -1727,6 +1789,13 @@ public class ServerGamePacketListenerImpl
                                         this.player.tryResetCurrentImpulseContext();
                                     }
 
+                                    // Purpur start - Dont run with scissors!
+                                    if (this.player.level().purpurConfig.dontRunWithScissors && this.player.isSprinting() && !(this.player.level().purpurConfig.ignoreScissorsInWater && this.player.isInWater()) && !(this.player.level().purpurConfig.ignoreScissorsInLava && this.player.isInLava()) && (isScissors(this.player.getItemInHand(InteractionHand.MAIN_HAND)) || isScissors(this.player.getItemInHand(InteractionHand.OFF_HAND))) && (int) (Math.random() * 10) == 0) {
+                                        this.player.hurtServer(this.player.level(), this.player.damageSources().scissors(), (float) this.player.level().purpurConfig.scissorsRunningDamage);
+                                        if (!org.purpurmc.purpur.PurpurConfig.dontRunWithScissors.isBlank()) this.player.sendActionBarMessage(org.purpurmc.purpur.PurpurConfig.dontRunWithScissors);
+                                    }
+                                    // Purpur end - Dont run with scissors!
+
                                     this.player.checkMovementStatistics(this.player.getX() - x, this.player.getY() - y, this.player.getZ() - z);
                                     this.lastGoodX = this.player.getX();
                                     this.lastGoodY = this.player.getY();
@@ -1744,6 +1813,17 @@ public class ServerGamePacketListenerImpl
         }
     }
 
+    // Purpur start - Dont run with scissors!
+    public boolean isScissors(ItemStack stack) {
+        if (!stack.is(Items.SHEARS)) return false;
+
+        ResourceLocation itemModelReference = stack.get(net.minecraft.core.component.DataComponents.ITEM_MODEL);
+        if (itemModelReference != null && itemModelReference.equals(this.player.level().purpurConfig.dontRunWithScissorsItemModelReference)) return true;
+
+        return stack.getOrDefault(DataComponents.CUSTOM_MODEL_DATA, net.minecraft.world.item.component.CustomModelData.EMPTY).equals(net.minecraft.world.item.component.CustomModelData.EMPTY);
+    }
+    // Purpur end - Dont run with scissors!
+
     private boolean shouldCheckPlayerMovement(boolean isElytraMovement) {
         if (this.isSingleplayerOwner()) {
             return false;
@@ -2141,6 +2221,7 @@ public class ServerGamePacketListenerImpl
 
                 boolean cancelled;
                 if (hitResult == null || hitResult.getType() != HitResult.Type.BLOCK) {
+                    if (this.player.gameMode.shiftClickMended(itemInHand)) return; // Purpur - Shift right click to use exp for mending
                     org.bukkit.event.player.PlayerInteractEvent event = CraftEventFactory.callPlayerInteractEvent(this.player, Action.RIGHT_CLICK_AIR, itemInHand, hand);
                     cancelled = event.useItemInHand() == Event.Result.DENY;
                 } else {
@@ -2810,6 +2891,7 @@ public class ServerGamePacketListenerImpl
 
                 AABB boundingBox = target.getBoundingBox();
                 if (this.player.canInteractWithEntity(boundingBox, io.papermc.paper.configuration.GlobalConfiguration.get().misc.clientInteractionLeniencyDistance.or(3.0))) { // Paper - configurable lenience value for interact range
+                    if (target instanceof net.minecraft.world.entity.Mob mob) mob.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
                     packet.dispatch(
                         new ServerboundInteractPacket.Handler() {
                             private void performInteraction(InteractionHand hand, ServerGamePacketListenerImpl.EntityInteraction entityInteraction, PlayerInteractEntityEvent event) { // CraftBukkit
@@ -2822,6 +2904,8 @@ public class ServerGamePacketListenerImpl
 
                                     ServerGamePacketListenerImpl.this.cserver.getPluginManager().callEvent(event);
 
+                                    player.processClick(hand); // Purpur - Ridables
+
                                     // Entity in bucket - SPIGOT-4048 and SPIGOT-6859a
                                     if ((target instanceof net.minecraft.world.entity.animal.Bucketable && target instanceof LivingEntity && origItem != null && origItem == Items.WATER_BUCKET) && (event.isCancelled() || ServerGamePacketListenerImpl.this.player.getInventory().getSelectedItem().isEmpty() || !ServerGamePacketListenerImpl.this.player.getInventory().getSelectedItem().is(origItem))) {
                                         target.resendPossiblyDesyncedEntityData(ServerGamePacketListenerImpl.this.player); // Paper - The entire mob gets deleted, so resend it
@@ -3622,7 +3706,7 @@ public class ServerGamePacketListenerImpl
     @Override
     public void handleChangeGameMode(ServerboundChangeGameModePacket packet) {
         PacketUtils.ensureRunningOnSameThread(packet, this, this.player.level());
-        if (!this.player.hasPermissions(2)) {
+        if (!this.player.hasPermissions(2) && !player.getBukkitEntity().hasPermission("purpur.debug.f3n")) { // Purpur - Add permission for F3+N debug
             LOGGER.warn(
                 "Player {} tried to change game mode to {} without required permissions",
                 this.player.getGameProfile().getName(),
diff --git a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
index 91ba46925961ea1deb5b92a063115b7d7e4341fc..2ab268c2e4746f5ee00c7e1c6be0dcd8a94f66f8 100644
--- a/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerLoginPacketListenerImpl.java
@@ -279,7 +279,7 @@ public class ServerLoginPacketListenerImpl implements ServerLoginPacketListener,
                         ServerLoginPacketListenerImpl.LOGGER.warn("Failed to verify username but will let them in anyway!");
                         ServerLoginPacketListenerImpl.this.startClientVerification(ServerLoginPacketListenerImpl.this.createOfflineProfile(string1)); // Spigot
                     } else {
-                        ServerLoginPacketListenerImpl.this.disconnect(Component.translatable("multiplayer.disconnect.unverified_username"));
+                        ServerLoginPacketListenerImpl.this.disconnect(org.purpurmc.purpur.PurpurConfig.unverifiedUsername.equals("default") ? Component.translatable("multiplayer.disconnect.unverified_username") : io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.purpurmc.purpur.PurpurConfig.unverifiedUsername))); // Purpur - Config for unverified username message
                         ServerLoginPacketListenerImpl.LOGGER.error("Username '{}' tried to join with an invalid session", string1);
                     }
                 } catch (AuthenticationUnavailableException var4) {
diff --git a/net/minecraft/server/network/ServerStatusPacketListenerImpl.java b/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
index 465559113071a47e706f77a5b0996597ee986b3d..1b966dc52b067cd9d1fa9f500b692e3f75f1cc90 100644
--- a/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerStatusPacketListenerImpl.java
@@ -37,6 +37,7 @@ public class ServerStatusPacketListenerImpl implements ServerStatusPacketListene
         } else {
             this.hasRequestedStatus = true;
             // this.connection.send(new ClientboundStatusResponsePacket(this.status)); // Paper
+            if (net.minecraft.server.MinecraftServer.getServer().getStatus().version().isEmpty()) return; // Purpur - Fix 'outdated server' showing in ping before server fully boots - do not respond to pings before we know the protocol version
             com.destroystokyo.paper.network.StandardPaperServerListPingEventImpl.processRequest(net.minecraft.server.MinecraftServer.getServer(), this.connection); // Paper - handle status request
         }
     }
diff --git a/net/minecraft/server/players/PlayerList.java b/net/minecraft/server/players/PlayerList.java
index 7294af08125db842d7457ab44e83912107a86f91..ea325839bded4e05dd369f41ddd157618d9f79f8 100644
--- a/net/minecraft/server/players/PlayerList.java
+++ b/net/minecraft/server/players/PlayerList.java
@@ -486,6 +486,7 @@ public abstract class PlayerList {
                 scoreboard.addPlayerToTeam(player.getScoreboardName(), collideRuleTeam);
             }
             // Paper end - Configurable player collision
+            org.purpurmc.purpur.task.BossBarTask.addToAll(player); // Purpur - Implement TPSBar
             PlayerList.LOGGER.info("{}[{}] logged in with entity id {} at ([{}]{}, {}, {})", player.getName().getString(), loggableAddress, player.getId(), serverLevel.serverLevelData.getLevelName(), player.getX(), player.getY(), player.getZ());
             // Paper start - Send empty chunk, so players aren't stuck in the world loading screen with our chunk system not sending chunks when dead
             if (player.isDeadOrDying()) {
@@ -593,6 +594,7 @@ public abstract class PlayerList {
     }
     public @Nullable net.kyori.adventure.text.Component remove(ServerPlayer player, net.kyori.adventure.text.Component leaveMessage) {
         // Paper end - Fix kick event leave message not being sent
+        org.purpurmc.purpur.task.BossBarTask.removeFromAll(player.getBukkitEntity()); // Purpur - Implement TPSBar
         ServerLevel serverLevel = player.level();
         player.awardStat(Stats.LEAVE_GAME);
         // CraftBukkit start - Quitting must be before we do final save of data, in case plugins need to modify it
@@ -977,6 +979,20 @@ public abstract class PlayerList {
         }
     }
 
+    // Purpur start - Component related conveniences
+    public void broadcastMiniMessage(@Nullable String message, boolean overlay) {
+        if (message != null && !message.isEmpty()) {
+            this.broadcastMessage(net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(message), overlay);
+        }
+    }
+
+    public void broadcastMessage(@Nullable net.kyori.adventure.text.Component message, boolean overlay) {
+        if (message != null) {
+            this.broadcastSystemMessage(io.papermc.paper.adventure.PaperAdventure.asVanilla(message), overlay);
+        }
+    }
+    // Purpur end - Component related conveniences
+
     public void broadcastAll(Packet<?> packet, ResourceKey<Level> dimension) {
         for (ServerPlayer serverPlayer : this.players) {
             if (serverPlayer.level().dimension() == dimension) {
@@ -1065,6 +1081,7 @@ public abstract class PlayerList {
             } else {
                 b = (byte)(24 + permLevel);
             }
+            if (b < 28 && player.getBukkitEntity().hasPermission("purpur.debug.f3n")) b = 28; // Purpur - Add permission for F3+N debug
 
             player.connection.send(new ClientboundEntityEventPacket(player, b));
         }
@@ -1073,11 +1090,32 @@ public abstract class PlayerList {
         player.getBukkitEntity().recalculatePermissions(); // CraftBukkit
         this.server.getCommands().sendCommands(player);
         } // Paper - Add sendOpLevel API
+
+        // Purpur start - Barrels and enderchests 6 rows
+        if (org.purpurmc.purpur.PurpurConfig.enderChestSixRows && org.purpurmc.purpur.PurpurConfig.enderChestPermissionRows) {
+            org.bukkit.craftbukkit.entity.CraftHumanEntity bukkit = player.getBukkitEntity();
+            if (bukkit.hasPermission("purpur.enderchest.rows.six")) {
+                player.sixRowEnderchestSlotCount = 54;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.five")) {
+                player.sixRowEnderchestSlotCount = 45;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.four")) {
+                player.sixRowEnderchestSlotCount = 36;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.three")) {
+                player.sixRowEnderchestSlotCount = 27;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.two")) {
+                player.sixRowEnderchestSlotCount = 18;
+            } else if (bukkit.hasPermission("purpur.enderchest.rows.one")) {
+                player.sixRowEnderchestSlotCount = 9;
+            }
+        } else {
+            player.sixRowEnderchestSlotCount = -1;
+        }
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     // Paper start - whitelist verify event / login event
     public LoginResult canBypassFullServerLogin(final GameProfile profile, final LoginResult currentResult, final Connection connection) { // Folia - region threading - add connection parameter
-        final boolean shouldKick = !this.countConnection(connection, this.maxPlayers) && !this.canBypassPlayerLimit(profile); // Folia - region threading - we control connection state here now async, not player list size
+        final boolean shouldKick = !this.countConnection(connection, this.maxPlayers) && !(/*player.hasPermission("purpur.joinfullserver") || */this.canBypassPlayerLimit(profile)); // Folia - region threading - we control connection state here now async, not player list size // Purpur - Allow player join full server by permission TODO: this hasn't worked for a while, so comment it out until we can reliably check perms of the player joining 
         final io.papermc.paper.event.player.PlayerServerFullCheckEvent fullCheckEvent = new io.papermc.paper.event.player.PlayerServerFullCheckEvent(
             com.destroystokyo.paper.profile.CraftPlayerProfile.asBukkitMirror(profile),
             io.papermc.paper.adventure.PaperAdventure.asAdventure(currentResult.message),
diff --git a/net/minecraft/server/players/SleepStatus.java b/net/minecraft/server/players/SleepStatus.java
index 2a7ae521654ad5c9f392baa5562e64bb71b13097..3a3e6992563236141db687084aeec9684437a7db 100644
--- a/net/minecraft/server/players/SleepStatus.java
+++ b/net/minecraft/server/players/SleepStatus.java
@@ -15,7 +15,7 @@ public class SleepStatus {
 
     public boolean areEnoughDeepSleeping(int requiredSleepPercentage, List<ServerPlayer> sleepingPlayers) {
         // CraftBukkit start
-        int i = (int) sleepingPlayers.stream().filter(player -> player.isSleepingLongEnough() || player.fauxSleeping).count();
+        int i = (int) sleepingPlayers.stream().filter(player -> player.isSleepingLongEnough() || player.fauxSleeping || (player.level().purpurConfig.idleTimeoutCountAsSleeping && player.isAfk())).count(); // Purpur - AFK API
         boolean anyDeepSleep = sleepingPlayers.stream().anyMatch(Player::isSleepingLongEnough);
         return anyDeepSleep && i >= this.sleepersNeeded(requiredSleepPercentage);
         // CraftBukkit end
@@ -43,7 +43,7 @@ public class SleepStatus {
         for (ServerPlayer serverPlayer : players) {
             if (!serverPlayer.isSpectator()) {
                 this.activePlayers++;
-                if (serverPlayer.isSleeping() || serverPlayer.fauxSleeping) { // CraftBukkit
+                if (serverPlayer.isSleeping() || serverPlayer.fauxSleeping || (serverPlayer.level().purpurConfig.idleTimeoutCountAsSleeping && serverPlayer.isAfk())) { // CraftBukkit // Purpur - AFK API
                     this.sleepingPlayers++;
                 }
                 // CraftBukkit start
diff --git a/net/minecraft/stats/ServerRecipeBook.java b/net/minecraft/stats/ServerRecipeBook.java
index 7e1a06b97ab0c744e910df1c82454ce5686c1870..a7cf3d2dbc3bb8db49629ec5ba049e196af836b7 100644
--- a/net/minecraft/stats/ServerRecipeBook.java
+++ b/net/minecraft/stats/ServerRecipeBook.java
@@ -102,6 +102,7 @@ public class ServerRecipeBook extends RecipeBook {
     private void loadRecipes(List<ResourceKey<Recipe<?>>> recipes, Consumer<ResourceKey<Recipe<?>>> output, Predicate<ResourceKey<Recipe<?>>> isRecognized) {
         for (ResourceKey<Recipe<?>> resourceKey : recipes) {
             if (!isRecognized.test(resourceKey)) {
+                if (!org.purpurmc.purpur.PurpurConfig.loggerSuppressUnrecognizedRecipeErrors) // Purpur - Logger settings (suppressing pointless logs)
                 LOGGER.error("Tried to load unrecognized recipe: {} removed now.", resourceKey);
             } else {
                 output.accept(resourceKey);
diff --git a/net/minecraft/util/StringUtil.java b/net/minecraft/util/StringUtil.java
index 77947e6915facee44588943fcd3e5b513de37e77..c3a99fe7b49858bc0ca9a7f800b0db40465f6901 100644
--- a/net/minecraft/util/StringUtil.java
+++ b/net/minecraft/util/StringUtil.java
@@ -87,6 +87,7 @@ public class StringUtil {
 
     // Paper start - Username validation
     public static boolean isReasonablePlayerName(final String name) {
+        if (true) return org.purpurmc.purpur.PurpurConfig.usernameValidCharactersPattern.matcher(name).matches(); // Purpur - Configurable valid characters for usernames
         if (name.isEmpty() || name.length() > 16) {
             return false;
         }
diff --git a/net/minecraft/world/damagesource/CombatRules.java b/net/minecraft/world/damagesource/CombatRules.java
index d5524038314591a10c9f08a68e2ac91f6079a897..bf82de45bf98e8605a1fdb69803f75f471c4af43 100644
--- a/net/minecraft/world/damagesource/CombatRules.java
+++ b/net/minecraft/world/damagesource/CombatRules.java
@@ -15,7 +15,7 @@ public class CombatRules {
 
     public static float getDamageAfterAbsorb(LivingEntity entity, float damage, DamageSource damageSource, float armorValue, float armorToughness) {
         float f = 2.0F + armorToughness / 4.0F;
-        float f1 = Mth.clamp(armorValue - damage / f, armorValue * 0.2F, 20.0F);
+        float f1 = Mth.clamp(armorValue - damage / f, armorValue * 0.2F, org.purpurmc.purpur.PurpurConfig.limitArmor ? 20F : Float.MAX_VALUE); // Purpur - Add attribute clamping and armor limit config
         float f2 = f1 / 25.0F;
         ItemStack weaponItem = damageSource.getWeaponItem();
         float f3;
@@ -30,7 +30,7 @@ public class CombatRules {
     }
 
     public static float getDamageAfterMagicAbsorb(float damage, float enchantModifiers) {
-        float f = Mth.clamp(enchantModifiers, 0.0F, 20.0F);
+        float f = Mth.clamp(enchantModifiers, 0.0F, org.purpurmc.purpur.PurpurConfig.limitArmor ? 20F : Float.MAX_VALUE); // Purpur - Add attribute clamping and armor limit config
         return damage * (1.0F - f / 25.0F);
     }
 }
diff --git a/net/minecraft/world/damagesource/CombatTracker.java b/net/minecraft/world/damagesource/CombatTracker.java
index c7473920cc014646c2cc52bb5f716858aa1c242e..96adda89805436448edd9a2feb473a62bcb09c94 100644
--- a/net/minecraft/world/damagesource/CombatTracker.java
+++ b/net/minecraft/world/damagesource/CombatTracker.java
@@ -64,7 +64,7 @@ public class CombatTracker {
 
     private Component getMessageForAssistedFall(Entity entity, Component entityDisplayName, String hasWeaponTranslationKey, String noWeaponTranslationKey) {
         ItemStack itemStack = entity instanceof LivingEntity livingEntity && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(livingEntity) ? livingEntity.getMainHandItem() : ItemStack.EMPTY; // Folia - region threading
-        return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
+        return !itemStack.isEmpty() && (org.purpurmc.purpur.PurpurConfig.playerDeathsAlwaysShowItem || itemStack.has(DataComponents.CUSTOM_NAME)) // Purpur - always show item in player death messages
             ? Component.translatable(hasWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName, itemStack.getDisplayName())
             : Component.translatable(noWeaponTranslationKey, this.mob.getDisplayName(), entityDisplayName);
     }
@@ -108,6 +108,15 @@ public class CombatTracker {
                 Component component = ComponentUtils.wrapInSquareBrackets(Component.translatable(string + ".link")).withStyle(INTENTIONAL_GAME_DESIGN_STYLE);
                 return Component.translatable(string + ".message", this.mob.getDisplayName(), component);
             } else {
+                // Purpur start - Dont run with scissors!
+                if (damageSource.isScissors()) {
+                    return damageSource.getLocalizedDeathMessage(org.purpurmc.purpur.PurpurConfig.deathMsgRunWithScissors, this.mob);
+                // Purpur start - Stonecutter damage
+                } else if (damageSource.isStonecutter()) {
+                    return damageSource.getLocalizedDeathMessage(org.purpurmc.purpur.PurpurConfig.deathMsgStonecutter, this.mob);
+                // Purpur end - Stonecutter damage
+                }
+                // Purpur end - Dont run with scissors!
                 return damageSource.getLocalizedDeathMessage(this.mob);
             }
         }
diff --git a/net/minecraft/world/damagesource/DamageSource.java b/net/minecraft/world/damagesource/DamageSource.java
index 111f79b1c5d0d041ce55feb4dd21c4ecc9824843..fd5aab977fae070fe205d171b72891620e3503f8 100644
--- a/net/minecraft/world/damagesource/DamageSource.java
+++ b/net/minecraft/world/damagesource/DamageSource.java
@@ -30,6 +30,8 @@ public class DamageSource {
     @Nullable
     private org.bukkit.block.BlockState fromBlockSnapshot; // Captured block snapshot when the eventBlockDamager is not relevant (e.g. for bad respawn point explosions the block is already removed)
     private boolean critical; // Supports arrows and sweeping damage
+    private boolean scissors = false; // Purpur - Dont run with scissors!
+    private boolean stonecutter = false; // Purpur - Stonecutter damage
 
     public DamageSource knownCause(final org.bukkit.event.entity.EntityDamageEvent.DamageCause cause) {
         final DamageSource damageSource = this.copy();
@@ -42,6 +44,30 @@ public class DamageSource {
         return this.knownCause;
     }
 
+    // Purpur start - Dont run with scissors!
+    public DamageSource scissors() {
+        this.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.SUICIDE);
+        this.scissors = true;
+        return this;
+    }
+
+    public boolean isScissors() {
+        return this.scissors;
+    }
+    // Purpur end - Dont run with scissors!
+
+    // Purpur start -  - Stonecutter damage
+    public DamageSource stonecutter() {
+        this.knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.CONTACT);
+        this.stonecutter = true;
+        return this;
+    }
+
+    public boolean isStonecutter() {
+        return this.stonecutter;
+    }
+    // Purpur end - Stonecutter damage
+
     @Nullable
     public Entity eventEntityDamager() {
         return this.eventEntityDamager;
@@ -103,6 +129,8 @@ public class DamageSource {
         damageSource.eventBlockDamager = this.eventBlockDamager;
         damageSource.fromBlockSnapshot = this.fromBlockSnapshot;
         damageSource.critical = this.critical;
+        damageSource.scissors = this.isScissors(); // Purpur - Dont run with scissors!
+        damageSource.stonecutter = this.isStonecutter(); // Purpur - Stonecutter damage
         return damageSource;
     }
     // CraftBukkit end
@@ -169,12 +197,21 @@ public class DamageSource {
         } else {
             Component component = this.causingEntity == null ? this.directEntity.getDisplayName() : this.causingEntity.getDisplayName();
             ItemStack itemStack = this.causingEntity instanceof LivingEntity livingEntity1 && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(livingEntity1) ? livingEntity1.getMainHandItem() : ItemStack.EMPTY; // Folia - region threading
-            return !itemStack.isEmpty() && itemStack.has(DataComponents.CUSTOM_NAME)
+            return !itemStack.isEmpty() && (org.purpurmc.purpur.PurpurConfig.playerDeathsAlwaysShowItem || itemStack.has(DataComponents.CUSTOM_NAME)) // Purpur - always show item in player death messages
                 ? Component.translatable(string + ".item", livingEntity.getDisplayName(), component, itemStack.getDisplayName())
                 : Component.translatable(string, livingEntity.getDisplayName(), component);
         }
     }
 
+    // Purpur start - Component related conveniences
+    public Component getLocalizedDeathMessage(String str, LivingEntity entity) {
+        net.kyori.adventure.text.Component name = io.papermc.paper.adventure.PaperAdventure.asAdventure(entity.getDisplayName());
+        net.kyori.adventure.text.minimessage.tag.resolver.TagResolver template = net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("player", name);
+        net.kyori.adventure.text.Component component = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(str, template);
+        return io.papermc.paper.adventure.PaperAdventure.asVanilla(component);
+    }
+    // Purpur end - Component related conveniences
+
     public String getMsgId() {
         return this.type().msgId();
     }
diff --git a/net/minecraft/world/damagesource/DamageSources.java b/net/minecraft/world/damagesource/DamageSources.java
index cc206ecff2d95f0398ca424c178a336ad80cc396..7afad362801082e5f2e3aceda864ad2a7d4e5ebb 100644
--- a/net/minecraft/world/damagesource/DamageSources.java
+++ b/net/minecraft/world/damagesource/DamageSources.java
@@ -42,6 +42,8 @@ public class DamageSources {
     private final DamageSource stalagmite;
     private final DamageSource outsideBorder;
     private final DamageSource genericKill;
+    private final DamageSource scissors; // Purpur - Dont run with scissors!
+    private final DamageSource stonecutter; // Purpur - Stonecutter damage
 
     public DamageSources(RegistryAccess registry) {
         this.damageTypes = registry.lookupOrThrow(Registries.DAMAGE_TYPE);
@@ -70,6 +72,8 @@ public class DamageSources {
         this.stalagmite = this.source(DamageTypes.STALAGMITE);
         this.outsideBorder = this.source(DamageTypes.OUTSIDE_BORDER);
         this.genericKill = this.source(DamageTypes.GENERIC_KILL);
+        this.scissors = this.source(DamageTypes.MAGIC).scissors(); // Purpur - Dont run with scissors!
+        this.stonecutter = this.source(DamageTypes.MAGIC).stonecutter(); // Purpur - Stonecutter damage
     }
 
     private DamageSource source(ResourceKey<DamageType> damageTypeKey) {
@@ -84,6 +88,18 @@ public class DamageSources {
         return new DamageSource(this.damageTypes.getOrThrow(damageTypeKey), causingEntity, directEntity);
     }
 
+    // Purpur start - Dont run with scissor
+    public DamageSource scissors() {
+        return this.scissors;
+    }
+    // Purpur end - Dont run with scissors!
+
+    // Purpur start - Stonecutter damage
+    public DamageSource stonecutter() {
+        return this.stonecutter;
+    }
+    // Purpur end - Stonecutter damage
+
     public DamageSource inFire() {
         return this.inFire;
     }
diff --git a/net/minecraft/world/effect/HungerMobEffect.java b/net/minecraft/world/effect/HungerMobEffect.java
index 0890694ae96b6cd60079c34066e7a6e288f038e8..6c0e6bd2a171edc57dec71af178764454de73313 100644
--- a/net/minecraft/world/effect/HungerMobEffect.java
+++ b/net/minecraft/world/effect/HungerMobEffect.java
@@ -12,7 +12,7 @@ class HungerMobEffect extends MobEffect {
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
         if (entity instanceof Player player) {
-            player.causeFoodExhaustion(0.005F * (amplifier + 1), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.HUNGER_EFFECT); // CraftBukkit - EntityExhaustionEvent
+            player.causeFoodExhaustion(entity.level().purpurConfig.humanHungerExhaustionAmount * (amplifier + 1), org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.HUNGER_EFFECT); // CraftBukkit - EntityExhaustionEvent // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/PoisonMobEffect.java b/net/minecraft/world/effect/PoisonMobEffect.java
index 75327fd96858fd508ea63a6983e5cbc655a8800f..73cfc61ac3f8e33e6b9f4fd08a292266c0adb535 100644
--- a/net/minecraft/world/effect/PoisonMobEffect.java
+++ b/net/minecraft/world/effect/PoisonMobEffect.java
@@ -12,8 +12,8 @@ public class PoisonMobEffect extends MobEffect {
 
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
-        if (entity.getHealth() > 1.0F) {
-            entity.hurtServer(level, entity.damageSources().magic().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.POISON), 1.0F); // CraftBukkit
+        if (entity.getHealth() > entity.level().purpurConfig.entityMinimalHealthPoison) { // Purpur
+            entity.hurtServer(level, entity.damageSources().magic().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.POISON), entity.level().purpurConfig.entityPoisonDegenerationAmount); // CraftBukkit // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/RegenerationMobEffect.java b/net/minecraft/world/effect/RegenerationMobEffect.java
index 76cffa4d4d18d6c04749d941dbdf5eb60aed4095..81481267a1577721dcc405f39a4c350bd59ac9a2 100644
--- a/net/minecraft/world/effect/RegenerationMobEffect.java
+++ b/net/minecraft/world/effect/RegenerationMobEffect.java
@@ -11,7 +11,7 @@ class RegenerationMobEffect extends MobEffect {
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
         if (entity.getHealth() < entity.getMaxHealth()) {
-            entity.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.MAGIC_REGEN); // CraftBukkit
+            entity.heal(entity.level().purpurConfig.entityHealthRegenAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.MAGIC_REGEN); // CraftBukkit // Purpur - Config MobEffect by world
         }
 
         return true;
diff --git a/net/minecraft/world/effect/SaturationMobEffect.java b/net/minecraft/world/effect/SaturationMobEffect.java
index c192165910f6b139df6f604d0bce989061efa9cb..622c23f4570d07de8bee9623bf900aabb3331ded 100644
--- a/net/minecraft/world/effect/SaturationMobEffect.java
+++ b/net/minecraft/world/effect/SaturationMobEffect.java
@@ -16,7 +16,8 @@ class SaturationMobEffect extends InstantenousMobEffect {
             int oldFoodLevel = player.getFoodData().foodLevel;
             org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(player, amplifier + 1 + oldFoodLevel);
             if (!event.isCancelled()) {
-                player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, 1.0F);
+                if (player.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) player.burpDelay = player.level().purpurConfig.playerBurpDelay; // Purpur - Burp delay
+                player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, entity.level().purpurConfig.humanSaturationRegenAmount); // Purpur - Config MobEffect by world
             }
 
             ((org.bukkit.craftbukkit.entity.CraftPlayer) player.getBukkitEntity()).sendHealthUpdate();
diff --git a/net/minecraft/world/effect/WitherMobEffect.java b/net/minecraft/world/effect/WitherMobEffect.java
index 1fc9e1ad541c46124183a401b2a7d99aea69cecf..881271f0bc77a8a8a7d31daad9a8188bebaca67b 100644
--- a/net/minecraft/world/effect/WitherMobEffect.java
+++ b/net/minecraft/world/effect/WitherMobEffect.java
@@ -12,7 +12,7 @@ public class WitherMobEffect extends MobEffect {
 
     @Override
     public boolean applyEffectTick(ServerLevel level, LivingEntity entity, int amplifier) {
-        entity.hurtServer(level, entity.damageSources().wither(), 1.0F);
+        entity.hurtServer(level, entity.damageSources().wither(), entity.level().purpurConfig.entityWitherDegenerationAmount); // Purpur - Config MobEffect by world
         return true;
     }
 
diff --git a/net/minecraft/world/entity/Entity.java b/net/minecraft/world/entity/Entity.java
index aff383132d8cbe47a59fc71d0932e243c4e3ba0b..9b5a58354fd71ddcaa17dce326224b82963bccb5 100644
--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -148,6 +148,7 @@ import org.jetbrains.annotations.Contract;
 import org.slf4j.Logger;
 
 public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess, ScoreHolder, DataComponentGetter, ca.spottedleaf.moonrise.patches.chunk_system.entity.ChunkSystemEntity, ca.spottedleaf.moonrise.patches.entity_tracker.EntityTrackerEntity { // Paper - rewrite chunk system // Paper - optimise entity tracker
+    public static javax.script.ScriptEngine scriptEngine = new javax.script.ScriptEngineManager().getEngineByName("rhino"); // Purpur - Configurable entity base attributes
     // CraftBukkit start
     private static final int CURRENT_LEVEL = 2;
     public boolean preserveMotion = true; // Paper - Fix Entity Teleportation and cancel velocity if teleported; keep initial motion on first snapTo
@@ -280,8 +281,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public double xOld;
     public double yOld;
     public double zOld;
+    public float maxUpStep; // Purpur - Add option to set armorstand step height
     public boolean noPhysics;
-    public final RandomSource random = SHARED_RANDOM; // Paper - Share random for entities to make them more random
+    public final RandomSource random; // Paper - Share random for entities to make them more random // Add toggle for RNG manipulation
     public int tickCount;
     private int remainingFireTicks;
     public boolean wasTouchingWater;
@@ -315,8 +317,8 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public PortalProcessor portalProcess;
     public int portalCooldown;
     private boolean invulnerable;
-    protected UUID uuid = Mth.createInsecureUUID(this.random);
-    protected String stringUUID = this.uuid.toString();
+    protected UUID uuid; // Purpur - Add toggle for RNG manipulation
+    protected String stringUUID; // Purpur - Add toggle for RNG manipulation
     private boolean hasGlowingTag;
     private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
@@ -371,6 +373,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public long activatedTick = Integer.MIN_VALUE;
     public boolean isTemporarilyActive;
     public long activatedImmunityTick = Integer.MIN_VALUE;
+    public @Nullable Boolean immuneToFire = null; // Purpur - Fire immune API
 
     public void inactiveTick() {
     }
@@ -550,10 +553,39 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
     // Folia end - region ticking
 
+    // Purpur start - Add canSaveToDisk to Entity
+    public boolean canSaveToDisk() {
+        return true;
+    }
+    // Purpur end - Add canSaveToDisk to Entity
+
+    // Purpur start - copied from Mob - API for any mob to burn daylight
+    public boolean isSunBurnTick() {
+        if (this.level().isBrightOutside() && !this.level().isClientSide) {
+            float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
+            BlockPos blockPos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
+            boolean flag = this.isInWaterOrRain() || this.isInPowderSnow || this.wasInPowderSnow;
+            if (lightLevelDependentMagicValue > 0.5F
+                && this.random.nextFloat() * 30.0F < (lightLevelDependentMagicValue - 0.4F) * 2.0F
+                && !flag
+                && this.level().canSeeSky(blockPos)) {
+                return true;
+            }
+        }
+
+        return false;
+    }
+    // Purpur end - copied from Mob - API for any mob to burn daylight
+
     public Entity(EntityType<?> entityType, Level level) {
         this.type = entityType;
         this.level = level;
         this.dimensions = entityType.getDimensions();
+        // Purpur start - Add toggle for RNG manipulation
+        this.random = level == null || level.purpurConfig.entitySharedRandom ? SHARED_RANDOM : RandomSource.create();
+        this.uuid = Mth.createInsecureUUID(this.random);
+        this.stringUUID = this.uuid.toString();
+        // Purpur end - Add toggle for RNG manipulation
         this.position = Vec3.ZERO;
         this.blockPosition = BlockPos.ZERO;
         this.chunkPosition = ChunkPos.ZERO;
@@ -927,6 +959,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             && this.level.paperConfig().environment.netherCeilingVoidDamageHeight.test(v -> this.getY() >= v)
             && (!(this instanceof Player player) || !player.getAbilities().invulnerable))) {
             // Paper end - Configurable nether ceiling damage
+            if (this.level.purpurConfig.teleportOnNetherCeilingDamage && this.level.getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER && this instanceof ServerPlayer player) player.teleport(org.bukkit.craftbukkit.util.CraftLocation.toBukkit(this.level.getSharedSpawnPos(), this.level)); else // Purpur - Add option to teleport to spawn on nether ceiling damage
             this.onBelowWorld();
         }
     }
@@ -1905,7 +1938,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public boolean fireImmune() {
-        return this.getType().fireImmune();
+        return this.immuneToFire != null ? immuneToFire : this.getType().fireImmune(); // Purpur - add fire immune API
     }
 
     public boolean causeFallDamage(double fallDistance, float damageMultiplier, DamageSource damageSource) {
@@ -2601,6 +2634,11 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 output.putBoolean("Paper.FreezeLock", true);
             }
             // Paper end
+            // Purpur start - Fire immune API
+            if (immuneToFire != null) {
+                output.putBoolean("Purpur.FireImmune", immuneToFire);
+            }
+            // Purpur end - Fire immune API
         } catch (Throwable var7) {
             CrashReport crashReport = CrashReport.forThrowable(var7, "Saving entity NBT");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being saved");
@@ -2721,6 +2759,9 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
             freezeLocked = input.getBooleanOr("Paper.FreezeLock", false);
             // Paper end
+
+            immuneToFire = input.read("Purpur.FireImmune", com.mojang.serialization.Codec.BOOL).orElse(null); // Purpur - Fire immune API
+
         } catch (Throwable var7) {
             CrashReport crashReport = CrashReport.forThrowable(var7, "Loading entity NBT");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Entity being loaded");
@@ -2999,6 +3040,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             if (this.isAlive() && this instanceof Leashable leashable2) {
                 if (leashable2.getLeashHolder() == player) {
                     if (!this.level().isClientSide()) {
+                        if (hand == InteractionHand.OFF_HAND && (level().purpurConfig.villagerCanBeLeashed || level().purpurConfig.wanderingTraderCanBeLeashed) && this instanceof net.minecraft.world.entity.npc.AbstractVillager) return InteractionResult.CONSUME; // Purpur - Allow leashing villagers
                         // Paper start - EntityUnleashEvent
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerUnleashEntityEvent(
                             leashable2, player, hand, !player.hasInfiniteMaterials(), true
@@ -3297,6 +3339,13 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                 this.passengers = ImmutableList.copyOf(list);
             }
 
+            // Purpur start - Ridables
+            if (isRidable() && this.passengers.get(0) == passenger && passenger instanceof Player player) {
+                onMount(player);
+                this.rider = player;
+            }
+            // Purpur end - Ridables
+
             if (!passenger.hasNullCallback()) this.gameEvent(GameEvent.ENTITY_MOUNT, passenger); // Folia - region threading - do not fire game events for entities not added
         }
     }
@@ -3340,6 +3389,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             }
             // CraftBukkit end
             } // Folia - region threading - suppress entire event logic during worldgen
+            // Purpur start - Ridables
+            if (this.rider != null && this.passengers.get(0) == this.rider) {
+                onDismount(this.rider);
+                this.rider = null;
+            }
+            // Purpur end - Ridables
             if (this.passengers.size() == 1 && this.passengers.get(0) == passenger) {
                 this.passengers = ImmutableList.of();
             } else {
@@ -3409,15 +3464,18 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return Vec3.directionFromRotation(this.getRotationVector());
     }
 
+    public BlockPos portalPos = BlockPos.ZERO; // Purpur - Fix stuck in portals
     public void setAsInsidePortal(Portal portal, BlockPos pos) {
         if (this.isOnPortalCooldown()) {
+            if (!(level().purpurConfig.playerFixStuckPortal && this instanceof Player && !pos.equals(this.portalPos))) // Purpur - Fix stuck in portals
             this.setPortalCooldown();
-        } else {
+        } else if (this.level.purpurConfig.entitiesCanUsePortals || this instanceof ServerPlayer) { // Purpur - Entities can use portals
             if (this.portalProcess == null || !this.portalProcess.isSamePortal(portal)) {
                 this.portalProcess = new PortalProcessor(portal, pos.immutable());
             } else if (!this.portalProcess.isInsidePortalThisTick()) {
                 this.portalProcess.updateEntryPosition(pos.immutable());
                 this.portalProcess.setAsInsidePortalThisTick(true);
+                this.portalPos = BlockPos.ZERO; // Purpur - Fix stuck in portals
             }
         }
     }
@@ -3626,7 +3684,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public int getMaxAirSupply() {
-        return this.maxAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir()
+        return this.level == null? this.maxAirTicks : this.level().purpurConfig.drowningAirTicks; // CraftBukkit - SPIGOT-6907: re-implement LivingEntity#setMaximumAir() // Purpur - Drowning Settings
     }
 
     public int getAirSupply() {
@@ -4973,7 +5031,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     // CraftBukkit end
 
     public boolean canUsePortal(boolean allowPassengers) {
-        return (allowPassengers || !this.isPassenger()) && this.isAlive();
+        return (allowPassengers || !this.isPassenger()) && this.isAlive() && (this.level.purpurConfig.entitiesCanUsePortals || this instanceof ServerPlayer); // Purpur - Entities can use portals
     }
 
     public boolean canTeleport(Level fromLevel, Level toLevel) {
@@ -5510,6 +5568,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return Mth.lerp(partialTick, this.yRotO, this.yRot);
     }
 
+    // Purpur start - Stop squids floating on top of water
+    public AABB getAxisForFluidCheck() {
+        return this.getBoundingBox().deflate(0.001D);
+    }
+    // Purpur end - Stop squids floating on top of water
+
     // Paper start - optimise collisions
     public boolean updateFluidHeightAndDoFluidPushing(final TagKey<Fluid> fluid, final double flowScale) {
         if (this.touchingUnloadedChunk()) {
@@ -5937,7 +6001,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public float maxUpStep() {
-        return 0.0F;
+        return maxUpStep; // Purpur - Add option to set armorstand step height
     }
 
     public void onExplosionHit(@Nullable Entity entity) {
@@ -6208,4 +6272,44 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return ((ServerLevel) this.level()).isPositionEntityTicking(this.blockPosition());
     }
     // Paper end - Expose entity id counter
+    // Purpur start - Ridables
+    @Nullable
+    private Player rider = null;
+
+    @Nullable
+    public Player getRider() {
+        return rider;
+    }
+
+    public boolean isRidable() {
+        return false;
+    }
+
+    public boolean isControllable() {
+        return true;
+    }
+
+    public void onMount(Player rider) {
+        if (this instanceof Mob) {
+            ((Mob) this).setTarget(null, null);
+            ((Mob) this).getNavigation().stop();
+        }
+        rider.setJumping(false); // fixes jump on mount
+    }
+
+    public void onDismount(Player player) {
+    }
+
+    public boolean onSpacebar() {
+        return false;
+    }
+
+    public boolean onClick(InteractionHand hand) {
+        return false;
+    }
+
+    public boolean processClick(InteractionHand hand) {
+        return false;
+    }
+    // Purpur end - Ridables
 }
diff --git a/net/minecraft/world/entity/EntitySelector.java b/net/minecraft/world/entity/EntitySelector.java
index 15daba9062d54a5bdf335c3645a3227ccb5a8e06..1842cbe25cc0f9be937caf0a78e915bd3d6ea1e5 100644
--- a/net/minecraft/world/entity/EntitySelector.java
+++ b/net/minecraft/world/entity/EntitySelector.java
@@ -28,6 +28,8 @@ public final class EntitySelector {
         return net.minecraft.util.Mth.clamp(serverPlayer.getStats().getValue(net.minecraft.stats.Stats.CUSTOM.get(net.minecraft.stats.Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE) >= playerInsomniaTicks;
     };
     // Paper end - Ability to control player's insomnia and phantoms
+    public static Predicate<Player> notAfk = (player) -> !player.isAfk(); // Purpur - AFK API
+
     // Paper start - Affects Spawning API
     public static final Predicate<Entity> PLAYER_AFFECTS_SPAWNING = (entity) -> {
         return !entity.isSpectator() && entity.isAlive() && entity instanceof Player player && player.affectsSpawning;
diff --git a/net/minecraft/world/entity/EntityType.java b/net/minecraft/world/entity/EntityType.java
index 5e6c339357c54a69415d2d858b18dc0d67b4c448..6fd871f9c5a509eaa576c16b93f1242959a6e41a 100644
--- a/net/minecraft/world/entity/EntityType.java
+++ b/net/minecraft/world/entity/EntityType.java
@@ -1105,6 +1105,16 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return register(vanillaEntityId(key), builder);
     }
 
+    // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+    public static EntityType<?> getFromBukkitType(org.bukkit.entity.EntityType bukkitType) {
+        return getFromKey(ResourceLocation.parse(bukkitType.getKey().toString()));
+    }
+
+    public static EntityType<?> getFromKey(ResourceLocation location) {
+        return BuiltInRegistries.ENTITY_TYPE.getValue(location);
+    }
+    // Purpur end - PlayerSetSpawnerTypeWithEggEvent
+
     public static ResourceLocation getKey(EntityType<?> entityType) {
         return BuiltInRegistries.ENTITY_TYPE.getKey(entityType);
     }
@@ -1348,6 +1358,16 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
         return this.category;
     }
 
+    // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+    public String getName() {
+        return BuiltInRegistries.ENTITY_TYPE.getKey(this).getPath();
+    }
+
+    public String getTranslatedName() {
+        return getDescription().getString();
+    }
+    // Purpur end - PlayerSetSpawnerTypeWithEggEvent
+
     public String getDescriptionId() {
         return this.descriptionId;
     }
@@ -1407,7 +1427,11 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
                 entity.load(input);
             },
             // Paper end - Don't fire sync event during generation
-            () -> LOGGER.warn("Skipping Entity with id {}", input.getStringOr("id", "[invalid]"))
+            // Purpur start - log skipped entity's position
+            () -> {LOGGER.warn("Skipping Entity with id {}", input.getStringOr("id", "[invalid]"));
+                EntityType.LOGGER.warn("Location: {} {}", level.getWorld().getName(), input.read("Pos", net.minecraft.world.phys.Vec3.CODEC).orElse(net.minecraft.world.phys.Vec3.ZERO));
+            }
+            // Purpur end - log skipped entity's position
         );
     }
 
diff --git a/net/minecraft/world/entity/ExperienceOrb.java b/net/minecraft/world/entity/ExperienceOrb.java
index a62edee768c30c99213baa6bd736d67ae52b558c..c8354d46ed909090f7c15f396863bf7d73afcefa 100644
--- a/net/minecraft/world/entity/ExperienceOrb.java
+++ b/net/minecraft/world/entity/ExperienceOrb.java
@@ -358,7 +358,7 @@ public class ExperienceOrb extends Entity {
     public void playerTouch(Player entity) {
         if (entity instanceof ServerPlayer serverPlayer) {
             if (entity.takeXpDelay == 0 && new com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent(serverPlayer.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) this.getBukkitEntity()).callEvent()) { // Paper - PlayerPickupExperienceEvent
-                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, 2, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2;
+                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, this.level().purpurConfig.playerExpPickupDelay, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2; // Purpur - Configurable player pickup exp delay
                 entity.take(this, 1);
                 int i = this.repairPlayerItems(serverPlayer, this.getValue());
                 if (i > 0) {
@@ -374,7 +374,7 @@ public class ExperienceOrb extends Entity {
     }
 
     private int repairPlayerItems(ServerPlayer player, int value) {
-        Optional<EnchantedItemInUse> randomItemWith = EnchantmentHelper.getRandomItemWith(
+        Optional<EnchantedItemInUse> randomItemWith = level().purpurConfig.useBetterMending ? EnchantmentHelper.getMostDamagedItemWith(EnchantmentEffectComponents.REPAIR_WITH_XP, player) : EnchantmentHelper.getRandomItemWith( // Purpur - Add option to mend the most damaged equipment first
             EnchantmentEffectComponents.REPAIR_WITH_XP, player, ItemStack::isDamaged
         );
         if (randomItemWith.isPresent()) {
diff --git a/net/minecraft/world/entity/GlowSquid.java b/net/minecraft/world/entity/GlowSquid.java
index aab9adb8313c4b18279c7fd7500ef04bda09c6c1..86a694b94045b47f6e98c480645f75738b8a052c 100644
--- a/net/minecraft/world/entity/GlowSquid.java
+++ b/net/minecraft/world/entity/GlowSquid.java
@@ -27,6 +27,47 @@ public class GlowSquid extends Squid {
         super(entityType, level);
     }
 
+    // Purpur start - Flying squids! Oh my!
+    @Override
+    public boolean canFly() {
+        return this.level().purpurConfig.glowSquidsCanFly;
+    }
+    // Purpur end - Flying squids! Oh my!
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.glowSquidRidable;
+    }
+
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.glowSquidControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.glowSquidMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.glowSquidTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.glowSquidAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected ParticleOptions getInkParticle() {
         return ParticleTypes.GLOW_SQUID_INK;
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 39b6fef48c6ba0ec53b6fbb5bd848774351c4a1e..444888b9a8744360ac05c16c2ca9104e0c103e90 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -238,9 +238,9 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     protected int noActionTime;
     public float lastHurt;
     public boolean jumping;
-    public float xxa;
-    public float yya;
-    public float zza;
+    public float xxa; public float getStrafeMot() { return xxa; } public void setStrafeMot(float strafe) { xxa = strafe; } // Purpur - OBFHELPER
+    public float yya; public float getVerticalMot() { return yya; } public void setVerticalMot(float vertical) { yya = vertical; } // Purpur - OBFHELPER
+    public float zza; public float getForwardMot() { return zza; } public void setForwardMot(float forward) { zza = forward; } // Purpur - OBFHELPER
     protected InterpolationHandler interpolation = new InterpolationHandler(this);
     protected double lerpYHeadRot;
     protected int lerpHeadSteps;
@@ -286,6 +286,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     public boolean silentDeath = false; // Paper - mark entity as dying silently for cancellable death event
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
     public int shieldBlockingDelay = this.level().paperConfig().misc.shieldBlockingDelay; // Paper - Make shield blocking delay configurable
+    protected boolean shouldBurnInDay = false; public boolean shouldBurnInDay() { return this.shouldBurnInDay; } public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; } // Purpur - API for any mob to burn daylight
     // CraftBukkit end
     // Folia start - region threading
     @Override
@@ -310,7 +311,8 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
     protected LivingEntity(EntityType<? extends LivingEntity> entityType, Level level) {
         super(entityType, level);
-        this.attributes = new AttributeMap(DefaultAttributes.getSupplier(entityType));
+        this.attributes = new AttributeMap(DefaultAttributes.getSupplier(entityType), this); // Purpur - Ridables
+        this.initAttributes(); // Purpur - Configurable entity base attributes
         this.craftAttributes = new org.bukkit.craftbukkit.attribute.CraftAttributeMap(this.attributes); // CraftBukkit
         // CraftBukkit - this.setHealth(this.getMaxHealth()) inlined and simplified to skip the instanceof check for Player, as getBukkitEntity() is not initialized in constructor
         this.entityData.set(LivingEntity.DATA_HEALTH_ID, this.getMaxHealth());
@@ -329,6 +331,8 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         return new EntityEquipment();
     }
 
+    protected void initAttributes() {}// Purpur - Configurable entity base attributes
+
     public Brain<?> getBrain() {
         return this.brain;
     }
@@ -384,6 +388,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             .add(Attributes.CAMERA_DISTANCE)
             .add(Attributes.WAYPOINT_TRANSMIT_RANGE);
     }
+    public boolean shouldSendAttribute(Attribute attribute) { return true; } // Purpur - Ridables
 
     @Override
     protected void checkFallDamage(double y, boolean onGround, BlockState state, BlockPos pos) {
@@ -464,6 +469,12 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 if (d < 0.0) {
                     double damagePerBlock = serverLevel1.getWorldBorder().getDamagePerBlock();
                     if (damagePerBlock > 0.0) {
+                        // Purpur start - Add option to teleport to spawn if outside world border
+                        if (this.level().purpurConfig.teleportIfOutsideBorder && this instanceof ServerPlayer serverPlayer) {
+                            serverPlayer.teleport(org.bukkit.craftbukkit.util.CraftLocation.toBukkit(this.level().getSharedSpawnPos(), this.level()));
+                            return;
+                        }
+                        // Purpur end - Add option to teleport to spawn if outside world border
                         this.hurtServer(serverLevel1, this.damageSources().outOfBorder(), Math.max(1, Mth.floor(-d * damagePerBlock)));
                     }
                 }
@@ -476,10 +487,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                     && (!flag || !((Player)this).getAbilities().invulnerable);
                 if (flag1) {
                     this.setAirSupply(this.decreaseAirSupply(this.getAirSupply()));
-                    if (this.getAirSupply() == -20) {
+                    if (this.getAirSupply() == -this.level().purpurConfig.drowningDamageInterval) { // Purpur - Drowning Settings
                         this.setAirSupply(0);
                         serverLevel1.broadcastEntityEvent(this, (byte)67);
-                        this.hurtServer(serverLevel1, this.damageSources().drown(), 2.0F);
+                        this.hurtServer(serverLevel1, this.damageSources().drown(), (float) this.level().purpurConfig.damageFromDrowning); // Purpur - Drowning Settings
                     }
                 } else if (this.getAirSupply() < this.getMaxAirSupply()) {
                     this.setAirSupply(this.increaseAirSupply(this.getAirSupply()));
@@ -802,6 +813,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         this.getSleepingPos().ifPresent(blockPos -> output.store("sleeping_pos", BlockPos.CODEC, blockPos));
         DataResult<Dynamic<?>> dataResult = this.brain.serializeStart(NbtOps.INSTANCE).map(tag -> new Dynamic<>(NbtOps.INSTANCE, tag));
         dataResult.resultOrPartial(LOGGER::error).ifPresent(dynamic -> output.store("Brain", Codec.PASSTHROUGH, (Dynamic<?>)dynamic));
+        output.putBoolean("Purpur.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - API for any mob to burn daylight
         if (this.lastHurtByPlayer != null) {
             this.lastHurtByPlayer.store(output, "last_hurt_by_player");
             output.putInt("last_hurt_by_player_memory_time", this.lastHurtByPlayerMemoryTime);
@@ -928,6 +940,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             } // Paper - The sleeping pos will always also set the actual pos, so a desync suggests something is wrong
         }, this::clearSleepingPos);
         input.read("Brain", Codec.PASSTHROUGH).ifPresent(dynamic -> this.brain = this.makeBrain((Dynamic<?>)dynamic));
+        this.shouldBurnInDay = input.getBooleanOr("Purpur.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - API for any mob to burn daylight
         this.lastHurtByPlayer = EntityReference.read(input, "last_hurt_by_player");
         this.lastHurtByPlayerMemoryTime = input.getIntOr("last_hurt_by_player_memory_time", 0);
         this.lastHurtByMob = EntityReference.read(input, "last_hurt_by_mob");
@@ -1062,15 +1075,33 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         if (lookingEntity != null) {
             ItemStack itemBySlot = this.getItemBySlot(EquipmentSlot.HEAD);
             EntityType<?> type = lookingEntity.getType();
-            if (type == EntityType.SKELETON && itemBySlot.is(Items.SKELETON_SKULL)
-                || type == EntityType.ZOMBIE && itemBySlot.is(Items.ZOMBIE_HEAD)
-                || type == EntityType.PIGLIN && itemBySlot.is(Items.PIGLIN_HEAD)
-                || type == EntityType.PIGLIN_BRUTE && itemBySlot.is(Items.PIGLIN_HEAD)
-                || type == EntityType.CREEPER && itemBySlot.is(Items.CREEPER_HEAD)) {
-                d *= 0.5;
+            // Purpur start - Mob head visibility percent
+            if (type == EntityType.SKELETON && itemBySlot.is(Items.SKELETON_SKULL)) {
+                d *= lookingEntity.level().purpurConfig.skeletonHeadVisibilityPercent;
+            }
+            else if (type == EntityType.ZOMBIE && itemBySlot.is(Items.ZOMBIE_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.zombieHeadVisibilityPercent;
+            }
+            else if ((type == EntityType.PIGLIN || type == EntityType.PIGLIN_BRUTE) && itemBySlot.is(Items.PIGLIN_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.piglinHeadVisibilityPercent;
+            }
+            else if (type == EntityType.CREEPER && itemBySlot.is(Items.CREEPER_HEAD)) {
+                d *= lookingEntity.level().purpurConfig.creeperHeadVisibilityPercent;
             }
+            // Purpur end - Mob head visibility percent
         }
 
+        // Purpur start - Configurable mob blindness
+        if (lookingEntity instanceof LivingEntity entityliving) {
+            if (entityliving.hasEffect(MobEffects.BLINDNESS)) {
+                int amplifier = entityliving.getEffect(MobEffects.BLINDNESS).getAmplifier();
+                for (int i = 0; i < amplifier; i++) {
+                    d *= this.level().purpurConfig.mobsBlindnessMultiplier;
+                }
+            }
+        }
+        // Purpur end - Configurable mob blindness
+
         return d;
     }
 
@@ -1116,6 +1147,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             Iterator<MobEffectInstance> iterator = this.activeEffects.values().iterator();
             while (iterator.hasNext()) {
                 MobEffectInstance effect = iterator.next();
+                if (cause == EntityPotionEffectEvent.Cause.MILK && !this.level().purpurConfig.milkClearsBeneficialEffects && effect.getEffect().value().isBeneficial()) continue; // Purpur - Milk Keeps Beneficial Effects
                 EntityPotionEffectEvent event = CraftEventFactory.callEntityPotionEffectChangeEvent(this, effect, null, cause, EntityPotionEffectEvent.Action.CLEARED);
                 if (event.isCancelled()) {
                     continue;
@@ -1441,6 +1473,24 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 this.stopSleeping();
             }
 
+            // Purpur start - One Punch Man!
+            if (damageSource.getEntity() instanceof net.minecraft.world.entity.player.Player player && damageSource.getEntity().level().purpurConfig.creativeOnePunch && !damageSource.is(DamageTypeTags.IS_PROJECTILE)) {
+                if (player.isCreative()) {
+                    org.apache.commons.lang3.mutable.MutableDouble attackDamage = new org.apache.commons.lang3.mutable.MutableDouble();
+                    player.getMainHandItem().forEachModifier(EquipmentSlot.MAINHAND, (attributeHolder, attributeModifier) -> {
+                        if (attributeModifier.operation() == AttributeModifier.Operation.ADD_VALUE) {
+                            attackDamage.addAndGet(attributeModifier.amount());
+                        }
+                    });
+
+                    if (attackDamage.doubleValue() == 0.0D) {
+                        // One punch!
+                        amount = 9999F;
+                    }
+                }
+            }
+            // Purpur end - One Punch Man!
+
             this.noActionTime = 0;
             if (amount < 0.0F) {
                 amount = 0.0F;
@@ -1702,10 +1752,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
     protected Player resolvePlayerResponsibleForDamage(DamageSource damageSource) {
         Entity entity = damageSource.getEntity();
         if (entity instanceof Player player) {
-            this.setLastHurtByPlayer(player, 100);
+            this.setLastHurtByPlayer(player, this.level().purpurConfig.mobLastHurtByPlayerTime); // Purpur - Config for mob last hurt by player time
         } else if (entity instanceof Wolf wolf && wolf.isTame()) {
             if (wolf.getOwnerReference() != null) {
-                this.setLastHurtByPlayer(wolf.getOwnerReference().getUUID(), 100);
+                this.setLastHurtByPlayer(wolf.getOwnerReference().getUUID(), this.level().purpurConfig.mobLastHurtByPlayerTime); // Purpur - Config for mob last hurt by player time
             } else {
                 this.lastHurtByPlayer = null;
                 this.lastHurtByPlayerMemoryTime = 0;
@@ -1756,6 +1806,18 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                 }
             }
 
+            // Purpur start - Totems work in inventory
+            if (level().purpurConfig.totemOfUndyingWorksInInventory && this instanceof ServerPlayer player && (itemStack == null || itemStack.getItem() != Items.TOTEM_OF_UNDYING) && player.getBukkitEntity().hasPermission("purpur.inventory_totem")) {
+                for (ItemStack item : player.getInventory().getNonEquipmentItems()) {
+                    if (item.getItem() == Items.TOTEM_OF_UNDYING) {
+                        itemInHand = item;
+                        itemStack = item.copy();
+                        break;
+                    }
+                }
+            }
+            // Purpur end - Totems work in inventory
+
             final org.bukkit.inventory.EquipmentSlot handSlot = (hand != null) ? org.bukkit.craftbukkit.CraftEquipmentSlot.getHand(hand) : null;
             final EntityResurrectEvent event = new EntityResurrectEvent((org.bukkit.entity.LivingEntity) this.getBukkitEntity(), handSlot);
             event.setCancelled(itemStack == null);
@@ -1901,7 +1963,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         if (this.level() instanceof ServerLevel serverLevel) {
             boolean var6 = false;
             if (this.dead && entitySource instanceof WitherBoss) { // Paper
-                if (serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+                if (serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.witherMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     BlockPos blockPos = this.blockPosition();
                     BlockState blockState = Blocks.WITHER_ROSE.defaultBlockState();
                     if (this.level().getBlockState(blockPos).isAir() && blockState.canSurvive(this.level(), blockPos)) {
@@ -1931,6 +1993,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         boolean flag = this.lastHurtByPlayerMemoryTime > 0;
         this.dropEquipment(level); // CraftBukkit - from below
         if (this.shouldDropLoot() && level.getGameRules().getBoolean(GameRules.RULE_DOMOBLOOT)) {
+            if (!(damageSource.is(net.minecraft.world.damagesource.DamageTypes.CRAMMING) && level().purpurConfig.disableDropsOnCrammingDeath)) { // Purpur - Disable loot drops on death by cramming
             this.dropFromLootTable(level, damageSource, flag);
             // Paper start
             final boolean prev = this.clearEquipmentSlots;
@@ -1939,6 +2002,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             // Paper end
             this.dropCustomDeathLoot(level, damageSource, flag);
             this.clearEquipmentSlots = prev; // Paper
+            } // Purpur - Disable loot drops on death by cramming
         }
 
         // CraftBukkit start - Call death event // Paper start - call advancement triggers with correct entity equipment
@@ -2993,6 +3057,20 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.5));
         } else {
+            // Purpur start - Ridables
+            if (this.getRider() != null && this.isControllable()) {
+                float friction = 0.91F;
+                if (this.onGround()) {
+                    friction = this.level().getBlockState(this.getBlockPosBelowThatAffectsMyMovement()).getBlock().getFriction() * 0.91F;
+                }
+
+                float frictionCompensation = 0.16277137F / (friction * friction * friction);
+                this.moveRelative(this.onGround() ? 0.1F * frictionCompensation : 0.02F, relative);
+                this.move(MoverType.SELF, this.getDeltaMovement());
+                this.setDeltaMovement(this.getDeltaMovement().scale(friction));
+                return;
+            }
+            // Purpur end - Ridables
             this.moveRelative(amount, relative);
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.91F));
@@ -3133,6 +3211,7 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             float f = (float)(d * 10.0 - 3.0);
             if (f > 0.0F) {
                 this.playSound(this.getFallDamageSound((int)f), 1.0F, 1.0F);
+                if (level().purpurConfig.elytraKineticDamage) // Purpur - Toggle for kinetic damage
                 this.hurt(this.damageSources().flyIntoWall(), f);
             }
         }
@@ -3595,8 +3674,10 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
         this.pushEntities();
         profilerFiller.pop();
         // Paper start - Add EntityMoveEvent
-        if (((ServerLevel) this.level()).getCurrentWorldData().hasEntityMoveEvent && !(this instanceof Player)) { // Folia - region threading
-            if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
+        // Purpur start - Ridables
+        if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
+            if (((ServerLevel) this.level()).getCurrentWorldData().hasEntityMoveEvent && !(this instanceof Player)) { // Folia - region threading
+                // Purpur end - Ridables
                 Location from = new Location(this.level().getWorld(), this.xo, this.yo, this.zo, this.yRotO, this.xRotO);
                 Location to = new Location(this.level().getWorld(), this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
                 io.papermc.paper.event.entity.EntityMoveEvent event = new io.papermc.paper.event.entity.EntityMoveEvent(this.getBukkitLivingEntity(), from, to.clone());
@@ -3606,11 +3687,52 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                     this.absSnapTo(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ(), event.getTo().getYaw(), event.getTo().getPitch());
                 }
             }
+            // Purpur start - Ridables
+            if (getRider() != null) {
+                getRider().resetLastActionTime();
+                if (((ServerLevel) this.level()).getCurrentWorldData().hasRidableMoveEvent && this instanceof Mob) {
+                    Location from = new Location(level().getWorld(), xo, yo, zo, this.yRotO, this.xRotO);
+                    Location to = new Location(level().getWorld(), getX(), getY(), getZ(), this.getYRot(), this.getXRot());
+                    org.purpurmc.purpur.event.entity.RidableMoveEvent event = new org.purpurmc.purpur.event.entity.RidableMoveEvent((org.bukkit.entity.Mob) getBukkitLivingEntity(), (org.bukkit.entity.Player) getRider().getBukkitEntity(), from, to.clone());
+                    if (!event.callEvent()) {
+                        this.absSnapTo(from.getX(), from.getY(), from.getZ(), from.getYaw(), from.getPitch());
+                    } else if (!to.equals(event.getTo())) {
+                        this.absSnapTo(event.getTo().getX(), event.getTo().getY(), event.getTo().getZ(), event.getTo().getYaw(), event.getTo().getPitch());
+                    }
+                }
+            }
+            // Purpur end - Ridables
         }
         // Paper end - Add EntityMoveEvent
         if (this.level() instanceof ServerLevel serverLevel && this.isSensitiveToWater() && this.isInWaterOrRain()) {
             this.hurtServer(serverLevel, this.damageSources().drown(), 1.0F);
         }
+
+        // Purpur start - copied from Zombie - API for any mob to burn daylight
+        if (this.isAlive()) {
+            boolean flag = this.shouldBurnInDay() && this.isSunBurnTick(); // Paper - shouldBurnInDay API // Purpur - use shouldBurnInDay() method to handle Phantoms properly - API for any mob to burn daylight
+            if (flag) {
+                ItemStack itemBySlot = this.getItemBySlot(EquipmentSlot.HEAD);
+                if (!itemBySlot.isEmpty()) {
+                    if (itemBySlot.isDamageableItem()) {
+                        Item item = itemBySlot.getItem();
+                        itemBySlot.setDamageValue(itemBySlot.getDamageValue() + this.random.nextInt(2));
+                        if (itemBySlot.getDamageValue() >= itemBySlot.getMaxDamage()) {
+                            this.onEquippedItemBroken(item, EquipmentSlot.HEAD);
+                            this.setItemSlot(EquipmentSlot.HEAD, ItemStack.EMPTY);
+                        }
+                    }
+
+                    flag = false;
+                }
+
+                if (flag) {
+                    if (getRider() == null || !this.isControllable()) // Purpur - ignore mobs which are uncontrollable or without rider - API for any mob to burn daylight
+                        this.igniteForSeconds(8.0F);
+                }
+            }
+        }
+        // Purpur end - copied from Zombie - API for any mob to burn daylight
     }
 
     protected void applyInput() {
@@ -3644,7 +3766,18 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
                         .filter(equipmentSlot1 -> canGlideUsing(this.getItemBySlot(equipmentSlot1), equipmentSlot1))
                         .toList();
                     EquipmentSlot equipmentSlot = Util.getRandom(list, this.random);
-                    this.getItemBySlot(equipmentSlot).hurtAndBreak(1, this, equipmentSlot);
+
+                    // Purpur start - Implement elytra settings
+                    int damage = level().purpurConfig.elytraDamagePerSecond;
+                    if (level().purpurConfig.elytraDamageMultiplyBySpeed > 0) {
+                        double speed = getDeltaMovement().lengthSqr();
+                        if (speed > level().purpurConfig.elytraDamageMultiplyBySpeed) {
+                            damage *= (int) speed;
+                        }
+                    }
+
+                    this.getItemBySlot(equipmentSlot).hurtAndBreak(damage, this, equipmentSlot);
+                    // Purpur end - Implement elytra settings
                 }
 
                 this.gameEvent(GameEvent.ELYTRA_GLIDE);
@@ -4537,6 +4670,12 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
             : slot == equippable.slot() && this.canUseSlot(equippable.slot()) && equippable.canBeEquippedBy(this.getType());
     }
 
+    // Purpur start - Dispenser curse of binding protection
+    public @Nullable EquipmentSlot getEquipmentSlotForDispenserItem(ItemStack itemstack) {
+        return EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.BINDING_CURSE, itemstack) > 0 ? null : this.getEquipmentSlotForItem(itemstack);
+    }
+    // Purpur end - Dispenser curse of binding protection
+
     private static SlotAccess createEquipmentSlotAccess(LivingEntity entity, EquipmentSlot slot) {
         return slot != EquipmentSlot.HEAD && slot != EquipmentSlot.MAINHAND && slot != EquipmentSlot.OFFHAND
             ? SlotAccess.forEquipmentSlot(entity, slot, itemStack -> itemStack.isEmpty() || entity.getEquipmentSlotForItem(itemStack) == slot)
diff --git a/net/minecraft/world/entity/Mob.java b/net/minecraft/world/entity/Mob.java
index 1240fb5394b1475c8e95a0e65bd03f2d15565d6f..b732af2eddaac6a770a3fc6e2c4e99ce71dad286 100644
--- a/net/minecraft/world/entity/Mob.java
+++ b/net/minecraft/world/entity/Mob.java
@@ -139,13 +139,14 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     private BlockPos homePosition = BlockPos.ZERO;
     private int homeRadius = -1;
     public boolean aware = true; // CraftBukkit
+    public int ticksSinceLastInteraction; // Purpur - Entity lifespan
 
     protected Mob(EntityType<? extends Mob> entityType, Level level) {
         super(entityType, level);
         this.goalSelector = new GoalSelector();
         this.targetSelector = new GoalSelector();
-        this.lookControl = new LookControl(this);
-        this.moveControl = new MoveControl(this);
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this); // Purpur - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this); // Purpur - Ridables
         this.jumpControl = new JumpControl(this);
         this.bodyRotationControl = this.createBodyControl();
         this.navigation = this.createNavigation(level);
@@ -296,6 +297,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
                 target = null;
             }
         }
+        if (target instanceof net.minecraft.server.level.ServerPlayer) this.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
         this.target = target;
         return true;
         // CraftBukkit end
@@ -339,8 +341,28 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         }
 
         profilerFiller.pop();
+        incrementTicksSinceLastInteraction(); // Purpur - Entity lifespan
     }
 
+    // Purpur start - Entity lifespan
+    private void incrementTicksSinceLastInteraction() {
+        ++this.ticksSinceLastInteraction;
+        if (getRider() != null) {
+            this.ticksSinceLastInteraction = 0;
+            return;
+        }
+        if (this.level().purpurConfig.entityLifeSpan <= 0) {
+            return; // feature disabled
+        }
+        if (!this.removeWhenFarAway(0) || isPersistenceRequired() || requiresCustomPersistence() || hasCustomName()) {
+            return; // mob persistent
+        }
+        if (this.ticksSinceLastInteraction > this.level().purpurConfig.entityLifeSpan) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        }
+    }
+    // Purpur end - Entity lifespan
+
     @Override
     protected void playHurtSound(DamageSource source) {
         this.resetAmbientSoundTime();
@@ -439,6 +461,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             output.putBoolean("NoAI", this.isNoAi());
         }
         output.putBoolean("Bukkit.Aware", this.aware); // CraftBukkit
+        output.putInt("Purpur.ticksSinceLastInteraction", this.ticksSinceLastInteraction); // Purpur - Entity lifespan
     }
 
     @Override
@@ -466,6 +489,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         this.lootTableSeed = input.getLongOr("DeathLootTableSeed", 0L);
         this.setNoAi(input.getBooleanOr("NoAI", false));
         this.aware = input.getBooleanOr("Bukkit.Aware", true); // CraftBukkit
+        this.ticksSinceLastInteraction = input.getIntOr("Purpur.ticksSinceLastInteraction", 0); // Purpur- Entity lifespan
     }
 
     @Override
@@ -520,7 +544,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             && this.canPickUpLoot()
             && this.isAlive()
             && !this.dead
-            && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+            && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.entitiesPickUpLootMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
             Vec3i pickupReach = this.getPickupReach();
 
             for (ItemEntity itemEntity : this.level()
@@ -1200,7 +1224,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             );
         }
 
-        this.setLeftHanded(random.nextFloat() < 0.05F);
+        this.setLeftHanded(random.nextFloat() < level.getLevel().purpurConfig.entityLeftHandedChance); // Purpur - Changeable Mob Left Handed Chance
         return spawnGroupData;
     }
 
@@ -1288,7 +1312,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     }
 
     protected InteractionResult mobInteract(Player player, InteractionHand hand) {
-        return InteractionResult.PASS;
+        return tryRide(player, hand); // Purpur - Ridables
     }
 
     public boolean isWithinHome() {
@@ -1537,6 +1561,7 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             this.playAttackSound();
         }
 
+        if (target instanceof net.minecraft.server.level.ServerPlayer) this.ticksSinceLastInteraction = 0; // Purpur - Entity lifespan
         return flag;
     }
 
@@ -1544,19 +1569,8 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
     }
 
     public boolean isSunBurnTick() {
-        if (this.level().isBrightOutside() && !this.level().isClientSide) {
-            float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
-            BlockPos blockPos = BlockPos.containing(this.getX(), this.getEyeY(), this.getZ());
-            boolean flag = this.isInWaterOrRain() || this.isInPowderSnow || this.wasInPowderSnow;
-            if (lightLevelDependentMagicValue > 0.5F
-                && this.random.nextFloat() * 30.0F < (lightLevelDependentMagicValue - 0.4F) * 2.0F
-                && !flag
-                && this.level().canSeeSky(blockPos)) {
-                return true;
-            }
-        }
-
-        return false;
+        // Purpur - implemented in Entity - API for any mob to burn daylight
+        return super.isSunBurnTick();
     }
 
     @Override
@@ -1618,4 +1632,58 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
             this.getNavigation().updatePathfinderMaxVisitedNodes();
         }
     }
+
+    // Purpur start - Ridables
+    public double getMaxY() {
+        return level().getHeight();
+    }
+
+    public InteractionResult tryRide(Player player, InteractionHand hand) {
+        return tryRide(player, hand, InteractionResult.PASS);
+    }
+
+    public InteractionResult tryRide(Player player, InteractionHand hand, InteractionResult result) {
+        if (!isRidable()) {
+            return result;
+        }
+        if (hand != InteractionHand.MAIN_HAND) {
+            return InteractionResult.PASS;
+        }
+        if (player.isShiftKeyDown()) {
+            return InteractionResult.PASS;
+        }
+        if (!player.getItemInHand(hand).isEmpty()) {
+            return InteractionResult.PASS;
+        }
+        if (!passengers.isEmpty() || player.isPassenger()) {
+            return InteractionResult.PASS;
+        }
+        if (this instanceof TamableAnimal tamable) {
+            if (tamable.isTame() && !tamable.isOwnedBy(player)) {
+                return InteractionResult.PASS;
+            }
+            if (!tamable.isTame() && !level().purpurConfig.untamedTamablesAreRidable) {
+                return InteractionResult.PASS;
+            }
+        }
+        if (this instanceof AgeableMob ageable) {
+            if (ageable.isBaby() && !level().purpurConfig.babiesAreRidable) {
+                return InteractionResult.PASS;
+            }
+        }
+        if (!player.getBukkitEntity().hasPermission("allow.ride." + net.minecraft.core.registries.BuiltInRegistries.ENTITY_TYPE.getKey(getType()).getPath())) {
+            if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
+                serverPlayer.sendMiniMessage(org.purpurmc.purpur.PurpurConfig.cannotRideMob);
+            }
+            return InteractionResult.PASS;
+        }
+        player.setYRot(this.getYRot());
+        player.setXRot(this.getXRot());
+        if (player.startRiding(this)) {
+            return InteractionResult.SUCCESS;
+        } else {
+            return InteractionResult.PASS;
+        }
+    }
+    // Purpur end - Ridables
 }
diff --git a/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index fdb02fc40579866167e8cc9bcefbd961588b53a6..7dd8c1c8e27410854ce1ee90defc607c2710b5a2 100644
--- a/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -18,14 +18,21 @@ public class AttributeMap {
     private final Set<AttributeInstance> attributesToSync = new ObjectOpenHashSet<>();
     private final Set<AttributeInstance> attributesToUpdate = new ObjectOpenHashSet<>();
     private final AttributeSupplier supplier;
+    private final net.minecraft.world.entity.LivingEntity entity; // Purpur - Ridables
 
     public AttributeMap(AttributeSupplier supplier) {
-        this.supplier = supplier;
+        // Purpur start - Ridables
+        this(supplier, null);
+    }
+    public AttributeMap(AttributeSupplier defaultAttributes, net.minecraft.world.entity.LivingEntity entity) {
+        this.entity = entity;
+        // Purpur end - Ridables
+        this.supplier = defaultAttributes;
     }
 
     private void onAttributeModified(AttributeInstance instance) {
         this.attributesToUpdate.add(instance);
-        if (instance.getAttribute().value().isClientSyncable()) {
+        if (instance.getAttribute().value().isClientSyncable() && (entity == null || entity.shouldSendAttribute(instance.getAttribute().value()))) { // Purpur - Ridables
             this.attributesToSync.add(instance);
         }
     }
@@ -39,7 +46,7 @@ public class AttributeMap {
     }
 
     public Collection<AttributeInstance> getSyncableAttributes() {
-        return this.attributes.values().stream().filter(instance -> instance.getAttribute().value().isClientSyncable()).collect(Collectors.toList());
+        return this.attributes.values().stream().filter(instance -> instance.getAttribute().value().isClientSyncable() && (entity == null || entity.shouldSendAttribute(instance.getAttribute().value()))).collect(Collectors.toList()); // Purpur - Ridables
     }
 
     @Nullable
diff --git a/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java b/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
index 26ffe98c94b2aaf61bf1693e86e8e7962e892a09..e6ef56d94e29a6629c9b672ed4ac4ef29ad6a286 100644
--- a/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
+++ b/net/minecraft/world/entity/ai/attributes/DefaultAttributes.java
@@ -128,12 +128,12 @@ public class DefaultAttributes {
         .put(EntityType.IRON_GOLEM, IronGolem.createAttributes().build())
         .put(EntityType.LLAMA, Llama.createAttributes().build())
         .put(EntityType.MAGMA_CUBE, MagmaCube.createAttributes().build())
-        .put(EntityType.MOOSHROOM, Cow.createAttributes().build())
+        .put(EntityType.MOOSHROOM, net.minecraft.world.entity.animal.AbstractCow.createAttributes().build()) // Purpur - Cows naturally aggressive to players chance
         .put(EntityType.MULE, AbstractChestedHorse.createBaseChestedHorseAttributes().build())
         .put(EntityType.OCELOT, Ocelot.createAttributes().build())
         .put(EntityType.PANDA, Panda.createAttributes().build())
         .put(EntityType.PARROT, Parrot.createAttributes().build())
-        .put(EntityType.PHANTOM, Monster.createMonsterAttributes().build())
+        .put(EntityType.PHANTOM, net.minecraft.world.entity.monster.Phantom.createAttributes().build()) // Purpur - Ridables
         .put(EntityType.PIG, Pig.createAttributes().build())
         .put(EntityType.PIGLIN, Piglin.createAttributes().build())
         .put(EntityType.PIGLIN_BRUTE, PiglinBrute.createAttributes().build())
@@ -164,7 +164,7 @@ public class DefaultAttributes {
         .put(EntityType.VILLAGER, Villager.createAttributes().build())
         .put(EntityType.VINDICATOR, Vindicator.createAttributes().build())
         .put(EntityType.WARDEN, Warden.createAttributes().build())
-        .put(EntityType.WANDERING_TRADER, Mob.createMobAttributes().build())
+        .put(EntityType.WANDERING_TRADER, net.minecraft.world.entity.npc.WanderingTrader.createAttributes().build()) // Purpur - Villagers follow emerald blocks
         .put(EntityType.WITCH, Witch.createAttributes().build())
         .put(EntityType.WITHER, WitherBoss.createAttributes().build())
         .put(EntityType.WITHER_SKELETON, AbstractSkeleton.createAttributes().build())
diff --git a/net/minecraft/world/entity/ai/attributes/RangedAttribute.java b/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
index a87accd5fe14102e7a2938f991a8ed0b9accd1bb..c7515f7f24e39d6931dcf18574cb47d754983903 100644
--- a/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
+++ b/net/minecraft/world/entity/ai/attributes/RangedAttribute.java
@@ -29,6 +29,7 @@ public class RangedAttribute extends Attribute {
 
     @Override
     public double sanitizeValue(double value) {
+        if (!org.purpurmc.purpur.PurpurConfig.clampAttributes) return Double.isNaN(value) ? this.minValue : value; // Purpur - Add attribute clamping and armor limit config
         return Double.isNaN(value) ? this.minValue : Mth.clamp(value, this.minValue, this.maxValue);
     }
 }
diff --git a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
index b9174ae7e3a3e2de2d570b95ab5012ac3c3a2eda..67cbf9f5760fae5db6f31e64095cd1b6be6ade8e 100644
--- a/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
+++ b/net/minecraft/world/entity/ai/behavior/AcquirePoi.java
@@ -86,7 +86,7 @@ public class AcquirePoi {
                             };
                             // Paper start - optimise POI access
                             final java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
-                            io.papermc.paper.util.PoiAccess.findNearestPoiPositions(poiManager, acquirablePois, predicate1, mob.blockPosition(), 48, 48*48, PoiManager.Occupancy.HAS_SPACE, false, 5, poiposes);
+                            io.papermc.paper.util.PoiAccess.findNearestPoiPositions(poiManager, acquirablePois, predicate1, mob.blockPosition(), level.purpurConfig.villagerAcquirePoiSearchRadius, level.purpurConfig.villagerAcquirePoiSearchRadius*level.purpurConfig.villagerAcquirePoiSearchRadius, PoiManager.Occupancy.HAS_SPACE, false, 5, poiposes); // Purpur - Configurable villager search radius
                             final Set<Pair<Holder<PoiType>, BlockPos>> set = new java.util.HashSet<>(poiposes.size());
                             for (final Pair<Holder<PoiType>, BlockPos> poiPose : poiposes) {
                                 if (predicate.test(level, poiPose.getSecond())) {
diff --git a/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java b/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
index de89e45ecd4ac4c6db8b74bbe3dd6b4a7cf21671..ec03365dc786596521d280ea4d6948c651ee8deb 100644
--- a/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
+++ b/net/minecraft/world/entity/ai/behavior/HarvestFarmland.java
@@ -32,6 +32,7 @@ public class HarvestFarmland extends Behavior<Villager> {
     private long nextOkStartTime;
     private int timeWorkedSoFar;
     private final List<BlockPos> validFarmlandAroundVillager = Lists.newArrayList();
+    private boolean clericWartFarmer = false; // Purpur - Option for Villager Clerics to farm Nether Wart
 
     public HarvestFarmland() {
         super(
@@ -48,11 +49,12 @@ public class HarvestFarmland extends Behavior<Villager> {
 
     @Override
     protected boolean checkExtraStartConditions(ServerLevel level, Villager owner) {
-        if (!level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+        if (!level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.villagerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
             return false;
-        } else if (!owner.getVillagerData().profession().is(VillagerProfession.FARMER)) {
+        } else if (!owner.getVillagerData().profession().is(VillagerProfession.FARMER) && !(level.purpurConfig.villagerClericsFarmWarts && owner.getVillagerData().profession().is(VillagerProfession.CLERIC))) { // Purpur - Option for Villager Clerics to farm Nether Wart
             return false;
         } else {
+            if (!this.clericWartFarmer && owner.getVillagerData().profession().is(VillagerProfession.CLERIC)) this.clericWartFarmer = true; // Purpur - Option for Villager Clerics to farm Nether Wart
             BlockPos.MutableBlockPos mutableBlockPos = owner.blockPosition().mutable();
             this.validFarmlandAroundVillager.clear();
 
@@ -83,6 +85,7 @@ public class HarvestFarmland extends Behavior<Villager> {
         BlockState blockState = serverLevel.getBlockState(pos);
         Block block = blockState.getBlock();
         Block block1 = serverLevel.getBlockState(pos.below()).getBlock();
+        if (this.clericWartFarmer) return block == net.minecraft.world.level.block.Blocks.NETHER_WART && blockState.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3 || blockState.isAir() && block1 == net.minecraft.world.level.block.Blocks.SOUL_SAND; // Purpur - Option for Villager Clerics to farm Nether Wart
         return block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState) || blockState.isAir() && block1 instanceof FarmBlock;
     }
 
@@ -109,19 +112,19 @@ public class HarvestFarmland extends Behavior<Villager> {
                 BlockState blockState = level.getBlockState(this.aboveFarmlandPos);
                 Block block = blockState.getBlock();
                 Block block1 = level.getBlockState(this.aboveFarmlandPos.below()).getBlock();
-                if (block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState)) {
+                if (block instanceof CropBlock && ((CropBlock)block).isMaxAge(blockState) && !this.clericWartFarmer || this.clericWartFarmer && block == net.minecraft.world.level.block.Blocks.NETHER_WART && blockState.getValue(net.minecraft.world.level.block.NetherWartBlock.AGE) == 3) { // Purpur - Option for Villager Clerics to farm Nether Wart
                     if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(owner, this.aboveFarmlandPos, blockState.getFluidState().createLegacyBlock())) { // CraftBukkit // Paper - fix wrong block state
                     level.destroyBlock(this.aboveFarmlandPos, true, owner);
                     } // CraftBukkit
                 }
 
-                if (blockState.isAir() && block1 instanceof FarmBlock && owner.hasFarmSeeds()) {
+                if (blockState.isAir() && block1 instanceof FarmBlock && !this.clericWartFarmer || this.clericWartFarmer && block1 == net.minecraft.world.level.block.Blocks.SOUL_SAND && owner.hasFarmSeeds()) { // Purpur - Option for Villager Clerics to farm Nether Wart
                     SimpleContainer inventory = owner.getInventory();
 
                     for (int i = 0; i < inventory.getContainerSize(); i++) {
                         ItemStack item = inventory.getItem(i);
                         boolean flag = false;
-                        if (!item.isEmpty() && item.is(ItemTags.VILLAGER_PLANTABLE_SEEDS) && item.getItem() instanceof BlockItem blockItem) {
+                        if (!item.isEmpty() && (item.is(ItemTags.VILLAGER_PLANTABLE_SEEDS) || this.clericWartFarmer && item.getItem() == net.minecraft.world.item.Items.NETHER_WART) && item.getItem() instanceof BlockItem blockItem) { // Purpur - Option for Villager Clerics to farm Nether Wart
                             BlockState blockState1 = blockItem.getBlock().defaultBlockState();
                             if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(owner, this.aboveFarmlandPos, blockState1)) { // CraftBukkit
                             level.setBlockAndUpdate(this.aboveFarmlandPos, blockState1);
@@ -136,7 +139,7 @@ public class HarvestFarmland extends Behavior<Villager> {
                                 this.aboveFarmlandPos.getX(),
                                 this.aboveFarmlandPos.getY(),
                                 this.aboveFarmlandPos.getZ(),
-                                SoundEvents.CROP_PLANTED,
+                                this.clericWartFarmer ? SoundEvents.NETHER_WART_PLANTED : SoundEvents.CROP_PLANTED, // Purpur - Option for Villager Clerics to farm Nether Wart
                                 SoundSource.BLOCKS,
                                 1.0F,
                                 1.0F
diff --git a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
index 296ecffbbce931b42c67ea523373a61cea23acf4..b2eec24be3635f2c19da9b147211fe6cb454c780 100644
--- a/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
+++ b/net/minecraft/world/entity/ai/behavior/InteractWithDoor.java
@@ -55,7 +55,7 @@ public class InteractWithDoor {
                             Node nextNode = path.getNextNode();
                             BlockPos blockPos = previousNode.asBlockPos();
                             BlockState blockState = level.getBlockState(blockPos);
-                            if (blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                            if (blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)&& !DoorBlock.requiresRedstone(entity.level(), blockState, blockPos)) { // Purpur - Option to make doors require redstone
                                 DoorBlock doorBlock = (DoorBlock)blockState.getBlock();
                                 if (!doorBlock.isOpen(blockState)) {
                                     // CraftBukkit start - entities opening doors
@@ -72,7 +72,7 @@ public class InteractWithDoor {
 
                             BlockPos blockPos1 = nextNode.asBlockPos();
                             BlockState blockState1 = level.getBlockState(blockPos1);
-                            if (blockState1.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                            if (blockState1.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock) && !DoorBlock.requiresRedstone(entity.level(), blockState1, blockPos1)) { // Purpur - Option to make doors require redstone
                                 DoorBlock doorBlock1 = (DoorBlock)blockState1.getBlock();
                                 if (!doorBlock1.isOpen(blockState1)) {
                                     // CraftBukkit start - entities opening doors
@@ -118,7 +118,7 @@ public class InteractWithDoor {
                     iterator.remove();
                 } else {
                     BlockState blockState = level.getBlockState(blockPos);
-                    if (!blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock)) {
+                    if (!blockState.is(BlockTags.MOB_INTERACTABLE_DOORS, state -> state.getBlock() instanceof DoorBlock) || DoorBlock.requiresRedstone(entity.level(), blockState, blockPos)) { // Purpur - Option to make doors require redstone
                         iterator.remove();
                     } else {
                         DoorBlock doorBlock = (DoorBlock)blockState.getBlock();
diff --git a/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java b/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
index 400e6d49144b3e5803901938dcd2ac4e52e9c131..45c45afeffcfba3558bdf46cbe39ff60004ffc01 100644
--- a/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
+++ b/net/minecraft/world/entity/ai/behavior/ShowTradesToPlayer.java
@@ -46,6 +46,7 @@ public class ShowTradesToPlayer extends Behavior<Villager> {
 
     @Override
     public boolean canStillUse(ServerLevel level, Villager entity, long gameTime) {
+        if (!entity.level().purpurConfig.villagerDisplayTradeItem) return false; // Purpur - Option for villager display trade item
         return this.checkExtraStartConditions(level, entity)
             && this.lookTime > 0
             && entity.getBrain().getMemory(MemoryModuleType.INTERACTION_TARGET).isPresent();
diff --git a/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java b/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
index 623dd33a85cb67ecb835de18e9aac29f3394ce28..72cca4897f9697573fd6987a5f0d2df52761b8c3 100644
--- a/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
+++ b/net/minecraft/world/entity/ai/behavior/TradeWithVillager.java
@@ -59,6 +59,12 @@ public class TradeWithVillager extends Behavior<Villager> {
                 throwHalfStack(owner, ImmutableSet.of(Items.WHEAT), villager);
             }
 
+            // Purpur start - Option for Villager Clerics to farm Nether Wart
+            if (level.purpurConfig.villagerClericsFarmWarts && level.purpurConfig.villagerClericFarmersThrowWarts && owner.getVillagerData().profession().is(VillagerProfession.CLERIC) && owner.getInventory().countItem(Items.NETHER_WART) > Items.NETHER_WART.getDefaultMaxStackSize() / 2) {
+                throwHalfStack(owner, ImmutableSet.of(Items.NETHER_WART), villager);
+            }
+            // Purpur end - Option for Villager Clerics to farm Nether Wart
+
             if (!this.trades.isEmpty() && owner.getInventory().hasAnyOf(this.trades)) {
                 throwHalfStack(owner, this.trades, villager);
             }
diff --git a/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java b/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
index c65f80aadeb27685653f6a4731888c612d4a59d6..bb07aa944ce60ec7db96e2b57bd6c2c862e2f787 100644
--- a/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
+++ b/net/minecraft/world/entity/ai/behavior/VillagerGoalPackages.java
@@ -79,8 +79,13 @@ public class VillagerGoalPackages {
     public static ImmutableList<Pair<Integer, ? extends BehaviorControl<? super Villager>>> getWorkPackage(
         Holder<VillagerProfession> profession, float speedModifier
     ) {
+        // Purpur start - Option for Villager Clerics to farm Nether Wart
+        return getWorkPackage(profession, speedModifier, false);
+    }
+    public static ImmutableList<Pair<Integer, ? extends BehaviorControl<? super Villager>>> getWorkPackage(Holder<VillagerProfession> profession, float speedModifier, boolean clericsFarmWarts) {
+        // Purpur end - Option for Villager Clerics to farm Nether Wart
         WorkAtPoi workAtPoi;
-        if (profession.is(VillagerProfession.FARMER)) {
+        if (profession.is(VillagerProfession.FARMER) || (clericsFarmWarts && profession.is(VillagerProfession.CLERIC))) { // Purpur - Option for Villager Clerics to farm Nether Wart
             workAtPoi = new WorkAtComposter();
         } else {
             workAtPoi = new WorkAtPoi();
diff --git a/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java b/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
index 2591e4bbd234e51ff2c6b00db888d3b158f5a07d..e3d48c7c6615185f8a14bc96476a665bdadc275b 100644
--- a/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
+++ b/net/minecraft/world/entity/ai/behavior/VillagerMakeLove.java
@@ -118,8 +118,10 @@ public class VillagerMakeLove extends Behavior<Villager> {
             if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityBreedEvent(breedOffspring, parent, partner, null, null, 0).isCancelled()) {
                 return Optional.empty();
             }
-            parent.setAge(6000);
-            partner.setAge(6000);
+            // Purpur start - Make entity breeding times configurable
+            parent.setAge(level.purpurConfig.villagerBreedingTicks);
+            partner.setAge(level.purpurConfig.villagerBreedingTicks);
+            // Purpur end - Make entity breeding times configurable
             level.addFreshEntityWithPassengers(breedOffspring, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BREEDING);
             // CraftBukkit end - call EntityBreedEvent
             level.broadcastEntityEvent(breedOffspring, (byte)12);
diff --git a/net/minecraft/world/entity/ai/control/MoveControl.java b/net/minecraft/world/entity/ai/control/MoveControl.java
index b6921582adef6f4c48de4dcffd6873ac0f909a08..89ee325b26ec3a647f55e45c9122ff4196433a43 100644
--- a/net/minecraft/world/entity/ai/control/MoveControl.java
+++ b/net/minecraft/world/entity/ai/control/MoveControl.java
@@ -29,6 +29,20 @@ public class MoveControl implements Control {
         this.mob = mob;
     }
 
+    // Purpur start - Ridables
+    public void setSpeedModifier(double speed) {
+        this.speedModifier = speed;
+    }
+
+    public void setForward(float forward) {
+        this.strafeForwards = forward;
+    }
+
+    public void setStrafe(float strafe) {
+        this.strafeRight = strafe;
+    }
+    // Purpur end - Ridables
+
     public boolean hasWanted() {
         return this.operation == MoveControl.Operation.MOVE_TO;
     }
diff --git a/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java b/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
index d7f9b3b2b1077ea10e8f64b87c8f4c4354e90858..713f62b34a91fa76f40e49a5e390145f70755e58 100644
--- a/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
+++ b/net/minecraft/world/entity/ai/control/SmoothSwimmingLookControl.java
@@ -3,7 +3,7 @@ package net.minecraft.world.entity.ai.control;
 import net.minecraft.util.Mth;
 import net.minecraft.world.entity.Mob;
 
-public class SmoothSwimmingLookControl extends LookControl {
+public class SmoothSwimmingLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
     private final int maxYRotFromCenter;
     private static final int HEAD_TILT_X = 10;
     private static final int HEAD_TILT_Y = 20;
@@ -14,7 +14,7 @@ public class SmoothSwimmingLookControl extends LookControl {
     }
 
     @Override
-    public void tick() {
+    public void vanillaTick() { // Purpur - Ridables
         if (this.lookAtCooldown > 0) {
             this.lookAtCooldown--;
             this.getYRotD().ifPresent(rotationWanted -> this.mob.yHeadRot = this.rotateTowards(this.mob.yHeadRot, rotationWanted + 20.0F, this.yMaxRotSpeed));
diff --git a/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java b/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
index e026e07ca86700c864a3dceda6817fb7b6cb11e9..cf380a13d6d54d1a9e8d10b31124942d59fca80c 100644
--- a/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
+++ b/net/minecraft/world/entity/ai/goal/BreakDoorGoal.java
@@ -30,7 +30,7 @@ public class BreakDoorGoal extends DoorInteractGoal {
     @Override
     public boolean canUse() {
         return super.canUse()
-            && getServerLevel(this.mob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)
+            && getServerLevel(this.mob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, this.mob.level().purpurConfig.zombieMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
             && this.isValidDifficulty(this.mob.level().getDifficulty())
             && !this.isOpen();
     }
diff --git a/net/minecraft/world/entity/ai/goal/EatBlockGoal.java b/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
index 7a75415a469bc99f45a5cfaab038181717903f1d..3c0b94e011f029a54460c878f1f7d4f603a5e3b0 100644
--- a/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/EatBlockGoal.java
@@ -67,7 +67,7 @@ public class EatBlockGoal extends Goal {
             BlockPos blockPos = this.mob.blockPosition();
             final BlockState blockState = this.level.getBlockState(blockPos); // Paper - fix wrong block state
             if (IS_EDIBLE.test(blockState)) { // Paper - fix wrong block state
-                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos, blockState.getFluidState().createLegacyBlock(), !getServerLevel(this.level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING))) { // CraftBukkit // Paper - fix wrong block state
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos, blockState.getFluidState().createLegacyBlock(), !getServerLevel(this.level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(this.level).purpurConfig.sheepMobGriefingOverride))) { // CraftBukkit // Paper - fix wrong block state // Purpur - Add mobGriefing override to everything affected
                     this.level.destroyBlock(blockPos, false);
                 }
 
@@ -75,7 +75,7 @@ public class EatBlockGoal extends Goal {
             } else {
                 BlockPos blockPos1 = blockPos.below();
                 if (this.level.getBlockState(blockPos1).is(Blocks.GRASS_BLOCK)) {
-                    if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos1, Blocks.DIRT.defaultBlockState(), !getServerLevel(this.level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING))) { // CraftBukkit // Paper - Fix wrong block state
+                    if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.mob, blockPos1, Blocks.DIRT.defaultBlockState(), !getServerLevel(this.level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(this.level).purpurConfig.sheepMobGriefingOverride))) { // CraftBukkit // Paper - Fix wrong block state // Purpur - Add mobGriefing override to everything affected
                         this.level.levelEvent(2001, blockPos1, Block.getId(Blocks.GRASS_BLOCK.defaultBlockState()));
                         this.level.setBlock(blockPos1, Blocks.DIRT.defaultBlockState(), 2);
                     }
diff --git a/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java b/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
index 6eaf0bd944349cd0c6084462ac385fa2caafe933..be59d0c27a83b329ec3f97c029cfb9c114e22472 100644
--- a/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
+++ b/net/minecraft/world/entity/ai/goal/LlamaFollowCaravanGoal.java
@@ -22,6 +22,7 @@ public class LlamaFollowCaravanGoal extends Goal {
 
     @Override
     public boolean canUse() {
+        if (!this.llama.level().purpurConfig.llamaJoinCaravans || !this.llama.shouldJoinCaravan) return false; // Purpur - Llama API // Purpur - Config to disable Llama caravans
         if (!this.llama.isLeashed() && !this.llama.inCaravan()) {
             List<Entity> entities = this.llama.level().getEntities(this.llama, this.llama.getBoundingBox().inflate(9.0, 4.0, 9.0), entity1 -> {
                 EntityType<?> type = entity1.getType();
@@ -71,6 +72,7 @@ public class LlamaFollowCaravanGoal extends Goal {
 
     @Override
     public boolean canContinueToUse() {
+        if (!this.llama.shouldJoinCaravan) return false; // Purpur - Llama API
         if (this.llama.inCaravan() && this.llama.getCaravanHead().isAlive() && this.firstIsLeashed(this.llama, 0)) {
             double d = this.llama.distanceToSqr(this.llama.getCaravanHead());
             if (d > 676.0) {
diff --git a/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java b/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
index 722f378bb3726200b6fe88948bf1e1d3514a7b5c..e337e22c2cf82b0c1cab3fe0a9ff894c0c718716 100644
--- a/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
+++ b/net/minecraft/world/entity/ai/goal/RangedBowAttackGoal.java
@@ -116,9 +116,9 @@ public class RangedBowAttackGoal<T extends Monster & RangedAttackMob> extends Go
                 }
 
                 this.mob.lookAt(target, 30.0F, 30.0F);
-            } else {
+            } //else { // Purpur - MC-121706 - Fix mobs not looking up and down when strafing
                 this.mob.getLookControl().setLookAt(target, 30.0F, 30.0F);
-            }
+            //} // Purpur - MC-121706 - Fix mobs not looking up and down when strafing
 
             if (this.mob.isUsingItem()) {
                 if (!hasLineOfSight && this.seeTime < -60) {
diff --git a/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java b/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
index 5d025e0e4381a045fd82c26cdd3907e1a8710b45..16ec032d84f128fc44a836843fafef303f52b699 100644
--- a/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
+++ b/net/minecraft/world/entity/ai/goal/RemoveBlockGoal.java
@@ -35,7 +35,7 @@ public class RemoveBlockGoal extends MoveToBlockGoal {
 
     @Override
     public boolean canUse() {
-        if (!getServerLevel(this.removerMob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+        if (!getServerLevel(this.removerMob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(this.removerMob).purpurConfig.zombieMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
             return false;
         } else if (this.nextStartTick > 0) {
             this.nextStartTick--;
diff --git a/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java b/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
index 878d7813b3f2f52bef336c6d855d738bc2f83491..d0f94f065d2ecf6ca6b47ac49422ffa656a18f55 100644
--- a/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
+++ b/net/minecraft/world/entity/ai/goal/RunAroundLikeCrazyGoal.java
@@ -58,7 +58,7 @@ public class RunAroundLikeCrazyGoal extends Goal {
             if (firstPassenger instanceof Player player) {
                 int temper = this.horse.getTemper();
                 int maxTemper = this.horse.getMaxTemper();
-                if (maxTemper > 0 && this.horse.getRandom().nextInt(maxTemper) < temper && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this.horse, ((org.bukkit.craftbukkit.entity.CraftHumanEntity) this.horse.getBukkitEntity().getPassenger()).getHandle()).isCancelled()) { // CraftBukkit - fire EntityTameEvent
+                if (((this.horse.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || (maxTemper > 0 && this.horse.getRandom().nextInt(maxTemper) < temper)) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this.horse, ((org.bukkit.craftbukkit.entity.CraftHumanEntity) this.horse.getBukkitEntity().getPassenger()).getHandle()).isCancelled()) { // CraftBukkit - fire EntityTameEvent // Purpur - Config to always tame in Creative
                     this.horse.tameWithName(player);
                     return;
                 }
diff --git a/net/minecraft/world/entity/ai/goal/SwellGoal.java b/net/minecraft/world/entity/ai/goal/SwellGoal.java
index 243a552f6f0c8c2bd25c0209c95e3bca08734711..38fd0196a0f5a90e39fa4eb8592f89bf6b88ccf5 100644
--- a/net/minecraft/world/entity/ai/goal/SwellGoal.java
+++ b/net/minecraft/world/entity/ai/goal/SwellGoal.java
@@ -55,6 +55,14 @@ public class SwellGoal extends Goal {
             this.creeper.setSwellDir(-1);
         } else {
             this.creeper.setSwellDir(1);
+            // Purpur start - option to allow creeper to encircle target when fusing
+            if (this.creeper.level().purpurConfig.creeperEncircleTarget) {
+                net.minecraft.world.phys.Vec3 relative = this.creeper.position().subtract(this.target.position());
+                relative = relative.yRot((float) Math.PI / 3).normalize().multiply(2, 2, 2);
+                net.minecraft.world.phys.Vec3 destination = this.target.position().add(relative);
+                this.creeper.getNavigation().moveTo(destination.x, destination.y, destination.z, 1);
+            }
+            // Purpur end - option to allow creeper to encircle target when fusing
         }
     }
 }
diff --git a/net/minecraft/world/entity/ai/goal/TemptGoal.java b/net/minecraft/world/entity/ai/goal/TemptGoal.java
index dae935cc68e2e571d50e56ac8913c099a11cf771..a805c9426630c2c46db9d0dd536f1d16769395d3 100644
--- a/net/minecraft/world/entity/ai/goal/TemptGoal.java
+++ b/net/minecraft/world/entity/ai/goal/TemptGoal.java
@@ -71,7 +71,7 @@ public class TemptGoal extends Goal {
     }
 
     private boolean shouldFollow(LivingEntity entity) {
-        return this.items.test(entity.getMainHandItem()) || this.items.test(entity.getOffhandItem());
+        return (this.items.test(entity.getMainHandItem()) || this.items.test(entity.getOffhandItem())) && (!(this.mob instanceof net.minecraft.world.entity.npc.Villager villager) || !villager.isSleeping()); // Purpur - Villagers follow emerald blocks
     }
 
     @Override
diff --git a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
index 066faa704338c573472381e1ebd063e0d52aaaa4..1f96fd5085bacb4c584576c7cb9f51e7898e9b03 100644
--- a/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/NearestBedSensor.java
@@ -56,7 +56,7 @@ public class NearestBedSensor extends Sensor<Mob> {
             // Paper start - optimise POI access
             java.util.List<Pair<Holder<PoiType>, BlockPos>> poiposes = new java.util.ArrayList<>();
             // don't ask me why it's unbounded. ask mojang.
-            io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), 48, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes);
+            io.papermc.paper.util.PoiAccess.findAnyPoiPositions(poiManager, type -> type.is(PoiTypes.HOME), predicate, entity.blockPosition(), level.purpurConfig.villagerNearestBedSensorSearchRadius, PoiManager.Occupancy.ANY, false, Integer.MAX_VALUE, poiposes); // Purpur - Configurable villager search radius
             Path path = AcquirePoi.findPathToPois(entity, new java.util.HashSet<>(poiposes));
             // Paper end - optimise POI access
             if (path != null && path.canReach()) {
diff --git a/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java b/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
index f0583076ef62189508a392a76c3fb6b741bbdde9..dc4a9ddb8479e9d0c4895b19d7d677cdd8ad3faa 100644
--- a/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
+++ b/net/minecraft/world/entity/ai/sensing/SecondaryPoiSensor.java
@@ -22,6 +22,13 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
 
     @Override
     protected void doTick(ServerLevel level, Villager entity) {
+        // Purpur start - Option for Villager Clerics to farm Nether Wart - make sure clerics don't wander to soul sand when the option is off
+        Brain<?> brain = entity.getBrain();
+        if (!level.purpurConfig.villagerClericsFarmWarts && entity.getVillagerData().profession().is(net.minecraft.world.entity.npc.VillagerProfession.CLERIC)) {
+            brain.eraseMemory(MemoryModuleType.SECONDARY_JOB_SITE);
+            return;
+        }
+        // Purpur end - Option for Villager Clerics to farm Nether Wart
         ResourceKey<Level> resourceKey = level.dimension();
         BlockPos blockPos = entity.blockPosition();
         List<GlobalPos> list = Lists.newArrayList();
@@ -38,7 +45,7 @@ public class SecondaryPoiSensor extends Sensor<Villager> {
             }
         }
 
-        Brain<?> brain = entity.getBrain();
+        //Brain<?> brain = entity.getBrain(); // Purpur - Option for Villager Clerics to farm Nether Wart - moved up
         if (!list.isEmpty()) {
             brain.setMemory(MemoryModuleType.SECONDARY_JOB_SITE, list);
         } else {
diff --git a/net/minecraft/world/entity/ai/targeting/TargetingConditions.java b/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
index 2f8920d8ee765d057a22d76f24f7d7dc1b0b17ca..6f0fcaeaba2fec2ad944d63550f0c3e29bd9133c 100644
--- a/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
+++ b/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
@@ -64,6 +64,10 @@ public class TargetingConditions {
             return false;
         } else if (this.selector != null && !this.selector.test(target, level)) {
             return false;
+        // Purpur start - AFK API
+        } else if (!level.purpurConfig.idleTimeoutTargetPlayer && target instanceof net.minecraft.server.level.ServerPlayer player && player.isAfk()) {
+            return false;
+        // Purpur end - AFK API
         } else {
             if (entity == null) {
                 if (this.isCombat && (!target.canBeSeenAsEnemy() || level.getDifficulty() == Difficulty.PEACEFUL)) {
diff --git a/net/minecraft/world/entity/ambient/Bat.java b/net/minecraft/world/entity/ambient/Bat.java
index 912b099a51269f92f250c7d6094ad41817749f93..4e046158a0782a1fd08c6b4d8d332b6eb5bce7aa 100644
--- a/net/minecraft/world/entity/ambient/Bat.java
+++ b/net/minecraft/world/entity/ambient/Bat.java
@@ -44,11 +44,87 @@ public class Bat extends AmbientCreature {
 
     public Bat(EntityType<? extends Bat> entityType, Level level) {
         super(entityType, level);
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.075F); // Purpur - Ridables
         if (!level.isClientSide) {
             this.setResting(true);
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean shouldSendAttribute(net.minecraft.world.entity.ai.attributes.Attribute attribute) { return attribute != Attributes.FLYING_SPEED.value(); } // Fixes log spam on clients
+
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.batRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.batRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.batControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.batMaxY;
+    }
+
+    @Override
+    public void onMount(net.minecraft.world.entity.player.Player rider) {
+        super.onMount(rider);
+        if (isResting()) {
+            setResting(false);
+            level().levelEvent(null, 1025, new BlockPos(this).above(), 0);
+        }
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.25, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.batMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.batScale);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.batFollowRange);
+        this.getAttribute(Attributes.KNOCKBACK_RESISTANCE).setBaseValue(this.level().purpurConfig.batKnockbackResistance);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.batMovementSpeed);
+        this.getAttribute(Attributes.FLYING_SPEED).setBaseValue(this.level().purpurConfig.batFlyingSpeed);
+        this.getAttribute(Attributes.ARMOR).setBaseValue(this.level().purpurConfig.batArmor);
+        this.getAttribute(Attributes.ARMOR_TOUGHNESS).setBaseValue(this.level().purpurConfig.batArmorToughness);
+        this.getAttribute(Attributes.ATTACK_KNOCKBACK).setBaseValue(this.level().purpurConfig.batAttackKnockback);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.batTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.batAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return !this.isResting() && this.tickCount % 10.0F == 0.0F;
@@ -100,7 +176,7 @@ public class Bat extends AmbientCreature {
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 6.0);
+        return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 6.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur - Ridables
     }
 
     public boolean isResting() {
@@ -131,6 +207,14 @@ public class Bat extends AmbientCreature {
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), mot.y() + (getVerticalMot() > 0 ? 0.07D : 0.0D), mot.z());
+            return;
+        }
+        // Purpur end - Ridables
+
         super.customServerAiStep(level);
         BlockPos blockPos = this.blockPosition();
         BlockPos blockPos1 = blockPos.above();
@@ -233,7 +317,7 @@ public class Bat extends AmbientCreature {
         } else {
             int maxLocalRawBrightness = level.getMaxLocalRawBrightness(pos);
             int i = 4;
-            if (isHalloween()) {
+            if (Bat.isHalloweenSeason(level.getMinecraftWorld())) { // Purpur - Halloween options and optimizations
                 i = 7;
             } else if (randomSource.nextBoolean()) {
                 return false;
@@ -245,6 +329,11 @@ public class Bat extends AmbientCreature {
         }
     }
 
+    // Pufferfish start - only check for spooky season once an hour
+    //private static boolean isSpookySeason = false;
+    //private static final int ONE_HOUR = 20 * 60 * 60;
+    //private static int lastSpookyCheck = -ONE_HOUR;
+    public static boolean isHalloweenSeason(Level level) { return level.purpurConfig.forceHalloweenSeason || isHalloween(); } // Purpur - Halloween options and optimizations
     private static boolean isHalloween() {
         LocalDate localDate = LocalDate.now();
         int i = localDate.get(ChronoField.DAY_OF_MONTH);
diff --git a/net/minecraft/world/entity/animal/AbstractCow.java b/net/minecraft/world/entity/animal/AbstractCow.java
index dd8ea03ba823996a5c97562e357650ab34d0e32e..61e7300bbf272398b2faebf5e537d9c2ddedc6d6 100644
--- a/net/minecraft/world/entity/animal/AbstractCow.java
+++ b/net/minecraft/world/entity/animal/AbstractCow.java
@@ -37,9 +37,10 @@ public abstract class AbstractCow extends Animal {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 2.0));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
-        this.goalSelector.addGoal(3, new TemptGoal(this, 1.25, itemStack -> itemStack.is(ItemTags.COW_FOOD), false));
+        this.goalSelector.addGoal(3, new TemptGoal(this, 1.25, itemStack -> level().purpurConfig.cowFeedMushrooms > 0 && (itemStack.is(net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem()) || itemStack.is(net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem())) || itemStack.is(ItemTags.COW_FOOD), false)); // Purpur - Cows eat mushrooms
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
@@ -82,19 +83,24 @@ public abstract class AbstractCow extends Animal {
 
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
+        if (getRider() != null) return InteractionResult.PASS; // Purpur - Ridables
         ItemStack itemInHand = player.getItemInHand(hand);
         if (itemInHand.is(Items.BUCKET) && !this.isBaby()) {
             // CraftBukkit start - Got milk?
             org.bukkit.event.player.PlayerBucketFillEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerBucketFillEvent(player.level(), player, this.blockPosition(), this.blockPosition(), null, itemInHand, Items.MILK_BUCKET, hand);
             if (event.isCancelled()) {
                 player.containerMenu.sendAllDataToRemote(); // Paper - Fix inventory desync
-                return InteractionResult.PASS;
+                return tryRide(player, hand); // Purpur - Ridables
             }
             // CraftBukkit end
             player.playSound(SoundEvents.COW_MILK, 1.0F, 1.0F);
             ItemStack itemStack = ItemUtils.createFilledResult(itemInHand, player, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItemStack())); // CraftBukkit
             player.setItemInHand(hand, itemStack);
             return InteractionResult.SUCCESS;
+        // Purpur start - Cows eat mushrooms - feed mushroom to change to mooshroom
+        } else if (level().purpurConfig.cowFeedMushrooms > 0 && this.getType() != EntityType.MOOSHROOM && isMushroom(itemInHand)) {
+            return this.feedMushroom(player, itemInHand);
+        // Purpur end - Cows eat mushrooms
         } else {
             return super.mobInteract(player, hand);
         }
@@ -104,4 +110,67 @@ public abstract class AbstractCow extends Animal {
     public EntityDimensions getDefaultDimensions(Pose pose) {
         return this.isBaby() ? BABY_DIMENSIONS : super.getDefaultDimensions(pose);
     }
+
+    // Purpur start - Cows eat mushrooms - feed mushroom to change to mooshroom
+    private int redMushroomsFed = 0;
+    private int brownMushroomsFed = 0;
+
+    private boolean isMushroom(ItemStack stack) {
+        return stack.getItem() == net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem() || stack.getItem() == net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem();
+    }
+
+    private int incrementFeedCount(ItemStack stack) {
+        if (stack.getItem() == net.minecraft.world.level.block.Blocks.RED_MUSHROOM.asItem()) {
+            return ++redMushroomsFed;
+        } else {
+            return ++brownMushroomsFed;
+        }
+    }
+
+    private InteractionResult feedMushroom(Player player, ItemStack stack) {
+        level().broadcastEntityEvent(this, (byte) 18); // hearts
+        playSound(SoundEvents.COW_MILK, 1.0F, 1.0F);
+        if (incrementFeedCount(stack) < level().purpurConfig.cowFeedMushrooms) {
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(1);
+            }
+            return InteractionResult.CONSUME; // require 5 mushrooms to transform (prevents mushroom duping)
+        }
+        MushroomCow mooshroom = EntityType.MOOSHROOM.create(level(), net.minecraft.world.entity.EntitySpawnReason.CONVERSION);
+        if (mooshroom == null) {
+            return InteractionResult.PASS;
+        }
+        if (stack.getItem() == net.minecraft.world.level.block.Blocks.BROWN_MUSHROOM.asItem()) {
+            mooshroom.setVariant(MushroomCow.Variant.BROWN);
+        } else {
+            mooshroom.setVariant(MushroomCow.Variant.RED);
+        }
+        mooshroom.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+        mooshroom.setHealth(this.getHealth());
+        mooshroom.setAge(getAge());
+        mooshroom.copyPosition(this);
+        mooshroom.setYBodyRot(this.yBodyRot);
+        mooshroom.setYHeadRot(this.getYHeadRot());
+        mooshroom.yRotO = this.yRotO;
+        mooshroom.xRotO = this.xRotO;
+        if (this.hasCustomName()) {
+            mooshroom.setCustomName(this.getCustomName());
+        }
+        if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTransformEvent(this, mooshroom, org.bukkit.event.entity.EntityTransformEvent.TransformReason.INFECTION).isCancelled()) {
+            return InteractionResult.PASS;
+        }
+        this.level().addFreshEntity(mooshroom);
+        this.remove(RemovalReason.DISCARDED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        if (!player.getAbilities().instabuild) {
+            stack.shrink(1);
+        }
+        for (int i = 0; i < 15; ++i) {
+            ((net.minecraft.server.level.ServerLevel) level()).sendParticlesSource(((net.minecraft.server.level.ServerLevel) level()).players(), null, net.minecraft.core.particles.ParticleTypes.HAPPY_VILLAGER,
+                    false, true,
+                    getX() + random.nextFloat(), getY() + (random.nextFloat() * 2), getZ() + random.nextFloat(), 1,
+                    random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+        }
+        return InteractionResult.SUCCESS;
+    }
+    // Purpur end - Cows eat mushrooms
 }
diff --git a/net/minecraft/world/entity/animal/AbstractFish.java b/net/minecraft/world/entity/animal/AbstractFish.java
index b18765bb91b4015bef326663dbc8966945929996..0002e39e2670ad92849ccc0aada163b174fe1ec2 100644
--- a/net/minecraft/world/entity/animal/AbstractFish.java
+++ b/net/minecraft/world/entity/animal/AbstractFish.java
@@ -90,6 +90,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
     @Override
     protected void registerGoals() {
         super.registerGoals();
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Player.class, 8.0F, 1.6, 1.4, EntitySelector.NO_SPECTATORS::test));
         this.goalSelector.addGoal(4, new AbstractFish.FishSwimGoal(this));
@@ -103,7 +104,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
     @Override
     public void travel(Vec3 travelVector) {
         if (this.isInWater()) {
-            this.moveRelative(0.01F, travelVector);
+            this.moveRelative(getRider() != null ? getSpeed() : 0.01F, travelVector); // Purpur - Ridables
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.9));
             if (this.getTarget() == null) {
@@ -163,7 +164,7 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
     protected void playStepSound(BlockPos pos, BlockState block) {
     }
 
-    static class FishMoveControl extends MoveControl {
+    static class FishMoveControl extends org.purpurmc.purpur.controller.WaterMoveControllerWASD { // Purpur - Ridables
         private final AbstractFish fish;
 
         FishMoveControl(AbstractFish mob) {
@@ -171,14 +172,22 @@ public abstract class AbstractFish extends WaterAnimal implements Bucketable {
             this.fish = mob;
         }
 
+        // Purpur start - Ridables
         @Override
-        public void tick() {
+        public void purpurTick(Player rider) {
+            super.purpurTick(rider);
+            fish.setDeltaMovement(fish.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
             if (this.fish.isEyeInFluid(FluidTags.WATER)) {
                 this.fish.setDeltaMovement(this.fish.getDeltaMovement().add(0.0, 0.005, 0.0));
             }
 
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.fish.getNavigation().isDone()) {
-                float f = (float)(this.speedModifier * this.fish.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f = (float)(this.getSpeedModifier() * this.fish.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 this.fish.setSpeed(Mth.lerp(0.125F, this.fish.getSpeed(), f));
                 double d = this.wantedX - this.fish.getX();
                 double d1 = this.wantedY - this.fish.getY();
diff --git a/net/minecraft/world/entity/animal/Animal.java b/net/minecraft/world/entity/animal/Animal.java
index cdf44c2586db396f1afdcbae4174b8b4fb00f48e..4d99a1bf2dc141630a76942ccbf1f60824cf7495 100644
--- a/net/minecraft/world/entity/animal/Animal.java
+++ b/net/minecraft/world/entity/animal/Animal.java
@@ -43,6 +43,7 @@ public abstract class Animal extends AgeableMob {
     @Nullable
     public EntityReference<ServerPlayer> loveCause;
     public @Nullable ItemStack breedItem; // CraftBukkit - Add breedItem variable
+    public abstract int getPurpurBreedTime(); // Purpur - Make entity breeding times configurable
 
     protected Animal(EntityType<? extends Animal> entityType, Level level) {
         super(entityType, level);
@@ -143,7 +144,7 @@ public abstract class Animal extends AgeableMob {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (this.isFood(itemInHand)) {
             int age = this.getAge();
-            if (player instanceof ServerPlayer serverPlayer && age == 0 && this.canFallInLove()) {
+            if (player instanceof ServerPlayer serverPlayer && age == 0 && this.canFallInLove() && (this.level().purpurConfig.animalBreedingCooldownSeconds <= 0 || !this.level().hasBreedingCooldown(player.getUUID(), this.getClass()))) { // Purpur - Add adjustable breeding cooldown to config
                 final ItemStack breedCopy = itemInHand.copy(); // Paper - Fix EntityBreedEvent copying
                 this.usePlayerItem(player, hand, itemInHand);
                 this.setInLove(serverPlayer, breedCopy); // Paper - Fix EntityBreedEvent copying
@@ -235,10 +236,20 @@ public abstract class Animal extends AgeableMob {
     public void spawnChildFromBreeding(ServerLevel level, Animal mate) {
         AgeableMob breedOffspring = this.getBreedOffspring(level, mate);
         if (breedOffspring != null) {
-            breedOffspring.setBaby(true);
-            breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F);
+            //breedOffspring.setBaby(true); // Purpur - Add adjustable breeding cooldown to config - moved down
+            //breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F); // Purpur - Add adjustable breeding cooldown to config - moved down
             // CraftBukkit start - Call EntityBreedEvent
             ServerPlayer breeder = Optional.ofNullable(this.getLoveCause()).or(() -> Optional.ofNullable(mate.getLoveCause())).orElse(null);
+            // Purpur start - Add adjustable breeding cooldown to config
+            if (breeder != null && level.purpurConfig.animalBreedingCooldownSeconds > 0) {
+                if (level.hasBreedingCooldown(breeder.getUUID(), this.getClass())) {
+                    return;
+                }
+                level.addBreedingCooldown(breeder.getUUID(), this.getClass());
+            }
+            breedOffspring.setBaby(true);
+            breedOffspring.snapTo(this.getX(), this.getY(), this.getZ(), 0.0F, 0.0F);
+            // Purpur end - Add adjustable breeding cooldown to config
             int experience = this.getRandom().nextInt(7) + 1;
             org.bukkit.event.entity.EntityBreedEvent entityBreedEvent = org.bukkit.craftbukkit.event.CraftEventFactory.callEntityBreedEvent(breedOffspring, this, mate, breeder, this.breedItem, experience);
             if (entityBreedEvent.isCancelled()) {
@@ -269,8 +280,10 @@ public abstract class Animal extends AgeableMob {
             player.awardStat(Stats.ANIMALS_BRED);
             CriteriaTriggers.BRED_ANIMALS.trigger(player, this, animal, baby);
         } // Paper - Call EntityBreedEvent
-        this.setAge(6000);
-        animal.setAge(6000);
+        // Purpur start - Make entity breeding times configurable
+        this.setAge(this.getPurpurBreedTime());
+        animal.setAge(animal.getPurpurBreedTime());
+        // Purpur end - Make entity breeding times configurable
         this.resetLove();
         animal.resetLove();
         level.broadcastEntityEvent(this, (byte)18);
diff --git a/net/minecraft/world/entity/animal/Bee.java b/net/minecraft/world/entity/animal/Bee.java
index 22b6b3452f410e8ace1847c87f31d566aebdb7e4..3a8c3dad4ac8ad575a6cdae24cb577ec55a9bbc8 100644
--- a/net/minecraft/world/entity/animal/Bee.java
+++ b/net/minecraft/world/entity/animal/Bee.java
@@ -150,6 +150,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     public Bee(EntityType<? extends Bee> entityType, Level level) {
         super(entityType, level);
+        final org.purpurmc.purpur.controller.FlyingMoveControllerWASD flyingController = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this, 0.25F, 1.0F, false); // Purpur - Ridables
         // Paper start - Fix MC-167279
         class BeeFlyingMoveControl extends FlyingMoveControl {
             public BeeFlyingMoveControl(final Mob entity, final int maxPitchChange, final boolean noGravity) {
@@ -158,22 +159,69 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
             @Override
             public void tick() {
+                // Purpur start - Ridables
+                if (mob.getRider() != null && mob.isControllable()) {
+                    flyingController.purpurTick(mob.getRider());
+                    return;
+                }
+                // Purpur end - Ridables
                 if (this.mob.getY() <= Bee.this.level().getMinY()) {
                     this.mob.setNoGravity(false);
                 }
                 super.tick();
             }
+
+            // Purpur start - Ridables
+            @Override
+            public boolean hasWanted() {
+                return mob.getRider() != null || !mob.isControllable() || super.hasWanted();
+            }
+            // Purpur end - Ridables
         }
         this.moveControl = new BeeFlyingMoveControl(this, 20, true);
         // Paper end - Fix MC-167279
         this.lookControl = new Bee.BeeLookControl(this);
         this.setPathfindingMalus(PathType.DANGER_FIRE, -1.0F);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (this.level().purpurConfig.beeCanInstantlyStartDrowning || isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - bee can instantly start drowning in water option // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.WATER_BORDER, 16.0F);
         this.setPathfindingMalus(PathType.COCOA, -1.0F);
         this.setPathfindingMalus(PathType.FENCE, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.beeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.beeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.beeControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.beeMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, speed, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -188,6 +236,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new Bee.BeeAttackGoal(this, 1.4F, true));
         this.goalSelector.addGoal(1, new Bee.BeeEnterHiveGoal());
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
@@ -205,6 +254,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         this.goalSelector.addGoal(7, new Bee.BeeGrowCropGoal());
         this.goalSelector.addGoal(8, new Bee.BeeWanderGoal());
         this.goalSelector.addGoal(9, new FloatGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Bee.BeeHurtByOtherGoal(this).setAlertOthers(new Class[0]));
         this.targetSelector.addGoal(2, new Bee.BeeBecomeAngryTargetGoal(this));
         this.targetSelector.addGoal(3, new ResetUniversalAngerTargetGoal<>(this, true));
@@ -366,7 +416,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     }
 
     public static boolean isNightOrRaining(Level level) {
-        return level.dimensionType().hasSkyLight() && (level.isDarkOutside() || level.isRaining());
+        return level.dimensionType().hasSkyLight() && (level.isDarkOutside() && !level.purpurConfig.beeCanWorkAtNight || level.isRaining() && !level.purpurConfig.beeCanWorkInRain); // Purpur - Bee can work when raining or at night
     }
 
     public void setStayOutOfHiveCountdown(int stayOutOfHiveCountdown) {
@@ -389,7 +439,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
     @Override
     protected void customServerAiStep(ServerLevel level) {
         boolean hasStung = this.hasStung();
-        if (this.isInWater()) {
+        if (this.level().purpurConfig.beeCanInstantlyStartDrowning && this.isInWater()) { // Purpur - bee can instantly start drowning in water option
             this.underWaterTicks++;
         } else {
             this.underWaterTicks = 0;
@@ -399,6 +449,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             this.hurtServer(level, this.damageSources().drown(), 1.0F);
         }
 
+        if (hasStung && !this.level().purpurConfig.beeDiesAfterSting) setHasStung(false); else // Purpur - Stop bees from dying after stinging
         if (hasStung) {
             this.timeSinceSting++;
             if (this.timeSinceSting % 5 == 0 && this.random.nextInt(Mth.clamp(1200 - this.timeSinceSting, 1, 1200)) == 0) {
@@ -422,6 +473,35 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         return beehiveBlockEntity != null && beehiveBlockEntity.isFireNearby();
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.beeMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.beeScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.beeBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.beeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.beeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public int getRemainingPersistentAngerTime() {
         return this.entityData.get(DATA_REMAINING_ANGER_TIME);
@@ -1090,15 +1170,15 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
         }
     }
 
-    class BeeLookControl extends LookControl {
+    class BeeLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         BeeLookControl(final Mob mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Bee.this.isAngry()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
 
@@ -1143,6 +1223,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                     Bee.this.savedFlowerPos = optional.get();
                     Bee.this.navigation
                         .moveTo(Bee.this.savedFlowerPos.getX() + 0.5, Bee.this.savedFlowerPos.getY() + 0.5, Bee.this.savedFlowerPos.getZ() + 0.5, 1.2F);
+                    new org.purpurmc.purpur.event.entity.BeeFoundFlowerEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level())).callEvent(); // Purpur - Bee API
                     return true;
                 } else {
                     Bee.this.remainingCooldownBeforeLocatingNewFlower = Mth.nextInt(Bee.this.random, 20, 60);
@@ -1189,6 +1270,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
             this.pollinating = false;
             Bee.this.navigation.stop();
             Bee.this.remainingCooldownBeforeLocatingNewFlower = 200;
+            new org.purpurmc.purpur.event.entity.BeeStopPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), Bee.this.savedFlowerPos == null ? null : org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level()), Bee.this.hasNectar()).callEvent(); // Purpur - Bee API
         }
 
         @Override
@@ -1235,6 +1317,7 @@ public class Bee extends Animal implements NeutralMob, FlyingAnimal {
                                 this.setWantedPos();
                             }
 
+                            if (this.successfulPollinatingTicks == 0) new org.purpurmc.purpur.event.entity.BeeStartedPollinatingEvent((org.bukkit.entity.Bee) Bee.this.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(Bee.this.savedFlowerPos, Bee.this.level())).callEvent(); // Purpur - Bee API
                             this.successfulPollinatingTicks++;
                             if (Bee.this.random.nextFloat() < 0.05F && this.successfulPollinatingTicks > this.lastSoundPlayedTick + 60) {
                                 this.lastSoundPlayedTick = this.successfulPollinatingTicks;
diff --git a/net/minecraft/world/entity/animal/Cat.java b/net/minecraft/world/entity/animal/Cat.java
index 7d20de1741e5e9219dea84fe5692f31c05fa82a2..09d518a59fe93afbeacb2d41a0c9d287f4a74443 100644
--- a/net/minecraft/world/entity/animal/Cat.java
+++ b/net/minecraft/world/entity/animal/Cat.java
@@ -92,10 +92,65 @@ public class Cat extends TamableAnimal {
         this.reassessTameGoals();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.catRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.catRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.catControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setInSittingPose(false);
+        setLying(false);
+        setRelaxStateOne(false);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.catMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.catScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.catBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.catTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.catAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.temptGoal = new Cat.CatTemptGoal(this, 0.6, stack -> stack.is(ItemTags.CAT_FOOD), true);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.5));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(3, new Cat.CatRelaxOnOwnerGoal(this));
@@ -108,6 +163,7 @@ public class Cat extends TamableAnimal {
         this.goalSelector.addGoal(10, new BreedGoal(this, 0.8));
         this.goalSelector.addGoal(11, new WaterAvoidingRandomStrollGoal(this, 0.8, 1.0000001E-5F));
         this.goalSelector.addGoal(12, new LookAtPlayerGoal(this, Player.class, 10.0F));
+        this.targetSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NonTameRandomTargetGoal<>(this, Rabbit.class, false, null));
         this.targetSelector.addGoal(1, new NonTameRandomTargetGoal<>(this, Turtle.class, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -354,6 +410,14 @@ public class Cat extends TamableAnimal {
         return this.isTame() && otherAnimal instanceof Cat cat && cat.isTame() && super.canMate(otherAnimal);
     }
 
+    // Purpur start - Configurable default collar color
+    @Override
+    public void tame(Player player) {
+        setCollarColor(level().purpurConfig.catDefaultCollarColor);
+        super.tame(player);
+    }
+    // Purpur end - Configurable default collar color
+
     @Nullable
     @Override
     public SpawnGroupData finalizeSpawn(
@@ -366,6 +430,7 @@ public class Cat extends TamableAnimal {
 
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
+        if (getRider() != null) return InteractionResult.PASS; // Purpur - Ridables
         ItemStack itemInHand = player.getItemInHand(hand);
         Item item = itemInHand.getItem();
         if (this.isTame()) {
@@ -452,7 +517,7 @@ public class Cat extends TamableAnimal {
     }
 
     private void tryToTame(Player player) {
-        if (this.random.nextInt(3) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit
+        if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(3) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit // Purpur - Config to always tame in Creative
             this.tame(player);
             this.setOrderedToSit(true);
             this.level().broadcastEntityEvent(this, (byte)7);
diff --git a/net/minecraft/world/entity/animal/Chicken.java b/net/minecraft/world/entity/animal/Chicken.java
index da408c313d898413dee928e9c80501ddf56d75e8..eaf913805195a580e3aa816dc28053abb9bdc246 100644
--- a/net/minecraft/world/entity/animal/Chicken.java
+++ b/net/minecraft/world/entity/animal/Chicken.java
@@ -72,16 +72,76 @@ public class Chicken extends Animal {
         this.setPathfindingMalus(PathType.WATER, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.chickenRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.chickenRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.chickenControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.chickenMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.chickenScale);
+        // Purpur start - Chickens can retaliate
+        if (level().purpurConfig.chickenRetaliate) {
+            this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(2.0D);
+        }
+        // Purpur end - Chickens can retaliate
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.chickenBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.chickenTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.chickenAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
-        this.goalSelector.addGoal(1, new PanicGoal(this, 1.4));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        //this.goalSelector.addGoal(1, new PanicGoal(this, 1.4)); // Purpur - Chickens can retaliate - moved down
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new TemptGoal(this, 1.0, itemStack -> itemStack.is(ItemTags.CHICKEN_FOOD), false));
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.1));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        // Purpur start - Chickens can retaliate
+        if (level().purpurConfig.chickenRetaliate) {
+            this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.0D, false));
+            this.targetSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.target.HurtByTargetGoal(this));
+        } else {
+            this.goalSelector.addGoal(1, new PanicGoal(this, 1.4D));
+        }
+        // Purpur end - Chickens can retaliate
     }
 
     @Override
@@ -90,7 +150,7 @@ public class Chicken extends Animal {
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 4.0).add(Attributes.MOVEMENT_SPEED, 0.25);
+        return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 4.0).add(Attributes.MOVEMENT_SPEED, 0.25).add(Attributes.ATTACK_DAMAGE, 0.0D); // Purpur - Chickens can retaliate
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/Cod.java b/net/minecraft/world/entity/animal/Cod.java
index 75509be5b9162c1f7f91f2290ef2d80171ae61df..7e08573cba6efcd78fcce37bccc2923f374f3c44 100644
--- a/net/minecraft/world/entity/animal/Cod.java
+++ b/net/minecraft/world/entity/animal/Cod.java
@@ -13,6 +13,39 @@ public class Cod extends AbstractSchoolingFish {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.codRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.codControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.codMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.codTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.codAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public ItemStack getBucketItemStack() {
         return new ItemStack(Items.COD_BUCKET);
diff --git a/net/minecraft/world/entity/animal/Cow.java b/net/minecraft/world/entity/animal/Cow.java
index 176425cbacea381990386d440059b768a583af98..b2fa170b14bc3037e5c143d320d0a1ef24738f1c 100644
--- a/net/minecraft/world/entity/animal/Cow.java
+++ b/net/minecraft/world/entity/animal/Cow.java
@@ -23,12 +23,68 @@ import net.minecraft.world.level.storage.ValueInput;
 import net.minecraft.world.level.storage.ValueOutput;
 
 public class Cow extends AbstractCow {
+    private boolean isNaturallyAggressiveToPlayers; // Purpur - Cows naturally aggressive to players chance
+
     private static final EntityDataAccessor<Holder<CowVariant>> DATA_VARIANT_ID = SynchedEntityData.defineId(Cow.class, EntityDataSerializers.COW_VARIANT);
 
     public Cow(EntityType<? extends Cow> entityType, Level level) {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.cowRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.cowRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.cowControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.cowMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SCALE).setBaseValue(this.level().purpurConfig.cowScale);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.cowNaturallyAggressiveToPlayersDamage); // Purpur - Cows naturally aggressive to players chance
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.cowBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.cowTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.cowAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
+    @Override
+    protected void registerGoals() {
+        super.registerGoals();
+        this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.2000000476837158D, true)); // Purpur - Cows naturally aggressive to players chance
+        this.targetSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.player.Player.class, 10, true, false, (ignored, ignored2) -> isNaturallyAggressiveToPlayers)); // Purpur - Cows naturally aggressive to players chance
+    }
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -41,6 +97,12 @@ public class Cow extends AbstractCow {
         VariantUtils.writeVariant(output, this.getVariant());
     }
 
+    // Purpur start - Cows naturally aggressive to players chance
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return AbstractCow.createAttributes().add(net.minecraft.world.entity.ai.attributes.Attributes.ATTACK_DAMAGE, 0.0D);
+    }
+    // Purpur end - Cows naturally aggressive to players chance
+
     @Override
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
@@ -62,6 +124,7 @@ public class Cow extends AbstractCow {
     public SpawnGroupData finalizeSpawn(
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
     ) {
+        this.isNaturallyAggressiveToPlayers = level.getLevel().purpurConfig.cowNaturallyAggressiveToPlayersChance > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.cowNaturallyAggressiveToPlayersChance; // Purpur - Cows naturally aggressive to players chance
         VariantUtils.selectVariantToSpawn(SpawnContext.create(level, this.blockPosition()), Registries.COW_VARIANT).ifPresent(this::setVariant);
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
diff --git a/net/minecraft/world/entity/animal/Dolphin.java b/net/minecraft/world/entity/animal/Dolphin.java
index 4bb273b11dbfbc6557c6771f79aa63f5f69d03cf..23696a5e2871ea07f34d4b4f6a20e2896ac3f5bd 100644
--- a/net/minecraft/world/entity/animal/Dolphin.java
+++ b/net/minecraft/world/entity/animal/Dolphin.java
@@ -74,14 +74,105 @@ public class Dolphin extends AgeableWaterCreature {
     private static final boolean DEFAULT_GOT_FISH = false;
     @Nullable
     public BlockPos treasurePos;
+    private boolean isNaturallyAggressiveToPlayers; // Purpur - Dolphins naturally aggressive to players chance
+    private int spitCooldown; // Purpur - Ridables
 
     public Dolphin(EntityType<? extends Dolphin> entityType, Level level) {
         super(entityType, level);
-        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        class DolphinMoveControl extends SmoothSwimmingMoveControl {
+            private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterMoveControllerWASD;
+            private final Dolphin dolphin;
+
+            public DolphinMoveControl(Dolphin dolphin, int pitchChange, int yawChange, float speedInWater, float speedInAir, boolean buoyant) {
+                super(dolphin, pitchChange, yawChange, speedInWater, speedInAir, buoyant);
+                this.dolphin = dolphin;
+                this.waterMoveControllerWASD = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(dolphin);
+            }
+
+            @Override
+            public void tick() {
+                if (dolphin.getRider() != null && dolphin.isControllable()) {
+                    purpurTick(dolphin.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+
+            public void purpurTick(Player rider) {
+                if (dolphin.getAirSupply() < 150) {
+                    // if drowning override player WASD controls to find air
+                    super.tick();
+                } else {
+                    waterMoveControllerWASD.purpurTick(rider);
+                    dolphin.setDeltaMovement(dolphin.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+                }
+            }
+        };
+        this.moveControl = new DolphinMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur end - Ridables
         this.lookControl = new SmoothSwimmingLookControl(this, 10);
         this.setCanPickUpLoot(true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.dolphinRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.dolphinControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (spitCooldown == 0 && getRider() != null) {
+            spitCooldown = level().purpurConfig.dolphinSpitCooldown;
+
+            org.bukkit.craftbukkit.entity.CraftPlayer player = (org.bukkit.craftbukkit.entity.CraftPlayer) getRider().getBukkitEntity();
+            if (!player.hasPermission("allow.special.dolphin")) {
+                return false;
+            }
+
+            org.bukkit.Location loc = player.getEyeLocation();
+            loc.setPitch(loc.getPitch() - 10);
+            org.bukkit.util.Vector target = loc.getDirection().normalize().multiply(10).add(loc.toVector());
+
+            org.purpurmc.purpur.entity.projectile.DolphinSpit spit = new org.purpurmc.purpur.entity.projectile.DolphinSpit(level(), this);
+            spit.shoot(target.getX() - getX(), target.getY() - getY(), target.getZ() - getZ(), level().purpurConfig.dolphinSpitSpeed, 5.0F);
+
+            level().addFreshEntity(spit);
+            playSound(SoundEvents.DOLPHIN_ATTACK, 1.0F, 1.0F + (random.nextFloat() - random.nextFloat()) * 0.2F);
+            return true;
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.dolphinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.dolphinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.dolphinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.dolphinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Nullable
     @Override
     public SpawnGroupData finalizeSpawn(
@@ -90,6 +181,7 @@ public class Dolphin extends AgeableWaterCreature {
         this.setAirSupply(this.getMaxAirSupply());
         this.setXRot(0.0F);
         SpawnGroupData spawnGroupData1 = Objects.requireNonNullElseGet(spawnGroupData, () -> new AgeableMob.AgeableMobGroupData(0.1F));
+        this.isNaturallyAggressiveToPlayers = level.getLevel().purpurConfig.dolphinNaturallyAggressiveToPlayersChance > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.dolphinNaturallyAggressiveToPlayersChance; // Purpur - Dolphins naturally aggressive to players chance
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData1);
     }
 
@@ -156,17 +248,21 @@ public class Dolphin extends AgeableWaterCreature {
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new BreathAirGoal(this));
         this.goalSelector.addGoal(0, new TryFindWaterGoal(this));
+        this.goalSelector.addGoal(1, new MeleeAttackGoal(this, 1.2000000476837158D, true)); // Purpur - Dolphins naturally aggressive to players chance
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Dolphin.DolphinSwimToTreasureGoal(this));
         this.goalSelector.addGoal(2, new Dolphin.DolphinSwimWithPlayerGoal(this, 4.0));
         this.goalSelector.addGoal(4, new RandomSwimmingGoal(this, 1.0, 10));
         this.goalSelector.addGoal(4, new RandomLookAroundGoal(this));
         this.goalSelector.addGoal(5, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(5, new DolphinJumpGoal(this, 10));
-        this.goalSelector.addGoal(6, new MeleeAttackGoal(this, 1.2F, true));
+        //this.goalSelector.addGoal(6, new MeleeAttackGoal(this, 1.2F, true)); // Purpur - moved up - Dolphins naturally aggressive to players chance
         this.goalSelector.addGoal(8, new Dolphin.PlayWithItemsGoal());
         this.goalSelector.addGoal(8, new FollowBoatGoal(this));
         this.goalSelector.addGoal(9, new AvoidEntityGoal<>(this, Guardian.class, 8.0F, 1.0, 1.0));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Guardian.class).setAlertOthers());
+        this.targetSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (ignored, ignored2) -> isNaturallyAggressiveToPlayers)); // Purpur - Dolphins naturally aggressive to players chance
     }
 
     public static AttributeSupplier.Builder createAttributes() {
@@ -210,7 +306,7 @@ public class Dolphin extends AgeableWaterCreature {
 
     @Override
     protected boolean canRide(Entity entity) {
-        return true;
+        return boardingCooldown <= 0; // Purpur - make dolphin honor ride cooldown like all other non-boss mobs;
     }
 
     @Override
@@ -239,6 +335,11 @@ public class Dolphin extends AgeableWaterCreature {
     @Override
     public void tick() {
         super.tick();
+        // Purpur start - Ridables
+        if (spitCooldown > 0) {
+            spitCooldown--;
+        }
+        // Purpur end - Ridables
         if (this.isNoAi()) {
             this.setAirSupply(this.getMaxAirSupply());
         } else {
@@ -399,6 +500,7 @@ public class Dolphin extends AgeableWaterCreature {
 
         @Override
         public boolean canUse() {
+            if (this.dolphin.level().purpurConfig.dolphinDisableTreasureSearching) return false; // Purpur - Add option to disable dolphin treasure searching
             return this.dolphin.gotFish() && this.dolphin.getAirSupply() >= 100;
         }
 
diff --git a/net/minecraft/world/entity/animal/Fox.java b/net/minecraft/world/entity/animal/Fox.java
index 517c546cfc8eca2191df57289e6a22ac64fc867c..8964bb5098c0dc36741af3656af6bc0b5b463abe 100644
--- a/net/minecraft/world/entity/animal/Fox.java
+++ b/net/minecraft/world/entity/animal/Fox.java
@@ -142,6 +142,73 @@ public class Fox extends Animal {
         this.getNavigation().setRequiredPathLength(32.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.foxRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.foxRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.foxControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        return getRider() != null && this.isControllable() ? 0.5F : super.getJumpPower();
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setCanPickUpLoot(false);
+        clearStates();
+        setIsPouncing(false);
+        spitOutItem(getItemBySlot(EquipmentSlot.MAINHAND));
+        setItemSlot(EquipmentSlot.MAINHAND, ItemStack.EMPTY);
+    }
+
+    @Override
+    public void onDismount(Player rider) {
+        super.onDismount(rider);
+        setCanPickUpLoot(true);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.foxMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.foxScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.foxBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.foxTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.foxAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -161,6 +228,7 @@ public class Fox extends Animal {
             this, AbstractFish.class, 20, false, false, (entity, level) -> entity instanceof AbstractSchoolingFish
         );
         this.goalSelector.addGoal(0, new Fox.FoxFloatGoal());
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(1, new Fox.FaceplantGoal());
         this.goalSelector.addGoal(2, new Fox.FoxPanicGoal(2.2));
@@ -186,6 +254,7 @@ public class Fox extends Animal {
         this.goalSelector.addGoal(11, new Fox.FoxSearchForItemsGoal());
         this.goalSelector.addGoal(12, new Fox.FoxLookAtPlayerGoal(this, Player.class, 24.0F));
         this.goalSelector.addGoal(13, new Fox.PerchAndSearchGoal());
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(
                 3,
@@ -346,6 +415,11 @@ public class Fox extends Animal {
     }
 
     private void setTargetGoals() {
+        // Purpur start - Tulips change fox type - do not add duplicate goals
+        this.targetSelector.removeGoal(this.landTargetGoal);
+        this.targetSelector.removeGoal(this.turtleEggTargetGoal);
+        this.targetSelector.removeGoal(this.fishTargetGoal);
+        // Purpur end - Tulips change fox type
         if (this.getVariant() == Fox.Variant.RED) {
             this.targetSelector.addGoal(4, this.landTargetGoal);
             this.targetSelector.addGoal(4, this.turtleEggTargetGoal);
@@ -373,6 +447,7 @@ public class Fox extends Animal {
 
     public void setVariant(Fox.Variant variant) {
         this.entityData.set(DATA_TYPE_ID, variant.getId());
+        this.setTargetGoals(); // Purpur - Tulips change fox type - fix API bug not updating pathfinders on type change
     }
 
     @Nullable
@@ -703,6 +778,29 @@ public class Fox extends Animal {
     }
     // Paper end
 
+    // Purpur start - Tulips change fox type
+    @Override
+    public net.minecraft.world.InteractionResult mobInteract(Player player, net.minecraft.world.InteractionHand hand) {
+        if (level().purpurConfig.foxTypeChangesWithTulips) {
+            ItemStack itemstack = player.getItemInHand(hand);
+            if (getVariant() == Variant.RED && itemstack.getItem() == Items.WHITE_TULIP) {
+                setVariant(Variant.SNOW);
+                if (!player.getAbilities().instabuild) {
+                    itemstack.shrink(1);
+                }
+                return net.minecraft.world.InteractionResult.SUCCESS;
+            } else if (getVariant() == Variant.SNOW && itemstack.getItem() == Items.ORANGE_TULIP) {
+                setVariant(Variant.RED);
+                if (!player.getAbilities().instabuild) {
+                    itemstack.shrink(1);
+                }
+                return net.minecraft.world.InteractionResult.SUCCESS;
+            }
+        }
+        return super.mobInteract(player, hand);
+    }
+    // Purpur end - Tulips change fox type
+
     @Override
     // Paper start - Cancellable death event
     protected org.bukkit.event.entity.EntityDeathEvent dropAllDeathLoot(ServerLevel level, DamageSource damageSource) {
@@ -916,8 +1014,10 @@ public class Fox extends Animal {
                     CriteriaTriggers.BRED_ANIMALS.trigger(serverPlayer, this.animal, this.partner, fox);
                 }
 
-                this.animal.setAge(6000);
-                this.partner.setAge(6000);
+                // Purpur start - Make entity breeding times configurable
+                this.animal.setAge(this.animal.getPurpurBreedTime());
+                this.partner.setAge(this.partner.getPurpurBreedTime());
+                // Purpur end - Make entity breeding times configurable
                 this.animal.resetLove();
                 this.partner.resetLove();
                 serverLevel.addFreshEntityWithPassengers(fox, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BREEDING); // CraftBukkit - added SpawnReason
@@ -972,7 +1072,7 @@ public class Fox extends Animal {
         }
 
         protected void onReachedTarget() {
-            if (getServerLevel(Fox.this.level()).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+            if (getServerLevel(Fox.this.level()).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(Fox.this.level()).purpurConfig.foxMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 BlockState blockState = Fox.this.level().getBlockState(this.blockPos);
                 if (blockState.is(Blocks.SWEET_BERRY_BUSH)) {
                     this.pickSweetBerries(blockState);
@@ -1086,15 +1186,15 @@ public class Fox extends Animal {
         }
     }
 
-    public class FoxLookControl extends LookControl {
+    public class FoxLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public FoxLookControl() {
             super(Fox.this);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Fox.this.isSleeping()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
 
@@ -1130,15 +1230,15 @@ public class Fox extends Animal {
         }
     }
 
-    class FoxMoveControl extends MoveControl {
+    class FoxMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         public FoxMoveControl() {
             super(Fox.this);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Fox.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/animal/HappyGhast.java b/net/minecraft/world/entity/animal/HappyGhast.java
index 272f57aca640e045efca64dd018b221335c667ee..fb37669b4d66bb853eabf2d15a369d7ad5a2dbb9 100644
--- a/net/minecraft/world/entity/animal/HappyGhast.java
+++ b/net/minecraft/world/entity/animal/HappyGhast.java
@@ -126,6 +126,47 @@ public class HappyGhast extends Animal {
         this.removeAllGoals(goal -> true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.happyGhastRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.happyGhastMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.happyGhastScale);
+        this.getAttribute(Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.happyGhastTemptRange);
+        this.getAttribute(Attributes.FLYING_SPEED).setBaseValue(this.level().purpurConfig.happyGhastFlyingSpeed);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.happyGhastMovementSpeed);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.happyGhastFollowRange);
+        this.getAttribute(Attributes.CAMERA_DISTANCE).setBaseValue(this.level().purpurConfig.happyGhastCameraDistance);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.happyGhastTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.happyGhastAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void ageBoundaryReached() {
         if (this.isBaby()) {
@@ -149,7 +190,7 @@ public class HappyGhast extends Animal {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return Math.min(scale, 1.0F);
+        return Math.min(scale, 1.0F); // Purpur - Configurable entity base attributes
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/IronGolem.java b/net/minecraft/world/entity/animal/IronGolem.java
index db309a1261778cc65da9b4bf5a962a372b83bba6..8885ab56eb72c0106ef57359ca11f70c012fc348 100644
--- a/net/minecraft/world/entity/animal/IronGolem.java
+++ b/net/minecraft/world/entity/animal/IronGolem.java
@@ -58,13 +58,67 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     private int remainingPersistentAngerTime;
     @Nullable
     private UUID persistentAngerTarget;
+    @Nullable private UUID summoner; // Purpur - Summoner API
 
     public IronGolem(EntityType<? extends IronGolem> entityType, Level level) {
         super(entityType, level);
     }
 
+    // Purpur start - Summoner API
+    @Nullable
+    public UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(@Nullable UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ironGolemRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ironGolemRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ironGolemControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ironGolemMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ironGolemScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ironGolemTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ironGolemAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        if (this.level().purpurConfig.ironGolemPoppyCalm) this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.ReceiveFlower(this)); // Purpur - Iron golem calm anger options
+        if (level().purpurConfig.ironGolemCanSwim) this.goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(2, new MoveTowardsTargetGoal(this, 0.9, 32.0F));
         this.goalSelector.addGoal(2, new MoveBackToVillageGoal(this, 0.6, false));
@@ -72,6 +126,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
         this.goalSelector.addGoal(5, new OfferFlowerGoal(this));
         this.goalSelector.addGoal(7, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new DefendVillageTargetGoal(this));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
@@ -142,6 +197,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putBoolean("PlayerCreated", this.isPlayerCreated());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
         this.addPersistentAngerSaveData(output);
     }
 
@@ -149,6 +205,7 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.setPlayerCreated(input.getBooleanOr("PlayerCreated", false));
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
         this.readPersistentAngerSaveData(this.level(), input);
     }
 
@@ -258,16 +315,17 @@ public class IronGolem extends AbstractGolem implements NeutralMob {
     protected InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (!itemInHand.is(Items.IRON_INGOT)) {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         } else {
             float health = this.getHealth();
             this.heal(25.0F);
             if (this.getHealth() == health) {
-                return InteractionResult.PASS;
+                return tryRide(player, hand); // Purpur - Ridables
             } else {
                 float f = 1.0F + (this.random.nextFloat() - this.random.nextFloat()) * 0.2F;
                 this.playSound(SoundEvents.IRON_GOLEM_REPAIR, 1.0F, f);
                 itemInHand.consume(1, player);
+                if (this.level().purpurConfig.ironGolemHealCalm && isAngry() && getHealth() == getMaxHealth()) stopBeingAngry(); // Purpur - Iron golem calm anger options
                 return InteractionResult.SUCCESS;
             }
         }
diff --git a/net/minecraft/world/entity/animal/MushroomCow.java b/net/minecraft/world/entity/animal/MushroomCow.java
index 1f82848c97c5b52d6c4225b07a895f00d20c7d6c..5750f87944ea84d59674d1df7f5d48121d987a54 100644
--- a/net/minecraft/world/entity/animal/MushroomCow.java
+++ b/net/minecraft/world/entity/animal/MushroomCow.java
@@ -62,6 +62,51 @@ public class MushroomCow extends AbstractCow implements Shearable {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.mooshroomRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.mooshroomRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.mooshroomControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.mooshroomMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.mooshroomBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.mooshroomTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.mooshroomAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
         return level.getBlockState(pos.below()).is(Blocks.MYCELIUM) ? 10.0F : level.getPathfindingCostFromLightLevels(pos);
@@ -122,7 +167,7 @@ public class MushroomCow extends AbstractCow implements Shearable {
                 java.util.List<ItemStack> drops = this.generateDefaultDrops(serverLevel, itemInHand);
                 org.bukkit.event.player.PlayerShearEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerShearEntityEvent(player, this, itemInHand, hand, drops);
                 if (event != null) {
-                    if (event.isCancelled()) return InteractionResult.PASS;
+                    if (event.isCancelled()) return tryRide(player, hand); // Purpur - Ridables
                     drops = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getDrops());
                     // Paper end - custom shear drops
                 }
@@ -199,6 +244,13 @@ public class MushroomCow extends AbstractCow implements Shearable {
         level.playSound(null, this, SoundEvents.MOOSHROOM_SHEAR, soundSource, 1.0F, 1.0F);
         this.convertTo(EntityType.COW, ConversionParams.single(this, false, false), cow -> {
             level.sendParticles(ParticleTypes.EXPLOSION, this.getX(), this.getY(0.5), this.getZ(), 1, 0.0, 0.0, 0.0, 0.0);
+            // Purpur start - Fix cow rotation when shearing mooshroom
+            cow.copyPosition(this);
+            cow.yBodyRot = this.yBodyRot;
+            cow.setYHeadRot(this.getYHeadRot());
+            cow.yRotO = this.yRotO;
+            cow.xRotO = this.xRotO;
+            // Purpur end - Fix cow rotation when shearing mooshroom
             // Paper start - custom shear drops; moved drop generation to separate method
             drops.forEach(drop -> {
                 this.spawnAtLocation(level, new ItemEntity(this.level(), this.getX(), this.getY(1.0), this.getZ(), drop));
diff --git a/net/minecraft/world/entity/animal/Ocelot.java b/net/minecraft/world/entity/animal/Ocelot.java
index e8b184f2e1a98e565a50ce6ae6cab248d5a6e89b..4c20569ec5c504c582575851ab1d74248289b1c0 100644
--- a/net/minecraft/world/entity/animal/Ocelot.java
+++ b/net/minecraft/world/entity/animal/Ocelot.java
@@ -64,6 +64,52 @@ public class Ocelot extends Animal {
         this.reassessTrustingGoals();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ocelotRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ocelotRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ocelotControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ocelotMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ocelotScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.ocelotBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ocelotTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ocelotAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public boolean isTrusting() {
         return this.entityData.get(DATA_TRUSTING);
     }
@@ -95,12 +141,14 @@ public class Ocelot extends Animal {
     protected void registerGoals() {
         this.temptGoal = new Ocelot.OcelotTemptGoal(this, 0.6, itemStack -> itemStack.is(ItemTags.OCELOT_FOOD), true);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(3, this.temptGoal);
         this.goalSelector.addGoal(7, new LeapAtTargetGoal(this, 0.3F));
         this.goalSelector.addGoal(8, new OcelotAttackGoal(this));
         this.goalSelector.addGoal(9, new BreedGoal(this, 0.8));
         this.goalSelector.addGoal(10, new WaterAvoidingRandomStrollGoal(this, 0.8, 1.0000001E-5F));
         this.goalSelector.addGoal(11, new LookAtPlayerGoal(this, Player.class, 10.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Chicken.class, false));
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, false, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -234,7 +282,7 @@ public class Ocelot extends Animal {
     public boolean checkSpawnObstruction(LevelReader level) {
         if (level.isUnobstructed(this) && !level.containsAnyLiquid(this.getBoundingBox())) {
             BlockPos blockPos = this.blockPosition();
-            if (blockPos.getY() < level.getSeaLevel()) {
+            if (!level().purpurConfig.ocelotSpawnUnderSeaLevel && blockPos.getY() < level.getSeaLevel()) { // Purpur - Option Ocelot Spawn Under Sea Level
                 return false;
             }
 
diff --git a/net/minecraft/world/entity/animal/Panda.java b/net/minecraft/world/entity/animal/Panda.java
index 44c12820b9b39acc5220db8b8d29a31c0e57526e..02bfa88568e635770675ea9173f2cf3ca21457fa 100644
--- a/net/minecraft/world/entity/animal/Panda.java
+++ b/net/minecraft/world/entity/animal/Panda.java
@@ -107,6 +107,62 @@ public class Panda extends Animal {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pandaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pandaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pandaControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setForwardMot(0.0F);
+        sit(false);
+        eat(false);
+        setOnBack(false);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pandaMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pandaScale);
+        setAttributes();
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.pandaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pandaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pandaAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected boolean canDispenserEquipIntoSlot(EquipmentSlot slot) {
         return slot == EquipmentSlot.MAINHAND && this.canPickUpLoot();
@@ -260,6 +316,7 @@ public class Panda extends Animal {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new Panda.PandaPanicGoal(this, 2.0));
         this.goalSelector.addGoal(2, new Panda.PandaBreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new Panda.PandaAttackGoal(this, 1.2F, true));
@@ -275,6 +332,7 @@ public class Panda extends Animal {
         this.goalSelector.addGoal(12, new Panda.PandaRollGoal(this));
         this.goalSelector.addGoal(13, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(14, new WaterAvoidingRandomStrollGoal(this, 1.0));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Panda.PandaHurtByTargetGoal(this).setAlertOthers(new Class[0]));
     }
 
@@ -598,7 +656,11 @@ public class Panda extends Animal {
 
     public void setAttributes() {
         if (this.isWeak()) {
-            this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(10.0);
+            // Purpur start - Configurable entity base attributes
+            net.minecraft.world.entity.ai.attributes.AttributeInstance maxHealth = this.getAttribute(Attributes.MAX_HEALTH);
+            maxHealth.setBaseValue(maxHealth.getValue() / 2);
+            // Purpur end - Configurable entity base attributes
+
         }
 
         if (this.isLazy()) {
@@ -618,7 +680,7 @@ public class Panda extends Animal {
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (this.isScared()) {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         } else if (this.isOnBack()) {
             this.setOnBack(false);
             return InteractionResult.SUCCESS;
@@ -654,7 +716,7 @@ public class Panda extends Animal {
 
             return InteractionResult.SUCCESS_SERVER;
         } else {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         }
     }
 
@@ -962,7 +1024,7 @@ public class Panda extends Animal {
         }
     }
 
-    static class PandaMoveControl extends MoveControl {
+    static class PandaMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Panda panda;
 
         public PandaMoveControl(Panda mob) {
@@ -971,9 +1033,9 @@ public class Panda extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.panda.canPerformAction()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/animal/Parrot.java b/net/minecraft/world/entity/animal/Parrot.java
index 22d1e36dadd6a8cbf615335074426aaab6ea7d01..dddf3a2e372bd0d483c1da01d36fe59b17b3d4e2 100644
--- a/net/minecraft/world/entity/animal/Parrot.java
+++ b/net/minecraft/world/entity/animal/Parrot.java
@@ -131,12 +131,97 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     public Parrot(EntityType<? extends Parrot> entityType, Level level) {
         super(entityType, level);
-        this.moveControl = new FlyingMoveControl(this, 10, false);
+        // Purpur start - Ridables
+        final org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD flyingController = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.3F);
+        class ParrotMoveControl extends FlyingMoveControl {
+            public ParrotMoveControl(Mob entity, int maxPitchChange, boolean noGravity) {
+                super(entity, maxPitchChange, noGravity);
+            }
+
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    flyingController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+
+            @Override
+            public boolean hasWanted() {
+                return mob.getRider() != null && mob.isControllable() ? getForwardMot() != 0 || getStrafeMot() != 0 : super.hasWanted();
+            }
+        }
+        this.moveControl = new ParrotMoveControl(this, 10, false);
+        // Purpur end - Ridables
         this.setPathfindingMalus(PathType.DANGER_FIRE, -1.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, -1.0F);
         this.setPathfindingMalus(PathType.COCOA, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.parrotRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.parrotRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.parrotControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.parrotMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 2;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.25, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.parrotMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.parrotScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.parrotTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.parrotAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Nullable
     @Override
     public SpawnGroupData finalizeSpawn(
@@ -157,8 +242,11 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(0, new TamableAnimal.TamableAnimalPanicGoal(1.25));
+        //this.goalSelector.addGoal(0, new TamableAnimal.TamableAnimalPanicGoal(1.25)); // Purpur - move down
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        if (this.level().purpurConfig.parrotBreedable) this.goalSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.BreedGoal(this, 1.0D)); // Purpur - Breedable parrots
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.25D)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(2, new FollowOwnerGoal(this, 1.0, 5.0F, 1.0F));
@@ -264,7 +352,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
             }
 
             if (!this.level().isClientSide) {
-                if (this.random.nextInt(10) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit
+                if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(10) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit // Purpur - Config to always tame in Creative
                     this.tame(player);
                     this.level().broadcastEntityEvent(this, (byte)7);
                 } else {
@@ -272,6 +360,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
                 }
             }
 
+            if (this.level().purpurConfig.parrotBreedable) return super.mobInteract(player, hand); // Purpur - Breedable parrots
             return InteractionResult.SUCCESS;
         } else if (!itemInHand.is(ItemTags.PARROT_POISONOUS_FOOD)) {
             if (!this.isFlying() && this.isTame() && this.isOwnedBy(player)) {
@@ -296,7 +385,7 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     public boolean isFood(ItemStack stack) {
-        return false;
+        return this.level().purpurConfig.parrotBreedable && stack.is(ItemTags.PARROT_FOOD); // Purpur - Breedable parrots
     }
 
     public static boolean checkParrotSpawnRules(
@@ -311,13 +400,13 @@ public class Parrot extends ShoulderRidingEntity implements FlyingAnimal {
 
     @Override
     public boolean canMate(Animal otherAnimal) {
-        return false;
+        return super.canMate(otherAnimal); // Purpur - Breedable parrots
     }
 
     @Nullable
     @Override
     public AgeableMob getBreedOffspring(ServerLevel level, AgeableMob otherParent) {
-        return null;
+        return level.purpurConfig.parrotBreedable ? EntityType.PARROT.create(level, EntitySpawnReason.BREEDING) : null; // Purpur - Breedable parrots
     }
 
     @Nullable
diff --git a/net/minecraft/world/entity/animal/Pig.java b/net/minecraft/world/entity/animal/Pig.java
index 155a51233895955d01c2ee73416e2daefc4dfd0f..adbbe938c14d14a628d9963acec57c32661957cd 100644
--- a/net/minecraft/world/entity/animal/Pig.java
+++ b/net/minecraft/world/entity/animal/Pig.java
@@ -66,9 +66,56 @@ public class Pig extends Animal implements ItemSteerable {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pigRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pigRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pigControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pigMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pigScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.pigBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pigTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pigAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(3, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(4, new TemptGoal(this, 1.2, itemStack -> itemStack.is(Items.CARROT_ON_A_STICK), false));
@@ -142,6 +189,19 @@ public class Pig extends Animal implements ItemSteerable {
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         boolean isFood = this.isFood(player.getItemInHand(hand));
+        // Purpur start - Pigs give saddle back
+        if (level().purpurConfig.pigGiveSaddleBack && player.isSecondaryUseActive() && !isFood && isSaddled() && !isVehicle()) {
+            this.setItemSlot(EquipmentSlot.SADDLE, ItemStack.EMPTY);
+            if (!player.getAbilities().instabuild) {
+                ItemStack saddle = new ItemStack(Items.SADDLE);
+                if (!player.getInventory().add(saddle)) {
+                    player.drop(saddle, false);
+                }
+            }
+            return InteractionResult.SUCCESS;
+        }
+        // Purpur end - Pigs give saddle back
+
         if (!isFood && this.isSaddled() && !this.isVehicle() && !player.isSecondaryUseActive()) {
             if (!this.level().isClientSide) {
                 player.startRiding(this);
diff --git a/net/minecraft/world/entity/animal/PolarBear.java b/net/minecraft/world/entity/animal/PolarBear.java
index d727e8e93e466b9bb91cbb43b9c1bbbccc56d486..e0b51b482607ec5a9f5b4d13d918d79b2f52f9c0 100644
--- a/net/minecraft/world/entity/animal/PolarBear.java
+++ b/net/minecraft/world/entity/animal/PolarBear.java
@@ -60,11 +60,92 @@ public class PolarBear extends Animal implements NeutralMob {
     private int remainingPersistentAngerTime;
     @Nullable
     private UUID persistentAngerTarget;
+    private int standTimer = 0; // Purpur - Ridables
 
     public PolarBear(EntityType<? extends PolarBear> entityType, Level level) {
         super(entityType, level);
     }
 
+    // Purpur start - Breedable Polar Bears
+    public boolean canMate(Animal other) {
+        if (other == this) {
+            return false;
+        } else if (this.isStanding()) {
+            return false;
+        } else if (this.getTarget() != null) {
+            return false;
+        } else if (!(other instanceof PolarBear)) {
+            return false;
+        } else {
+            PolarBear bear = (PolarBear) other;
+            if (bear.isStanding()) {
+                return false;
+            }
+            if (bear.getTarget() != null) {
+                return false;
+            }
+            return this.isInLove() && bear.isInLove();
+        }
+    }
+    // Purpur end - Breedable Polar Bears
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.polarBearRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.polarBearRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.polarBearControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (!isStanding()) {
+            if (getRider() != null && getRider().getForwardMot() == 0 && getRider().getStrafeMot() == 0) {
+                setStanding(true);
+                playSound(SoundEvents.POLAR_BEAR_WARNING, 1.0F, 1.0F);
+            }
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.polarBearMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.polarBearScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.polarBearBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.polarBearTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.polarBearAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Nullable
     @Override
     public AgeableMob getBreedOffspring(ServerLevel level, AgeableMob otherParent) {
@@ -73,19 +154,27 @@ public class PolarBear extends Animal implements NeutralMob {
 
     @Override
     public boolean isFood(ItemStack stack) {
-        return false;
+        return level().purpurConfig.polarBearBreedableItem != null && stack.getItem() == level().purpurConfig.polarBearBreedableItem; // Purpur - Breedable Polar Bears
     }
 
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PolarBear.PolarBearMeleeAttackGoal());
         this.goalSelector.addGoal(1, new PanicGoal(this, 2.0, mob -> mob.isBaby() ? DamageTypeTags.PANIC_CAUSES : DamageTypeTags.PANIC_ENVIRONMENTAL_CAUSES));
+        // Purpur start - Breedable Polar Bears
+        if (level().purpurConfig.polarBearBreedableItem != null) {
+            this.goalSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.BreedGoal(this, 1.0D));
+            this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, net.minecraft.world.item.crafting.Ingredient.of(level().purpurConfig.polarBearBreedableItem), false));
+        }
+        // Purpur end - Breedable Polar Bears
         this.goalSelector.addGoal(4, new FollowParentGoal(this, 1.25));
         this.goalSelector.addGoal(5, new RandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new PolarBear.PolarBearHurtByTargetGoal());
         this.targetSelector.addGoal(2, new PolarBear.PolarBearAttackPlayersGoal());
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
@@ -204,6 +293,12 @@ public class PolarBear extends Animal implements NeutralMob {
         if (!this.level().isClientSide) {
             this.updatePersistentAnger((ServerLevel)this.level(), true);
         }
+
+        // Purpur start - Ridables
+        if (isStanding() && --standTimer <= 0) {
+            setStanding(false);
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -223,6 +318,7 @@ public class PolarBear extends Animal implements NeutralMob {
 
     public void setStanding(boolean standing) {
         this.entityData.set(DATA_STANDING_ID, standing);
+        standTimer = standing ? 20 : -1; // Purpur - Ridables
     }
 
     public float getStandingAnimationScale(float partialTick) {
diff --git a/net/minecraft/world/entity/animal/Pufferfish.java b/net/minecraft/world/entity/animal/Pufferfish.java
index e67f9b26444e3af42feeb0223c1b7c1e536646ba..685176ce37538cbbc614401db568acdb0ad264bb 100644
--- a/net/minecraft/world/entity/animal/Pufferfish.java
+++ b/net/minecraft/world/entity/animal/Pufferfish.java
@@ -47,6 +47,39 @@ public class Pufferfish extends AbstractFish {
         this.refreshDimensions();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pufferfishRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pufferfishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pufferfishMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pufferfishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pufferfishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/animal/Rabbit.java b/net/minecraft/world/entity/animal/Rabbit.java
index ac99590dad689f2cfffb9b9e2465f6a252d41e9c..1af1b33702296f9aa74c33436ea2904c5e5ae43d 100644
--- a/net/minecraft/world/entity/animal/Rabbit.java
+++ b/net/minecraft/world/entity/animal/Rabbit.java
@@ -91,6 +91,7 @@ public class Rabbit extends Animal {
     private boolean wasOnGround;
     private int jumpDelayTicks;
     public int moreCarrotTicks = 0;
+    private boolean actualJump; // Purpur - Ridables
 
     public Rabbit(EntityType<? extends Rabbit> entityType, Level level) {
         super(entityType, level);
@@ -99,9 +100,84 @@ public class Rabbit extends Animal {
         //this.setSpeedModifier(0.0); // CraftBukkit
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.rabbitRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.rabbitRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.rabbitControllable;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (onGround) {
+            actualJump = true;
+            jumpFromGround();
+            actualJump = false;
+        }
+        return true;
+    }
+
+    private void handleJumping() {
+        if (onGround) {
+            RabbitJumpControl jumpController = (RabbitJumpControl) jumpControl;
+            if (!wasOnGround) {
+                setJumping(false);
+                jumpController.setCanJump(false);
+            }
+            if (!jumpController.wantJump()) {
+                if (moveControl.hasWanted()) {
+                    startJumping();
+                }
+            } else if (!jumpController.canJump()) {
+                jumpController.setCanJump(true);
+            }
+        }
+        wasOnGround = onGround;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.rabbitMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.rabbitScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.rabbitBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.rabbitTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.rabbitAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(1, new Rabbit.RabbitPanicGoal(this, 2.2));
         this.goalSelector.addGoal(2, new BreedGoal(this, 0.8));
@@ -116,6 +192,14 @@ public class Rabbit extends Animal {
 
     @Override
     protected float getJumpPower() {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            if (getForwardMot() < 0) {
+                setSpeed(getForwardMot() * 2F);
+            }
+            return actualJump ? 0.5F : 0.3F;
+        }
+        // Purpur end - Ridables
         float f = 0.3F;
         if (this.moveControl.getSpeedModifier() <= 0.6) {
             f = 0.2F;
@@ -183,6 +267,12 @@ public class Rabbit extends Animal {
 
     @Override
     public void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            handleJumping();
+            return;
+        }
+        // Purpur end - Ridables
         if (this.jumpDelayTicks > 0) {
             this.jumpDelayTicks--;
         }
@@ -404,10 +494,23 @@ public class Rabbit extends Animal {
         }
 
         this.setVariant(randomRabbitVariant);
+
+        // Purpur start - Special mobs naturally spawn
+        if (randomRabbitVariant != Variant.EVIL && level.getLevel().purpurConfig.rabbitNaturalToast > 0D && random.nextDouble() <= level.getLevel().purpurConfig.rabbitNaturalToast) {
+            setCustomName(Component.translatable("Toast"));
+        }
+        // Purpur end - Special mobs naturally spawn
+
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
     private static Rabbit.Variant getRandomRabbitVariant(LevelAccessor level, BlockPos pos) {
+        // Purpur start - Special mobs naturally spawn
+        Level world = level.getMinecraftWorld();
+        if (world.purpurConfig.rabbitNaturalKiller > 0D && world.getRandom().nextDouble() <= world.purpurConfig.rabbitNaturalKiller) {
+            return Rabbit.Variant.EVIL;
+        }
+        // Purpur end - Special mobs naturally spawn
         Holder<Biome> biome = level.getBiome(pos);
         int randomInt = level.getRandom().nextInt(100);
         if (biome.is(BiomeTags.SPAWNS_WHITE_RABBITS)) {
@@ -498,7 +601,7 @@ public class Rabbit extends Animal {
         }
     }
 
-    static class RabbitMoveControl extends MoveControl {
+    static class RabbitMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Rabbit rabbit;
         private double nextJumpSpeed;
 
@@ -508,14 +611,14 @@ public class Rabbit extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.rabbit.onGround() && !this.rabbit.jumping && !((Rabbit.RabbitJumpControl)this.rabbit.jumpControl).wantJump()) {
                 this.rabbit.setSpeedModifier(0.0);
             } else if (this.hasWanted() || this.operation == MoveControl.Operation.JUMPING) {
                 this.rabbit.setSpeedModifier(this.nextJumpSpeed);
             }
 
-            super.tick();
+            super.vanillaTick(); // Purpur - Ridables
         }
 
         @Override
@@ -559,7 +662,7 @@ public class Rabbit extends Animal {
         @Override
         public boolean canUse() {
             if (this.nextStartTick <= 0) {
-                if (!getServerLevel(this.rabbit).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+                if (!getServerLevel(this.rabbit).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(this.rabbit).purpurConfig.rabbitMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     return false;
                 }
 
diff --git a/net/minecraft/world/entity/animal/Salmon.java b/net/minecraft/world/entity/animal/Salmon.java
index 8a3e1d420263ac53b87ffed026380dcdc4a48285..d2679beaa3be6de36227c5b66609e0df393c4376 100644
--- a/net/minecraft/world/entity/animal/Salmon.java
+++ b/net/minecraft/world/entity/animal/Salmon.java
@@ -39,6 +39,39 @@ public class Salmon extends AbstractSchoolingFish {
         this.refreshDimensions();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.salmonRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.salmonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.salmonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.salmonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.salmonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public int getMaxSchoolSize() {
         return 5;
diff --git a/net/minecraft/world/entity/animal/SnowGolem.java b/net/minecraft/world/entity/animal/SnowGolem.java
index 1b3a020e35fb2f9a28be718415c51fde5b52d399..8984a4fc0aae9fd72bc3f7222003c7593810ab77 100644
--- a/net/minecraft/world/entity/animal/SnowGolem.java
+++ b/net/minecraft/world/entity/animal/SnowGolem.java
@@ -46,17 +46,63 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
     private static final EntityDataAccessor<Byte> DATA_PUMPKIN_ID = SynchedEntityData.defineId(SnowGolem.class, EntityDataSerializers.BYTE);
     private static final byte PUMPKIN_FLAG = 16;
     private static final boolean DEFAULT_PUMPKIN = true;
+    @Nullable private java.util.UUID summoner; // Purpur - Summoner API
 
     public SnowGolem(EntityType<? extends SnowGolem> entityType, Level level) {
         super(entityType, level);
     }
 
+    // Purpur start - Summoner API
+    @Nullable
+    public java.util.UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(@Nullable java.util.UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.snowGolemRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.snowGolemRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.snowGolemControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.snowGolemMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.snowGolemScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.snowGolemAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(1, new RangedAttackGoal(this, 1.25, 20, 10.0F));
-        this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0, 1.0000001E-5F));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.goalSelector.addGoal(1, new RangedAttackGoal(this, level().purpurConfig.snowGolemAttackDistance, level().purpurConfig.snowGolemSnowBallMin, level().purpurConfig.snowGolemSnowBallMax, level().purpurConfig.snowGolemSnowBallModifier)); // Purpur - Snow Golem rate of fire config
+        this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0D, 1.0000001E-5F));
         this.goalSelector.addGoal(3, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(4, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Mob.class, 10, true, false, (entity, level) -> entity instanceof Enemy));
     }
 
@@ -74,17 +120,19 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putBoolean("Pumpkin", this.hasPumpkin());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
     }
 
     @Override
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.setPumpkin(input.getBooleanOr("Pumpkin", true));
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
     }
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.snowGolemTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
@@ -95,10 +143,11 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
                 this.hurtServer(serverLevel, this.damageSources().onFire().knownCause(org.bukkit.event.entity.EntityDamageEvent.DamageCause.MELTING), 1.0F); // CraftBukkit
             }
 
-            if (!serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+            if (!serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.snowGolemMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 return;
             }
 
+            if (getRider() != null && this.isControllable() && !level().purpurConfig.snowGolemLeaveTrailWhenRidden) return; // Purpur - don't leave snow trail when being ridden
             BlockState blockState = Blocks.SNOW.defaultBlockState();
 
             for (int i = 0; i < 4; i++) {
@@ -141,7 +190,7 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
                 org.bukkit.event.player.PlayerShearEntityEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.handlePlayerShearEntityEvent(player, this, itemInHand, hand, drops);
                 if (event != null) {
                     if (event.isCancelled()) {
-                        return InteractionResult.PASS;
+                        return tryRide(player, hand); // Purpur - Ridables
                     }
                     drops = org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getDrops());
                     // Paper end - custom shear drops
@@ -153,8 +202,16 @@ public class SnowGolem extends AbstractGolem implements Shearable, RangedAttackM
             }
 
             return InteractionResult.SUCCESS;
+        // Purpur start - Snowman drop and put back pumpkin
+        } else if (level().purpurConfig.snowGolemPutPumpkinBack && !hasPumpkin() && itemInHand.getItem() == Blocks.CARVED_PUMPKIN.asItem()) {
+            setPumpkin(true);
+            if (!player.getAbilities().instabuild) {
+                itemInHand.shrink(1);
+            }
+            return InteractionResult.SUCCESS;
+        // Purpur end - Snowman drop and put back pumpkin
         } else {
-            return InteractionResult.PASS;
+            return tryRide(player, hand); // Purpur - Ridables
         }
     }
 
diff --git a/net/minecraft/world/entity/animal/Squid.java b/net/minecraft/world/entity/animal/Squid.java
index 58e1bc90cbc32669fa6c66d214119f0c459ff38c..8371f3892e50150db018f0b265986ffab37f21e7 100644
--- a/net/minecraft/world/entity/animal/Squid.java
+++ b/net/minecraft/world/entity/animal/Squid.java
@@ -46,13 +46,77 @@ public class Squid extends AgeableWaterCreature {
 
     public Squid(EntityType<? extends Squid> entityType, Level level) {
         super(entityType, level);
-        //this.random.setSeed(this.getId()); // Paper - Share random for entities to make them more random
+        if (!level.purpurConfig.entitySharedRandom) this.random.setSeed(this.getId()); // Paper - Share random for entities to make them more random // Purpur - Add toggle for RNG manipulation
         this.tentacleSpeed = 1.0F / (this.random.nextFloat() + 1.0F) * 0.2F;
     }
 
+    // Purpur start - Stop squids floating on top of water
+    @Override
+    public net.minecraft.world.phys.AABB getAxisForFluidCheck() {
+        // Stops squids from floating just over the water
+        return super.getAxisForFluidCheck().offsetY(level().purpurConfig.squidOffsetWaterCheck);
+    }
+    // Purpur end - Stop squids floating on top of water
+
+    // Purpur start - Flying squids! Oh my!
+    public boolean canFly() {
+        return this.level().purpurConfig.squidsCanFly;
+    }
+
+    @Override
+    public boolean isInWater() {
+        return this.wasTouchingWater || canFly();
+    }
+    // Purpur end - Flying squids! Oh my!
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.squidRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.squidControllable;
+    }
+
+    protected static void rotateVectorAroundY(org.bukkit.util.Vector vector, double degrees) {
+        double rad = Math.toRadians(degrees);
+        double cos = Math.cos(rad);
+        double sine = Math.sin(rad);
+        double x = vector.getX();
+        double z = vector.getZ();
+        vector.setX(cos * x - sine * z);
+        vector.setZ(sine * x + cos * z);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.squidMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.squidScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.squidTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.squidAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new Squid.SquidRandomMovementGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Squid.SquidFleeGoal());
     }
 
@@ -127,6 +191,7 @@ public class Squid extends AgeableWaterCreature {
         }
 
         if (this.isInWater()) {
+            if (canFly()) setNoGravity(!wasTouchingWater); // Purpur - Flying squids! Oh my!
             if (this.tentacleMovement < (float) Math.PI) {
                 float f = this.tentacleMovement / (float) Math.PI;
                 this.tentacleAngle = Mth.sin(f * f * (float) Math.PI) * (float) Math.PI * 0.25F;
@@ -305,10 +370,41 @@ public class Squid extends AgeableWaterCreature {
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            net.minecraft.world.entity.player.Player rider = squid.getRider();
+            if (rider != null && squid.isControllable()) {
+                if (rider.jumping) {
+                    squid.onSpacebar();
+                }
+                float forward = rider.getForwardMot();
+                float strafe = rider.getStrafeMot();
+                float speed = (float) squid.getAttributeValue(Attributes.MOVEMENT_SPEED) * 10F;
+                if (forward < 0.0F) {
+                    speed *= -0.5;
+                }
+                org.bukkit.util.Vector dir = rider.getBukkitEntity().getEyeLocation().getDirection().normalize().multiply(speed / 20.0F);
+                if (strafe != 0.0F) {
+                    if (forward == 0.0F) {
+                        dir.setY(0);
+                        rotateVectorAroundY(dir, strafe > 0.0F ? -90 : 90);
+                    } else if (forward < 0.0F) {
+                        rotateVectorAroundY(dir, strafe > 0.0F ? 45 : -45);
+                    } else {
+                        rotateVectorAroundY(dir, strafe > 0.0F ? -45 : 45);
+                    }
+                }
+                if (forward != 0.0F || strafe != 0.0F) {
+                    squid.movementVector = new Vec3((float) dir.getX(), (float) dir.getY(), (float) dir.getZ());
+                } else {
+                    squid.movementVector = Vec3.ZERO;
+                }
+                return;
+            }
+            // Purpur end - Ridables
             int noActionTime = this.squid.getNoActionTime();
             if (noActionTime > 100) {
                 this.squid.movementVector = Vec3.ZERO;
-            } else if (this.squid.getRandom().nextInt(reducedTickDelay(50)) == 0 || !this.squid.wasTouchingWater || !this.squid.hasMovementVector()) {
+            } else if (this.squid.getRandom().nextInt(reducedTickDelay(50)) == 0 || !this.squid.isInWater() || !this.squid.hasMovementVector()) { // Purpur - Flying squids! Oh my!
                 float f = this.squid.getRandom().nextFloat() * (float) (Math.PI * 2);
                 this.squid.movementVector = new Vec3(Mth.cos(f) * 0.2F, -0.1F + this.squid.getRandom().nextFloat() * 0.2F, Mth.sin(f) * 0.2F);
             }
diff --git a/net/minecraft/world/entity/animal/TropicalFish.java b/net/minecraft/world/entity/animal/TropicalFish.java
index 806fb2561d1eb0fba56dc40ba5c1f306c3105880..8d1fa86c6f4881c05f11fa80018b8de7f4920006 100644
--- a/net/minecraft/world/entity/animal/TropicalFish.java
+++ b/net/minecraft/world/entity/animal/TropicalFish.java
@@ -77,6 +77,39 @@ public class TropicalFish extends AbstractSchoolingFish {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.tropicalFishRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.tropicalFishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.tropicalFishMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.tropicalFishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.tropicalFishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static String getPredefinedName(int variantId) {
         return "entity.minecraft.tropical_fish.predefined." + variantId;
     }
diff --git a/net/minecraft/world/entity/animal/Turtle.java b/net/minecraft/world/entity/animal/Turtle.java
index 8738424b92726f45de2c166a063d46e1071e8b29..9bdc1f10e3b40672449ad166f130ecabdacc75d3 100644
--- a/net/minecraft/world/entity/animal/Turtle.java
+++ b/net/minecraft/world/entity/animal/Turtle.java
@@ -86,6 +86,52 @@ public class Turtle extends Animal {
         this.moveControl = new Turtle.TurtleMoveControl(this);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.turtleRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.turtleRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.turtleControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.turtleMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.turtleScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.turtleBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.turtleTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.turtleAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public void setHomePos(BlockPos homePos) {
         this.homePos = homePos;
     }
@@ -145,6 +191,7 @@ public class Turtle extends Animal {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new Turtle.TurtlePanicGoal(this, 1.2));
         this.goalSelector.addGoal(1, new Turtle.TurtleBreedGoal(this, 1.0));
         this.goalSelector.addGoal(1, new Turtle.TurtleLayEggGoal(this, 1.0));
@@ -325,8 +372,10 @@ public class Turtle extends Animal {
             }
 
             this.turtle.setHasEgg(true);
-            this.animal.setAge(6000);
-            this.partner.setAge(6000);
+            // Purpur start - Make entity breeding times configurable
+            this.animal.setAge(this.animal.getPurpurBreedTime());
+            this.partner.setAge(this.partner.getPurpurBreedTime());
+            // Purpur end - Make entity breeding times configurable
             this.animal.resetLove();
             this.partner.resetLove();
             RandomSource random = this.animal.getRandom();
@@ -493,12 +542,14 @@ public class Turtle extends Animal {
         }
     }
 
-    static class TurtleMoveControl extends MoveControl {
+    static class TurtleMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Turtle turtle;
+        private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterController; // Purpur - Ridables
 
         TurtleMoveControl(Turtle mob) {
             super(mob);
             this.turtle = mob;
+            waterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(turtle, 0.25D); // Purpur - Ridables
         }
 
         private void updateSpeed() {
@@ -517,7 +568,7 @@ public class Turtle extends Animal {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             this.updateSpeed();
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.turtle.getNavigation().isDone()) {
                 double d = this.wantedX - this.turtle.getX();
@@ -531,7 +582,7 @@ public class Turtle extends Animal {
                     float f = (float)(Mth.atan2(d2, d) * 180.0F / (float)Math.PI) - 90.0F;
                     this.turtle.setYRot(this.rotlerp(this.turtle.getYRot(), f, 90.0F));
                     this.turtle.yBodyRot = this.turtle.getYRot();
-                    float f1 = (float)(this.speedModifier * this.turtle.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                    float f1 = (float)(this.getSpeedModifier() * this.turtle.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                     this.turtle.setSpeed(Mth.lerp(0.125F, this.turtle.getSpeed(), f1));
                     this.turtle.setDeltaMovement(this.turtle.getDeltaMovement().add(0.0, this.turtle.getSpeed() * d1 * 0.1, 0.0));
                 }
diff --git a/net/minecraft/world/entity/animal/WaterAnimal.java b/net/minecraft/world/entity/animal/WaterAnimal.java
index 2b5e091b6ebe17e30d8d0e73999e19eed49e9a9f..6ff9ca735eba1c3376f3bc4916d5ab76af782de1 100644
--- a/net/minecraft/world/entity/animal/WaterAnimal.java
+++ b/net/minecraft/world/entity/animal/WaterAnimal.java
@@ -76,8 +76,7 @@ public abstract class WaterAnimal extends PathfinderMob {
         seaLevel = level.getMinecraftWorld().paperConfig().entities.spawning.wateranimalSpawnHeight.maximum.or(seaLevel);
         i = level.getMinecraftWorld().paperConfig().entities.spawning.wateranimalSpawnHeight.minimum.or(i);
         // Paper end - Make water animal spawn height configurable
-        return pos.getY() >= i
-            && pos.getY() <= seaLevel
+        return ((spawnReason == EntitySpawnReason.SPAWNER && level.getMinecraftWorld().purpurConfig.spawnerFixMC238526) || (pos.getY() >= i && pos.getY() <= seaLevel)) // Purpur - MC-238526 - Fix spawner not spawning water animals correctly
             && level.getFluidState(pos.below()).is(FluidTags.WATER)
             && level.getBlockState(pos.above()).is(Blocks.WATER);
     }
diff --git a/net/minecraft/world/entity/animal/allay/Allay.java b/net/minecraft/world/entity/animal/allay/Allay.java
index b7b964bd4e2d611a3e48ece072d5787193077a92..cf6ff7b7b4a007d7ff4b3c5a25d4f5a36422c683 100644
--- a/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/net/minecraft/world/entity/animal/allay/Allay.java
@@ -114,10 +114,23 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     private float spinningAnimationTicks;
     private float spinningAnimationTicks0;
     public boolean forceDancing = false; // CraftBukkit
+    private org.purpurmc.purpur.controller.FlyingMoveControllerWASD purpurController; // Purpur - Ridables
 
     public Allay(EntityType<? extends Allay> entityType, Level level) {
         super(entityType, level);
-        this.moveControl = new FlyingMoveControl(this, 20, true);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this, 0.1F, 0.5F);
+        this.moveControl = new FlyingMoveControl(this, 20, true) {
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    purpurController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.setCanPickUpLoot(this.canPickUpLoot());
         this.vibrationUser = new Allay.VibrationUser();
         this.vibrationData = new VibrationSystem.Data();
@@ -133,6 +146,36 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     }
     // CraftBukkit end
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.allayRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.allayRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.allayControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.allayMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.allayScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected Brain.Provider<Allay> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -228,6 +271,7 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("allayBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("allayActivityUpdate");
diff --git a/net/minecraft/world/entity/animal/armadillo/Armadillo.java b/net/minecraft/world/entity/animal/armadillo/Armadillo.java
index c1798db2972c8f2a343cf6e16fd9354ff212d906..0da5c51c4830cf1826261f4d8877303b34c6cb87 100644
--- a/net/minecraft/world/entity/animal/armadillo/Armadillo.java
+++ b/net/minecraft/world/entity/animal/armadillo/Armadillo.java
@@ -82,6 +82,38 @@ public class Armadillo extends Animal {
         return Animal.createAnimalAttributes().add(Attributes.MAX_HEALTH, 12.0).add(Attributes.MOVEMENT_SPEED, 0.14);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.armadilloRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.armadilloRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.armadilloControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.armadilloMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.armadilloScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.armadilloBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/animal/axolotl/Axolotl.java b/net/minecraft/world/entity/animal/axolotl/Axolotl.java
index b0467750dab4c6f411fd2f318009d25f83d94bc0..05070562ee7ea23d4e2fa602466f097827ffa35b 100644
--- a/net/minecraft/world/entity/animal/axolotl/Axolotl.java
+++ b/net/minecraft/world/entity/animal/axolotl/Axolotl.java
@@ -122,6 +122,52 @@ public class Axolotl extends Animal implements Bucketable {
         this.lookControl = new Axolotl.AxolotlLookControl(this, 20);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.axolotlRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.axolotlControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.axolotlMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.axolotlScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.axolotlBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.axolotlTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.axolotlAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
         return 0.0F;
@@ -331,6 +377,7 @@ public class Axolotl extends Animal implements Bucketable {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("axolotlBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("axolotlActivityUpdate");
@@ -580,23 +627,31 @@ public class Axolotl extends Animal implements Bucketable {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (!Axolotl.this.isPlayingDead()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
 
     static class AxolotlMoveControl extends SmoothSwimmingMoveControl {
         private final Axolotl axolotl;
+        private final org.purpurmc.purpur.controller.WaterMoveControllerWASD waterController; // Purpur - Ridables
 
         public AxolotlMoveControl(Axolotl axolotl) {
             super(axolotl, 85, 10, 0.1F, 0.5F, false);
             this.axolotl = axolotl;
+            waterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(axolotl, 0.5D); // Purpur - Ridables
         }
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            if (axolotl.getRider() != null && axolotl.isControllable()) {
+                waterController.purpurTick(axolotl.getRider());
+                return;
+            }
+            // Purpur end - Ridables
             if (!this.axolotl.isPlayingDead()) {
                 super.tick();
             }
diff --git a/net/minecraft/world/entity/animal/camel/Camel.java b/net/minecraft/world/entity/animal/camel/Camel.java
index 757b63ee059c95e673a098706b4ee7ab4fc21f70..0c698241b10f84afb17ae10d3661a90bc62ec243 100644
--- a/net/minecraft/world/entity/animal/camel/Camel.java
+++ b/net/minecraft/world/entity/animal/camel/Camel.java
@@ -91,6 +91,20 @@ public class Camel extends AbstractHorse {
         groundPathNavigation.setCanWalkOverFences(true);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.camelRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.camelBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
@@ -329,6 +343,23 @@ public class Camel extends AbstractHorse {
         return this.dashCooldown;
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.camelMaxHealthMin, this.level().purpurConfig.camelMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.camelJumpStrengthMin, this.level().purpurConfig.camelJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.camelMovementSpeedMin, this.level().purpurConfig.camelMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.CAMEL_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/frog/Frog.java b/net/minecraft/world/entity/animal/frog/Frog.java
index 66f503e045ccb0985ec718b39be07eea538fad8d..1d5079602e7ae1042e2bb92209dded4007f703da 100644
--- a/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/net/minecraft/world/entity/animal/frog/Frog.java
@@ -106,6 +106,8 @@ public class Frog extends Animal {
     public final AnimationState croakAnimationState = new AnimationState();
     public final AnimationState tongueAnimationState = new AnimationState();
     public final AnimationState swimIdleAnimationState = new AnimationState();
+    private org.purpurmc.purpur.controller.MoveControllerWASD purpurLandController; // Purpur - Ridables
+    private org.purpurmc.purpur.controller.WaterMoveControllerWASD purpurWaterController; // Purpur - Ridables
 
     public Frog(EntityType<? extends Animal> entityType, Level level) {
         super(entityType, level);
@@ -113,7 +115,62 @@ public class Frog extends Animal {
         this.setPathfindingMalus(PathType.WATER, 4.0F);
         this.setPathfindingMalus(PathType.TRAPDOOR, -1.0F);
         this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        this.purpurLandController = new org.purpurmc.purpur.controller.MoveControllerWASD(this, 0.2F);
+        this.purpurWaterController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(this, 0.5F);
+        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true) {
+            @Override
+            public void tick() {
+                net.minecraft.world.entity.player.Player rider = mob.getRider();
+                if (rider != null && mob.isControllable()) {
+                    if (mob.isInWater()) {
+                        purpurWaterController.purpurTick(rider);
+                        mob.setDeltaMovement(mob.getDeltaMovement().add(0.0D, -0.005D, 0.0D));
+                    } else {
+                        purpurLandController.purpurTick(rider);
+                    }
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.frogRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.frogRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.frogControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+
+    @Override
+    public float getJumpPower() {
+        return (getRider() != null && isControllable()) ? level().purpurConfig.frogRidableJumpHeight * this.getBlockJumpFactor() : super.getJumpPower();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.frogBreedingTicks;
     }
+    // Purpur end - Make entity breeding times configurable
 
     @Override
     protected Brain.Provider<Frog> brainProvider() {
@@ -206,6 +263,7 @@ public class Frog extends Animal {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("frogBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("frogActivityUpdate");
@@ -390,7 +448,7 @@ public class Frog extends Animal {
         return level.getBlockState(pos.below()).is(BlockTags.FROGS_SPAWNABLE_ON) && isBrightEnoughToSpawn(level, pos);
     }
 
-    class FrogLookControl extends LookControl {
+    class FrogLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         FrogLookControl(final Mob mob) {
             super(mob);
         }
diff --git a/net/minecraft/world/entity/animal/frog/Tadpole.java b/net/minecraft/world/entity/animal/frog/Tadpole.java
index 17f58246849ed407821a987b200cc765eb7943f9..6932e85b3db0205f9a69d9ef965a934f100e6bcf 100644
--- a/net/minecraft/world/entity/animal/frog/Tadpole.java
+++ b/net/minecraft/world/entity/animal/frog/Tadpole.java
@@ -66,13 +66,50 @@ public class Tadpole extends AbstractFish {
         MemoryModuleType.IS_PANICKING
     );
     public boolean ageLocked; // Paper
+    private org.purpurmc.purpur.controller.WaterMoveControllerWASD purpurController; // Purpur - Ridables
 
     public Tadpole(EntityType<? extends AbstractFish> entityType, Level level) {
         super(entityType, level);
-        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.WaterMoveControllerWASD(this, 0.5F);
+        this.moveControl = new SmoothSwimmingMoveControl(this, 85, 10, 0.02F, 0.1F, true) {
+            @Override
+            public void tick() {
+                Player rider = mob.getRider();
+                if (rider != null && mob.isControllable()) {
+                    purpurController.purpurTick(rider);
+                    mob.setDeltaMovement(mob.getDeltaMovement().add(0.0D, 0.002D, 0.0D));
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.lookControl = new SmoothSwimmingLookControl(this, 10);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.tadpoleRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.tadpoleRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.tadpoleControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         return new WaterBoundPathNavigation(this, level);
@@ -102,6 +139,7 @@ public class Tadpole extends AbstractFish {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("tadpoleBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("tadpoleActivityUpdate");
diff --git a/net/minecraft/world/entity/animal/goat/Goat.java b/net/minecraft/world/entity/animal/goat/Goat.java
index 75af1b92a0a60cffa3317d83bd599a3d4d26f93c..386591ff45c45146b75d44071f54c2789db15a21 100644
--- a/net/minecraft/world/entity/animal/goat/Goat.java
+++ b/net/minecraft/world/entity/animal/goat/Goat.java
@@ -115,6 +115,44 @@ public class Goat extends Animal {
             .orElseGet(() -> new ItemStack(Items.GOAT_HORN));
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.goatRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.goatRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.goatControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.goatBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.goatTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.goatAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected Brain.Provider<Goat> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -192,6 +230,7 @@ public class Goat extends Animal {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("goatBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         profilerFiller.push("goatActivityUpdate");
@@ -396,6 +435,7 @@ public class Goat extends Animal {
 
     // Paper start - Goat ram API
     public void ram(net.minecraft.world.entity.LivingEntity entity) {
+        if(!new org.purpurmc.purpur.event.entity.GoatRamEntityEvent((org.bukkit.entity.Goat) getBukkitEntity(), entity.getBukkitLivingEntity()).callEvent()) return; // Purpur - Added goat ram event
         Brain<Goat> brain = this.getBrain();
         brain.setMemory(MemoryModuleType.RAM_TARGET, entity.position());
         brain.eraseMemory(MemoryModuleType.RAM_COOLDOWN_TICKS);
diff --git a/net/minecraft/world/entity/animal/horse/AbstractHorse.java b/net/minecraft/world/entity/animal/horse/AbstractHorse.java
index 31ed5d7cfbda1a1f98ebfc89f5cbc65332cabdae..e78ef459d6eecb7f69882ed95cd9f9967f53989f 100644
--- a/net/minecraft/world/entity/animal/horse/AbstractHorse.java
+++ b/net/minecraft/world/entity/animal/horse/AbstractHorse.java
@@ -127,11 +127,61 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
 
     protected AbstractHorse(EntityType<? extends AbstractHorse> entityType, Level level) {
         super(entityType, level);
+        this.moveControl = new net.minecraft.world.entity.ai.control.MoveControl(this); // Purpur - use vanilla controller
+        this.lookControl = new net.minecraft.world.entity.ai.control.LookControl(this); // Purpur - use vanilla controller
         this.createInventory();
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return false; // vanilla handles
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.generateMaxHealth(random));
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.generateSpeed(random));
+        this.getAttribute(Attributes.JUMP_STRENGTH).setBaseValue(this.generateJumpStrength(random));
+    }
+
+    protected double generateMaxHealth(double min, double max) {
+        if (min == max) return min;
+        int diff = Mth.floor(max - min);
+        double base = max - diff;
+        int first = Mth.floor((double) diff / 2);
+        int rest = diff - first;
+        return base + random.nextInt(first + 1) + random.nextInt(rest + 1);
+    }
+
+    protected double generateJumpStrength(double min, double max) {
+        if (min == max) return min;
+        return min + (max - min) * this.random.nextDouble();
+    }
+
+    protected double generateSpeed(double min, double max) {
+        if (min == max) return min;
+        return min + (max - min) * this.random.nextDouble();
+    }
+
+    protected float generateMaxHealth(RandomSource random) {
+        return 15.0F + (float) random.nextInt(8) + (float) random.nextInt(9);
+    }
+
+    protected double generateJumpStrength(RandomSource random) {
+        return 0.4F + random.nextDouble() * 0.2 + random.nextDouble() * 0.2 + random.nextDouble() * 0.2;
+    }
+
+    protected double generateSpeed(RandomSource random) {
+        return (0.45F + random.nextDouble() * 0.3 + random.nextDouble() * 0.3 + random.nextDouble() * 0.3) * 0.25;
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HorseHasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.2));
         this.goalSelector.addGoal(1, new RunAroundLikeCrazyGoal(this, 1.2));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0, AbstractHorse.class));
@@ -142,6 +192,7 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
         if (this.canPerformRearing()) {
             this.goalSelector.addGoal(9, new RandomStandGoal(this));
         }
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HorseHasRider(this)); // Purpur - Ridables
 
         this.addBehaviourGoals();
     }
@@ -1040,7 +1091,7 @@ public abstract class AbstractHorse extends Animal implements HasCustomInventory
             spawnGroupData = new AgeableMob.AgeableMobGroupData(0.2F);
         }
 
-        this.randomizeAttributes(level.getRandom());
+        //this.randomizeAttributes(level.getRandom()); // Purpur - replaced by initAttributes()
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
diff --git a/net/minecraft/world/entity/animal/horse/Donkey.java b/net/minecraft/world/entity/animal/horse/Donkey.java
index 5dff98b5b2e4bba5f874d6a99d034a3905775c9b..0783d41a6c4622b03d9d368c1af949af1292dcb7 100644
--- a/net/minecraft/world/entity/animal/horse/Donkey.java
+++ b/net/minecraft/world/entity/animal/horse/Donkey.java
@@ -16,6 +16,51 @@ public class Donkey extends AbstractChestedHorse {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.donkeyRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.donkeyMaxHealthMin, this.level().purpurConfig.donkeyMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.donkeyJumpStrengthMin, this.level().purpurConfig.donkeyJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.donkeyMovementSpeedMin, this.level().purpurConfig.donkeyMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.donkeyBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.donkeyTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.donkeyAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.DONKEY_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/horse/Horse.java b/net/minecraft/world/entity/animal/horse/Horse.java
index 2a1d720557c0bd4895a32723e34512c0a557e4f2..f1080a40f759b30b921b88b4f6edd35f4795406f 100644
--- a/net/minecraft/world/entity/animal/horse/Horse.java
+++ b/net/minecraft/world/entity/animal/horse/Horse.java
@@ -47,6 +47,51 @@ public class Horse extends AbstractHorse {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.horseRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.horseMaxHealthMin, this.level().purpurConfig.horseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.horseJumpStrengthMin, this.level().purpurConfig.horseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.horseMovementSpeedMin, this.level().purpurConfig.horseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.horseBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.horseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.horseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void randomizeAttributes(RandomSource random) {
         this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(generateMaxHealth(random::nextInt));
diff --git a/net/minecraft/world/entity/animal/horse/Llama.java b/net/minecraft/world/entity/animal/horse/Llama.java
index 1e2b629641e5fa1040307461dbbf03ad2d75ba00..455a84ffa16152137409777e1fddbab5a21bd57d 100644
--- a/net/minecraft/world/entity/animal/horse/Llama.java
+++ b/net/minecraft/world/entity/animal/horse/Llama.java
@@ -78,12 +78,102 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
     private Llama caravanHead;
     @Nullable
     public Llama caravanTail; // Paper
+    public boolean shouldJoinCaravan = true; // Purpur - Llama API
 
     public Llama(EntityType<? extends Llama> entityType, Level level) {
         super(entityType, level);
         this.getNavigation().setRequiredPathLength(40.0F);
         this.maxDomestication = 30; // Paper - Missing entity API; configure max temper instead of a hardcoded value
+        // Purpur start - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this) {
+            @Override
+            public void tick() {
+                if (entity.getRider() != null && entity.isControllable() && isSaddled()) {
+                    purpurTick(entity.getRider());
+                } else {
+                    vanillaTick();
+                }
+            }
+        };
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void tick() {
+                if (entity.getRider() != null && entity.isControllable() && isSaddled()) {
+                    purpurTick(entity.getRider());
+                } else {
+                    vanillaTick();
+                }
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.llamaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.llamaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.llamaControllable;
+    }
+
+    @Override
+    public boolean isSaddled() {
+        return super.isWearingBodyArmor() || this.isTamed();
+    }
+
+    @Nullable
+    @Override
+    public LivingEntity getControllingPassenger() {
+        Entity firstPassenger = this.getFirstPassenger();
+        return !this.isNoAi() && firstPassenger instanceof net.minecraft.world.entity.Mob mob && firstPassenger.canControlVehicle() ? mob : null;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.llamaMaxHealthMin, this.level().purpurConfig.llamaMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.llamaJumpStrengthMin, this.level().purpurConfig.llamaJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.llamaMovementSpeedMin, this.level().purpurConfig.llamaMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.llamaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.llamaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.llamaAlwaysDropExp;
     }
+    // Purpur end - Mobs always drop experience
 
     public boolean isTraderLlama() {
         return false;
@@ -112,6 +202,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         super.addAdditionalSaveData(output);
         output.store("Variant", Llama.Variant.LEGACY_CODEC, this.getVariant());
         output.putInt("Strength", this.getStrength());
+        output.putBoolean("Purpur.ShouldJoinCaravan", shouldJoinCaravan); // Purpur - Llama API
     }
 
     @Override
@@ -119,11 +210,13 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         this.setStrength(input.getIntOr("Strength", 0));
         super.readAdditionalSaveData(input);
         this.setVariant(input.read("Variant", Llama.Variant.LEGACY_CODEC).orElse(Llama.Variant.DEFAULT));
+        this.shouldJoinCaravan = input.getBooleanOr("Purpur.ShouldJoinCaravan", true); // Purpur - Llama API
     }
 
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.LlamaHasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new RunAroundLikeCrazyGoal(this, 1.2));
         this.goalSelector.addGoal(2, new LlamaFollowCaravanGoal(this, 2.1F));
         this.goalSelector.addGoal(3, new RangedAttackGoal(this, 1.25, 40, 20.0F));
@@ -134,6 +227,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 0.7));
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(9, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.LlamaHasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Llama.LlamaHurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new Llama.LlamaAttackWolfGoal(this));
     }
@@ -400,6 +494,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
 
     public void leaveCaravan() {
         if (this.caravanHead != null) {
+            new org.purpurmc.purpur.event.entity.LlamaLeaveCaravanEvent((org.bukkit.entity.Llama) getBukkitEntity()).callEvent(); // Purpur - Llama API
             this.caravanHead.caravanTail = null;
         }
 
@@ -407,6 +502,7 @@ public class Llama extends AbstractChestedHorse implements RangedAttackMob {
     }
 
     public void joinCaravan(Llama caravanHead) {
+        if (!this.level().purpurConfig.llamaJoinCaravans || !shouldJoinCaravan || !new org.purpurmc.purpur.event.entity.LlamaJoinCaravanEvent((org.bukkit.entity.Llama) getBukkitEntity(), (org.bukkit.entity.Llama) caravanHead.getBukkitEntity()).callEvent()) return; // Purpur - Llama API // Purpur - Config to disable Llama caravans
         this.caravanHead = caravanHead;
         this.caravanHead.caravanTail = this;
     }
diff --git a/net/minecraft/world/entity/animal/horse/Mule.java b/net/minecraft/world/entity/animal/horse/Mule.java
index 39725b7a6bac9390406733cd51d7341d0cb363d1..6e0b1c83a6a03d12296e0e3b2c805b64d8378abd 100644
--- a/net/minecraft/world/entity/animal/horse/Mule.java
+++ b/net/minecraft/world/entity/animal/horse/Mule.java
@@ -15,6 +15,51 @@ public class Mule extends AbstractChestedHorse {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.muleRidableInWater;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.muleMaxHealthMin, this.level().purpurConfig.muleMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.muleJumpStrengthMin, this.level().purpurConfig.muleJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.muleMovementSpeedMin, this.level().purpurConfig.muleMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.muleBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.muleTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.muleAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getAmbientSound() {
         return SoundEvents.MULE_AMBIENT;
diff --git a/net/minecraft/world/entity/animal/horse/SkeletonHorse.java b/net/minecraft/world/entity/animal/horse/SkeletonHorse.java
index 580134c5a075c7efdc7c2f86a179df2fa336eba9..f6ab6ecc10486694d77905239a82bda4dec94936 100644
--- a/net/minecraft/world/entity/animal/horse/SkeletonHorse.java
+++ b/net/minecraft/world/entity/animal/horse/SkeletonHorse.java
@@ -42,6 +42,51 @@ public class SkeletonHorse extends AbstractHorse {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isTamed() {
+        return super.isTamed() || this.level().purpurConfig.skeletonHorseRidable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.skeletonHorseMaxHealthMin, this.level().purpurConfig.skeletonHorseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.skeletonHorseJumpStrengthMin, this.level().purpurConfig.skeletonHorseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.skeletonHorseMovementSpeedMin, this.level().purpurConfig.skeletonHorseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.skeletonHorseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.skeletonHorseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return createBaseHorseAttributes().add(Attributes.MAX_HEALTH, 15.0).add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
@@ -61,6 +106,7 @@ public class SkeletonHorse extends AbstractHorse {
 
     @Override
     protected void addBehaviourGoals() {
+        if (level().purpurConfig.skeletonHorseCanSwim) goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this)); // Purpur - Ridables
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/horse/TraderLlama.java b/net/minecraft/world/entity/animal/horse/TraderLlama.java
index 2cd1b988f44caf271a7d2dfccf118be53b77caba..a8540e491161d82a6b72262e4414f8bb16705d47 100644
--- a/net/minecraft/world/entity/animal/horse/TraderLlama.java
+++ b/net/minecraft/world/entity/animal/horse/TraderLlama.java
@@ -31,6 +31,66 @@ public class TraderLlama extends Llama {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.traderLlamaRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.traderLlamaRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.traderLlamaControllable;
+    }
+
+    @Override
+    public boolean isSaddled() {
+        return super.isSaddled() || isTamed();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(net.minecraft.util.RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.traderLlamaMaxHealthMin, this.level().purpurConfig.traderLlamaMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(net.minecraft.util.RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.traderLlamaJumpStrengthMin, this.level().purpurConfig.traderLlamaJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(net.minecraft.util.RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.traderLlamaMovementSpeedMin, this.level().purpurConfig.traderLlamaMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.traderLlamaBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.traderLlamaTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.traderLlamaAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isTraderLlama() {
         return true;
diff --git a/net/minecraft/world/entity/animal/horse/ZombieHorse.java b/net/minecraft/world/entity/animal/horse/ZombieHorse.java
index ee327bdec37df5197c35aef60cf456bb81f8d048..e59172ea2fafbab673dc3e9bdc25055f3d8f85ee 100644
--- a/net/minecraft/world/entity/animal/horse/ZombieHorse.java
+++ b/net/minecraft/world/entity/animal/horse/ZombieHorse.java
@@ -33,6 +33,56 @@ public class ZombieHorse extends AbstractHorse {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieHorseRidableInWater;
+    }
+
+    @Override
+    public boolean isTamed() {
+        return super.isTamed() || this.level().purpurConfig.zombieHorseRidable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public float generateMaxHealth(RandomSource random) {
+        return (float) generateMaxHealth(this.level().purpurConfig.zombieHorseMaxHealthMin, this.level().purpurConfig.zombieHorseMaxHealthMax);
+    }
+
+    @Override
+    public double generateJumpStrength(RandomSource random) {
+        return generateJumpStrength(this.level().purpurConfig.zombieHorseJumpStrengthMin, this.level().purpurConfig.zombieHorseJumpStrengthMax);
+    }
+
+    @Override
+    public double generateSpeed(RandomSource random) {
+        return generateSpeed(this.level().purpurConfig.zombieHorseMovementSpeedMin, this.level().purpurConfig.zombieHorseMovementSpeedMax);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return 6000;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieHorseTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieHorseAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return createBaseHorseAttributes().add(Attributes.MAX_HEALTH, 15.0).add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
@@ -78,6 +128,7 @@ public class ZombieHorse extends AbstractHorse {
 
     @Override
     protected void addBehaviourGoals() {
+        if (level().purpurConfig.zombieHorseCanSwim) goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this)); // Purpur - Ridables
     }
 
     @Override
diff --git a/net/minecraft/world/entity/animal/sheep/Sheep.java b/net/minecraft/world/entity/animal/sheep/Sheep.java
index 4e4887cd2c6d6d22966395d68ed59da090f609a3..500c87f5f7b2eda637103125d6e541f7c9fb385f 100644
--- a/net/minecraft/world/entity/animal/sheep/Sheep.java
+++ b/net/minecraft/world/entity/animal/sheep/Sheep.java
@@ -62,10 +62,57 @@ public class Sheep extends Animal implements Shearable {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.sheepRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.sheepRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.sheepControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.sheepMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.sheepScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.sheepBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.sheepTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.sheepAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.eatBlockGoal = new EatBlockGoal(this);
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.25));
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.goalSelector.addGoal(3, new TemptGoal(this, 1.1, stack -> stack.is(ItemTags.SHEEP_FOOD), false));
diff --git a/net/minecraft/world/entity/animal/sniffer/Sniffer.java b/net/minecraft/world/entity/animal/sniffer/Sniffer.java
index 6a9f31c1f39cc14ad7b5ae3af85908bc7a4caae4..9ad310cbc5fa41c949a37c1a5db6d6cd024f1483 100644
--- a/net/minecraft/world/entity/animal/sniffer/Sniffer.java
+++ b/net/minecraft/world/entity/animal/sniffer/Sniffer.java
@@ -89,6 +89,38 @@ public class Sniffer extends Animal {
         this.setPathfindingMalus(PathType.DAMAGE_CAUTIOUS, -1.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.snifferRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.snifferRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.snifferControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.snifferMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.snifferScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.snifferBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/animal/wolf/Wolf.java b/net/minecraft/world/entity/animal/wolf/Wolf.java
index dca01e7e6af74bc6e26d4968ccdf0c34f8707b94..7e7cb9db1c84bdb173b444bec90663a93fb3b549 100644
--- a/net/minecraft/world/entity/animal/wolf/Wolf.java
+++ b/net/minecraft/world/entity/animal/wolf/Wolf.java
@@ -99,6 +99,37 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         EntityType<?> type = entity.getType();
         return type == EntityType.SHEEP || type == EntityType.RABBIT || type == EntityType.FOX;
     };
+    // Purpur start - Configurable chance for wolves to spawn rabid
+    private boolean isRabid = false;
+    private static final TargetingConditions.Selector RABID_PREDICATE = (entity, ignored) -> entity instanceof net.minecraft.server.level.ServerPlayer || entity instanceof net.minecraft.world.entity.Mob;
+    private final net.minecraft.world.entity.ai.goal.Goal PATHFINDER_VANILLA = new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR);
+    private final net.minecraft.world.entity.ai.goal.Goal PATHFINDER_RABID = new NonTameRandomTargetGoal<>(this, LivingEntity.class, false, RABID_PREDICATE);
+    private static final class AvoidRabidWolfGoal extends AvoidEntityGoal<Wolf> {
+        private final Wolf wolf;
+
+        public AvoidRabidWolfGoal(Wolf wolf, float distance, double minSpeed, double maxSpeed) {
+            super(wolf, Wolf.class, distance, minSpeed, maxSpeed);
+            this.wolf = wolf;
+        }
+
+        @Override
+        public boolean canUse() {
+            return super.canUse() && !this.wolf.isRabid() && this.toAvoid != null && this.toAvoid.isRabid(); // wolves which are not rabid run away from rabid wolves
+        }
+
+        @Override
+        public void start() {
+            this.wolf.setTarget(null);
+            super.start();
+        }
+
+        @Override
+        public void tick() {
+            this.wolf.setTarget(null);
+            super.tick();
+        }
+    }
+    // Purpur end - Configurable chance for wolves to spawn rabid
     private static final float START_HEALTH = 8.0F;
     private static final float TAME_HEALTH = 40.0F;
     private static final float ARMOR_REPAIR_UNIT = 0.125F;
@@ -121,12 +152,99 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         this.setPathfindingMalus(PathType.DANGER_POWDER_SNOW, -1.0F);
     }
 
+    // Purpur start - Configurable chance for wolves to spawn rabid
+    public boolean isRabid() {
+        return this.isRabid;
+    }
+
+    public void setRabid(boolean isRabid) {
+        this.isRabid = isRabid;
+        updatePathfinders(true);
+    }
+
+    public void updatePathfinders(boolean modifyEffects) {
+        this.targetSelector.removeGoal(PATHFINDER_VANILLA);
+        this.targetSelector.removeGoal(PATHFINDER_RABID);
+        if (this.isRabid) {
+            this.setOwnerReference(null);
+            setTame(false, true);
+            this.targetSelector.addGoal(5, PATHFINDER_RABID);
+            if (modifyEffects) this.addEffect(new net.minecraft.world.effect.MobEffectInstance(net.minecraft.world.effect.MobEffects.NAUSEA, 1200));
+        } else {
+            this.targetSelector.addGoal(5, PATHFINDER_VANILLA);
+            this.stopBeingAngry();
+            if (modifyEffects) this.removeEffect(net.minecraft.world.effect.MobEffects.NAUSEA);
+        }
+    }
+    // Purpur end - Configurable chance for wolves to spawn rabid
+
+    // Purpur start - Configurable default collar color
+    @Override
+    public void tame(Player player) {
+        setCollarColor(level().purpurConfig.wolfDefaultCollarColor);
+        super.tame(player);
+    }
+    // Purpur end - Configurable default collar color
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wolfRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wolfRidableInWater;
+    }
+
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setInSittingPose(false);
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wolfControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.wolfMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.wolfScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.wolfBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.wolfTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.wolfAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new TamableAnimal.TamableAnimalPanicGoal(1.5, DamageTypeTags.PANIC_ENVIRONMENTAL_CAUSES));
         this.goalSelector.addGoal(2, new SitWhenOrderedToGoal(this));
         this.goalSelector.addGoal(3, new Wolf.WolfAvoidEntityGoal<>(this, Llama.class, 24.0F, 1.5, 1.5));
+        this.goalSelector.addGoal(3, new AvoidRabidWolfGoal(this, 24.0F, 1.5D, 1.5D)); // Purpur - Configurable chance for wolves to spawn rabid
         this.goalSelector.addGoal(4, new LeapAtTargetGoal(this, 0.4F));
         this.goalSelector.addGoal(5, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(6, new FollowOwnerGoal(this, 1.0, 10.0F, 2.0F));
@@ -135,11 +253,12 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         this.goalSelector.addGoal(9, new BegGoal(this, 8.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(10, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new OwnerHurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new OwnerHurtTargetGoal(this));
         this.targetSelector.addGoal(3, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(4, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, this::isAngryAt));
-        this.targetSelector.addGoal(5, new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR));
+        //this.targetSelector.addGoal(5, new NonTameRandomTargetGoal<>(this, Animal.class, false, PREY_SELECTOR)); // Purpur - Configurable chance for wolves to spawn rabid - moved to updatePathfinders()
         this.targetSelector.addGoal(6, new NonTameRandomTargetGoal<>(this, Turtle.class, false, Turtle.BABY_ON_LAND_SELECTOR));
         this.targetSelector.addGoal(7, new NearestAttackableTargetGoal<>(this, AbstractSkeleton.class, false));
         this.targetSelector.addGoal(8, new ResetUniversalAngerTargetGoal<>(this, true));
@@ -230,6 +349,7 @@ public class Wolf extends TamableAnimal implements NeutralMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.store("CollarColor", DyeColor.LEGACY_ID_CODEC, this.getCollarColor());
+        output.putBoolean("Purpur.IsRabid", this.isRabid); // Purpur - Configurable chance for wolves to spawn rabid
         VariantUtils.writeVariant(output, this.getVariant());
         this.addPersistentAngerSaveData(output);
         this.getSoundVariant()
@@ -244,6 +364,10 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         super.readAdditionalSaveData(input);
         VariantUtils.readVariant(input, Registries.WOLF_VARIANT).ifPresent(this::setVariant);
         this.setCollarColor(input.read("CollarColor", DyeColor.LEGACY_ID_CODEC).orElse(DEFAULT_COLLAR_COLOR));
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        this.isRabid = input.getBooleanOr("Purpur.IsRabid", false);
+        this.updatePathfinders(false);
+        // Purpur end - Configurable chance for wolves to spawn rabid
         this.readPersistentAngerSaveData(this.level(), input);
         input.read("sound_variant", ResourceKey.codec(Registries.WOLF_SOUND_VARIANT))
             .flatMap(resourceKey -> this.registryAccess().lookupOrThrow(Registries.WOLF_SOUND_VARIANT).get((ResourceKey<WolfSoundVariant>)resourceKey))
@@ -268,6 +392,10 @@ public class Wolf extends TamableAnimal implements NeutralMob {
         }
 
         this.setSoundVariant(WolfSoundVariants.pickRandomSoundVariant(this.registryAccess(), level.getRandom()));
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        this.isRabid = level.getLevel().purpurConfig.wolfNaturalRabid > 0.0D && random.nextDouble() <= level.getLevel().purpurConfig.wolfNaturalRabid;
+        this.updatePathfinders(false);
+        // Purpur end - Configurable chance for wolves to spawn rabid
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
@@ -318,6 +446,11 @@ public class Wolf extends TamableAnimal implements NeutralMob {
     public void tick() {
         super.tick();
         if (this.isAlive()) {
+            // Purpur start - Configurable chance for wolves to spawn rabid
+            if (this.age % 300 == 0 && this.isRabid()) {
+                this.addEffect(new net.minecraft.world.effect.MobEffectInstance(net.minecraft.world.effect.MobEffects.NAUSEA, 400));
+            }
+            // Purpur end - Configurable chance for wolves to spawn rabid
             this.interestedAngleO = this.interestedAngle;
             if (this.isInterested()) {
                 this.interestedAngle = this.interestedAngle + (1.0F - this.interestedAngle) * 0.4F;
@@ -519,13 +652,27 @@ public class Wolf extends TamableAnimal implements NeutralMob {
             itemInHand.consume(1, player);
             this.tryToTame(player);
             return InteractionResult.SUCCESS_SERVER;
+        // Purpur start - Configurable chance for wolves to spawn rabid
+        } else if (this.level().purpurConfig.wolfMilkCuresRabies && itemInHand.getItem() == Items.MILK_BUCKET && this.isRabid()) {
+            if (!player.isCreative()) {
+                player.setItemInHand(hand, new ItemStack(Items.BUCKET));
+            }
+            this.setRabid(false);
+            for (int i = 0; i < 10; ++i) {
+                ((ServerLevel) level()).sendParticlesSource(((ServerLevel) level()).players(), null, ParticleTypes.HAPPY_VILLAGER,
+                        false, true,
+                        getX() + random.nextFloat(), getY() + (random.nextFloat() * 1.5), getZ() + random.nextFloat(), 1,
+                        random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+            }
+            return InteractionResult.SUCCESS_SERVER;
+        // Purpur end - Configurable chance for wolves to spawn rabid
         }
 
         return super.mobInteract(player, hand);
     }
 
     private void tryToTame(Player player) {
-        if (this.random.nextInt(3) == 0 && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit - added event call and isCancelled check.
+        if (((this.level().purpurConfig.alwaysTameInCreative && player.hasInfiniteMaterials()) || this.random.nextInt(3) == 0) && !org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTameEvent(this, player).isCancelled()) { // CraftBukkit - added event call and isCancelled check. // Purpur - Config to always tame in Creative
             this.tame(player);
             this.navigation.stop();
             this.setTarget(null);
diff --git a/net/minecraft/world/entity/boss/EnderDragonPart.java b/net/minecraft/world/entity/boss/EnderDragonPart.java
index c9443cbde85109b19e6c84274c562d83a229c763..ec82bd00f7be253beac1dfbe00a36d25daa11775 100644
--- a/net/minecraft/world/entity/boss/EnderDragonPart.java
+++ b/net/minecraft/world/entity/boss/EnderDragonPart.java
@@ -28,6 +28,13 @@ public class EnderDragonPart extends Entity {
         this.name = name;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public net.minecraft.world.InteractionResult interact(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        return parentMob.isAlive() ? parentMob.tryRide(player, hand) : net.minecraft.world.InteractionResult.PASS;
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
     }
diff --git a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
index 5a6e10db234d7e5e76420cea1a0ba0e746f1f496..abddb6939963340fc9ba0307986209f18d01e1d8 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EndCrystal.java
@@ -27,6 +27,12 @@ public class EndCrystal extends Entity {
     private static final boolean DEFAULT_SHOW_BOTTOM = true;
     public int time;
     public boolean generatedByDragonFight = false; // Paper - Fix invulnerable end crystals
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    private net.minecraft.world.entity.monster.Phantom targetPhantom;
+    private int phantomBeamTicks = 0;
+    private int phantomDamageCooldown = 0;
+    private int idleCooldown = 0;
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
 
     public EndCrystal(EntityType<? extends EndCrystal> entityType, Level level) {
         super(entityType, level);
@@ -39,6 +45,24 @@ public class EndCrystal extends Entity {
         this.setPos(x, y, z);
     }
 
+    // Purpur start - End crystal explosion options
+    public boolean shouldExplode() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplode : level().purpurConfig.baselessEndCrystalExplode;
+    }
+
+    public float getExplosionPower() {
+        return (float) (showsBottom() ? level().purpurConfig.basedEndCrystalExplosionPower : level().purpurConfig.baselessEndCrystalExplosionPower);
+    }
+
+    public boolean hasExplosionFire() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplosionFire : level().purpurConfig.baselessEndCrystalExplosionFire;
+    }
+
+    public Level.ExplosionInteraction getExplosionEffect() {
+        return showsBottom() ? level().purpurConfig.basedEndCrystalExplosionEffect : level().purpurConfig.baselessEndCrystalExplosionEffect;
+    }
+    // Purpur end - End crystal explosion options
+
     @Override
     protected Entity.MovementEmission getMovementEmission() {
         return Entity.MovementEmission.NONE;
@@ -75,6 +99,51 @@ public class EndCrystal extends Entity {
             }
         }
         // Paper end - Fix invulnerable end crystals
+        if (this.level().purpurConfig.endCrystalCramming > 0 && this.level().getEntitiesOfClass(EndCrystal.class, getBoundingBox()).size() > this.level().purpurConfig.endCrystalCramming) this.hurt(this.damageSources().cramming(), 6.0F); // Purpur - End Crystal Cramming
+
+        // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+        if (level().purpurConfig.phantomAttackedByCrystalRadius <= 0 || --idleCooldown > 0) {
+            return; // on cooldown
+        }
+
+        if (targetPhantom == null) {
+            for (net.minecraft.world.entity.monster.Phantom phantom : level().getEntitiesOfClass(net.minecraft.world.entity.monster.Phantom.class, getBoundingBox().inflate(level().purpurConfig.phantomAttackedByCrystalRadius))) {
+                if (phantom.hasLineOfSight(this)) {
+                    attackPhantom(phantom);
+                    break;
+                }
+            }
+        } else {
+            setBeamTarget(new BlockPos(targetPhantom).offset(0, -2, 0));
+            if (--phantomBeamTicks > 0 && targetPhantom.isAlive()) {
+                phantomDamageCooldown--;
+                if (targetPhantom.hasLineOfSight(this)) {
+                    if (phantomDamageCooldown <= 0) {
+                        phantomDamageCooldown = 20;
+                        targetPhantom.hurt(targetPhantom.damageSources().indirectMagic(this, this), level().purpurConfig.phantomAttackedByCrystalDamage);
+                    }
+                } else {
+                    forgetPhantom(); // no longer in sight
+                }
+            } else {
+                forgetPhantom(); // attacked long enough
+            }
+        }
+    }
+
+    private void attackPhantom(net.minecraft.world.entity.monster.Phantom phantom) {
+        phantomDamageCooldown = 0;
+        phantomBeamTicks = 60;
+        targetPhantom = phantom;
+    }
+
+    private void forgetPhantom() {
+        targetPhantom = null;
+        setBeamTarget(null);
+        phantomBeamTicks = 0;
+        phantomDamageCooldown = 0;
+        idleCooldown = 60;
+        // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
     }
 
     @Override
@@ -115,15 +184,17 @@ public class EndCrystal extends Entity {
                 }
                 // CraftBukkit end
                 if (!damageSource.is(DamageTypeTags.IS_EXPLOSION)) {
+                    if (shouldExplode()) {// Purpur - End crystal explosion options
                     DamageSource damageSource1 = damageSource.getEntity() != null ? this.damageSources().explosion(this, damageSource.getEntity()) : null;
                     // CraftBukkit start
-                    org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, 6.0F, false);
+                    org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, getExplosionPower(), hasExplosionFire()); // Purpur - End crystal explosion options
                     if (event.isCancelled()) {
                         return false;
                     }
 
                     this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.EXPLODE); // Paper - add Bukkit remove cause
-                    level.explode(this, damageSource1, null, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.BLOCK);
+                    level.explode(this, damageSource1, null, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), getExplosionEffect()); // Purpur - End crystal explosion options
+                    } else this.unsetRemoved(); // Purpur - End crystal explosion options
                 } else {
                     this.remove(Entity.RemovalReason.KILLED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DEATH); // Paper - add Bukkit remove cause
                     // CraftBukkit end
diff --git a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
index 84d215a498d9bf6f1232bf4af5a4a98d3ba9b131..de09a91b89661118e460842453e33f383ea08a94 100644
--- a/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
+++ b/net/minecraft/world/entity/boss/enderdragon/EnderDragon.java
@@ -92,6 +92,7 @@ public class EnderDragon extends Mob implements Enemy {
     private final net.minecraft.world.level.Explosion explosionSource; // Paper - reusable source for CraftTNTPrimed.getSource()
     @Nullable private BlockPos podium;
     // Paper end
+    private boolean hadRider; // Purpur - Ridables
 
     public EnderDragon(EntityType<? extends EnderDragon> entityType, Level level) {
         super(EntityType.ENDER_DRAGON, level);
@@ -108,6 +109,37 @@ public class EnderDragon extends Mob implements Enemy {
         this.noPhysics = true;
         this.phaseManager = new EnderDragonPhaseManager(this);
         this.explosionSource = new net.minecraft.world.level.ServerExplosion(level.getMinecraftWorld(), this, null, null, new Vec3(Double.NaN, Double.NaN, Double.NaN), Float.NaN, true, net.minecraft.world.level.Explosion.BlockInteraction.DESTROY); // Paper
+
+        // Purpur start - Ridables
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingMoveControllerWASD(this) {
+            @Override
+            public void vanillaTick() {
+                // dragon doesn't use the controller. do nothing
+            }
+        };
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void vanillaTick() {
+                // dragon doesn't use the controller. do nothing
+            }
+
+            @Override
+            public void purpurTick(Player rider) {
+                setYawPitch(rider.getYRot() - 180F, rider.xRotO * 0.5F);
+            }
+        };
+        // Purpur end - Ridables
+    }
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.enderDragonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.enderDragonRidableInWater;
     }
 
     public void setDragonFight(EndDragonFight dragonFight) {
@@ -122,6 +154,31 @@ public class EnderDragon extends Mob implements Enemy {
         return this.fightOrigin;
     }
 
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.enderDragonControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.enderDragonMaxY;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.enderDragonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.enderDragonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
     public static AttributeSupplier.Builder createAttributes() {
         return Mob.createMobAttributes().add(Attributes.MAX_HEALTH, 200.0).add(Attributes.CAMERA_DISTANCE, 16.0);
     }
@@ -171,6 +228,37 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     public void aiStep() {
+        // Purpur start - Ridables
+        boolean hasRider = getRider() != null && this.isControllable();
+        if (hasRider) {
+            if (!hadRider) {
+                hadRider = true;
+                noPhysics = false;
+                this.dimensions = net.minecraft.world.entity.EntityDimensions.scalable(4.0F, 2.0F);
+            }
+
+            // dragon doesn't use controllers, so must tick manually
+            moveControl.tick();
+            lookControl.tick();
+
+            moveRelative((float) getAttributeValue(Attributes.MOVEMENT_SPEED) * 0.1F, new Vec3(-getStrafeMot(), getVerticalMot(), -getForwardMot()));
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot);
+            move(MoverType.PLAYER, mot);
+
+            mot = mot.multiply(0.9F, 0.9F, 0.9F);
+            setDeltaMovement(mot);
+
+            // control wing flap speed on client
+            phaseManager.setPhase(mot.x() * mot.x() + mot.z() * mot.z() < 0.005F ? EnderDragonPhase.HOVERING : EnderDragonPhase.HOLDING_PATTERN);
+        } else if (hadRider) {
+            hadRider = false;
+            noPhysics = true;
+            this.dimensions = net.minecraft.world.entity.EntityDimensions.scalable(16.0F, 8.0F);
+            phaseManager.setPhase(EnderDragonPhase.HOLDING_PATTERN); // HoldingPattern
+        }
+        // Purpur end - Ridables
+
         this.processFlappingMovement();
         if (this.level().isClientSide) {
             this.setHealth(this.getHealth());
@@ -199,6 +287,8 @@ public class EnderDragon extends Mob implements Enemy {
 
         this.oFlapTime = this.flapTime;
         if (this.isDeadOrDying()) {
+            if (hasRider) ejectPassengers(); // Purpur - Ridables
+
             float f = (this.random.nextFloat() - 0.5F) * 8.0F;
             float f1 = (this.random.nextFloat() - 0.5F) * 4.0F;
             float f2 = (this.random.nextFloat() - 0.5F) * 8.0F;
@@ -208,9 +298,9 @@ public class EnderDragon extends Mob implements Enemy {
             Vec3 deltaMovement = this.getDeltaMovement();
             float f1 = 0.2F / ((float)deltaMovement.horizontalDistance() * 10.0F + 1.0F);
             f1 *= (float)Math.pow(2.0, deltaMovement.y);
-            if (this.phaseManager.getCurrentPhase().isSitting()) {
+            if (!hasRider && this.phaseManager.getCurrentPhase().isSitting()) { // Purpur - Ridables
                 this.flapTime += 0.1F;
-            } else if (this.inWall) {
+            } else if (!hasRider && this.inWall) { // Purpur - Ridables
                 this.flapTime += f1 * 0.5F;
             } else {
                 this.flapTime += f1;
@@ -221,7 +311,7 @@ public class EnderDragon extends Mob implements Enemy {
                 this.flapTime = 0.5F;
             } else {
                 this.flightHistory.record(this.getY(), this.getYRot());
-                if (this.level() instanceof ServerLevel serverLevel1) {
+                if (this.level() instanceof ServerLevel serverLevel1 && !hasRider) { // Purpur - Ridables
                     DragonPhaseInstance currentPhase = this.phaseManager.getCurrentPhase();
                     currentPhase.doServerTick(serverLevel1);
                     if (this.phaseManager.getCurrentPhase() != currentPhase) {
@@ -296,7 +386,7 @@ public class EnderDragon extends Mob implements Enemy {
                 this.tickPart(this.body, sin1 * 0.5F, 0.0, -cos1 * 0.5F);
                 this.tickPart(this.wing1, cos1 * 4.5F, 2.0, sin1 * 4.5F);
                 this.tickPart(this.wing2, cos1 * -4.5F, 2.0, sin1 * -4.5F);
-                if (this.level() instanceof ServerLevel serverLevel2 && this.hurtTime == 0) {
+                if (this.level() instanceof ServerLevel serverLevel2 && this.hurtTime == 0 && !hasRider) { // Purpur - Ridables
                     this.knockBack(
                         serverLevel2,
                         serverLevel2.getEntities(
@@ -346,9 +436,9 @@ public class EnderDragon extends Mob implements Enemy {
                 }
 
                 if (this.level() instanceof ServerLevel serverLevel3) {
-                    this.inWall = this.checkWalls(serverLevel3, this.head.getBoundingBox())
+                    this.inWall = !hasRider && this.checkWalls(serverLevel3, this.head.getBoundingBox())
                         | this.checkWalls(serverLevel3, this.neck.getBoundingBox())
-                        | this.checkWalls(serverLevel3, this.body.getBoundingBox());
+                        | this.checkWalls(serverLevel3, this.body.getBoundingBox()); // Purpur - Ridables
                     if (this.dragonFight != null) {
                         this.dragonFight.updateDragon(this);
                     }
@@ -461,7 +551,7 @@ public class EnderDragon extends Mob implements Enemy {
                     BlockPos blockPos = new BlockPos(i, i1, i2);
                     BlockState blockState = level.getBlockState(blockPos);
                     if (!blockState.isAir() && !blockState.is(BlockTags.DRAGON_TRANSPARENT)) {
-                        if (level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) && !blockState.is(BlockTags.DRAGON_IMMUNE)) {
+                        if (level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.enderDragonMobGriefingOverride) && !blockState.is(BlockTags.DRAGON_IMMUNE)) { // Purpur - Add mobGriefing override to everything affected
                             // CraftBukkit start - Add blocks to list rather than destroying them
                             //flag1 = level.removeBlock(blockPos, false) || flag1;
                             flag1 = true;
@@ -961,6 +1051,7 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     protected boolean canRide(Entity entity) {
+        if (this.level().purpurConfig.enderDragonCanRideVehicles) return this.boardingCooldown <= 0; // Purpur - Configs for if Wither/Ender Dragon can ride vehicles
         return false;
     }
 
@@ -986,7 +1077,7 @@ public class EnderDragon extends Mob implements Enemy {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return 1.0F;
+        return 1.0F; // Purpur - Configurable entity base attributes
     }
 
     // CraftBukkit start - SPIGOT-2420: Special case, the ender dragon drops 12000 xp for the first kill and 500 xp for every other kill and this over time.
@@ -996,7 +1087,7 @@ public class EnderDragon extends Mob implements Enemy {
         boolean flag = level.getGameRules().getBoolean(GameRules.RULE_DOMOBLOOT);
         int i = 500;
 
-        if (this.dragonFight != null && !this.dragonFight.hasPreviouslyKilledDragon()) {
+        if (this.dragonFight != null && (level().purpurConfig.enderDragonAlwaysDropsFullExp || !this.dragonFight.hasPreviouslyKilledDragon())) { // Purpur - Ender dragon always drop full exp
             i = 12000;
         }
 
diff --git a/net/minecraft/world/entity/boss/wither/WitherBoss.java b/net/minecraft/world/entity/boss/wither/WitherBoss.java
index 787b74c5aa02afc4ba95fa1cdaf6cc21b6554b56..0613d80561f50e32dc4d1c471521f001659d017d 100644
--- a/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -71,6 +71,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     private final int[] nextHeadUpdate = new int[2];
     private final int[] idleHeadUpdates = new int[2];
     private int destroyBlocksTick;
+    private int shootCooldown = 0; // Purpur - Ridables
     private boolean canPortal = false; // Paper
     public final ServerBossEvent bossEvent = (ServerBossEvent)new ServerBossEvent(
             this.getDisplayName(), BossEvent.BossBarColor.PURPLE, BossEvent.BossBarOverlay.PROGRESS
@@ -79,14 +80,161 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     private static final TargetingConditions.Selector LIVING_ENTITY_SELECTOR = (entity, level) -> !entity.getType().is(EntityTypeTags.WITHER_FRIENDS)
         && entity.attackable();
     private static final TargetingConditions TARGETING_CONDITIONS = TargetingConditions.forCombat().range(20.0).selector(LIVING_ENTITY_SELECTOR);
+    @Nullable private java.util.UUID summoner; // Purpur - Summoner API
+    private org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD purpurController; // Purpur - Ridables
 
     public WitherBoss(EntityType<? extends WitherBoss> entityType, Level level) {
         super(entityType, level);
+        // Purpur start - Ridables
+        this.purpurController = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.1F);
+        this.moveControl = new FlyingMoveControl(this, 10, false) {
+            @Override
+            public void tick() {
+                if (mob.getRider() != null && mob.isControllable()) {
+                    purpurController.purpurTick(mob.getRider());
+                } else {
+                    super.tick();
+                }
+            }
+        };
+        // Purpur end - Ridables
         this.moveControl = new FlyingMoveControl(this, 10, false);
         this.setHealth(this.getMaxHealth());
         this.xpReward = 50;
     }
 
+    // Purpur start - Summoner API
+    @Nullable
+    public java.util.UUID getSummoner() {
+        return summoner;
+    }
+
+    public void setSummoner(@Nullable java.util.UUID summoner) {
+        this.summoner = summoner;
+    }
+    // Purpur end - Summoner API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witherRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witherRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witherControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.witherMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED) * 5F;
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 0.5, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        this.entityData.set(DATA_TARGETS.get(0), 0);
+        this.entityData.set(DATA_TARGETS.get(1), 0);
+        this.entityData.set(DATA_TARGETS.get(2), 0);
+        getNavigation().stop();
+        shootCooldown = 20;
+    }
+
+    @Override
+    public boolean onClick(net.minecraft.world.InteractionHand hand) {
+        return shoot(getRider(), hand == net.minecraft.world.InteractionHand.MAIN_HAND ? new int[]{1} : new int[]{2});
+    }
+
+    public boolean shoot(@Nullable Player rider, int[] heads) {
+        if (shootCooldown > 0) {
+            return false;
+        }
+
+        shootCooldown = 20;
+        if (rider == null) {
+            return false;
+        }
+
+        org.bukkit.craftbukkit.entity.CraftHumanEntity player = rider.getBukkitEntity();
+        if (!player.hasPermission("allow.special.wither")) {
+            return false;
+        }
+
+        net.minecraft.world.phys.HitResult rayTrace = getRayTrace(120, net.minecraft.world.level.ClipContext.Fluid.NONE);
+        if (rayTrace == null) {
+            return false;
+        }
+
+        Vec3 loc;
+        if (rayTrace.getType() == net.minecraft.world.phys.HitResult.Type.BLOCK) {
+            BlockPos pos = ((net.minecraft.world.phys.BlockHitResult) rayTrace).getBlockPos();
+            loc = new Vec3(pos.getX() + 0.5D, pos.getY() + 0.5D, pos.getZ() + 0.5D);
+        } else if (rayTrace.getType() == net.minecraft.world.phys.HitResult.Type.ENTITY) {
+            Entity target = ((net.minecraft.world.phys.EntityHitResult) rayTrace).getEntity();
+            loc = new Vec3(target.getX(), target.getY() + (target.getEyeHeight() / 2), target.getZ());
+        } else {
+            org.bukkit.block.Block block = player.getTargetBlock(null, 120);
+            loc = new Vec3(block.getX() + 0.5D, block.getY() + 0.5D, block.getZ() + 0.5D);
+        }
+
+        for (int head : heads) {
+            shoot(head, loc.x(), loc.y(), loc.z(), rider);
+        }
+
+        return true; // handled
+    }
+
+    public void shoot(int head, double x, double y, double z, Player rider) {
+        level().levelEvent(null, 1024, blockPosition(), 0);
+        double headX = getHeadX(head);
+        double headY = getHeadY(head);
+        double headZ = getHeadZ(head);
+        Vec3 vec3d = new Vec3(x - headX, y - headY, z - headZ);
+        WitherSkull skull = new WitherSkull(level(), this, vec3d.normalize());
+        skull.setPosRaw(headX, headY, headZ);
+        level().addFreshEntity(skull);
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witherMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witherScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witherTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witherAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         FlyingPathNavigation flyingPathNavigation = new FlyingPathNavigation(this, level);
@@ -97,11 +245,13 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(0, new WitherBoss.WitherDoNothingGoal());
         this.goalSelector.addGoal(2, new RangedAttackGoal(this, 1.0, 40, 20.0F));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomFlyingGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(7, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, LivingEntity.class, 0, false, false, LIVING_ENTITY_SELECTOR));
     }
@@ -119,6 +269,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putInt("Invul", this.getInvulnerableTicks());
+        output.storeNullable("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC, getSummoner()); // Purpur - Summoner API
     }
 
     @Override
@@ -128,6 +279,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
         if (this.hasCustomName()) {
             this.bossEvent.setName(this.getDisplayName());
         }
+        this.setSummoner(input.read("Purpur.Summoner", net.minecraft.core.UUIDUtil.CODEC).orElse(null)); // Purpur - Summoner API
     }
 
     @Override
@@ -259,6 +411,15 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), mot.y() + (getVerticalMot() > 0 ? 0.07D : 0.0D), mot.z());
+        }
+        if (shootCooldown > 0) {
+            shootCooldown--;
+        }
+        // Purpur end - Ridables
         if (this.getInvulnerableTicks() > 0) {
             int i = this.getInvulnerableTicks() - 1;
             this.bossEvent.setProgress(1.0F - i / 220.0F);
@@ -271,7 +432,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
                     level.explode(this, this.getX(), this.getEyeY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB);
                 }
                 // CraftBukkit end
-                if (!this.isSilent()) {
+                if (!this.isSilent() && level.purpurConfig.witherPlaySpawnSound) { // Purpur - Toggle for Wither's spawn sound
                     // CraftBukkit start - Use relative location for far away sounds
                     // level.globalLevelEvent(1023, this.blockPosition(), 0);
                     int viewDistance = level.getCraftServer().getViewDistance() * 16;
@@ -296,7 +457,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
             this.setInvulnerableTicks(i);
             if (this.tickCount % 10 == 0) {
-                this.heal(10.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.WITHER_SPAWN); // CraftBukkit
+                this.heal(this.getMaxHealth() / 30, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.WITHER_SPAWN); // CraftBukkit // Purpur - Configurable entity base attributes
             }
         } else {
             super.customServerAiStep(level);
@@ -348,7 +509,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
             if (this.destroyBlocksTick > 0) {
                 this.destroyBlocksTick--;
-                if (this.destroyBlocksTick == 0 && level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+                if (this.destroyBlocksTick == 0 && level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.witherMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     boolean flag = false;
                     int alternativeTarget = Mth.floor(this.getBbWidth() / 2.0F + 1.0F);
                     int floor = Mth.floor(this.getBbHeight());
@@ -378,8 +539,10 @@ public class WitherBoss extends Monster implements RangedAttackMob {
                 }
             }
 
-            if (this.tickCount % 20 == 0) {
-                this.heal(1.0F, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN); // CraftBukkit
+            // Purpur start - Customizable wither health and healing - customizable heal rate and amount
+            if (this.tickCount % level().purpurConfig.witherHealthRegenDelay == 0) {
+                this.heal(level().purpurConfig.witherHealthRegenAmount, org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason.REGEN); // CraftBukkit
+            // Purpur end - Customizable wither health and healing
             }
 
             this.bossEvent.setProgress(this.getHealth() / this.getMaxHealth());
@@ -563,11 +726,11 @@ public class WitherBoss extends Monster implements RangedAttackMob {
     }
 
     public int getAlternativeTarget(int head) {
-        return this.entityData.get(DATA_TARGETS.get(head));
+        return getRider() != null && this.isControllable() ? 0 : this.entityData.get(DATA_TARGETS.get(head)); // Purpur - Ridables
     }
 
     public void setAlternativeTarget(int targetOffset, int newId) {
-        this.entityData.set(DATA_TARGETS.get(targetOffset), newId);
+        if (getRider() == null || !this.isControllable()) this.entityData.set(DATA_TARGETS.get(targetOffset), newId); // Purpur - Ridables
     }
 
     public boolean isPowered() {
@@ -576,6 +739,7 @@ public class WitherBoss extends Monster implements RangedAttackMob {
 
     @Override
     protected boolean canRide(Entity entity) {
+        if (this.level().purpurConfig.witherCanRideVehicles) return this.boardingCooldown <= 0; // Purpur - Configs for if Wither/Ender Dragon can ride vehicles
         return false;
     }
 
diff --git a/net/minecraft/world/entity/decoration/ArmorStand.java b/net/minecraft/world/entity/decoration/ArmorStand.java
index 5ee368580d878a3845349c3d50cc0dc549c42cab..83fdd22eeb141079e05018ebf5cef70e7eb78726 100644
--- a/net/minecraft/world/entity/decoration/ArmorStand.java
+++ b/net/minecraft/world/entity/decoration/ArmorStand.java
@@ -91,10 +91,13 @@ public class ArmorStand extends LivingEntity {
     public boolean canTickSetByAPI = false;
     public boolean noTickEquipmentDirty = false;
     // Paper end - Allow ArmorStands not to tick
+    public boolean canMovementTick = true; // Purpur - Movement options for armor stands
 
     public ArmorStand(EntityType<? extends ArmorStand> entityType, Level level) {
         super(entityType, level);
         if (level != null) this.canTick = level.paperConfig().entities.armorStands.tick; // Paper - Allow ArmorStands not to tick
+        if (level != null) this.canMovementTick = level.purpurConfig.armorstandMovement; // Purpur - Movement options for armor stands
+        this.setShowArms(level != null && level.purpurConfig.armorstandPlaceWithArms); // Purpur - Config to show Armor Stand arms on spawn
     }
 
     public ArmorStand(Level level, double x, double y, double z) {
@@ -447,6 +450,7 @@ public class ArmorStand extends LivingEntity {
 
     private org.bukkit.event.entity.EntityDeathEvent brokenByPlayer(ServerLevel level, DamageSource damageSource) { // Paper
         ItemStack itemStack = new ItemStack(Items.ARMOR_STAND);
+        if (level.purpurConfig.persistentDroppableEntityDisplayNames) // Purpur - Apply display names from item forms of entities to entities and vice versa
         itemStack.set(DataComponents.CUSTOM_NAME, this.getCustomName());
         this.drops.add(new DefaultDrop(itemStack, stack -> Block.popResource(this.level(), this.blockPosition(), stack))); // CraftBukkit - add to drops // Paper - Restore vanilla drops behavior
         return this.brokenByAnything(level, damageSource); // Paper
@@ -521,6 +525,7 @@ public class ArmorStand extends LivingEntity {
     // Paper start - Allow ArmorStands not to tick
     @Override
     public void tick() {
+        maxUpStep = level().purpurConfig.armorstandStepHeight; // Purpur - Add option to set armorstand step height
         if (!this.canTick) {
             if (this.noTickEquipmentDirty) {
                 this.noTickEquipmentDirty = false;
@@ -811,4 +816,18 @@ public class ArmorStand extends LivingEntity {
         }
     }
     // Paper end
+
+    // Purpur start - Movement options for armor stands
+    @Override
+    public void updateInWaterStateAndDoWaterCurrentPushing() {
+        if (this.level().purpurConfig.armorstandWaterMovement &&
+            (this.level().purpurConfig.armorstandWaterFence || !(level().getBlockState(blockPosition().below()).getBlock() instanceof net.minecraft.world.level.block.FenceBlock)))
+            super.updateInWaterStateAndDoWaterCurrentPushing();
+    }
+
+    @Override
+    public void aiStep() {
+        if (this.canMovementTick && this.canMove) super.aiStep();
+    }
+    // Purpur end - Movement options for armor stands
 }
diff --git a/net/minecraft/world/entity/decoration/ItemFrame.java b/net/minecraft/world/entity/decoration/ItemFrame.java
index 324e150f9ae79d15a25710bc9da0368bbddda534..0f513c4807326a966062016e48bb8dce6395552a 100644
--- a/net/minecraft/world/entity/decoration/ItemFrame.java
+++ b/net/minecraft/world/entity/decoration/ItemFrame.java
@@ -237,7 +237,11 @@ public class ItemFrame extends HangingEntity {
                 this.removeFramedMap(item);
             } else {
                 if (dropItem) {
-                    this.spawnAtLocation(level, this.getFrameItemStack());
+                    // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                    final ItemStack itemFrame = this.getFrameItemStack();
+                    if (!level.purpurConfig.persistentDroppableEntityDisplayNames) itemFrame.set(DataComponents.CUSTOM_NAME, null);
+                    this.spawnAtLocation(level, itemFrame);
+                    // Purpur end - Apply display names from item forms of entities to entities and vice versa
                 }
 
                 if (!item.isEmpty()) {
diff --git a/net/minecraft/world/entity/decoration/Painting.java b/net/minecraft/world/entity/decoration/Painting.java
index cc34cadac8896a5f546d0879e795fea08d0c3f98..26a08b16de2318d5080be59a29c5f11e3597426d 100644
--- a/net/minecraft/world/entity/decoration/Painting.java
+++ b/net/minecraft/world/entity/decoration/Painting.java
@@ -182,7 +182,11 @@ public class Painting extends HangingEntity {
         if (level.getGameRules().getBoolean(GameRules.RULE_DOENTITYDROPS)) {
             this.playSound(SoundEvents.PAINTING_BREAK, 1.0F, 1.0F);
             if (!(entity instanceof Player player && player.hasInfiniteMaterials())) {
-                this.spawnAtLocation(level, Items.PAINTING);
+                // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                final ItemStack painting = new ItemStack(Items.PAINTING);
+                if (!this.level().purpurConfig.persistentDroppableEntityDisplayNames) painting.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, null);
+                this.spawnAtLocation(level, painting);
+                // Purpur end - Apply display names from item forms of entities to entities and vice versa
             }
         }
     }
diff --git a/net/minecraft/world/entity/item/ItemEntity.java b/net/minecraft/world/entity/item/ItemEntity.java
index 2309d1a30459ff986ab5bc4316247efaa7472a41..07d1ac1c19535bfc423fbd743c7b0a22e73cea5b 100644
--- a/net/minecraft/world/entity/item/ItemEntity.java
+++ b/net/minecraft/world/entity/item/ItemEntity.java
@@ -56,6 +56,12 @@ public class ItemEntity extends Entity implements TraceableEntity {
     public boolean canMobPickup = true; // Paper - Item#canEntityPickup
     private int despawnRate = -1; // Paper - Alternative item-despawn-rate
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
+    // Purpur start - Item entity immunities
+    public boolean immuneToCactus = false;
+    public boolean immuneToExplosion = false;
+    public boolean immuneToFire = false;
+    public boolean immuneToLightning = false;
+    // Purpur end - Item entity immunities
 
     public ItemEntity(EntityType<? extends ItemEntity> entityType, Level level) {
         super(entityType, level);
@@ -342,7 +348,16 @@ public class ItemEntity extends Entity implements TraceableEntity {
 
     @Override
     public final boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
-        if (this.isInvulnerableToBase(damageSource)) {
+        // Purpur start - Item entity immunities
+        if (
+            (immuneToCactus && damageSource.is(net.minecraft.world.damagesource.DamageTypes.CACTUS)) ||
+            (immuneToFire && (damageSource.is(net.minecraft.tags.DamageTypeTags.IS_FIRE) || damageSource.is(net.minecraft.world.damagesource.DamageTypes.ON_FIRE) || damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_FIRE))) ||
+            (immuneToLightning && damageSource.is(net.minecraft.world.damagesource.DamageTypes.LIGHTNING_BOLT)) ||
+            (immuneToExplosion && damageSource.is(net.minecraft.tags.DamageTypeTags.IS_EXPLOSION))
+        ) {
+            return false;
+        } else if (this.isInvulnerableToBase(damageSource)) {
+        // Purpur end - Item entity immunities
             return false;
         } else if (!level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) && damageSource.getEntity() instanceof Mob) {
             return false;
@@ -529,6 +544,12 @@ public class ItemEntity extends Entity implements TraceableEntity {
     public void setItem(ItemStack stack) {
         this.getEntityData().set(DATA_ITEM, stack);
         this.despawnRate = this.level().paperConfig().entities.spawning.altItemDespawnRate.enabled ? this.level().paperConfig().entities.spawning.altItemDespawnRate.items.getOrDefault(stack.getItem(), this.level().spigotConfig.itemDespawnRate) : this.level().spigotConfig.itemDespawnRate; // Paper - Alternative item-despawn-rate
+        // Purpur start - Item entity immunities
+        if (level().purpurConfig.itemImmuneToCactus.contains(stack.getItem())) immuneToCactus = true;
+        if (level().purpurConfig.itemImmuneToExplosion.contains(stack.getItem())) immuneToExplosion = true;
+        if (level().purpurConfig.itemImmuneToFire.contains(stack.getItem())) immuneToFire = true;
+        if (level().purpurConfig.itemImmuneToLightning.contains(stack.getItem())) immuneToLightning = true;
+        // level end - Item entity immunities
     }
 
     @Override
diff --git a/net/minecraft/world/entity/item/PrimedTnt.java b/net/minecraft/world/entity/item/PrimedTnt.java
index 732672aa7d915217eb4af44179b2f2ab1e796cca..8db1178e3d5e1f8e6018202462e0ce819d6da63f 100644
--- a/net/minecraft/world/entity/item/PrimedTnt.java
+++ b/net/minecraft/world/entity/item/PrimedTnt.java
@@ -246,4 +246,32 @@ public class PrimedTnt extends Entity implements TraceableEntity {
         return !this.level().paperConfig().fixes.preventTntFromMovingInWater && super.isPushedByFluid();
     }
     // Paper end - Option to prevent TNT from moving in water
+
+    // Purpur start - Shears can defuse TNT
+    @Override
+    public net.minecraft.world.InteractionResult interact(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel serverWorld && level().purpurConfig.shearsCanDefuseTnt) {
+            final net.minecraft.world.item.ItemStack inHand = player.getItemInHand(hand);
+
+            if (!inHand.is(net.minecraft.world.item.Items.SHEARS) || !player.getBukkitEntity().hasPermission("purpur.tnt.defuse") ||
+                    serverWorld.random.nextFloat() > serverWorld.purpurConfig.shearsCanDefuseTntChance) return net.minecraft.world.InteractionResult.PASS;
+
+            net.minecraft.world.entity.item.ItemEntity tntItem = new net.minecraft.world.entity.item.ItemEntity(serverWorld, getX(), getY(), getZ(),
+                    new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.TNT));
+            tntItem.setPickUpDelay(10);
+
+            inHand.hurtAndBreak(1, player, LivingEntity.getSlotForHand(hand));
+            serverWorld.addFreshEntity(tntItem, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CUSTOM);
+
+            this.playSound(net.minecraft.sounds.SoundEvents.SHEEP_SHEAR);
+
+            this.kill(serverWorld);
+            return net.minecraft.world.InteractionResult.SUCCESS;
+        }
+
+        return super.interact(player, hand);
+    }
+    // Purpur end - Shears can defuse TNT
 }
diff --git a/net/minecraft/world/entity/monster/AbstractSkeleton.java b/net/minecraft/world/entity/monster/AbstractSkeleton.java
index 894a3d988d0530d42d3a282b61cdb445a0f820ad..53ab51ffa5dd7d30a25f17dea0d9106bf30b49ba 100644
--- a/net/minecraft/world/entity/monster/AbstractSkeleton.java
+++ b/net/minecraft/world/entity/monster/AbstractSkeleton.java
@@ -64,21 +64,24 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
             AbstractSkeleton.this.setAggressive(true);
         }
     };
-    private boolean shouldBurnInDay = true; // Paper - shouldBurnInDay API
+    //private boolean shouldBurnInDay = true; // Paper - shouldBurnInDay API // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
 
     protected AbstractSkeleton(EntityType<? extends AbstractSkeleton> entityType, Level level) {
         super(entityType, level);
         this.reassessWeaponGoal();
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new RestrictSunGoal(this));
         this.goalSelector.addGoal(3, new FleeSunGoal(this, 1.0));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Wolf.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
@@ -108,27 +111,7 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
 
     @Override
     public void aiStep() {
-        boolean isSunBurnTick = this.shouldBurnInDay && this.isSunBurnTick(); // Paper - shouldBurnInDay API
-        if (isSunBurnTick) {
-            ItemStack itemBySlot = this.getItemBySlot(EquipmentSlot.HEAD);
-            if (!itemBySlot.isEmpty()) {
-                if (itemBySlot.isDamageableItem()) {
-                    Item item = itemBySlot.getItem();
-                    itemBySlot.setDamageValue(itemBySlot.getDamageValue() + this.random.nextInt(2));
-                    if (itemBySlot.getDamageValue() >= itemBySlot.getMaxDamage()) {
-                        this.onEquippedItemBroken(item, EquipmentSlot.HEAD);
-                        this.setItemSlot(EquipmentSlot.HEAD, ItemStack.EMPTY);
-                    }
-                }
-
-                isSunBurnTick = false;
-            }
-
-            if (isSunBurnTick) {
-                this.igniteForSeconds(8.0F);
-            }
-        }
-
+        // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         super.aiStep();
     }
 
@@ -158,10 +141,7 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
         this.reassessWeaponGoal();
         this.setCanPickUpLoot(this.level().paperConfig().entities.behavior.mobsCanAlwaysPickUpLoot.skeletons || random.nextFloat() < 0.55F * difficulty.getSpecialMultiplier()); // Paper - Add world settings for mobs picking up loot
         if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty()) {
-            LocalDate localDate = LocalDate.now();
-            int i = localDate.get(ChronoField.DAY_OF_MONTH);
-            int i1 = localDate.get(ChronoField.MONTH_OF_YEAR);
-            if (i1 == 10 && i == 31 && random.nextFloat() < 0.25F) {
+            if (net.minecraft.world.entity.ambient.Bat.isHalloweenSeason(level.getMinecraftWorld()) && this.random.nextFloat() < this.level().purpurConfig.chanceHeadHalloweenOnEntity) { // Purpur - Halloween options and optimizations
                 this.setItemSlot(EquipmentSlot.HEAD, new ItemStack(random.nextFloat() < 0.1F ? Blocks.JACK_O_LANTERN : Blocks.CARVED_PUMPKIN));
                 this.setDropChance(EquipmentSlot.HEAD, 0.0F);
             }
@@ -209,7 +189,7 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
         double squareRoot = Math.sqrt(d * d + d2 * d2);
         if (this.level() instanceof ServerLevel serverLevel) {
             Projectile.Delayed<AbstractArrow> delayedEntity = Projectile.spawnProjectileUsingShootDelayed( // Paper - delayed
-                arrow, serverLevel, projectile, d, d1 + squareRoot * 0.2F, d2, 1.6F, 14 - serverLevel.getDifficulty().getId() * 4
+                arrow, serverLevel, projectile, d, d1 + squareRoot * 0.2F, d2, 1.6F, serverLevel.purpurConfig.skeletonBowAccuracyMap.getOrDefault(serverLevel.getDifficulty().getId(), (float) (14 - serverLevel.getDifficulty().getId() * 4))  // Purpur - skeleton bow accuracy option
             );
 
             // Paper start - call EntityShootBowEvent
@@ -246,14 +226,14 @@ public abstract class AbstractSkeleton extends Monster implements RangedAttackMo
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.reassessWeaponGoal();
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - shouldBurnInDay API
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - shouldBurnInDay API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     // Paper start - shouldBurnInDay API
     @Override
     protected void addAdditionalSaveData(final net.minecraft.world.level.storage.ValueOutput output) {
         super.addAdditionalSaveData(output);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay);
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
     // Paper end - shouldBurnInDay API
 
diff --git a/net/minecraft/world/entity/monster/Blaze.java b/net/minecraft/world/entity/monster/Blaze.java
index 4ab7072b4290db7fbe72f81b89d3c428b05f737c..fa21b7dba208d5ba6ecf1d2b68965bb50642b53a 100644
--- a/net/minecraft/world/entity/monster/Blaze.java
+++ b/net/minecraft/world/entity/monster/Blaze.java
@@ -33,26 +33,78 @@ public class Blaze extends Monster {
 
     public Blaze(EntityType<? extends Blaze> entityType, Level level) {
         super(entityType, level);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        this.moveControl = new org.purpurmc.purpur.controller.FlyingWithSpacebarMoveControllerWASD(this, 0.3F); // Purpur - Ridables
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
         this.xpReward = 10;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.blazeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.blazeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.blazeControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.blazeMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.blazeMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.blazeScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.blazeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new Blaze.BlazeAttackGoal(this));
         this.goalSelector.addGoal(5, new MoveTowardsRestrictionGoal(this, 1.0));
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0, 0.0F));
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.ATTACK_DAMAGE, 6.0).add(Attributes.MOVEMENT_SPEED, 0.23F).add(Attributes.FOLLOW_RANGE, 48.0);
+        return Monster.createMonsterAttributes().add(Attributes.ATTACK_DAMAGE, 6.0).add(Attributes.MOVEMENT_SPEED, 0.23F).add(Attributes.FOLLOW_RANGE, 48.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur - Ridables
     }
 
     @Override
@@ -112,11 +164,18 @@ public class Blaze extends Monster {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.blazeTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable()) {
+            Vec3 mot = getDeltaMovement();
+            setDeltaMovement(mot.x(), getVerticalMot() > 0 ? 0.07D : -0.07D, mot.z());
+            return;
+        }
+        // Purpur end - Ridables
         this.nextHeightOffsetChangeTick--;
         if (this.nextHeightOffsetChangeTick <= 0) {
             this.nextHeightOffsetChangeTick = 100;
diff --git a/net/minecraft/world/entity/monster/Bogged.java b/net/minecraft/world/entity/monster/Bogged.java
index afb4cee70d0feecab93d943baf7ddfd83ad7f3b5..cace310ad4ad320a8a5745c6af3ec4b57e75b6a5 100644
--- a/net/minecraft/world/entity/monster/Bogged.java
+++ b/net/minecraft/world/entity/monster/Bogged.java
@@ -43,6 +43,31 @@ public class Bogged extends AbstractSkeleton implements Shearable {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.boggedRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.boggedRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.boggedControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.boggedMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.boggedScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
diff --git a/net/minecraft/world/entity/monster/CaveSpider.java b/net/minecraft/world/entity/monster/CaveSpider.java
index 2e32567fca7a2a4cd87bc078a6eeb30e3ffabfce..7eca4b751d900c6d6ee34993c3e2368127d19e03 100644
--- a/net/minecraft/world/entity/monster/CaveSpider.java
+++ b/net/minecraft/world/entity/monster/CaveSpider.java
@@ -26,6 +26,45 @@ public class CaveSpider extends Spider {
         return Spider.createAttributes().add(Attributes.MAX_HEALTH, 12.0);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.caveSpiderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.caveSpiderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.caveSpiderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.caveSpiderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.caveSpiderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.caveSpiderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.caveSpiderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean doHurtTarget(ServerLevel level, Entity source) {
         if (super.doHurtTarget(level, source)) {
diff --git a/net/minecraft/world/entity/monster/Creeper.java b/net/minecraft/world/entity/monster/Creeper.java
index eabc778ba06c14f3020391b9850ae1a283ecf106..2839c755e5ca58896bc14f95ce4889d48ec415b3 100644
--- a/net/minecraft/world/entity/monster/Creeper.java
+++ b/net/minecraft/world/entity/monster/Creeper.java
@@ -55,21 +55,107 @@ public class Creeper extends Monster {
     public int explosionRadius = 3;
     private int droppedSkulls;
     public @Nullable Entity entityIgniter; // CraftBukkit
+    private boolean exploding = false; // Purpur - Config to make Creepers explode on death
+    // Purpur start - Ridables
+    private int spacebarCharge = 0;
+    private int prevSpacebarCharge = 0;
+    private int powerToggleDelay = 0;
+    // Purpur end - Ridables
 
     public Creeper(EntityType<? extends Creeper> entityType, Level level) {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.creeperRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.creeperRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.creeperControllable;
+    }
+
+    @Override
+    protected void customServerAiStep(ServerLevel world) {
+        if (powerToggleDelay > 0) {
+            powerToggleDelay--;
+        }
+        if (getRider() != null && this.isControllable()) {
+            if (getRider().getForwardMot() != 0 || getRider().getStrafeMot() != 0) {
+                spacebarCharge = 0;
+                setIgnited(false);
+                setSwellDir(-1);
+            }
+            if (spacebarCharge == prevSpacebarCharge) {
+                spacebarCharge = 0;
+            }
+            prevSpacebarCharge = spacebarCharge;
+        }
+        super.customServerAiStep(world);
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        setIgnited(false);
+        setSwellDir(-1);
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (powerToggleDelay > 0) {
+            return true; // just toggled power, do not jump or ignite
+        }
+        spacebarCharge++;
+        if (spacebarCharge > maxSwell - 2) {
+            spacebarCharge = 0;
+            if (getRider() != null && getRider().getBukkitEntity().hasPermission("allow.powered.creeper")) {
+                powerToggleDelay = 20;
+                setPowered(!isPowered());
+                setIgnited(false);
+                setSwellDir(-1);
+                return true;
+            }
+        }
+        if (!isIgnited()) {
+            if (getRider() != null && getRider().getForwardMot() == 0 && getRider().getStrafeMot() == 0 &&
+                    getRider().getBukkitEntity().hasPermission("allow.special.creeper")) {
+                setIgnited(true);
+                setSwellDir(1);
+                return true;
+            }
+        }
+        return getForwardMot() == 0 && getStrafeMot() == 0; // do not jump if standing still
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.creeperMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.creeperScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
         this.goalSelector.addGoal(2, new SwellGoal(this));
+        this.goalSelector.addGoal(3, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Ocelot.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Cat.class, 6.0F, 1.0, 1.2));
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.8));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
     }
@@ -158,6 +244,41 @@ public class Creeper extends Monster {
         return false; // CraftBukkit
     }
 
+    // Purpur start - Special mobs naturally spawn
+    @Override
+    public net.minecraft.world.entity.SpawnGroupData finalizeSpawn(net.minecraft.world.level.ServerLevelAccessor world, net.minecraft.world.DifficultyInstance difficulty, net.minecraft.world.entity.EntitySpawnReason spawnReason, @Nullable net.minecraft.world.entity.SpawnGroupData entityData) {
+        double chance = world.getLevel().purpurConfig.creeperChargedChance;
+        if (chance > 0D && random.nextDouble() <= chance) {
+            setPowered(true);
+        }
+        return super.finalizeSpawn(world, difficulty, spawnReason, entityData);
+    }
+    // Purpur end - Special mobs naturally spawn
+
+    // Purpur start - Config to make Creepers explode on death
+    @Override
+    protected org.bukkit.event.entity.EntityDeathEvent dropAllDeathLoot(ServerLevel world, DamageSource damageSource) {
+        if (!this.exploding && this.level().purpurConfig.creeperExplodeWhenKilled && damageSource.getEntity() instanceof net.minecraft.server.level.ServerPlayer) {
+            this.explodeCreeper();
+        }
+        return super.dropAllDeathLoot(world, damageSource);
+    }
+    // Purpur end - Config to make Creepers explode on death
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.creeperTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.creeperAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public SoundEvent getHurtSound(DamageSource damageSource) {
         return SoundEvents.CREEPER_HURT;
@@ -240,14 +361,16 @@ public class Creeper extends Monster {
     }
 
     public void explodeCreeper() {
+        this.exploding = true; // Purpur - Config to make Creepers explode on death
         if (this.level() instanceof ServerLevel serverLevel) {
             float f = this.isPowered() ? 2.0F : 1.0F;
+            float multiplier = serverLevel.purpurConfig.creeperHealthRadius ? this.getHealth() / this.getMaxHealth() : 1; // Purpur - Config for health to impact Creeper explosion radius
             // CraftBukkit start
-            org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, this.explosionRadius * f, false);
+            org.bukkit.event.entity.ExplosionPrimeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callExplosionPrimeEvent(this, (this.explosionRadius * f) * multiplier, false); // Purpur - Config for health to impact Creeper explosion radius
             if (!event.isCancelled()) {
             // CraftBukkit end
             this.dead = true;
-            serverLevel.explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB); // CraftBukkit // Paper - fix DamageSource API (revert to vanilla, no, just no, don't change this)
+            serverLevel.explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), serverLevel.getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_MOBGRIEFING) && level().purpurConfig.creeperAllowGriefing ? Level.ExplosionInteraction.MOB : Level.ExplosionInteraction.NONE); // CraftBukkit // Paper - fix DamageSource API (revert to vanilla, no, just no, don't change this) // Purpur - Add enderman and creeper griefing controls
             this.spawnLingeringCloud();
             this.triggerOnDeathMobEffects(serverLevel, Entity.RemovalReason.KILLED);
             this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.EXPLODE); // CraftBukkit - add Bukkit remove cause
@@ -258,6 +381,7 @@ public class Creeper extends Monster {
             }
             // CraftBukkit end
         }
+        this.exploding = false; // Purpur - Config to make Creepers explode on death
     }
 
     private void spawnLingeringCloud() {
@@ -286,6 +410,7 @@ public class Creeper extends Monster {
             com.destroystokyo.paper.event.entity.CreeperIgniteEvent event = new com.destroystokyo.paper.event.entity.CreeperIgniteEvent((org.bukkit.entity.Creeper) getBukkitEntity(), ignited);
             if (event.callEvent()) {
                 this.entityData.set(DATA_IS_IGNITED, event.isIgnited());
+                if (!event.isIgnited()) setSwellDir(-1); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/Drowned.java b/net/minecraft/world/entity/monster/Drowned.java
index f42f9c232fa588835654de0fdea36b9cdfa34571..2e6d0f035a01277aa28bbe912d5df8dc4cf04547 100644
--- a/net/minecraft/world/entity/monster/Drowned.java
+++ b/net/minecraft/world/entity/monster/Drowned.java
@@ -71,11 +71,72 @@ public class Drowned extends Zombie implements RangedAttackMob {
         return Zombie.createAttributes().add(Attributes.STEP_HEIGHT, 1.0);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.drownedRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.drownedRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.drownedControllable;
+    }
+    // Purpur end - Ridables
+
     @Override
     protected PathNavigation createNavigation(Level level) {
         return new AmphibiousPathNavigation(this, level);
     }
 
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.drownedMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.drownedScale);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.drownedSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.drownedJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.drownedJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.drownedJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.drownedTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.drownedAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void addBehaviourGoals() {
         this.goalSelector.addGoal(1, new Drowned.DrownedGoToWaterGoal(this, 1.0));
@@ -83,10 +144,23 @@ public class Drowned extends Zombie implements RangedAttackMob {
         this.goalSelector.addGoal(2, new Drowned.DrownedAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new Drowned.DrownedGoToBeachGoal(this, 1.0));
         this.goalSelector.addGoal(6, new Drowned.DrownedSwimUpGoal(this, 1.0, this.level().getSeaLevel()));
+        if (level().purpurConfig.drownedBreakDoors) this.goalSelector.addGoal(6, new net.minecraft.world.entity.ai.goal.MoveThroughVillageGoal(this, 1.0D, true, 4, this::canBreakDoors)); // Purpur - Option to make drowned break doors
         this.goalSelector.addGoal(7, new RandomStrollGoal(this, 1.0));
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Drowned.class).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> this.okTarget(entity)));
-        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Paper - Check drowned for villager aggression config
+        // Purpur start - Add option to disable zombie aggressiveness towards villagers
+        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false) { // Paper - Check drowned for villager aggression config
+            @Override
+            public boolean canUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canUse();
+            }
+
+            @Override
+            public boolean canContinueToUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canContinueToUse();
+            }
+        });
+        // Purpur end - Add option to disable zombie aggressiveness towards villagers
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Axolotl.class, true, false));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
@@ -392,7 +466,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
         }
     }
 
-    static class DrownedMoveControl extends MoveControl {
+    static class DrownedMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private final Drowned drowned;
 
         public DrownedMoveControl(Drowned mob) {
@@ -401,7 +475,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             LivingEntity target = this.drowned.getTarget();
             if (this.drowned.wantsToSwim() && this.drowned.isInWater()) {
                 if (target != null && target.getY() > this.drowned.getY() || this.drowned.searchingForLand) {
@@ -421,7 +495,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
                 float f = (float)(Mth.atan2(d2, d) * 180.0F / (float)Math.PI) - 90.0F;
                 this.drowned.setYRot(this.rotlerp(this.drowned.getYRot(), f, 90.0F));
                 this.drowned.yBodyRot = this.drowned.getYRot();
-                float f1 = (float)(this.speedModifier * this.drowned.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f1 = (float)(this.getSpeedModifier() * this.drowned.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 float f2 = Mth.lerp(0.125F, this.drowned.getSpeed(), f1);
                 this.drowned.setSpeed(f2);
                 this.drowned.setDeltaMovement(this.drowned.getDeltaMovement().add(f2 * d * 0.005, f2 * d1 * 0.1, f2 * d2 * 0.005));
@@ -430,7 +504,7 @@ public class Drowned extends Zombie implements RangedAttackMob {
                     this.drowned.setDeltaMovement(this.drowned.getDeltaMovement().add(0.0, -0.008, 0.0));
                 }
 
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/ElderGuardian.java b/net/minecraft/world/entity/monster/ElderGuardian.java
index 7eef05b988d52391ab061382fd8898705c705e03..ab1c050ff326a072e817a05958b8f4ec803af063 100644
--- a/net/minecraft/world/entity/monster/ElderGuardian.java
+++ b/net/minecraft/world/entity/monster/ElderGuardian.java
@@ -31,6 +31,40 @@ public class ElderGuardian extends Guardian {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.elderGuardianRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.elderGuardianControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.elderGuardianMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.elderGuardianScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.elderGuardianTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.elderGuardianAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Guardian.createAttributes().add(Attributes.MOVEMENT_SPEED, 0.3F).add(Attributes.ATTACK_DAMAGE, 8.0).add(Attributes.MAX_HEALTH, 80.0);
     }
diff --git a/net/minecraft/world/entity/monster/EnderMan.java b/net/minecraft/world/entity/monster/EnderMan.java
index 4edd94ac765d2ab107612504b67e6e07da609313..fcdb3ee493e65bf002e78862f00061336e731ede 100644
--- a/net/minecraft/world/entity/monster/EnderMan.java
+++ b/net/minecraft/world/entity/monster/EnderMan.java
@@ -86,12 +86,45 @@ public class EnderMan extends Monster implements NeutralMob {
 
     public EnderMan(EntityType<? extends EnderMan> entityType, Level level) {
         super(entityType, level);
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.endermanRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.endermanRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.endermanControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.endermanMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.endermanScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.endermanAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new EnderMan.EndermanFreezeWhenLookedAt(this));
         this.goalSelector.addGoal(2, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0, 0.0F));
@@ -99,9 +132,10 @@ public class EnderMan extends Monster implements NeutralMob {
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
         this.goalSelector.addGoal(10, new EnderMan.EndermanLeaveBlockGoal(this));
         this.goalSelector.addGoal(11, new EnderMan.EndermanTakeBlockGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new EnderMan.EndermanLookForPlayerGoal(this, this::isAngryAt));
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this));
-        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Endermite.class, true, false));
+        this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Endermite.class, 10, true, false, (entityliving, ignored) -> entityliving.level().purpurConfig.endermanAggroEndermites && entityliving instanceof Endermite endermite && (!entityliving.level().purpurConfig.endermanAggroEndermitesOnlyIfPlayerSpawned || endermite.isPlayerSpawned()))); // Purpur
         this.targetSelector.addGoal(4, new ResetUniversalAngerTargetGoal<>(this, false));
     }
 
@@ -216,7 +250,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
     boolean isBeingStaredBy(Player player) {
         // Paper start - EndermanAttackPlayerEvent
-        final boolean shouldAttack = this.isBeingStaredBy0(player);
+        final boolean shouldAttack = !this.level().purpurConfig.endermanDisableStareAggro && this.isBeingStaredBy0(player); // Purpur - Config to ignore Dragon Head wearers and stare aggro
         final com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent event = new com.destroystokyo.paper.event.entity.EndermanAttackPlayerEvent((org.bukkit.entity.Enderman) getBukkitEntity(), (org.bukkit.entity.Player) player.getBukkitEntity());
         event.setCancelled(!shouldAttack);
         return event.callEvent();
@@ -254,12 +288,12 @@ public class EnderMan extends Monster implements NeutralMob {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.endermanTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
     protected void customServerAiStep(ServerLevel level) {
-        if (level.isBrightOutside() && this.tickCount >= this.targetChangeTime + 600) {
+        if ((getRider() == null || !this.isControllable()) && level.isBrightOutside() && this.tickCount >= this.targetChangeTime + 600) { // Purpur - Ridables - no random teleporting
             float lightLevelDependentMagicValue = this.getLightLevelDependentMagicValue();
             if (lightLevelDependentMagicValue > 0.5F
                 && level.canSeeSky(this.blockPosition())
@@ -372,6 +406,8 @@ public class EnderMan extends Monster implements NeutralMob {
     public boolean hurtServer(ServerLevel level, DamageSource damageSource, float amount) {
         if (this.isInvulnerableTo(level, damageSource)) {
             return false;
+        } else if (getRider() != null && this.isControllable()) { return super.hurtServer(level, damageSource, amount); // Purpur - no teleporting on damage
+        } else if (org.purpurmc.purpur.PurpurConfig.endermanShortHeight && damageSource.is(net.minecraft.world.damagesource.DamageTypes.IN_WALL)) { return false; // Purpur - no suffocation damage if short height - Short enderman height
         } else {
             AbstractThrownPotion abstractThrownPotion1 = damageSource.getDirectEntity() instanceof AbstractThrownPotion abstractThrownPotion
                 ? abstractThrownPotion
@@ -388,6 +424,7 @@ public class EnderMan extends Monster implements NeutralMob {
             } else {
                 boolean flag = abstractThrownPotion1 != null && this.hurtWithCleanWater(level, damageSource, abstractThrownPotion1, amount);
 
+                if (!flag && level.purpurConfig.endermanIgnoreProjectiles) return super.hurtServer(level, damageSource, amount); // Purpur - Config to disable Enderman teleport on projectile hit
                 if (this.tryEscape(com.destroystokyo.paper.event.entity.EndermanEscapeEvent.Reason.INDIRECT)) { // Paper - EndermanEscapeEvent
                 for (int i = 0; i < 64; i++) {
                     if (this.teleport()) {
@@ -431,7 +468,7 @@ public class EnderMan extends Monster implements NeutralMob {
 
     @Override
     public boolean requiresCustomPersistence() {
-        return super.requiresCustomPersistence() || this.getCarriedBlock() != null;
+        return super.requiresCustomPersistence() || (!this.level().purpurConfig.endermanDespawnEvenWithBlock && this.getCarriedBlock() != null); // Purpur - Add config for allowing Endermen to despawn even while holding a block
     }
 
     static class EndermanFreezeWhenLookedAt extends Goal {
@@ -475,8 +512,9 @@ public class EnderMan extends Monster implements NeutralMob {
 
         @Override
         public boolean canUse() {
+            if (!enderman.level().purpurConfig.endermanAllowGriefing) return false; // Purpur - Add enderman and creeper griefing controls
             return this.enderman.getCarriedBlock() != null
-                && getServerLevel(this.enderman).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)
+                && getServerLevel(this.enderman).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, this.enderman.level().purpurConfig.endermanMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
                 && this.enderman.getRandom().nextInt(reducedTickDelay(2000)) == 0;
         }
 
@@ -624,8 +662,9 @@ public class EnderMan extends Monster implements NeutralMob {
 
         @Override
         public boolean canUse() {
+            if (!enderman.level().purpurConfig.endermanAllowGriefing) return false; // Purpur - Add enderman and creeper griefing controls
             return this.enderman.getCarriedBlock() == null
-                && getServerLevel(this.enderman).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)
+                && getServerLevel(this.enderman).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, this.enderman.level().purpurConfig.endermanMobGriefingOverride) // Purpur - Add mobGriefing override to everything affected
                 && this.enderman.getRandom().nextInt(reducedTickDelay(20)) == 0;
         }
 
diff --git a/net/minecraft/world/entity/monster/Endermite.java b/net/minecraft/world/entity/monster/Endermite.java
index f448aac89c6125246c730a71e7ee21c8168d7003..4ea0e5f24664a1c8f2c8bdae559784434374adf6 100644
--- a/net/minecraft/world/entity/monster/Endermite.java
+++ b/net/minecraft/world/entity/monster/Endermite.java
@@ -30,20 +30,72 @@ public class Endermite extends Monster {
     private static final int MAX_LIFE = 2400;
     private static final int DEFAULT_LIFE = 0;
     public int life = 0;
+    private boolean isPlayerSpawned; // Purpur - Add back player spawned endermite API
 
     public Endermite(EntityType<? extends Endermite> entityType, Level level) {
         super(entityType, level);
         this.xpReward = 3;
     }
 
+    // Purpur start - Add back player spawned endermite API
+    public boolean isPlayerSpawned() {
+        return this.isPlayerSpawned;
+    }
+
+    public void setPlayerSpawned(boolean playerSpawned) {
+        this.isPlayerSpawned = playerSpawned;
+    }
+    // Purpur end - Add back player spawned endermite API
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.endermiteRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.endermiteRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.endermiteControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.endermiteMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.endermiteScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.endermiteTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.endermiteAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(2, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(3, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(7, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
@@ -81,12 +133,14 @@ public class Endermite extends Monster {
     protected void readAdditionalSaveData(ValueInput input) {
         super.readAdditionalSaveData(input);
         this.life = input.getIntOr("Lifetime", 0);
+        this.isPlayerSpawned = input.getBooleanOr("PlayerSpawned", false); // Purpur - Add back player spawned endermite API
     }
 
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
         output.putInt("Lifetime", this.life);
+        output.putBoolean("PlayerSpawned", this.isPlayerSpawned); // Purpur - Add back player spawned endermite API
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/Evoker.java b/net/minecraft/world/entity/monster/Evoker.java
index 7efa39ab1fb34da41a04cd6816f2571c6eba98f5..5c1992a7fd5d7c5fe23ebfad35a828263d0ff93c 100644
--- a/net/minecraft/world/entity/monster/Evoker.java
+++ b/net/minecraft/world/entity/monster/Evoker.java
@@ -48,10 +48,50 @@ public class Evoker extends SpellcasterIllager {
         this.xpReward = 10;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.evokerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.evokerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.evokerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.evokerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.evokerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.evokerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.evokerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Evoker.EvokerCastingSpellGoal());
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Player.class, 8.0F, 0.6, 1.0));
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 0.6, 1.0));
@@ -61,6 +101,7 @@ public class Evoker extends SpellcasterIllager {
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true).setUnseenMemoryTicks(300));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false).setUnseenMemoryTicks(300));
@@ -279,7 +320,7 @@ public class Evoker extends SpellcasterIllager {
                 return false;
             } else {
                 ServerLevel serverLevel = getServerLevel(Evoker.this.level());
-                if (!serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+                if (!serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.evokerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                     return false;
                 } else {
                     List<Sheep> nearbyEntities = serverLevel.getNearbyEntities(
diff --git a/net/minecraft/world/entity/monster/Ghast.java b/net/minecraft/world/entity/monster/Ghast.java
index bbdff8b4043f27045684a2aa5687e2b7ca7afbb5..6f312f0b8ab60c839129ea671f2d9c128fa58e58 100644
--- a/net/minecraft/world/entity/monster/Ghast.java
+++ b/net/minecraft/world/entity/monster/Ghast.java
@@ -52,11 +52,57 @@ public class Ghast extends Mob implements Enemy {
         this.moveControl = new Ghast.GhastMoveControl(this, false, () -> false);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ghastRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ghastRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ghastControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.ghastMaxY;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ghastMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ghastScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ghastTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ghastAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(5, new Ghast.RandomFloatAroundGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastLookGoal(this));
         this.goalSelector.addGoal(7, new Ghast.GhastShootFireballGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> Math.abs(entity.getY() - this.getY()) <= 4.0));
     }
@@ -106,6 +152,15 @@ public class Ghast extends Mob implements Enemy {
     @Override
     public void travel(Vec3 travelVector) {
         this.travelFlying(travelVector, 0.02F);
+        // Purpur start - Ridables
+        if (getRider() != null && this.isControllable() && !onGround) {
+            float speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -236,7 +291,7 @@ public class Ghast extends Mob implements Enemy {
         }
     }
 
-    public static class GhastMoveControl extends MoveControl {
+    public static class GhastMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         private final Mob ghast;
         private int floatDuration;
         private final boolean careful;
@@ -250,7 +305,7 @@ public class Ghast extends Mob implements Enemy {
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.shouldBeStopped.getAsBoolean()) {
                 this.operation = MoveControl.Operation.WAIT;
                 this.ghast.stopInPlace();
diff --git a/net/minecraft/world/entity/monster/Giant.java b/net/minecraft/world/entity/monster/Giant.java
index ab0b44fd3e20fcab4e2fea985e7471575b619069..f4ec41a74b13be98f3ac78521fdd357842bc9ebd 100644
--- a/net/minecraft/world/entity/monster/Giant.java
+++ b/net/minecraft/world/entity/monster/Giant.java
@@ -12,6 +12,70 @@ public class Giant extends Monster {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.giantRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.giantRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.giantControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        // Purpur start - Giants AI settings
+        if (level().purpurConfig.giantHaveAI) {
+            this.goalSelector.addGoal(0, new net.minecraft.world.entity.ai.goal.FloatGoal(this));
+            this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+            this.goalSelector.addGoal(7, new net.minecraft.world.entity.ai.goal.WaterAvoidingRandomStrollGoal(this, 1.0D));
+            this.goalSelector.addGoal(8, new net.minecraft.world.entity.ai.goal.LookAtPlayerGoal(this, net.minecraft.world.entity.player.Player.class, 16.0F));
+            this.goalSelector.addGoal(8, new net.minecraft.world.entity.ai.goal.RandomLookAroundGoal(this));
+            this.goalSelector.addGoal(5, new net.minecraft.world.entity.ai.goal.MoveTowardsRestrictionGoal(this, 1.0D));
+            if (level().purpurConfig.giantHaveHostileAI) {
+                this.goalSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.MeleeAttackGoal(this, 1.0D, false));
+                this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+                this.targetSelector.addGoal(1, new net.minecraft.world.entity.ai.goal.target.HurtByTargetGoal(this).setAlertOthers(ZombifiedPiglin.class));
+                this.targetSelector.addGoal(2, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.player.Player.class, true));
+                this.targetSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.npc.Villager.class, false));
+                this.targetSelector.addGoal(4, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.animal.IronGolem.class, true));
+                this.targetSelector.addGoal(5, new net.minecraft.world.entity.ai.goal.target.NearestAttackableTargetGoal<>(this, net.minecraft.world.entity.animal.Turtle.class, true));
+            }
+        }
+        // Purpur end - Giants AI settings
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.giantMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.giantScale);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.giantMovementSpeed);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.giantAttackDamage);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.giantTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.giantAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes()
             .add(Attributes.MAX_HEALTH, 100.0)
@@ -20,8 +84,36 @@ public class Giant extends Monster {
             .add(Attributes.CAMERA_DISTANCE, 16.0);
     }
 
+    // Purpur - Giants AI settings
+    @Override
+    public net.minecraft.world.entity.SpawnGroupData finalizeSpawn(net.minecraft.world.level.ServerLevelAccessor world, net.minecraft.world.DifficultyInstance difficulty, net.minecraft.world.entity.EntitySpawnReason spawnReason, @org.jetbrains.annotations.Nullable net.minecraft.world.entity.SpawnGroupData entityData) {
+        net.minecraft.world.entity.SpawnGroupData groupData = super.finalizeSpawn(world, difficulty, spawnReason, entityData);
+        if (groupData == null) {
+            populateDefaultEquipmentSlots(this.random, difficulty);
+            populateDefaultEquipmentEnchantments(world, this.random, difficulty);
+        }
+        return groupData;
+    }
+
+    @Override
+    protected void populateDefaultEquipmentSlots(net.minecraft.util.RandomSource random, net.minecraft.world.DifficultyInstance difficulty) {
+        super.populateDefaultEquipmentSlots(this.random, difficulty);
+        // TODO make configurable
+        if (random.nextFloat() < (level().getDifficulty() == net.minecraft.world.Difficulty.HARD ? 0.1F : 0.05F)) {
+            this.setItemSlot(net.minecraft.world.entity.EquipmentSlot.MAINHAND, new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.IRON_SWORD));
+        }
+    }
+
+    @Override
+    public float getJumpPower() {
+        // make giants jump as high as everything else relative to their size
+        // 1.0 makes bottom of feet about as high as their waist when they jump
+        return level().purpurConfig.giantJumpHeight;
+    }
+    // Purpur end - Giants AI settings
+
     @Override
     public float getWalkTargetValue(BlockPos pos, LevelReader level) {
-        return level.getPathfindingCostFromLightLevels(pos);
+        return super.getWalkTargetValue(pos, level); // Purpur - Giants AI settings - fix light requirements for natural spawns
     }
 }
diff --git a/net/minecraft/world/entity/monster/Guardian.java b/net/minecraft/world/entity/monster/Guardian.java
index a36f0181e1aa24538d6c868a8675da89427bdeae..3ba8da3bd04774fb3131fdbd2aa0bd6c9f31c817 100644
--- a/net/minecraft/world/entity/monster/Guardian.java
+++ b/net/minecraft/world/entity/monster/Guardian.java
@@ -66,14 +66,57 @@ public class Guardian extends Monster {
         this.xpReward = 10;
         this.setPathfindingMalus(PathType.WATER, 0.0F);
         this.moveControl = new Guardian.GuardianMoveControl(this);
+        // Purpur start - Ridables
+        this.lookControl = new org.purpurmc.purpur.controller.LookControllerWASD(this) {
+            @Override
+            public void setYawPitch(float yaw, float pitch) {
+                super.setYawPitch(yaw, pitch * 0.35F);
+            }
+        };
+        // Purpur end - Ridables
         this.clientSideTailAnimation = this.random.nextFloat();
         this.clientSideTailAnimationO = this.clientSideTailAnimation;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.guardianRidable;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.guardianControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.guardianMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.guardianScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.guardianTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.guardianAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         MoveTowardsRestrictionGoal moveTowardsRestrictionGoal = new MoveTowardsRestrictionGoal(this, 1.0);
         this.randomStrollGoal = new RandomStrollGoal(this, 1.0, 80);
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, this.guardianAttackGoal = new Guardian.GuardianAttackGoal(this)); // CraftBukkit - assign field
         this.goalSelector.addGoal(5, moveTowardsRestrictionGoal);
         this.goalSelector.addGoal(7, this.randomStrollGoal);
@@ -82,6 +125,7 @@ public class Guardian extends Monster {
         this.goalSelector.addGoal(9, new RandomLookAroundGoal(this));
         this.randomStrollGoal.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK));
         moveTowardsRestrictionGoal.setFlags(EnumSet.of(Goal.Flag.MOVE, Goal.Flag.LOOK));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new NearestAttackableTargetGoal<>(this, LivingEntity.class, 10, true, false, new Guardian.GuardianAttackSelector(this)));
     }
 
@@ -344,7 +388,7 @@ public class Guardian extends Monster {
     @Override
     public void travel(Vec3 travelVector) {
         if (this.isInWater()) {
-            this.moveRelative(0.1F, travelVector);
+            this.moveRelative(getRider() != null && this.isControllable() ? getSpeed() : 0.1F, travelVector); // Purpur - Ridables
             this.move(MoverType.SELF, this.getDeltaMovement());
             this.setDeltaMovement(this.getDeltaMovement().scale(0.9));
             if (!this.isMoving() && this.getTarget() == null) {
@@ -452,7 +496,7 @@ public class Guardian extends Monster {
         }
     }
 
-    static class GuardianMoveControl extends MoveControl {
+    static class GuardianMoveControl extends org.purpurmc.purpur.controller.WaterMoveControllerWASD { // Purpur - Ridables
         private final Guardian guardian;
 
         public GuardianMoveControl(Guardian mob) {
@@ -460,8 +504,17 @@ public class Guardian extends Monster {
             this.guardian = mob;
         }
 
+        // Purpur start - Ridables
         @Override
-        public void tick() {
+        public void purpurTick(Player rider) {
+            super.purpurTick(rider);
+            guardian.setDeltaMovement(guardian.getDeltaMovement().add(0.0D, 0.005D, 0.0D));
+            guardian.setMoving(guardian.getForwardMot() > 0.0F); // control tail speed
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
             if (this.operation == MoveControl.Operation.MOVE_TO && !this.guardian.getNavigation().isDone()) {
                 Vec3 vec3 = new Vec3(this.wantedX - this.guardian.getX(), this.wantedY - this.guardian.getY(), this.wantedZ - this.guardian.getZ());
                 double len = vec3.length();
@@ -471,7 +524,7 @@ public class Guardian extends Monster {
                 float f = (float)(Mth.atan2(vec3.z, vec3.x) * 180.0F / (float)Math.PI) - 90.0F;
                 this.guardian.setYRot(this.rotlerp(this.guardian.getYRot(), f, 90.0F));
                 this.guardian.yBodyRot = this.guardian.getYRot();
-                float f1 = (float)(this.speedModifier * this.guardian.getAttributeValue(Attributes.MOVEMENT_SPEED));
+                float f1 = (float)(this.getSpeedModifier() * this.guardian.getAttributeValue(Attributes.MOVEMENT_SPEED)); // Purpur - Ridables
                 float f2 = Mth.lerp(0.125F, this.guardian.getSpeed(), f1);
                 this.guardian.setSpeed(f2);
                 double d3 = Math.sin((this.guardian.tickCount + this.guardian.getId()) * 0.5) * 0.05;
diff --git a/net/minecraft/world/entity/monster/Husk.java b/net/minecraft/world/entity/monster/Husk.java
index 8d6def85583a111841b28f20f58ddb8b8cbd7bc1..a4ce65911a5d778f60bcedb3acd9fe59a5094c96 100644
--- a/net/minecraft/world/entity/monster/Husk.java
+++ b/net/minecraft/world/entity/monster/Husk.java
@@ -19,8 +19,69 @@ import net.minecraft.world.level.ServerLevelAccessor;
 public class Husk extends Zombie {
     public Husk(EntityType<? extends Husk> entityType, Level level) {
         super(entityType, level);
+        this.setShouldBurnInDay(false); // Purpur - API for any mob to burn daylight
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.huskRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.huskRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.huskControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.huskMaxHealth);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.huskSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.huskJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.huskJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.huskJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.huskTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.huskAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static boolean checkHuskSpawnRules(
         EntityType<Husk> entityType, ServerLevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
@@ -29,7 +90,7 @@ public class Husk extends Zombie {
 
     @Override
     public boolean isSunSensitive() {
-        return false;
+        return this.shouldBurnInDay; // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/Illusioner.java b/net/minecraft/world/entity/monster/Illusioner.java
index 7441b019f669653e3e738f27c866270c30acffd4..2ea8c8480dcc15eb5b4bc9686554ec912ef1f3f4 100644
--- a/net/minecraft/world/entity/monster/Illusioner.java
+++ b/net/minecraft/world/entity/monster/Illusioner.java
@@ -57,10 +57,52 @@ public class Illusioner extends SpellcasterIllager implements RangedAttackMob {
         }
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.illusionerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.illusionerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.illusionerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected void initAttributes() {
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.illusionerMovementSpeed);
+        this.getAttribute(Attributes.FOLLOW_RANGE).setBaseValue(this.level().purpurConfig.illusionerFollowRange);
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.illusionerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.illusionerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.illusionerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.illusionerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new SpellcasterIllager.SpellcasterCastingSpellGoal());
         this.goalSelector.addGoal(3, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(4, new Illusioner.IllusionerMirrorSpellGoal());
@@ -69,6 +111,7 @@ public class Illusioner extends SpellcasterIllager implements RangedAttackMob {
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true).setUnseenMemoryTicks(300));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false).setUnseenMemoryTicks(300));
diff --git a/net/minecraft/world/entity/monster/MagmaCube.java b/net/minecraft/world/entity/monster/MagmaCube.java
index 889c31cc9257fbbd5df8325ccee9ce39b026ec4b..7ef0f84d4c449a8991683ca66d7b16ca21ef4cdf 100644
--- a/net/minecraft/world/entity/monster/MagmaCube.java
+++ b/net/minecraft/world/entity/monster/MagmaCube.java
@@ -24,6 +24,64 @@ public class MagmaCube extends Slime {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.magmaCubeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.magmaCubeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.magmaCubeControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        return 0.42F * this.getBlockJumpFactor(); // from EntityLiving
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    protected String getMaxHealthEquation() {
+        return level().purpurConfig.magmaCubeMaxHealth;
+    }
+
+    @Override
+    protected String getAttackDamageEquation() {
+        return level().purpurConfig.magmaCubeAttackDamage;
+    }
+
+    @Override
+    protected java.util.Map<Integer, Double> getMaxHealthCache() {
+        return level().purpurConfig.magmaCubeMaxHealthCache;
+    }
+
+    @Override
+    protected java.util.Map<Integer, Double> getAttackDamageCache() {
+        return level().purpurConfig.magmaCubeAttackDamageCache;
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.magmaCubeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.magmaCubeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes().add(Attributes.MOVEMENT_SPEED, 0.2F);
     }
@@ -71,6 +129,7 @@ public class MagmaCube extends Slime {
         float f = this.getSize() * 0.1F;
         this.setDeltaMovement(deltaMovement.x, this.getJumpPower() + f, deltaMovement.z);
         this.hasImpulse = true;
+        this.actualJump = false; // Purpur - Ridables
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/Monster.java b/net/minecraft/world/entity/monster/Monster.java
index 5ef9566b16a4d0300ee45a993c46e734db156416..04d5910d736dee2a88a2602f4a98495459277157 100644
--- a/net/minecraft/world/entity/monster/Monster.java
+++ b/net/minecraft/world/entity/monster/Monster.java
@@ -88,6 +88,14 @@ public abstract class Monster extends PathfinderMob implements Enemy {
     }
 
     public static boolean isDarkEnoughToSpawn(ServerLevelAccessor level, BlockPos pos, RandomSource random) {
+        // Purpur start - Config to disable hostile mob spawn on ice
+        if (!level.getMinecraftWorld().purpurConfig.mobsSpawnOnPackedIce || !level.getMinecraftWorld().purpurConfig.mobsSpawnOnBlueIce) {
+            net.minecraft.world.level.block.state.BlockState spawnBlock = level.getBlockState(pos.below());
+            if ((!level.getMinecraftWorld().purpurConfig.mobsSpawnOnPackedIce && spawnBlock.is(net.minecraft.world.level.block.Blocks.PACKED_ICE)) || (!level.getMinecraftWorld().purpurConfig.mobsSpawnOnBlueIce && spawnBlock.is(net.minecraft.world.level.block.Blocks.BLUE_ICE))) {
+                return false;
+            }
+        }
+        // Purpur end - Config to disable hostile mob spawn on ice
         if (level.getBrightness(LightLayer.SKY, pos) > random.nextInt(32)) {
             return false;
         } else {
diff --git a/net/minecraft/world/entity/monster/Phantom.java b/net/minecraft/world/entity/monster/Phantom.java
index ffcfdbc80df2a9e6c546348b86e7615e6109eb49..57864e45811df4870e4c5abd87e4f5e52fd91d50 100644
--- a/net/minecraft/world/entity/monster/Phantom.java
+++ b/net/minecraft/world/entity/monster/Phantom.java
@@ -49,19 +49,111 @@ public class Phantom extends Mob implements Enemy {
     @Nullable
     public BlockPos anchorPoint;
     Phantom.AttackPhase attackPhase = Phantom.AttackPhase.CIRCLE;
+    Vec3 crystalPosition; // Purpur - Phantoms attracted to crystals and crystals shoot phantoms
     // Paper start
     @Nullable
     public java.util.UUID spawningEntity;
-    public boolean shouldBurnInDay = true;
+    //public boolean shouldBurnInDay = true; // Purpur - API for any mob to burn daylight
     // Paper end
+    private static final net.minecraft.world.item.crafting.Ingredient TORCH = net.minecraft.world.item.crafting.Ingredient.of(net.minecraft.world.item.Items.TORCH, net.minecraft.world.item.Items.SOUL_TORCH); // Purpur - Phantoms burn in light
 
     public Phantom(EntityType<? extends Phantom> entityType, Level level) {
         super(entityType, level);
         this.xpReward = 5;
         this.moveControl = new Phantom.PhantomMoveControl(this);
         this.lookControl = new Phantom.PhantomLookControl(this);
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.phantomRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.phantomRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.phantomControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.phantomMaxY;
+    }
+
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return Monster.createMonsterAttributes().add(Attributes.FLYING_SPEED, 3.0D);
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (getRider() != null && getRider().getBukkitEntity().hasPermission("allow.special.phantom")) {
+            shoot();
+        }
+        return false;
+    }
+
+    public boolean shoot() {
+        org.bukkit.Location loc = ((org.bukkit.entity.LivingEntity) getBukkitEntity()).getEyeLocation();
+        loc.setPitch(-loc.getPitch());
+        org.bukkit.util.Vector target = loc.getDirection().normalize().multiply(100).add(loc.toVector());
+
+        org.purpurmc.purpur.entity.projectile.PhantomFlames flames = new org.purpurmc.purpur.entity.projectile.PhantomFlames(level(), this);
+        flames.canGrief = level().purpurConfig.phantomAllowGriefing;
+        flames.shoot(target.getX() - getX(), target.getY() - getY(), target.getZ() - getZ(), 1.0F, 5.0F);
+        level().addFreshEntity(flames);
+        return true;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    @Override
+    protected void dropFromLootTable(ServerLevel world, DamageSource damageSource, boolean causedByPlayer) {
+        boolean dropped = false;
+        if (lastHurtByPlayer == null && damageSource.getEntity() instanceof net.minecraft.world.entity.boss.enderdragon.EndCrystal) {
+            if (random.nextInt(5) < 1) {
+                dropped = spawnAtLocation(world, new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.PHANTOM_MEMBRANE)) != null;
+            }
+        }
+        if (!dropped) {
+            super.dropFromLootTable(world, damageSource, causedByPlayer);
+        }
+    }
+
+    public boolean isCirclingCrystal() {
+        return crystalPosition != null;
+    }
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.phantomTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    //private boolean shouldBurnInDay = true; // Purpur - moved to LivingEntity; keep methods for ABI compatibility - API for any mob to burn daylight
+    // Purpur start - API for any mob to burn daylight
+    public boolean shouldBurnInDay() {
+        boolean burnFromDaylight = this.shouldBurnInDay && this.level().purpurConfig.phantomBurnInDaylight;
+        boolean burnFromLightSource = this.level().purpurConfig.phantomBurnInLight > 0 && this.level().getMaxLocalRawBrightness(blockPosition()) >= this.level().purpurConfig.phantomBurnInLight;
+        return burnFromDaylight || burnFromLightSource;
+    }
+    public void setShouldBurnInDay(boolean shouldBurnInDay) { this.shouldBurnInDay = shouldBurnInDay; }
+    // Purpur end - API for any mob to burn daylight
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.phantomAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return (this.getUniqueFlapTickOffset() + this.tickCount) % TICKS_PER_FLAP == 0;
@@ -74,9 +166,17 @@ public class Phantom extends Mob implements Enemy {
 
     @Override
     protected void registerGoals() {
-        this.goalSelector.addGoal(1, new Phantom.PhantomAttackStrategyGoal());
-        this.goalSelector.addGoal(2, new Phantom.PhantomSweepAttackGoal());
-        this.goalSelector.addGoal(3, new Phantom.PhantomCircleAroundAnchorGoal());
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+        if (level().purpurConfig.phantomOrbitCrystalRadius > 0) {
+            this.goalSelector.addGoal(1, new PhantomFindCrystalGoal(this));
+            this.goalSelector.addGoal(2, new PhantomOrbitCrystalGoal(this));
+        }
+        this.goalSelector.addGoal(3, new Phantom.PhantomAttackStrategyGoal());
+        this.goalSelector.addGoal(4, new Phantom.PhantomSweepAttackGoal());
+        this.goalSelector.addGoal(5, new Phantom.PhantomCircleAroundAnchorGoal());
+        // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new Phantom.PhantomAttackPlayerTargetGoal());
     }
 
@@ -92,7 +192,11 @@ public class Phantom extends Mob implements Enemy {
 
     private void updatePhantomSizeInfo() {
         this.refreshDimensions();
-        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(6 + this.getPhantomSize());
+        if (level().purpurConfig.phantomFlamesOnSwoop && attackPhase == AttackPhase.SWOOP) shoot(); // Purpur - Ridables - Phantom flames on swoop
+        // Purpur start - Configurable entity base attributes
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(getFromCache(() -> this.level().purpurConfig.phantomMaxHealth, () -> this.level().purpurConfig.phantomMaxHealthCache, () -> 20.0D));
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(getFromCache(() -> this.level().purpurConfig.phantomAttackDamage, () -> this.level().purpurConfig.phantomAttackDamageCache, () -> (double) (6 + this.getPhantomSize())));
+        // Purpur end - Configurable entity base attributes
     }
 
     public int getPhantomSize() {
@@ -117,6 +221,23 @@ public class Phantom extends Mob implements Enemy {
         return true;
     }
 
+    // Purpur start - Configurable entity base attributes
+    private double getFromCache(java.util.function.Supplier<String> equation, java.util.function.Supplier<java.util.Map<Integer, Double>> cache, java.util.function.Supplier<Double> defaultValue) {
+        int size = getPhantomSize();
+        Double value = cache.get().get(size);
+        if (value == null) {
+            try {
+                value = ((Number) scriptEngine.eval("let size = " + size + "; " + equation.get())).doubleValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                value = defaultValue.get();
+            }
+            cache.get().put(size, value);
+        }
+        return value;
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     public void tick() {
         super.tick();
@@ -148,10 +269,7 @@ public class Phantom extends Mob implements Enemy {
 
     @Override
     public void aiStep() {
-        if (this.isAlive() && this.shouldBurnInDay && this.isSunBurnTick()) { // Paper - shouldBurnInDay API
-            this.igniteForSeconds(8.0F);
-        }
-
+        // Purpur - implemented in LivingEntity; moved down to shouldBurnInDay() - API for any mob to burn daylight
         super.aiStep();
     }
 
@@ -167,6 +285,15 @@ public class Phantom extends Mob implements Enemy {
     @Override
     public void travel(Vec3 travelVector) {
         this.travelFlying(travelVector, 0.2F);
+        // Purpur start - Ridables
+        if (this.getRider() != null && this.isControllable() && !this.onGround) {
+            float speed = (float) this.getAttributeValue(Attributes.FLYING_SPEED);
+            this.setSpeed(speed);
+            Vec3 mot = this.getDeltaMovement();
+            this.move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, speed, speed));
+            this.setDeltaMovement(mot.scale(0.9D));
+        }
+        // Purpur end - Ridables
     }
 
     @Override
@@ -174,7 +301,11 @@ public class Phantom extends Mob implements Enemy {
         ServerLevelAccessor level, DifficultyInstance difficulty, EntitySpawnReason spawnReason, @Nullable SpawnGroupData spawnGroupData
     ) {
         this.anchorPoint = this.blockPosition().above(5);
-        this.setPhantomSize(0);
+        // Purpur start - Configurable phantom size
+        int min = level.getLevel().purpurConfig.phantomMinSize;
+        int max = level.getLevel().purpurConfig.phantomMaxSize;
+        this.setPhantomSize(min == max ? min : level.getRandom().nextInt(max + 1 - min) + min);
+        // Purpur end - Configurable phantom size
         return super.finalizeSpawn(level, difficulty, spawnReason, spawnGroupData);
     }
 
@@ -185,7 +316,7 @@ public class Phantom extends Mob implements Enemy {
         this.setPhantomSize(input.getIntOr("size", 0));
         // Paper start
         this.spawningEntity = input.read("Paper.SpawningEntity", net.minecraft.core.UUIDUtil.CODEC).orElse(null);
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true);
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         // Paper end
     }
 
@@ -196,7 +327,7 @@ public class Phantom extends Mob implements Enemy {
         output.putInt("size", this.getPhantomSize());
         // Paper start
         output.storeNullable("Paper.SpawningEntity", net.minecraft.core.UUIDUtil.CODEC, this.spawningEntity);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay);
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         // Paper end
     }
 
@@ -266,6 +397,7 @@ public class Phantom extends Mob implements Enemy {
                 List<Player> nearbyPlayers = serverLevel.getNearbyPlayers(
                     this.attackTargeting, Phantom.this, Phantom.this.getBoundingBox().inflate(16.0, 64.0, 16.0)
                 );
+                if (level().purpurConfig.phantomIgnorePlayersWithTorch) nearbyPlayers.removeIf(human -> TORCH.test(human.getItemInHand(net.minecraft.world.InteractionHand.MAIN_HAND)) || TORCH.test(human.getItemInHand(net.minecraft.world.InteractionHand.OFF_HAND))); // Purpur - Phantoms burn in light
                 if (!nearbyPlayers.isEmpty()) {
                     nearbyPlayers.sort(Comparator.<Player, Double>comparing(Entity::getY).reversed());
 
@@ -415,25 +547,160 @@ public class Phantom extends Mob implements Enemy {
         }
     }
 
-    static class PhantomLookControl extends LookControl {
+    static class PhantomLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public PhantomLookControl(Mob mob) {
             super(mob);
         }
 
+        // Purpur start - Ridables
+        public void purpurTick(Player rider) {
+            setYawPitch(rider.getYRot(), -rider.xRotO * 0.75F);
+        }
+        // Purpur end - Ridables
+
+        @Override
+        public void vanillaTick() { // Purpur - Ridables
+        }
+    }
+
+    // Purpur start - Phantoms attracted to crystals and crystals shoot phantoms
+    class PhantomFindCrystalGoal extends Goal {
+        private final Phantom phantom;
+        private net.minecraft.world.entity.boss.enderdragon.EndCrystal crystal;
+        private Comparator<net.minecraft.world.entity.boss.enderdragon.EndCrystal> comparator;
+
+        PhantomFindCrystalGoal(Phantom phantom) {
+            this.phantom = phantom;
+            this.comparator = Comparator.comparingDouble(phantom::distanceToSqr);
+            this.setFlags(EnumSet.of(Flag.LOOK));
+        }
+
+        @Override
+        public boolean canUse() {
+            double range = maxTargetRange();
+            List<net.minecraft.world.entity.boss.enderdragon.EndCrystal> crystals = level().getEntitiesOfClass(net.minecraft.world.entity.boss.enderdragon.EndCrystal.class, phantom.getBoundingBox().inflate(range));
+            if (crystals.isEmpty()) {
+                return false;
+            }
+            crystals.sort(comparator);
+            crystal = crystals.get(0);
+            if (phantom.distanceToSqr(crystal) > range * range) {
+                crystal = null;
+                return false;
+            }
+            return true;
+        }
+
+        @Override
+        public boolean canContinueToUse() {
+            if (crystal == null || !crystal.isAlive()) {
+                return false;
+            }
+            double range = maxTargetRange();
+            return phantom.distanceToSqr(crystal) <= (range * range) * 2;
+        }
+
+        @Override
+        public void start() {
+            phantom.crystalPosition = new Vec3(crystal.getX(), crystal.getY() + (phantom.random.nextInt(10) + 10), crystal.getZ());
+        }
+
+        @Override
+        public void stop() {
+            crystal = null;
+            phantom.crystalPosition = null;
+            super.stop();
+        }
+
+        private double maxTargetRange() {
+            return phantom.level().purpurConfig.phantomOrbitCrystalRadius;
+        }
+    }
+
+    class PhantomOrbitCrystalGoal extends Goal {
+        private final Phantom phantom;
+        private float offset;
+        private float radius;
+        private float verticalChange;
+        private float direction;
+
+        PhantomOrbitCrystalGoal(Phantom phantom) {
+            this.phantom = phantom;
+            this.setFlags(EnumSet.of(Flag.MOVE));
+        }
+
+        @Override
+        public boolean canUse() {
+            return phantom.isCirclingCrystal();
+        }
+
+        @Override
+        public void start() {
+            this.radius = 5.0F + phantom.random.nextFloat() * 10.0F;
+            this.verticalChange = -4.0F + phantom.random.nextFloat() * 9.0F;
+            this.direction = phantom.random.nextBoolean() ? 1.0F : -1.0F;
+            updateOffset();
+        }
+
         @Override
         public void tick() {
+            if (phantom.random.nextInt(350) == 0) {
+                this.verticalChange = -4.0F + phantom.random.nextFloat() * 9.0F;
+            }
+            if (phantom.random.nextInt(250) == 0) {
+                ++this.radius;
+                if (this.radius > 15.0F) {
+                    this.radius = 5.0F;
+                    this.direction = -this.direction;
+                }
+            }
+            if (phantom.random.nextInt(450) == 0) {
+                this.offset = phantom.random.nextFloat() * 2.0F * 3.1415927F;
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.distanceToSqr(phantom.getX(), phantom.getY(), phantom.getZ()) < 4.0D) {
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.y < phantom.getY() && !phantom.level().isEmptyBlock(new BlockPos(phantom).below(1))) {
+                this.verticalChange = Math.max(1.0F, this.verticalChange);
+                updateOffset();
+            }
+            if (phantom.moveTargetPoint.y > phantom.getY() && !phantom.level().isEmptyBlock(new BlockPos(phantom).above(1))) {
+                this.verticalChange = Math.min(-1.0F, this.verticalChange);
+                updateOffset();
+            }
+        }
+
+        private void updateOffset() {
+            this.offset += this.direction * 15.0F * 0.017453292F;
+            phantom.moveTargetPoint = phantom.crystalPosition.add(
+                    this.radius * Mth.cos(this.offset),
+                    -4.0F + this.verticalChange,
+                    this.radius * Mth.sin(this.offset));
         }
     }
+    // Purpur end - Phantoms attracted to crystals and crystals shoot phantoms
 
-    class PhantomMoveControl extends MoveControl {
+    class PhantomMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         private float speed = 0.1F;
 
         public PhantomMoveControl(final Mob mob) {
             super(mob);
         }
 
+        // Purpur start - Ridables
+        public void purpurTick(Player rider) {
+            if (!Phantom.this.onGround) {
+                // phantom is always in motion when flying
+                // TODO - FIX THIS
+                // rider.setForward(1.0F);
+            }
+            super.purpurTick(rider);
+        }
+        // Purpur end - Ridables
+
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Phantom.this.horizontalCollision) {
                 Phantom.this.setYRot(Phantom.this.getYRot() + 180.0F);
                 this.speed = 0.1F;
@@ -500,6 +767,12 @@ public class Phantom extends Mob implements Enemy {
                 return false;
             } else if (!target.isAlive()) {
                 return false;
+            // Purpur start - Phantoms burn in light
+            } else if (level().purpurConfig.phantomBurnInLight > 0 && level().getLightEmission(new BlockPos(Phantom.this)) >= level().purpurConfig.phantomBurnInLight) {
+                return false;
+            } else if (level().purpurConfig.phantomIgnorePlayersWithTorch && (TORCH.test(target.getItemInHand(net.minecraft.world.InteractionHand.MAIN_HAND)) || TORCH.test(target.getItemInHand(net.minecraft.world.InteractionHand.OFF_HAND)))) {
+                return false;
+            // Purpur end - Phantoms burn in light
             } else if (target instanceof Player player && (target.isSpectator() || player.isCreative())) {
                 return false;
             } else if (!this.canUse()) {
diff --git a/net/minecraft/world/entity/monster/Pillager.java b/net/minecraft/world/entity/monster/Pillager.java
index 4f72db7e6f99844761de2f749e52cda156b08ad7..2ed473468032bb6edbd03882b5f5405b90a2f0f4 100644
--- a/net/minecraft/world/entity/monster/Pillager.java
+++ b/net/minecraft/world/entity/monster/Pillager.java
@@ -64,16 +64,57 @@ public class Pillager extends AbstractIllager implements CrossbowAttackMob, Inve
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.pillagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.pillagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.pillagerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.pillagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.pillagerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.pillagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.pillagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(2, new Raider.HoldGroundAttackGoal(this, 10.0F));
         this.goalSelector.addGoal(3, new RangedCrossbowAttackGoal<>(this, 1.0, 8.0F));
         this.goalSelector.addGoal(8, new RandomStrollGoal(this, 0.6));
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 15.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 15.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false));
diff --git a/net/minecraft/world/entity/monster/Ravager.java b/net/minecraft/world/entity/monster/Ravager.java
index 9d84bf2cffee25404eebbefdc9cc3f37ebc386b0..2b85cedf235e673d6030c2a649abf60b5792b242 100644
--- a/net/minecraft/world/entity/monster/Ravager.java
+++ b/net/minecraft/world/entity/monster/Ravager.java
@@ -70,14 +70,62 @@ public class Ravager extends Raider {
         this.setPathfindingMalus(PathType.LEAVES, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.ravagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.ravagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.ravagerControllable;
+    }
+
+    @Override
+    public void onMount(Player rider) {
+        super.onMount(rider);
+        getNavigation().stop();
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.ravagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.ravagerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.ravagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.ravagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        if (level().purpurConfig.ravagerAvoidRabbits) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.AvoidEntityGoal<>(this, net.minecraft.world.entity.animal.Rabbit.class, 6.0F, 1.0D, 1.2D)); // Purpur - option to make ravagers afraid of rabbits
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, true));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.4));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 6.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(2, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(4, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, true, (entity, level) -> !entity.isBaby()));
@@ -134,7 +182,7 @@ public class Ravager extends Raider {
     @Override
     public void aiStep() {
         super.aiStep();
-        if (this.isAlive()) {
+        if (this.isAlive() && (getRider() == null || !this.isControllable())) { // Purpur - Ridables
             if (this.isImmobile()) {
                 this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(0.0);
             } else {
@@ -145,7 +193,7 @@ public class Ravager extends Raider {
 
             if (this.level() instanceof ServerLevel serverLevel
                 && this.horizontalCollision
-                && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING)) {
+                && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.ravagerMobGriefingOverride)) { // Purpur - Add mobGriefing override to everything affected
                 boolean flag = false;
                 AABB aabb = this.getBoundingBox().inflate(0.2);
 
@@ -154,7 +202,7 @@ public class Ravager extends Raider {
                 )) {
                     BlockState blockState = serverLevel.getBlockState(blockPos);
                     Block block = blockState.getBlock();
-                    if (block instanceof LeavesBlock) {
+                    if (this.level().purpurConfig.ravagerGriefableBlocks.contains(block)) { // Purpur - Configurable ravager griefable blocks list
                         // CraftBukkit start
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, blockPos, blockState.getFluidState().createLegacyBlock())) { // Paper - fix wrong block state
                             continue;
diff --git a/net/minecraft/world/entity/monster/Shulker.java b/net/minecraft/world/entity/monster/Shulker.java
index f667fc5ff1ea4149cb25608e0d12f9f73f86095e..a46ca09f661a4f8f3ede6550d613e0c704a9389b 100644
--- a/net/minecraft/world/entity/monster/Shulker.java
+++ b/net/minecraft/world/entity/monster/Shulker.java
@@ -94,12 +94,68 @@ public class Shulker extends AbstractGolem implements Enemy {
         this.lookControl = new Shulker.ShulkerLookControl(this);
     }
 
+    // Purpur start - Shulker change color with dye
+    @Override
+    protected net.minecraft.world.InteractionResult mobInteract(Player player, net.minecraft.world.InteractionHand hand) {
+        net.minecraft.world.item.ItemStack itemstack = player.getItemInHand(hand);
+        if (player.level().purpurConfig.shulkerChangeColorWithDye && itemstack.getItem() instanceof net.minecraft.world.item.DyeItem dye && dye.getDyeColor() != this.getColor()) {
+            this.setVariant(Optional.of(dye.getDyeColor()));
+            if (!player.getAbilities().instabuild) {
+                itemstack.shrink(1);
+            }
+            return net.minecraft.world.InteractionResult.SUCCESS;
+        }
+        return super.mobInteract(player, hand);
+    }
+    // Purpur end - Shulker change color with dye
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.shulkerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.shulkerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.shulkerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.shulkerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.shulkerScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.shulkerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.shulkerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new LookAtPlayerGoal(this, Player.class, 8.0F, 0.02F, true));
         this.goalSelector.addGoal(4, new Shulker.ShulkerAttackGoal());
         this.goalSelector.addGoal(7, new Shulker.ShulkerPeekGoal());
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, this.getClass()).setAlertOthers());
         this.targetSelector.addGoal(2, new Shulker.ShulkerNearestAttackGoal(this));
         this.targetSelector.addGoal(3, new Shulker.ShulkerDefenseAttackGoal(this));
@@ -461,11 +517,21 @@ public class Shulker extends AbstractGolem implements Enemy {
     private void hitByShulkerBullet() {
         Vec3 vec3 = this.position();
         AABB boundingBox = this.getBoundingBox();
-        if (!this.isClosed() && this.teleportSomewhere()) {
-            int size = this.level().getEntities(EntityType.SHULKER, boundingBox.inflate(8.0), Entity::isAlive).size();
-            float f = (size - 1) / 5.0F;
-            if (!(this.level().random.nextFloat() < f)) {
+        // Purpur start - Shulker spawn from bullet options
+        if ((!this.level().purpurConfig.shulkerSpawnFromBulletRequireOpenLid || !this.isClosed()) && this.teleportSomewhere()) {
+            float chance = this.level().purpurConfig.shulkerSpawnFromBulletBaseChance;
+            if (!this.level().purpurConfig.shulkerSpawnFromBulletNearbyEquation.isBlank()) {
+                int nearby = this.level().getEntities((net.minecraft.world.level.entity.EntityTypeTest) EntityType.SHULKER, boundingBox.inflate(this.level().purpurConfig.shulkerSpawnFromBulletNearbyRange), Entity::isAlive).size();
+                try {
+                    chance -= ((Number) scriptEngine.eval("let nearby = " + nearby + "; " + this.level().purpurConfig.shulkerSpawnFromBulletNearbyEquation)).floatValue();
+                } catch (javax.script.ScriptException e) {
+                    e.printStackTrace();
+                    chance -= (nearby - 1) / 5.0F;
+                }
+            }
+            if (this.level().random.nextFloat() <= chance) {
                 Shulker shulker = EntityType.SHULKER.create(this.level(), EntitySpawnReason.BREEDING);
+                // Purpur end - Shulker spawn from bullet options
                 if (shulker != null) {
                     shulker.setVariant(this.getVariant());
                     shulker.snapTo(vec3);
@@ -565,7 +631,7 @@ public class Shulker extends AbstractGolem implements Enemy {
 
     @Override
     protected float sanitizeScale(float scale) {
-        return Math.min(scale, 3.0F);
+        return Math.min(scale, MAX_SCALE); // Purpur - Configurable entity base attributes
     }
 
     private void setVariant(Optional<DyeColor> variant) {
@@ -573,7 +639,7 @@ public class Shulker extends AbstractGolem implements Enemy {
     }
 
     public Optional<DyeColor> getVariant() {
-        return Optional.ofNullable(this.getColor());
+        return Optional.ofNullable(this.level().purpurConfig.shulkerSpawnFromBulletRandomColor ? DyeColor.random(this.level().random) : this.getColor()); // Purpur - Shulker spawn from bullet options
     }
 
     @Nullable
@@ -693,7 +759,7 @@ public class Shulker extends AbstractGolem implements Enemy {
         }
     }
 
-    class ShulkerLookControl extends LookControl {
+    class ShulkerLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables
         public ShulkerLookControl(final Mob mob) {
             super(mob);
         }
diff --git a/net/minecraft/world/entity/monster/Silverfish.java b/net/minecraft/world/entity/monster/Silverfish.java
index 4e34833ea5c71b817c9f42a58320fe100981ec93..bcae390578519fef362a126fbcf2b5cfd18c3dc4 100644
--- a/net/minecraft/world/entity/monster/Silverfish.java
+++ b/net/minecraft/world/entity/monster/Silverfish.java
@@ -39,14 +39,57 @@ public class Silverfish extends Monster {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.silverfishRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.silverfishRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.silverfishControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.silverfishMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.silverfishScale);
+        this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(this.level().purpurConfig.silverfishMovementSpeed);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(this.level().purpurConfig.silverfishAttackDamage);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.silverfishTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.silverfishAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.friendsGoal = new Silverfish.SilverfishWakeUpFriendsGoal(this);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new ClimbOnTopOfPowderSnowGoal(this, this.level()));
         this.goalSelector.addGoal(3, this.friendsGoal);
         this.goalSelector.addGoal(4, new MeleeAttackGoal(this, 1.0, false));
         this.goalSelector.addGoal(5, new Silverfish.SilverfishMergeWithStoneGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
@@ -141,7 +184,7 @@ public class Silverfish extends Monster {
                 return false;
             } else {
                 RandomSource random = this.mob.getRandom();
-                if (getServerLevel(this.mob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) && random.nextInt(reducedTickDelay(10)) == 0) {
+                if (getServerLevel(this.mob).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(this.mob).purpurConfig.silverfishMobGriefingOverride) && random.nextInt(reducedTickDelay(10)) == 0) { // Purpur - Add mobGriefing override to everything affected
                     this.selectedDirection = Direction.getRandom(random);
                     BlockPos blockPos = BlockPos.containing(this.mob.getX(), this.mob.getY() + 0.5, this.mob.getZ()).relative(this.selectedDirection);
                     BlockState blockState = this.mob.level().getBlockState(blockPos);
@@ -218,7 +261,7 @@ public class Silverfish extends Monster {
                             Block block = blockState.getBlock();
                             if (block instanceof InfestedBlock) {
                                 // CraftBukkit start
-                                BlockState afterState = getServerLevel(level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) ? blockState.getFluidState().createLegacyBlock() : ((InfestedBlock) block).hostStateByInfested(level.getBlockState(blockPos1)); // Paper - fix wrong block state
+                                BlockState afterState = getServerLevel(level).getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, getServerLevel(level).purpurConfig.silverfishMobGriefingOverride) ? blockState.getFluidState().createLegacyBlock() : ((InfestedBlock) block).hostStateByInfested(level.getBlockState(blockPos1)); // Paper - fix wrong block state // Purpur - Add mobGriefing override to everything affected
                                 if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this.silverfish, blockPos1, afterState)) { // Paper - fix wrong block state
                                     continue;
                                 }
diff --git a/net/minecraft/world/entity/monster/Skeleton.java b/net/minecraft/world/entity/monster/Skeleton.java
index 743bc2986b962d4aaef00d2e457117f375ca65c7..c6ab31fa5204220f4c89dd48dd0966036a4975cf 100644
--- a/net/minecraft/world/entity/monster/Skeleton.java
+++ b/net/minecraft/world/entity/monster/Skeleton.java
@@ -27,6 +27,44 @@ public class Skeleton extends AbstractSkeleton {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.skeletonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.skeletonRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.skeletonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.skeletonMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.skeletonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.skeletonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -140,4 +178,64 @@ public class Skeleton extends AbstractSkeleton {
             this.spawnAtLocation(level, Items.SKELETON_SKULL);
         }
     }
+
+    // Purpur start - Skeletons eat wither roses
+    private int witherRosesFed = 0;
+
+    @Override
+    public net.minecraft.world.InteractionResult mobInteract(net.minecraft.world.entity.player.Player player, net.minecraft.world.InteractionHand hand) {
+        net.minecraft.world.item.ItemStack stack = player.getItemInHand(hand);
+
+        if (level().purpurConfig.skeletonFeedWitherRoses > 0 && this.getType() != EntityType.WITHER_SKELETON && stack.getItem() == net.minecraft.world.level.block.Blocks.WITHER_ROSE.asItem()) {
+            return this.feedWitherRose(player, stack);
+        }
+
+        return super.mobInteract(player, hand);
+    }
+
+    private net.minecraft.world.InteractionResult feedWitherRose(net.minecraft.world.entity.player.Player player, net.minecraft.world.item.ItemStack stack) {
+        if (++witherRosesFed < level().purpurConfig.skeletonFeedWitherRoses) {
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(1);
+            }
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+
+        WitherSkeleton skeleton = EntityType.WITHER_SKELETON.create(level(), net.minecraft.world.entity.EntitySpawnReason.CONVERSION);
+        if (skeleton == null) {
+            return net.minecraft.world.InteractionResult.PASS;
+        }
+
+        skeleton.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), this.getXRot());
+        skeleton.setHealth(this.getHealth());
+        skeleton.setAggressive(this.isAggressive());
+        skeleton.copyPosition(this);
+        skeleton.setYBodyRot(this.yBodyRot);
+        skeleton.setYHeadRot(this.getYHeadRot());
+        skeleton.yRotO = this.yRotO;
+        skeleton.xRotO = this.xRotO;
+
+        if (this.hasCustomName()) {
+            skeleton.setCustomName(this.getCustomName());
+        }
+
+        if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityTransformEvent(this, skeleton, org.bukkit.event.entity.EntityTransformEvent.TransformReason.INFECTION).isCancelled()) {
+            return net.minecraft.world.InteractionResult.PASS;
+        }
+
+        this.level().addFreshEntity(skeleton);
+        this.remove(RemovalReason.DISCARDED, org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        if (!player.getAbilities().instabuild) {
+            stack.shrink(1);
+        }
+
+        for (int i = 0; i < 15; ++i) {
+            ((ServerLevel) level()).sendParticlesSource(((ServerLevel) level()).players(), null, net.minecraft.core.particles.ParticleTypes.HAPPY_VILLAGER,
+                    false, true,
+                    getX() + random.nextFloat(), getY() + (random.nextFloat() * 2), getZ() + random.nextFloat(), 1,
+                    random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, random.nextGaussian() * 0.05D, 0);
+        }
+        return net.minecraft.world.InteractionResult.SUCCESS;
+    }
+    // Purpur end - Skeletons eat wither roses
 }
diff --git a/net/minecraft/world/entity/monster/Slime.java b/net/minecraft/world/entity/monster/Slime.java
index 7b9105cc38380d60892647e52608787dbde28f0d..b299fc08fe900b4d48ce3e6986bcea000253053e 100644
--- a/net/minecraft/world/entity/monster/Slime.java
+++ b/net/minecraft/world/entity/monster/Slime.java
@@ -59,6 +59,7 @@ public class Slime extends Mob implements Enemy {
     public float oSquish;
     private boolean wasOnGround = false;
     private boolean canWander = true; // Paper - Slime pathfinder events
+    protected boolean actualJump; // Purpur - Ridables
 
     public Slime(EntityType<? extends Slime> entityType, Level level) {
         super(entityType, level);
@@ -66,12 +67,95 @@ public class Slime extends Mob implements Enemy {
         this.moveControl = new Slime.SlimeMoveControl(this);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.slimeRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.slimeRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.slimeControllable;
+    }
+
+    @Override
+    public float getJumpPower() {
+        float height = super.getJumpPower();
+        return getRider() != null && this.isControllable() && actualJump ? height * 1.5F : height;
+    }
+
+    @Override
+    public boolean onSpacebar() {
+        if (onGround && getRider() != null && this.isControllable()) {
+            actualJump = true;
+            if (getRider().getForwardMot() == 0 || getRider().getStrafeMot() == 0) {
+                jumpFromGround(); // jump() here if not moving
+            }
+        }
+        return true; // do not jump() in wasd controller, let vanilla controller handle
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    protected String getMaxHealthEquation() {
+        return level().purpurConfig.slimeMaxHealth;
+    }
+
+    protected String getAttackDamageEquation() {
+        return level().purpurConfig.slimeAttackDamage;
+    }
+
+    protected java.util.Map<Integer, Double> getMaxHealthCache() {
+        return level().purpurConfig.slimeMaxHealthCache;
+    }
+
+    protected java.util.Map<Integer, Double> getAttackDamageCache() {
+        return level().purpurConfig.slimeAttackDamageCache;
+    }
+
+    protected double getFromCache(java.util.function.Supplier<String> equation, java.util.function.Supplier<java.util.Map<Integer, Double>> cache, java.util.function.Supplier<Double> defaultValue) {
+        int size = getSize();
+        Double value = cache.get().get(size);
+        if (value == null) {
+            try {
+                value = ((Number) scriptEngine.eval("let size = " + size + "; " + equation.get())).doubleValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                value = defaultValue.get();
+            }
+            cache.get().put(size, value);
+        }
+        return value;
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.slimeTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.slimeAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new Slime.SlimeFloatGoal(this));
         this.goalSelector.addGoal(2, new Slime.SlimeAttackGoal(this));
         this.goalSelector.addGoal(3, new Slime.SlimeRandomDirectionGoal(this));
         this.goalSelector.addGoal(5, new Slime.SlimeKeepOnJumpingGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector
             .addGoal(1, new NearestAttackableTargetGoal<>(this, Player.class, 10, true, false, (entity, level) -> Math.abs(entity.getY() - this.getY()) <= 4.0));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
@@ -94,9 +178,9 @@ public class Slime extends Mob implements Enemy {
         this.entityData.set(ID_SIZE, i);
         this.reapplyPosition();
         this.refreshDimensions();
-        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(i * i);
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(getFromCache(this::getMaxHealthEquation, this::getMaxHealthCache, () -> (double) (size * size))); // Purpur - Configurable entity base attributes
         this.getAttribute(Attributes.MOVEMENT_SPEED).setBaseValue(0.2F + 0.1F * i);
-        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(i);
+        this.getAttribute(Attributes.ATTACK_DAMAGE).setBaseValue(getFromCache(this::getAttackDamageEquation, this::getAttackDamageCache, () -> (double) i)); // Purpur - Configurable entity base attributes
         if (resetHealth) {
             this.setHealth(this.getMaxHealth());
         }
@@ -360,6 +444,7 @@ public class Slime extends Mob implements Enemy {
         Vec3 deltaMovement = this.getDeltaMovement();
         this.setDeltaMovement(deltaMovement.x, this.getJumpPower(), deltaMovement.z);
         this.hasImpulse = true;
+        this.actualJump = false; // Purpur - Ridables
     }
 
     @Nullable
@@ -524,7 +609,7 @@ public class Slime extends Mob implements Enemy {
         }
     }
 
-    static class SlimeMoveControl extends MoveControl {
+    static class SlimeMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         private float yRot;
         private int jumpDelay;
         private final Slime slime;
@@ -542,21 +627,33 @@ public class Slime extends Mob implements Enemy {
         }
 
         public void setWantedMovement(double speed) {
-            this.speedModifier = speed;
+            this.setSpeedModifier(speed); // Purpur - Ridables
             this.operation = MoveControl.Operation.MOVE_TO;
         }
 
         @Override
         public void tick() {
+            // Purpur start - Ridables
+            if (slime.getRider() != null && slime.isControllable()) {
+                purpurTick(slime.getRider());
+                if (slime.getForwardMot() != 0 || slime.getStrafeMot() != 0) {
+                    if (jumpDelay > 10) {
+                        jumpDelay = 6;
+                    }
+                } else {
+                    jumpDelay = 20;
+                }
+            } else {
+            // Purpur end - Ridables
             this.mob.setYRot(this.rotlerp(this.mob.getYRot(), this.yRot, 90.0F));
             this.mob.yHeadRot = this.mob.getYRot();
             this.mob.yBodyRot = this.mob.getYRot();
-            if (this.operation != MoveControl.Operation.MOVE_TO) {
+            } if ((slime.getRider() == null || !slime.isControllable()) && this.operation != MoveControl.Operation.MOVE_TO) { // Purpur - Ridables
                 this.mob.setZza(0.0F);
             } else {
                 this.operation = MoveControl.Operation.WAIT;
                 if (this.mob.onGround()) {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                    this.mob.setSpeed((float)(this.getSpeedModifier() * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED) * (slime.getRider() != null && slime.isControllable() && (slime.getRider().getForwardMot() != 0 || slime.getRider().getStrafeMot() != 0) ? 2.0D : 1.0D))); // Purpur - Ridables
                     if (this.jumpDelay-- <= 0) {
                         this.jumpDelay = this.slime.getJumpDelay();
                         if (this.isAggressive) {
@@ -573,7 +670,7 @@ public class Slime extends Mob implements Enemy {
                         this.mob.setSpeed(0.0F);
                     }
                 } else {
-                    this.mob.setSpeed((float)(this.speedModifier * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED)));
+                    this.mob.setSpeed((float)(this.getSpeedModifier() * this.mob.getAttributeValue(Attributes.MOVEMENT_SPEED) * (slime.getRider() != null && slime.isControllable() && (slime.getRider().getForwardMot() != 0 || slime.getRider().getStrafeMot() != 0) ? 2.0D : 1.0D))); // Purpur - Ridables
                 }
             }
         }
diff --git a/net/minecraft/world/entity/monster/Spider.java b/net/minecraft/world/entity/monster/Spider.java
index 60c4ac37bb491af13f9f9bf730b85bbe544cf81d..7c50ed0b7bd0d7138b80613ea08519ae457f49a3 100644
--- a/net/minecraft/world/entity/monster/Spider.java
+++ b/net/minecraft/world/entity/monster/Spider.java
@@ -50,15 +50,56 @@ public class Spider extends Monster {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.spiderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.spiderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.spiderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.spiderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.spiderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.spiderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.spiderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new AvoidEntityGoal<>(this, Armadillo.class, 6.0F, 1.0, 1.2, livingEntity -> !((Armadillo)livingEntity).isScared()));
         this.goalSelector.addGoal(3, new LeapAtTargetGoal(this, 0.4F));
         this.goalSelector.addGoal(4, new Spider.SpiderAttackGoal(this));
         this.goalSelector.addGoal(5, new WaterAvoidingRandomStrollGoal(this, 0.8));
         this.goalSelector.addGoal(6, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(6, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this));
         this.targetSelector.addGoal(2, new Spider.SpiderTargetGoal<>(this, Player.class));
         this.targetSelector.addGoal(3, new Spider.SpiderTargetGoal<>(this, IronGolem.class));
diff --git a/net/minecraft/world/entity/monster/Stray.java b/net/minecraft/world/entity/monster/Stray.java
index f3de370ee4bafc2cca033293d0d8e5c9c2a6737b..e69a5c552d2f57bc373cb2b89690a7dd9c2faefc 100644
--- a/net/minecraft/world/entity/monster/Stray.java
+++ b/net/minecraft/world/entity/monster/Stray.java
@@ -22,6 +22,44 @@ public class Stray extends AbstractSkeleton {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.strayRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.strayRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.strayControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.strayMaxHealth);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.strayTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.strayAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static boolean checkStraySpawnRules(
         EntityType<Stray> entityType, ServerLevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
diff --git a/net/minecraft/world/entity/monster/Strider.java b/net/minecraft/world/entity/monster/Strider.java
index afa584e2aba6bebfb2dd343215b043c983281853..fe31c4a45afd61be8b74efe9d0858ccd0aced075 100644
--- a/net/minecraft/world/entity/monster/Strider.java
+++ b/net/minecraft/world/entity/monster/Strider.java
@@ -86,12 +86,51 @@ public class Strider extends Animal implements ItemSteerable {
     public Strider(EntityType<? extends Strider> entityType, Level level) {
         super(entityType, level);
         this.blocksBuilding = true;
-        this.setPathfindingMalus(PathType.WATER, -1.0F);
+        if (isSensitiveToWater()) this.setPathfindingMalus(PathType.WATER, -1.0F); // Purpur - Toggle for water sensitive mob damage
         this.setPathfindingMalus(PathType.LAVA, 0.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.striderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.striderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.striderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.striderMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.striderScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.striderBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.striderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static boolean checkStriderSpawnRules(
         EntityType<Strider> entityType, LevelAccessor level, EntitySpawnReason spawnReason, BlockPos pos, RandomSource random
     ) {
@@ -138,6 +177,7 @@ public class Strider extends Animal implements ItemSteerable {
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(1, new PanicGoal(this, 1.65));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new BreedGoal(this, 1.0));
         this.temptGoal = new TemptGoal(this, 1.4, itemStack -> itemStack.is(ItemTags.STRIDER_TEMPT_ITEMS), false);
         this.goalSelector.addGoal(3, this.temptGoal);
@@ -356,7 +396,7 @@ public class Strider extends Animal implements ItemSteerable {
 
     @Override
     public boolean isSensitiveToWater() {
-        return true;
+        return this.level().purpurConfig.striderTakeDamageFromWater; // Purpur - Toggle for water sensitive mob damage
     }
 
     @Override
@@ -392,6 +432,19 @@ public class Strider extends Animal implements ItemSteerable {
     @Override
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         boolean isFood = this.isFood(player.getItemInHand(hand));
+        // Purpur start
+        if (level().purpurConfig.striderGiveSaddleBack && player.isSecondaryUseActive() && !isFood && isSaddled() && !isVehicle()) {
+            this.setItemSlot(EquipmentSlot.SADDLE, ItemStack.EMPTY);
+            if (!player.getAbilities().instabuild) {
+                ItemStack saddle = new ItemStack(Items.SADDLE);
+                if (!player.getInventory().add(saddle)) {
+                    player.drop(saddle, false);
+                }
+            }
+            return InteractionResult.SUCCESS;
+        }
+        // Purpur end
+
         if (!isFood && this.isSaddled() && !this.isVehicle() && !player.isSecondaryUseActive()) {
             if (!this.level().isClientSide) {
                 player.startRiding(this);
@@ -404,7 +457,7 @@ public class Strider extends Animal implements ItemSteerable {
                 ItemStack itemInHand = player.getItemInHand(hand);
                 return (InteractionResult)(this.isEquippableInSlot(itemInHand, EquipmentSlot.SADDLE)
                     ? itemInHand.interactLivingEntity(player, this, hand)
-                    : InteractionResult.PASS);
+                    : tryRide(player, hand)); // Purpur - Ridables
             } else {
                 if (isFood && !this.isSilent()) {
                     this.level()
diff --git a/net/minecraft/world/entity/monster/Vex.java b/net/minecraft/world/entity/monster/Vex.java
index ccddac6b1bebbe164f4192d0d8b5a1aa14851169..fc41db0619554a0fda845278c76ebd129765fc4b 100644
--- a/net/minecraft/world/entity/monster/Vex.java
+++ b/net/minecraft/world/entity/monster/Vex.java
@@ -60,6 +60,72 @@ public class Vex extends Monster implements TraceableEntity {
         this.xpReward = 3;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.vexRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.vexRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.vexControllable;
+    }
+
+    @Override
+    public double getMaxY() {
+        return level().purpurConfig.vexMaxY;
+    }
+
+    @Override
+    public void travel(Vec3 vec3) {
+        super.travel(vec3);
+        if (getRider() != null && this.isControllable()) {
+            float speed;
+            if (onGround) {
+                speed = (float) getAttributeValue(Attributes.MOVEMENT_SPEED) * 0.1F;
+            } else {
+                speed = (float) getAttributeValue(Attributes.FLYING_SPEED);
+            }
+            setSpeed(speed);
+            Vec3 mot = getDeltaMovement();
+            move(net.minecraft.world.entity.MoverType.SELF, mot.multiply(speed, 1.0, speed));
+            setDeltaMovement(mot.scale(0.9D));
+        }
+    }
+
+    @Override
+    public boolean causeFallDamage(double fallDistance, float damageMultiplier, DamageSource damageSource) {
+        return false; //  no fall damage please
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.vexMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.vexScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.vexTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.vexAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public boolean isFlapping() {
         return this.tickCount % TICKS_PER_FLAP == 0;
@@ -72,7 +138,7 @@ public class Vex extends Monster implements TraceableEntity {
 
     @Override
     public void tick() {
-        this.noPhysics = true;
+        this.noPhysics = getRider() == null || !this.isControllable(); // Purpur - Ridables
         super.tick();
         this.noPhysics = false;
         this.setNoGravity(true);
@@ -86,17 +152,19 @@ public class Vex extends Monster implements TraceableEntity {
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(4, new Vex.VexChargeAttackGoal());
         this.goalSelector.addGoal(8, new Vex.VexRandomMoveGoal());
         this.goalSelector.addGoal(9, new LookAtPlayerGoal(this, Player.class, 3.0F, 1.0F));
         this.goalSelector.addGoal(10, new LookAtPlayerGoal(this, Mob.class, 8.0F));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new Vex.VexCopyOwnerTargetGoal(this));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, Player.class, true));
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Monster.createMonsterAttributes().add(Attributes.MAX_HEALTH, 14.0).add(Attributes.ATTACK_DAMAGE, 4.0);
+        return Monster.createMonsterAttributes().add(Attributes.MAX_HEALTH, 14.0).add(Attributes.ATTACK_DAMAGE, 4.0).add(Attributes.FLYING_SPEED, 0.6D); // Purpur;
     }
 
     @Override
@@ -298,13 +366,13 @@ public class Vex extends Monster implements TraceableEntity {
         }
     }
 
-    class VexMoveControl extends MoveControl {
+    class VexMoveControl extends org.purpurmc.purpur.controller.FlyingMoveControllerWASD { // Purpur - Ridables
         public VexMoveControl(final Vex mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (this.operation == MoveControl.Operation.MOVE_TO) {
                 Vec3 vec3 = new Vec3(this.wantedX - Vex.this.getX(), this.wantedY - Vex.this.getY(), this.wantedZ - Vex.this.getZ());
                 double len = vec3.length();
@@ -312,7 +380,7 @@ public class Vex extends Monster implements TraceableEntity {
                     this.operation = MoveControl.Operation.WAIT;
                     Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().scale(0.5));
                 } else {
-                    Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().add(vec3.scale(this.speedModifier * 0.05 / len)));
+                    Vex.this.setDeltaMovement(Vex.this.getDeltaMovement().add(vec3.scale(this.getSpeedModifier() * 0.05 / len))); // Purpur - Ridables
                     if (Vex.this.getTarget() == null) {
                         Vec3 deltaMovement = Vex.this.getDeltaMovement();
                         Vex.this.setYRot(-((float)Mth.atan2(deltaMovement.x, deltaMovement.z)) * (180.0F / (float)Math.PI));
diff --git a/net/minecraft/world/entity/monster/Vindicator.java b/net/minecraft/world/entity/monster/Vindicator.java
index 835b522a77fc4e1ec84bd5134e12233a02b66a66..7f70b2387842f65da4632f1a27669a02d4e0402d 100644
--- a/net/minecraft/world/entity/monster/Vindicator.java
+++ b/net/minecraft/world/entity/monster/Vindicator.java
@@ -56,15 +56,56 @@ public class Vindicator extends AbstractIllager {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.vindicatorRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.vindicatorRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.vindicatorControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.vindicatorMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.vindicatorScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.vindicatorTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.vindicatorAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
         this.goalSelector.addGoal(0, new FloatGoal(this));
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(1, new AvoidEntityGoal<>(this, Creaking.class, 8.0F, 1.0, 1.2));
         this.goalSelector.addGoal(2, new Vindicator.VindicatorBreakDoorGoal(this));
         this.goalSelector.addGoal(3, new AbstractIllager.RaiderOpenDoorGoal(this));
         this.goalSelector.addGoal(4, new Raider.HoldGroundAttackGoal(this, 10.0F));
         this.goalSelector.addGoal(5, new MeleeAttackGoal(this, 1.0, false));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class).setAlertOthers());
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, true));
@@ -131,6 +172,11 @@ public class Vindicator extends AbstractIllager {
         RandomSource random = level.getRandom();
         this.populateDefaultEquipmentSlots(random, difficulty);
         this.populateDefaultEquipmentEnchantments(level, random, difficulty);
+        // Purpur start - Special mobs naturally spawn
+        if (level().purpurConfig.vindicatorJohnnySpawnChance > 0D && random.nextDouble() <= level().purpurConfig.vindicatorJohnnySpawnChance) {
+            setCustomName(Component.translatable("Johnny"));
+        }
+        // Purpur end - Special mobs naturally spawn
         return spawnGroupData1;
     }
 
diff --git a/net/minecraft/world/entity/monster/Witch.java b/net/minecraft/world/entity/monster/Witch.java
index cc156f6d98f193bc98eae75bd5aaf8abe69ace4c..4b253ae8149f5d9505c5140a00a96d8c8850b1c4 100644
--- a/net/minecraft/world/entity/monster/Witch.java
+++ b/net/minecraft/world/entity/monster/Witch.java
@@ -56,6 +56,45 @@ public class Witch extends Raider implements RangedAttackMob {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witchRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witchRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witchControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witchMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witchScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witchTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witchAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         super.registerGoals();
@@ -64,10 +103,12 @@ public class Witch extends Raider implements RangedAttackMob {
         );
         this.attackPlayersGoal = new NearestAttackableWitchTargetGoal<>(this, Player.class, 10, true, false, null);
         this.goalSelector.addGoal(1, new FloatGoal(this));
+        this.goalSelector.addGoal(1, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.goalSelector.addGoal(2, new RangedAttackGoal(this, 1.0, 60, 10.0F));
         this.goalSelector.addGoal(2, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.goalSelector.addGoal(3, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(3, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this, Raider.class));
         this.targetSelector.addGoal(2, this.healRaidersGoal);
         this.targetSelector.addGoal(3, this.attackPlayersGoal);
diff --git a/net/minecraft/world/entity/monster/WitherSkeleton.java b/net/minecraft/world/entity/monster/WitherSkeleton.java
index 3ff71ba1bd29faa4d8380dad9397ab34ef930234..b3f5b2e3e2cfc378de948c0e186727d5687c0e98 100644
--- a/net/minecraft/world/entity/monster/WitherSkeleton.java
+++ b/net/minecraft/world/entity/monster/WitherSkeleton.java
@@ -34,6 +34,45 @@ public class WitherSkeleton extends AbstractSkeleton {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.witherSkeletonRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.witherSkeletonRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.witherSkeletonControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.witherSkeletonMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.witherSkeletonScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.witherSkeletonTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.witherSkeletonAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractPiglin.class, true));
diff --git a/net/minecraft/world/entity/monster/Zoglin.java b/net/minecraft/world/entity/monster/Zoglin.java
index 0dbc528bcad2b2f79585e2462a265d43fcbebe76..e37c6dcbe62cba2cb7f33ac1792d539f9b07aa24 100644
--- a/net/minecraft/world/entity/monster/Zoglin.java
+++ b/net/minecraft/world/entity/monster/Zoglin.java
@@ -87,6 +87,45 @@ public class Zoglin extends Monster implements HoglinBase {
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zoglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zoglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zoglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zoglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zoglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zoglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zoglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected Brain.Provider<Zoglin> brainProvider() {
         return Brain.provider(MEMORY_TYPES, SENSOR_TYPES);
@@ -252,6 +291,7 @@ public class Zoglin extends Monster implements HoglinBase {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("zoglinBrain");
+        if (getRider() == null || !this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         this.updateActivity();
diff --git a/net/minecraft/world/entity/monster/Zombie.java b/net/minecraft/world/entity/monster/Zombie.java
index a23607874a72723914cbfeea0ad1c51236c044d8..ab4dc7b3a7593d255dbd7d1df667fce3504af3ed 100644
--- a/net/minecraft/world/entity/monster/Zombie.java
+++ b/net/minecraft/world/entity/monster/Zombie.java
@@ -92,22 +92,78 @@ public class Zombie extends Monster {
     private boolean canBreakDoors = false;
     private int inWaterTime = 0;
     public int conversionTime;
-    private boolean shouldBurnInDay = true; // Paper - Add more Zombie API
+    //private boolean shouldBurnInDay = true; // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
 
     public Zombie(EntityType<? extends Zombie> entityType, Level level) {
         super(entityType, level);
         this.breakDoorGoal = new BreakDoorGoal(this, com.google.common.base.Predicates.in(level.paperConfig().entities.behavior.doorBreakingDifficulty.getOrDefault(entityType, level.paperConfig().entities.behavior.doorBreakingDifficulty.get(EntityType.ZOMBIE)))); // Paper - Configurable door breaking difficulty
+        this.setShouldBurnInDay(true); // Purpur - API for any mob to burn daylight
     }
 
     public Zombie(Level level) {
         this(EntityType.ZOMBIE, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombieRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombieControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombieMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zombieScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start -  Configurable jockey options
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombieJockeyOnlyBaby;
+    }
+
+    public double jockeyChance() {
+        return level().purpurConfig.zombieJockeyChance;
+    }
+
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombieJockeyTryExistingChickens;
+    }
+    // Purpur end -  Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         if (this.level().paperConfig().entities.behavior.zombiesTargetTurtleEggs) this.goalSelector.addGoal(4, new Zombie.ZombieAttackTurtleEggGoal(this, 1.0, 3)); // Paper - Add zombie targets turtle egg config
         this.goalSelector.addGoal(8, new LookAtPlayerGoal(this, Player.class, 8.0F));
         this.goalSelector.addGoal(8, new RandomLookAroundGoal(this));
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
         this.addBehaviourGoals();
     }
 
@@ -117,7 +173,19 @@ public class Zombie extends Monster {
         this.goalSelector.addGoal(7, new WaterAvoidingRandomStrollGoal(this, 1.0));
         this.targetSelector.addGoal(1, new HurtByTargetGoal(this).setAlertOthers(ZombifiedPiglin.class));
         this.targetSelector.addGoal(2, new NearestAttackableTargetGoal<>(this, Player.class, true));
-        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false)); // Spigot
+        // Purpur start - Add option to disable zombie aggressiveness towards villagers
+        if (this.level().spigotConfig.zombieAggressiveTowardsVillager) this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, AbstractVillager.class, false) { // Spigot
+            @Override
+            public boolean canUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canUse();
+            }
+
+            @Override
+            public boolean canContinueToUse() {
+                return (level().purpurConfig.zombieAggressiveTowardsVillagerWhenLagging || !level().getServer().server.isLagging()) && super.canContinueToUse();
+            }
+        });
+        // Purpur end - Add option to disable zombie aggressiveness towards villagers
         this.targetSelector.addGoal(3, new NearestAttackableTargetGoal<>(this, IronGolem.class, true));
         this.targetSelector.addGoal(5, new NearestAttackableTargetGoal<>(this, Turtle.class, 10, true, false, Turtle.BABY_ON_LAND_SELECTOR));
     }
@@ -233,29 +301,7 @@ public class Zombie extends Monster {
 
     @Override
     public void aiStep() {
-        if (this.isAlive()) {
-            boolean flag = this.isSunSensitive() && this.isSunBurnTick();
-            if (flag) {
-                ItemStack itemBySlot = this.getItemBySlot(EquipmentSlot.HEAD);
-                if (!itemBySlot.isEmpty()) {
-                    if (itemBySlot.isDamageableItem()) {
-                        Item item = itemBySlot.getItem();
-                        itemBySlot.setDamageValue(itemBySlot.getDamageValue() + this.random.nextInt(2));
-                        if (itemBySlot.getDamageValue() >= itemBySlot.getMaxDamage()) {
-                            this.onEquippedItemBroken(item, EquipmentSlot.HEAD);
-                            this.setItemSlot(EquipmentSlot.HEAD, ItemStack.EMPTY);
-                        }
-                    }
-
-                    flag = false;
-                }
-
-                if (flag) {
-                    this.igniteForSeconds(8.0F);
-                }
-            }
-        }
-
+        // Purpur - implemented in LivingEntity - API for any mob to burn daylight
         super.aiStep();
     }
 
@@ -314,6 +360,7 @@ public class Zombie extends Monster {
         // CraftBukkit end
     }
 
+    public boolean shouldBurnInDay() { return this.isSunSensitive(); } // Purpur - for ABI compatibility - API for any mob to burn daylight
     public boolean isSunSensitive() {
         return this.shouldBurnInDay; // Paper - Add more Zombie API
     }
@@ -451,7 +498,7 @@ public class Zombie extends Monster {
         output.putBoolean("CanBreakDoors", this.canBreakDoors());
         output.putInt("InWaterTime", this.isInWater() ? this.inWaterTime : -1);
         output.putInt("DrownedConversionTime", this.isUnderWaterConverting() ? this.conversionTime : -1);
-        output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Paper - Add more Zombie API
+        //output.putBoolean("Paper.ShouldBurnInDay", this.shouldBurnInDay); // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     @Override
@@ -466,7 +513,7 @@ public class Zombie extends Monster {
         } else {
             this.getEntityData().set(DATA_DROWNED_CONVERSION_ID, false);
         }
-        this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - Add more Zombie API
+        //this.shouldBurnInDay = input.getBooleanOr("Paper.ShouldBurnInDay", true); // Paper - Add more Zombie API // Purpur - implemented in LivingEntity - API for any mob to burn daylight
     }
 
     @Override
@@ -518,19 +565,18 @@ public class Zombie extends Monster {
         }
 
         if (spawnGroupData instanceof Zombie.ZombieGroupData zombieGroupData) {
-            if (zombieGroupData.isBaby) {
-                this.setBaby(true);
+            if (!jockeyOnlyBaby() || zombieGroupData.isBaby) { // Purpur - Configurable jockey options
+                this.setBaby(zombieGroupData.isBaby); // Purpur - Configurable jockey options
                 if (zombieGroupData.canSpawnJockey) {
-                    if (random.nextFloat() < 0.05) {
-                        List<Chicken> entitiesOfClass = level.getEntitiesOfClass(
+                    if (random.nextFloat() < jockeyChance()) { // Purpur - Configurable jockey options
+                        List<Chicken> entitiesOfClass = jockeyTryExistingChickens() ? level.getEntitiesOfClass( // Purpur - Configurable jockey options
                             Chicken.class, this.getBoundingBox().inflate(5.0, 3.0, 5.0), EntitySelector.ENTITY_NOT_BEING_RIDDEN
-                        );
+                        ) : java.util.Collections.emptyList(); // Purpur - Configurable jockey options
                         if (!entitiesOfClass.isEmpty()) {
                             Chicken chicken = entitiesOfClass.get(0);
                             chicken.setChickenJockey(true);
                             this.startRiding(chicken);
-                        }
-                    } else if (random.nextFloat() < 0.05) {
+                    } else { // Purpur - Configurable jockey options
                         Chicken chicken1 = EntityType.CHICKEN.create(this.level(), EntitySpawnReason.JOCKEY);
                         if (chicken1 != null) {
                             chicken1.snapTo(this.getX(), this.getY(), this.getZ(), this.getYRot(), 0.0F);
@@ -539,6 +585,7 @@ public class Zombie extends Monster {
                             this.startRiding(chicken1);
                             level.addFreshEntity(chicken1, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.MOUNT); // CraftBukkit
                         }
+                        } // Purpur - Configurable jockey options
                     }
                 }
             }
@@ -551,10 +598,7 @@ public class Zombie extends Monster {
         }
 
         if (this.getItemBySlot(EquipmentSlot.HEAD).isEmpty()) {
-            LocalDate localDate = LocalDate.now();
-            int i = localDate.get(ChronoField.DAY_OF_MONTH);
-            int i1 = localDate.get(ChronoField.MONTH_OF_YEAR);
-            if (i1 == 10 && i == 31 && random.nextFloat() < 0.25F) {
+            if (net.minecraft.world.entity.ambient.Bat.isHalloweenSeason(level.getMinecraftWorld()) && this.random.nextFloat() < this.level().purpurConfig.chanceHeadHalloweenOnEntity) { // Purpur - Halloween options and optimizations
                 this.setItemSlot(EquipmentSlot.HEAD, new ItemStack(random.nextFloat() < 0.1F ? Blocks.JACK_O_LANTERN : Blocks.CARVED_PUMPKIN));
                 this.setDropChance(EquipmentSlot.HEAD, 0.0F);
             }
@@ -604,7 +648,7 @@ public class Zombie extends Monster {
     }
 
     protected void randomizeReinforcementsChance() {
-        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * 0.1F);
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombieSpawnReinforcements); // Purpur - Configurable entity base attributes
     }
 
     @Override
diff --git a/net/minecraft/world/entity/monster/ZombieVillager.java b/net/minecraft/world/entity/monster/ZombieVillager.java
index bc80d5b302f24974ce89db502b41d659457dd98c..e218e5d5f146ec996a6f5ce7e76b1d6506ac1cb9 100644
--- a/net/minecraft/world/entity/monster/ZombieVillager.java
+++ b/net/minecraft/world/entity/monster/ZombieVillager.java
@@ -76,6 +76,66 @@ public class ZombieVillager extends Zombie implements VillagerDataHolder {
         super(entityType, level);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombieVillagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombieVillagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombieVillagerControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombieVillagerMaxHealth);
+    }
+
+    @Override
+    protected void randomizeReinforcementsChance() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombieVillagerSpawnReinforcements);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombieVillagerJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.zombieVillagerJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombieVillagerJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombieVillagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombieVillagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         super.defineSynchedData(builder);
@@ -129,10 +189,10 @@ public class ZombieVillager extends Zombie implements VillagerDataHolder {
     public InteractionResult mobInteract(Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         if (itemInHand.is(Items.GOLDEN_APPLE)) {
-            if (this.hasEffect(MobEffects.WEAKNESS)) {
+            if (this.hasEffect(MobEffects.WEAKNESS) && level().purpurConfig.zombieVillagerCureEnabled) { // Purpur - Add option to disable zombie villagers cure
                 itemInHand.consume(1, player);
                 if (!this.level().isClientSide) {
-                    this.startConverting(player.getUUID(), this.random.nextInt(2401) + 3600);
+                    this.startConverting(player.getUUID(), this.random.nextInt(level().purpurConfig.zombieVillagerCuringTimeMax - level().purpurConfig.zombieVillagerCuringTimeMin + 1) + level().purpurConfig.zombieVillagerCuringTimeMin); // Purpur - Customizable Zombie Villager curing times
                 }
 
                 return InteractionResult.SUCCESS_SERVER;
diff --git a/net/minecraft/world/entity/monster/ZombifiedPiglin.java b/net/minecraft/world/entity/monster/ZombifiedPiglin.java
index 822712eaff2f6c579d982734ab14a00c02182770..f58c48d9de85fda3d13079f3e56b31af75b3c725 100644
--- a/net/minecraft/world/entity/monster/ZombifiedPiglin.java
+++ b/net/minecraft/world/entity/monster/ZombifiedPiglin.java
@@ -64,6 +64,62 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.zombifiedPiglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.zombifiedPiglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.zombifiedPiglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.zombifiedPiglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.zombifiedPiglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Configurable jockey options
+    @Override
+    public boolean jockeyOnlyBaby() {
+        return level().purpurConfig.zombifiedPiglinJockeyOnlyBaby;
+    }
+
+    @Override
+    public double jockeyChance() {
+        return level().purpurConfig.zombifiedPiglinJockeyChance;
+    }
+
+    @Override
+    public boolean jockeyTryExistingChickens() {
+        return level().purpurConfig.zombifiedPiglinJockeyTryExistingChickens;
+    }
+    // Purpur end - Configurable jockey options
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.zombifiedPiglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.zombifiedPiglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public void setPersistentAngerTarget(@Nullable UUID target) {
         this.persistentAngerTarget = target;
@@ -113,6 +169,12 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
             this.maybeAlertOthers();
         }
 
+        // Purpur start - Toggle for Zombified Piglin death always counting as player kill when angry
+        if (this.isAngry() && this.level().purpurConfig.zombifiedPiglinCountAsPlayerKillWhenAngry) {
+            this.lastHurtByPlayerMemoryTime = this.tickCount;
+        }
+        // Purpur end - Toggle for Zombified Piglin death always counting as player kill when angry
+
         super.customServerAiStep(level);
     }
 
@@ -160,6 +222,12 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
             this.ticksUntilNextAlert = ALERT_INTERVAL.sample(this.random);
         }
 
+        // Purpur start - Toggle for Zombified Piglin death always counting as player kill when angry
+        if (livingEntity instanceof Player player && this.level().purpurConfig.zombifiedPiglinCountAsPlayerKillWhenAngry) {
+            this.setLastHurtByPlayer(player, this.tickCount);
+        }
+        // Purpur end - Toggle for Zombified Piglin death always counting as player kill when angry
+
         return super.setTarget(livingEntity, reason); // CraftBukkit
     }
 
@@ -237,7 +305,7 @@ public class ZombifiedPiglin extends Zombie implements NeutralMob {
 
     @Override
     protected void randomizeReinforcementsChance() {
-        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(0.0);
+        this.getAttribute(Attributes.SPAWN_REINFORCEMENTS_CHANCE).setBaseValue(this.random.nextDouble() * this.level().purpurConfig.zombifiedPiglinSpawnReinforcements); // Purpur - Configurable entity base attributes
     }
 
     @Nullable
diff --git a/net/minecraft/world/entity/monster/creaking/Creaking.java b/net/minecraft/world/entity/monster/creaking/Creaking.java
index 567e7952efec69b4222563fae724d18a9902bb05..1b01d2b37dd221d5832cb68c072af9863aeb6868 100644
--- a/net/minecraft/world/entity/monster/creaking/Creaking.java
+++ b/net/minecraft/world/entity/monster/creaking/Creaking.java
@@ -103,6 +103,37 @@ public class Creaking extends Monster {
         return this.getHomePos() != null;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.creakingRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.creakingRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.creakingControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.creakingMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.creakingScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
     @Override
     protected BodyRotationControl createBodyControl() {
         return new Creaking.CreakingBodyRotationControl(this);
@@ -572,28 +603,28 @@ public class Creaking extends Monster {
         }
     }
 
-    class CreakingLookControl extends LookControl {
+    class CreakingLookControl extends org.purpurmc.purpur.controller.LookControllerWASD { // Purpur - Ridables {
         public CreakingLookControl(final Creaking mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Creaking.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
 
-    class CreakingMoveControl extends MoveControl {
+    class CreakingMoveControl extends org.purpurmc.purpur.controller.MoveControllerWASD { // Purpur - Ridables
         public CreakingMoveControl(final Creaking mob) {
             super(mob);
         }
 
         @Override
-        public void tick() {
+        public void vanillaTick() { // Purpur - Ridables
             if (Creaking.this.canMove()) {
-                super.tick();
+                super.vanillaTick(); // Purpur - Ridables
             }
         }
     }
diff --git a/net/minecraft/world/entity/monster/hoglin/Hoglin.java b/net/minecraft/world/entity/monster/hoglin/Hoglin.java
index 0ecf8533f6cad081df8713856feb74db93028f71..994f6e5cb0960d43de00d9ef6d25e81107e0774a 100644
--- a/net/minecraft/world/entity/monster/hoglin/Hoglin.java
+++ b/net/minecraft/world/entity/monster/hoglin/Hoglin.java
@@ -96,6 +96,52 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.hoglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.hoglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.hoglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.hoglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.hoglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Make entity breeding times configurable
+    @Override
+    public int getPurpurBreedTime() {
+        return this.level().purpurConfig.hoglinBreedingTicks;
+    }
+    // Purpur end - Make entity breeding times configurable
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.hoglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.hoglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @VisibleForTesting
     public void setTimeInOverworld(int timeInOverworld) {
         this.timeInOverworld = timeInOverworld;
@@ -164,6 +210,7 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("hoglinBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         HoglinAi.updateActivity(this);
diff --git a/net/minecraft/world/entity/monster/piglin/Piglin.java b/net/minecraft/world/entity/monster/piglin/Piglin.java
index 8392ff1316f0c5be685a6ded7ccd08933c10ff4e..c48044ff1fd5b587935d11747d93598d0bc0c7a3 100644
--- a/net/minecraft/world/entity/monster/piglin/Piglin.java
+++ b/net/minecraft/world/entity/monster/piglin/Piglin.java
@@ -137,6 +137,45 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
         this.xpReward = 5;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.piglinRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.piglinRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.piglinControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.piglinMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.piglinScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.piglinTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.piglinAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void addAdditionalSaveData(ValueOutput output) {
         super.addAdditionalSaveData(output);
@@ -322,6 +361,7 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("piglinBrain");
+        //if ((getRider() == null || !this.isControllable()) && this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         PiglinAi.updateActivity(this);
@@ -424,7 +464,7 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
 
     @Override
     public boolean wantsToPickUp(ServerLevel level, ItemStack stack) {
-        return level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) && this.canPickUpLoot() && PiglinAi.wantsToPickup(this, stack);
+        return level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.piglinMobGriefingOverride) && this.canPickUpLoot() && PiglinAi.wantsToPickup(this, stack); // Purpur - Add mobGriefing override to everything affected
     }
 
     protected boolean canReplaceCurrentItem(ItemStack candidate) {
diff --git a/net/minecraft/world/entity/monster/piglin/PiglinAi.java b/net/minecraft/world/entity/monster/piglin/PiglinAi.java
index 4b1a3772f9e6b9e4efcf11e14b0fb882512ec86d..2841c765b2bd804f08bd0e603b4b29cf8a801fab 100644
--- a/net/minecraft/world/entity/monster/piglin/PiglinAi.java
+++ b/net/minecraft/world/entity/monster/piglin/PiglinAi.java
@@ -661,7 +661,10 @@ public class PiglinAi {
 
     public static boolean isWearingSafeArmor(LivingEntity entity) {
         for (EquipmentSlot equipmentSlot : EquipmentSlotGroup.ARMOR) {
-            if (entity.getItemBySlot(equipmentSlot).is(ItemTags.PIGLIN_SAFE_ARMOR)) {
+            // Purpur start - piglins ignore gold-trimmed armor
+            net.minecraft.world.item.ItemStack itemStack = entity.getItemBySlot(equipmentSlot);
+            if (itemStack.is(ItemTags.PIGLIN_SAFE_ARMOR) || (entity.level().purpurConfig.piglinIgnoresArmorWithGoldTrim && isWearingGoldTrim(itemStack))) {
+            // Purpur end - piglins ignore gold-trimmed armor
                 return true;
             }
         }
@@ -669,6 +672,13 @@ public class PiglinAi {
         return false;
     }
 
+    // Purpur start - piglins ignore gold-trimmed armor
+    private static boolean isWearingGoldTrim(net.minecraft.world.item.ItemStack itemstack) {
+        net.minecraft.world.item.equipment.trim.ArmorTrim armorTrim = itemstack.getComponents().get(net.minecraft.core.component.DataComponents.TRIM);
+        return armorTrim != null && armorTrim.material().is(net.minecraft.world.item.equipment.trim.TrimMaterials.GOLD);
+    }
+    // Purpur end - piglins ignore gold-trimmed armor
+
     private static void stopWalking(Piglin piglin) {
         piglin.getBrain().eraseMemory(MemoryModuleType.WALK_TARGET);
         piglin.getNavigation().stop();
diff --git a/net/minecraft/world/entity/monster/piglin/PiglinBrute.java b/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
index 219978cb0341b2d691f44c1146707d875788881e..70ee15527fa6f30783d6a58bb767b18124f25c53 100644
--- a/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
+++ b/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
@@ -65,6 +65,45 @@ public class PiglinBrute extends AbstractPiglin {
         this.xpReward = 20;
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.piglinBruteRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.piglinBruteRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.piglinBruteControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.piglinBruteMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.piglinBruteScale);
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.piglinBruteTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.piglinBruteAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     public static AttributeSupplier.Builder createAttributes() {
         return Monster.createMonsterAttributes()
             .add(Attributes.MAX_HEALTH, 50.0)
@@ -117,6 +156,7 @@ public class PiglinBrute extends AbstractPiglin {
     protected void customServerAiStep(ServerLevel level) {
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("piglinBruteBrain");
+        if (getRider() == null || this.isControllable()) // Purpur - only use brain if no rider
         this.getBrain().tick(level, this);
         profilerFiller.pop();
         PiglinBruteAi.updateActivity(this);
diff --git a/net/minecraft/world/entity/monster/warden/Warden.java b/net/minecraft/world/entity/monster/warden/Warden.java
index 4a4cc7f9c95d4f4b6ad4948e3ed3504efbbcef15..f8a6aba7d6f0f357c72602f4ac6c2537b604eb6c 100644
--- a/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/net/minecraft/world/entity/monster/warden/Warden.java
@@ -124,8 +124,32 @@ public class Warden extends Monster implements VibrationSystem {
         this.setPathfindingMalus(PathType.LAVA, 8.0F);
         this.setPathfindingMalus(PathType.DAMAGE_FIRE, 0.0F);
         this.setPathfindingMalus(PathType.DANGER_FIRE, 0.0F);
+        this.moveControl = new org.purpurmc.purpur.controller.MoveControllerWASD(this, 0.5F); // Purpur - Ridables
     }
 
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wardenRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wardenRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wardenControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+        this.targetSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this)); // Purpur - Ridables
+    }
+    // Purpur end - Ridables
+
     @Override
     public Packet<ClientGamePacketListener> getAddEntityPacket(ServerEntity entity) {
         return new ClientboundAddEntityPacket(this, entity, this.hasPose(Pose.EMERGING) ? 1 : 0);
@@ -389,6 +413,7 @@ public class Warden extends Monster implements VibrationSystem {
 
     @Contract("null->false")
     public boolean canTargetEntity(@Nullable Entity entity) {
+        if (getRider() != null && isControllable()) return false; // Purpur - Ridables
         return entity instanceof LivingEntity livingEntity
             && this.level() == entity.level()
             && EntitySelector.NO_CREATIVE_OR_SPECTATOR.test(entity)
diff --git a/net/minecraft/world/entity/npc/AbstractVillager.java b/net/minecraft/world/entity/npc/AbstractVillager.java
index 66c6a65f39847956839de5c60836b3ec07c4ebef..8f14327d82dd7ed282cb536d540029856febae64 100644
--- a/net/minecraft/world/entity/npc/AbstractVillager.java
+++ b/net/minecraft/world/entity/npc/AbstractVillager.java
@@ -35,6 +35,7 @@ import net.minecraft.world.level.storage.ValueOutput;
 import net.minecraft.world.phys.Vec3;
 
 public abstract class AbstractVillager extends AgeableMob implements InventoryCarrier, Npc, Merchant {
+    static final net.minecraft.world.item.crafting.Ingredient TEMPT_ITEMS = net.minecraft.world.item.crafting.Ingredient.of(net.minecraft.world.level.block.Blocks.EMERALD_BLOCK.asItem()); // Purpur - Villagers follow emerald blocks
     private static final EntityDataAccessor<Integer> DATA_UNHAPPY_COUNTER = SynchedEntityData.defineId(AbstractVillager.class, EntityDataSerializers.INT);
     public static final int VILLAGER_SLOT_OFFSET = 300;
     private static final int VILLAGER_INVENTORY_SIZE = 8;
diff --git a/net/minecraft/world/entity/npc/CatSpawner.java b/net/minecraft/world/entity/npc/CatSpawner.java
index a92769d2c0a93afa85797c0e778f460cc6d28599..8c942aec756544027bae38e9ec73b025c1cd8815 100644
--- a/net/minecraft/world/entity/npc/CatSpawner.java
+++ b/net/minecraft/world/entity/npc/CatSpawner.java
@@ -26,7 +26,7 @@ public class CatSpawner implements CustomSpawner {
             io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
             worldData.catSpawnerNextTick--; // Folia - region threading
             if (worldData.catSpawnerNextTick <= 0) { // Folia - region threading
-                worldData.catSpawnerNextTick = 1200; // Folia - region threading
+                worldData.catSpawnerNextTick = level.purpurConfig.catSpawnDelay; // Folia - region threading // Purpur - Cat spawning options
                 Player randomPlayer = level.getRandomLocalPlayer(); // Folia - region threading
                 if (randomPlayer != null) {
                     RandomSource randomSource = level.random;
@@ -49,9 +49,12 @@ public class CatSpawner implements CustomSpawner {
     }
 
     private void spawnInVillage(ServerLevel level, BlockPos pos) {
-        int i = 48;
-        if (level.getPoiManager().getCountInRange(holder -> holder.is(PoiTypes.HOME), pos, 48, PoiManager.Occupancy.IS_OCCUPIED) > 4L) {
-            List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(48.0, 8.0, 48.0));
+        // Purpur start - Cat spawning options
+        int range = level.purpurConfig.catSpawnVillageScanRange;
+        if (range <= 0) return;
+        if (level.getPoiManager().getCountInRange(holder -> holder.is(PoiTypes.HOME), pos, range, PoiManager.Occupancy.IS_OCCUPIED) > 4L) {
+            List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(range, 8.0, range));
+        // Purpur end - Cat spawning options
             if (entitiesOfClass.size() < 5) {
                 this.spawnCat(pos, level, false);
             }
@@ -59,8 +62,11 @@ public class CatSpawner implements CustomSpawner {
     }
 
     private void spawnInHut(ServerLevel level, BlockPos pos) {
-        int i = 16;
-        List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(16.0, 8.0, 16.0));
+        // Purpur start - Cat spawning options
+        int range = level.purpurConfig.catSpawnSwampHutScanRange;
+        if (range <= 0) return;
+        List<Cat> entitiesOfClass = level.getEntitiesOfClass(Cat.class, new AABB(pos).inflate(range, 8.0, range));
+        // Purpur end - Cat spawning options
         if (entitiesOfClass.isEmpty()) {
             this.spawnCat(pos, level, true);
         }
diff --git a/net/minecraft/world/entity/npc/Villager.java b/net/minecraft/world/entity/npc/Villager.java
index 7d02def8b650a7574c1a6b0c212d6973d2b46f45..4dfcc3a9b8bec022b577370807fb157f4f04eecb 100644
--- a/net/minecraft/world/entity/npc/Villager.java
+++ b/net/minecraft/world/entity/npc/Villager.java
@@ -178,6 +178,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         MemoryModuleType.MEETING_POINT,
         (villager, poiType) -> poiType.is(PoiTypes.MEETING)
     );
+    private boolean isLobotomized = false; public boolean isLobotomized() { return this.isLobotomized; } // Purpur - Lobotomize stuck villagers
+    private int notLobotomizedCount = 0; // Purpur - Lobotomize stuck villagers
 
     public Villager(EntityType<? extends Villager> entityType, Level level) {
         this(entityType, level, VillagerType.PLAINS);
@@ -196,6 +198,103 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         this.setVillagerData(this.getVillagerData().withType(villagerType).withProfession(level.registryAccess(), VillagerProfession.NONE));
     }
 
+    // Purpur start - Allow leashing villagers
+    @Override
+    public boolean canBeLeashed() {
+        return level().purpurConfig.villagerCanBeLeashed;
+    }
+    // Purpur end - Allow leashing villagers
+
+    // Purpur start - Lobotomize stuck villagers
+    private boolean checkLobotomized() {
+        int interval = this.level().purpurConfig.villagerLobotomizeCheckInterval;
+        boolean shouldCheckForTradeLocked = this.level().purpurConfig.villagerLobotomizeWaitUntilTradeLocked;
+        if (this.notLobotomizedCount > 3) {
+            // check half as often if not lobotomized for the last 3+ consecutive checks
+            interval *= 2;
+        }
+        if (this.level().getGameTime() % interval == 0) {
+            // offset Y for short blocks like dirt_path/farmland
+            this.isLobotomized = !(shouldCheckForTradeLocked && this.getVillagerXp() == 0) && !canTravelFrom(BlockPos.containing(this.position().x, this.getBoundingBox().minY + 0.0625D, this.position().z));
+
+            if (this.isLobotomized) {
+                this.notLobotomizedCount = 0;
+            } else {
+                this.notLobotomizedCount++;
+            }
+        }
+        return this.isLobotomized;
+    }
+
+    private boolean canTravelFrom(BlockPos pos) {
+        return canTravelTo(pos.east()) || canTravelTo(pos.west()) || canTravelTo(pos.north()) || canTravelTo(pos.south());
+    }
+
+    private boolean canTravelTo(BlockPos pos) {
+        net.minecraft.world.level.block.state.BlockState state = this.level().getBlockStateIfLoaded(pos);
+        if (state == null) {
+            // chunk not loaded
+            return false;
+        }
+        net.minecraft.world.level.block.Block bottom = state.getBlock();
+        if (bottom instanceof net.minecraft.world.level.block.FenceBlock ||
+            bottom instanceof net.minecraft.world.level.block.FenceGateBlock ||
+            bottom instanceof net.minecraft.world.level.block.WallBlock) {
+            // bottom block is too tall to get over
+            return false;
+        }
+        net.minecraft.world.level.block.Block top = level().getBlockState(pos.above()).getBlock();
+        // only if both blocks have no collision
+        return !bottom.hasCollision && !top.hasCollision;
+    }
+    // Purpur end - Lobotomize stuck villagers
+
+    // Purpur start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.villagerRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.villagerRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.villagerControllable;
+    }
+
+    @Override
+    protected void registerGoals() {
+        this.goalSelector.addGoal(0, new org.purpurmc.purpur.entity.ai.HasRider(this));
+        if (level().purpurConfig.villagerFollowEmeraldBlock) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, TEMPT_ITEMS, false)); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.villagerMaxHealth);
+        this.getAttribute(Attributes.SCALE).setBaseValue(this.level().purpurConfig.villagerScale);
+        this.getAttribute(Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.villagerTemptRange); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.villagerTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.villagerAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     public Brain<Villager> getBrain() {
         return (Brain<Villager>)super.getBrain();
@@ -229,7 +328,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             villagerBrain.setSchedule(Schedule.VILLAGER_DEFAULT);
             villagerBrain.addActivityWithConditions(
                 Activity.WORK,
-                VillagerGoalPackages.getWorkPackage(holder, 0.5F),
+                VillagerGoalPackages.getWorkPackage(holder, 0.5F, this.level().purpurConfig.villagerClericsFarmWarts), // Purpur - Option for Villager Clerics to farm Nether Wart
                 ImmutableSet.of(Pair.of(MemoryModuleType.JOB_SITE, MemoryStatus.VALUE_PRESENT))
             );
         }
@@ -261,7 +360,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public static AttributeSupplier.Builder createAttributes() {
-        return Mob.createMobAttributes().add(Attributes.MOVEMENT_SPEED, 0.5);
+        return Mob.createMobAttributes().add(Attributes.MOVEMENT_SPEED, 0.5).add(Attributes.TEMPT_RANGE, 10.0D); // Purpur - Villagers follow emerald blocks
     }
 
     public boolean assignProfessionWhenSpawned() {
@@ -292,11 +391,24 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         // Paper start - EAR 2
         this.customServerAiStep(level, false);
     }
-    protected void customServerAiStep(ServerLevel level, final boolean inactive) {
+    protected void customServerAiStep(ServerLevel level, boolean inactive) { // Purpur - Lobotomize stuck villagers - not final
         // Paper end - EAR 2
         ProfilerFiller profilerFiller = Profiler.get();
         profilerFiller.push("villagerBrain");
-        if (!inactive) this.getBrain().tick(level, this); // Paper - EAR 2
+        // Purpur start - Lobotomize stuck villagers
+        if (this.level().purpurConfig.villagerLobotomizeEnabled) {
+            // treat as inactive if lobotomized
+            inactive = inactive || checkLobotomized();
+        } else {
+            this.isLobotomized = false;
+        }
+        // Purpur end - Lobotomize stuck villagers
+        // Pufferfish start
+        if (!inactive && (getRider() == null || !this.isControllable()) /*&& this.behaviorTick++ % this.activatedPriority == 0*/) { // Purpur - Ridables
+            this.getBrain().tick(level, this); // Paper - EAR 2
+        }
+        else if (this.isLobotomized && shouldRestock()) restock(); // Purpur - Lobotomize stuck villagers
+        // Pufferfish end
         profilerFiller.pop();
         if (this.assignProfessionWhenSpawned) {
             this.assignProfessionWhenSpawned = false;
@@ -352,7 +464,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
             return super.mobInteract(player, hand);
         } else if (this.isBaby()) {
             this.setUnhappy();
-            return InteractionResult.SUCCESS;
+            return tryRide(player, hand, InteractionResult.SUCCESS); // Purpur - Ridables
         } else {
             if (!this.level().isClientSide) {
                 boolean isEmpty = this.getOffers().isEmpty();
@@ -365,9 +477,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
                 }
 
                 if (isEmpty) {
-                    return InteractionResult.CONSUME;
+                    return tryRide(player, hand, InteractionResult.CONSUME); // Purpur - Ridables
                 }
 
+                if (level().purpurConfig.villagerRidable && itemInHand.isEmpty()) return tryRide(player, hand); // Purpur - Ridables
+
+                if (this.level().purpurConfig.villagerAllowTrading) // Purpur - Add config for villager trading
                 this.startTrading(player);
             }
 
@@ -504,7 +619,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     public void updateDemand() {
         for (MerchantOffer merchantOffer : this.getOffers()) {
-            merchantOffer.updateDemand();
+            merchantOffer.updateDemand(this.level().purpurConfig.villagerMinimumDemand); // Purpur - Configurable minimum demand for trades
         }
     }
 
@@ -700,7 +815,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public boolean canBreed() {
-        return this.foodLevel + this.countFoodPointsInInventory() >= 12 && !this.isSleeping() && this.getAge() == 0;
+        return this.level().purpurConfig.villagerCanBreed && this.foodLevel + this.countFoodPointsInInventory() >= 12 && !this.isSleeping() && this.getAge() == 0; // Purpur - Configurable villager breeding
     }
 
     private boolean hungry() {
@@ -867,7 +982,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public boolean hasFarmSeeds() {
-        return this.getInventory().hasAnyMatching(stack -> stack.is(ItemTags.VILLAGER_PLANTABLE_SEEDS));
+        return this.getInventory().hasAnyMatching(stack -> this.level().purpurConfig.villagerClericsFarmWarts && this.getVillagerData().profession().is(VillagerProfession.CLERIC) ? stack.is(Items.NETHER_WART) : stack.is(ItemTags.VILLAGER_PLANTABLE_SEEDS)); // Purpur - Option for Villager Clerics to farm Nether Wart
     }
 
     @Override
@@ -922,6 +1037,7 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
 
     public void spawnGolemIfNeeded(ServerLevel serverLevel, long gameTime, int minVillagerAmount) {
+        if (serverLevel.purpurConfig.villagerSpawnIronGolemRadius > 0 && serverLevel.getEntitiesOfClass(net.minecraft.world.entity.animal.IronGolem.class, getBoundingBox().inflate(serverLevel.purpurConfig.villagerSpawnIronGolemRadius)).size() > serverLevel.purpurConfig.villagerSpawnIronGolemLimit) return; // Purpur - Implement configurable search radius for villagers to spawn iron golems
         if (this.wantsToSpawnGolem(gameTime)) {
             AABB aabb = this.getBoundingBox().inflate(10.0, 10.0, 10.0);
             List<Villager> entitiesOfClass = serverLevel.getEntitiesOfClass(Villager.class, aabb);
@@ -995,6 +1111,12 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
 
     @Override
     public void startSleeping(BlockPos pos) {
+        // Purpur start - Option for beds to explode on villager sleep
+        if (level().purpurConfig.bedExplodeOnVillagerSleep && this.level().getBlockState(pos).getBlock() instanceof net.minecraft.world.level.block.BedBlock) {
+            this.level().explode(null, (double) pos.getX() + 0.5D, (double) pos.getY() + 0.5D, (double) pos.getZ() + 0.5D, (float) this.level().purpurConfig.bedExplosionPower, this.level().purpurConfig.bedExplosionFire, this.level().purpurConfig.bedExplosionEffect);
+            return;
+        }
+        // Purpur end - Option for beds to explode on villager sleep
         super.startSleeping(pos);
         this.brain.setMemory(MemoryModuleType.LAST_SLEPT, this.level().getGameTime());
         this.brain.eraseMemory(MemoryModuleType.WALK_TARGET);
diff --git a/net/minecraft/world/entity/npc/VillagerProfession.java b/net/minecraft/world/entity/npc/VillagerProfession.java
index 0b7fdbc19f8a977be8168bca198c157fbe90044b..abfc2542a486d5a64bf88eac69f7d9587869d3cf 100644
--- a/net/minecraft/world/entity/npc/VillagerProfession.java
+++ b/net/minecraft/world/entity/npc/VillagerProfession.java
@@ -103,7 +103,7 @@ public record VillagerProfession(
         register(registry, ARMORER, PoiTypes.ARMORER, SoundEvents.VILLAGER_WORK_ARMORER);
         register(registry, BUTCHER, PoiTypes.BUTCHER, SoundEvents.VILLAGER_WORK_BUTCHER);
         register(registry, CARTOGRAPHER, PoiTypes.CARTOGRAPHER, SoundEvents.VILLAGER_WORK_CARTOGRAPHER);
-        register(registry, CLERIC, PoiTypes.CLERIC, SoundEvents.VILLAGER_WORK_CLERIC);
+        register(registry, CLERIC, PoiTypes.CLERIC, ImmutableSet.of(Items.NETHER_WART), ImmutableSet.of(Blocks.SOUL_SAND), SoundEvents.VILLAGER_WORK_CLERIC); // Purpur - Option for Villager Clerics to farm Nether Wart
         register(
             registry,
             FARMER,
diff --git a/net/minecraft/world/entity/npc/WanderingTrader.java b/net/minecraft/world/entity/npc/WanderingTrader.java
index c2573946dd1244eb5d1ef2be7823211064daa80d..dc6b30518270486cf3b2eaab4db13a507917f37d 100644
--- a/net/minecraft/world/entity/npc/WanderingTrader.java
+++ b/net/minecraft/world/entity/npc/WanderingTrader.java
@@ -60,6 +60,58 @@ public class WanderingTrader extends net.minecraft.world.entity.npc.AbstractVill
         super(entityType, level);
     }
 
+    // Purpur start - Allow leashing villagers
+    @Override
+    public boolean canBeLeashed() {
+        return level().purpurConfig.wanderingTraderCanBeLeashed;
+    }
+    // Purpur end - Allow leashing villagers
+
+    // Purpur - start - Ridables
+    @Override
+    public boolean isRidable() {
+        return level().purpurConfig.wanderingTraderRidable;
+    }
+
+    @Override
+    public boolean dismountsUnderwater() {
+        return level().purpurConfig.useDismountsUnderwaterTag ? super.dismountsUnderwater() : !level().purpurConfig.wanderingTraderRidableInWater;
+    }
+
+    @Override
+    public boolean isControllable() {
+        return level().purpurConfig.wanderingTraderControllable;
+    }
+    // Purpur end - Ridables
+
+    // Purpur start - Configurable entity base attributes
+    @Override
+    public void initAttributes() {
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.MAX_HEALTH).setBaseValue(this.level().purpurConfig.wanderingTraderMaxHealth);
+        this.getAttribute(net.minecraft.world.entity.ai.attributes.Attributes.TEMPT_RANGE).setBaseValue(this.level().purpurConfig.wanderingTraderTemptRange); // Purpur - Villagers follow emerald blocks
+    }
+    // Purpur end - Configurable entity base attributes
+
+    // Purpur start - Villagers follow emerald blocks
+    public static net.minecraft.world.entity.ai.attributes.AttributeSupplier.Builder createAttributes() {
+        return Mob.createMobAttributes().add(net.minecraft.world.entity.ai.attributes.Attributes.TEMPT_RANGE, 10.0D);
+    }
+    // Purpur end - Villagers follow emerald blocks
+
+    // Purpur start - Toggle for water sensitive mob damage
+    @Override
+    public boolean isSensitiveToWater() {
+        return this.level().purpurConfig.wanderingTraderTakeDamageFromWater;
+    }
+    // Purpur end - Toggle for water sensitive mob damage
+
+    // Purpur start - Mobs always drop experience
+    @Override
+    protected boolean isAlwaysExperienceDropper() {
+        return this.level().purpurConfig.wanderingTraderAlwaysDropExp;
+    }
+    // Purpur end - Mobs always drop experience
+
     @Override
     protected void registerGoals() {
         this.goalSelector.addGoal(0, new FloatGoal(this));
@@ -80,7 +132,7 @@ public class WanderingTrader extends net.minecraft.world.entity.npc.AbstractVill
                     this,
                     new ItemStack(Items.MILK_BUCKET),
                     SoundEvents.WANDERING_TRADER_REAPPEARED,
-                    wanderingTrader -> this.canDrinkMilk && this.level().isBrightOutside() && wanderingTrader.isInvisible() // Paper - Add more WanderingTrader API
+                    wanderingTrader -> level().purpurConfig.milkClearsBeneficialEffects && this.canDrinkMilk && this.level().isBrightOutside() && wanderingTrader.isInvisible() // Paper - Add more WanderingTrader API // // Purpur - Milk Keeps Beneficial Effects
                 )
             );
         this.goalSelector.addGoal(1, new TradeWithPlayerGoal(this));
@@ -94,6 +146,7 @@ public class WanderingTrader extends net.minecraft.world.entity.npc.AbstractVill
         this.goalSelector.addGoal(1, new PanicGoal(this, 0.5));
         this.goalSelector.addGoal(1, new LookAtTradingPlayerGoal(this));
         this.goalSelector.addGoal(2, new WanderingTrader.WanderToPositionGoal(this, 2.0, 0.35));
+        if (level().purpurConfig.wanderingTraderFollowEmeraldBlock) this.goalSelector.addGoal(3, new net.minecraft.world.entity.ai.goal.TemptGoal(this, 1.0D, TEMPT_ITEMS, false)); // Purpur - Villagers follow emerald blocks
         this.goalSelector.addGoal(4, new MoveTowardsRestrictionGoal(this, 0.35));
         this.goalSelector.addGoal(8, new WaterAvoidingRandomStrollGoal(this, 0.35));
         this.goalSelector.addGoal(9, new InteractGoal(this, Player.class, 3.0F, 1.0F));
@@ -121,11 +174,14 @@ public class WanderingTrader extends net.minecraft.world.entity.npc.AbstractVill
 
             if (!this.level().isClientSide) {
                 if (this.getOffers().isEmpty()) {
-                    return InteractionResult.CONSUME;
+                    return tryRide(player, hand, InteractionResult.CONSUME); // Purpur - Ridables
                 }
+                if (level().purpurConfig.wanderingTraderRidable && itemInHand.isEmpty()) return tryRide(player, hand); // Purpur - Ridables
 
+                if (this.level().purpurConfig.wanderingTraderAllowTrading) { // Purpur - Add config for villager trading
                 this.setTradingPlayer(player);
                 this.openTradingScreen(player, this.getDisplayName(), 1);
+                } // Purpur - Add config for villager trading
             }
 
             return InteractionResult.SUCCESS;
diff --git a/net/minecraft/world/entity/npc/WanderingTraderSpawner.java b/net/minecraft/world/entity/npc/WanderingTraderSpawner.java
index f83020635a24174777d5266a7f23d1b0607a00e6..387939b54da00273ff8e100ca851f0c413f2f6db 100644
--- a/net/minecraft/world/entity/npc/WanderingTraderSpawner.java
+++ b/net/minecraft/world/entity/npc/WanderingTraderSpawner.java
@@ -136,7 +136,17 @@ public class WanderingTraderSpawner implements CustomSpawner {
             int i1 = pos.getX() + this.random.nextInt(maxDistance * 2) - maxDistance;
             int i2 = pos.getZ() + this.random.nextInt(maxDistance * 2) - maxDistance;
             int height = level.getHeight(Heightmap.Types.WORLD_SURFACE, i1, i2);
-            BlockPos blockPos1 = new BlockPos(i1, height, i2);
+            // Purpur start - Allow toggling special MobSpawners per world - allow traders to spawn below nether roof
+            BlockPos.MutableBlockPos blockPos1 = new BlockPos.MutableBlockPos(i1, height, i2);
+            if (level.dimensionType().hasCeiling()) {
+                do {
+                    blockPos1.relative(net.minecraft.core.Direction.DOWN);
+                } while (!level.getBlockState(blockPos1).isAir());
+                do {
+                    blockPos1.relative(net.minecraft.core.Direction.DOWN);
+                } while (level.getBlockState(blockPos1).isAir() && blockPos1.getY() > 0);
+            }
+            // Purpur end - Allow toggling special MobSpawners per world
             if (placementType.isSpawnPositionOk(level, blockPos1, EntityType.WANDERING_TRADER)) {
                 blockPos = blockPos1;
                 break;
diff --git a/net/minecraft/world/entity/player/Player.java b/net/minecraft/world/entity/player/Player.java
index 59a0315d38d4f6f9eb5322a0f7736652a532b3e9..f17b649cacc4258739630acdcf4b84b3173df64c 100644
--- a/net/minecraft/world/entity/player/Player.java
+++ b/net/minecraft/world/entity/player/Player.java
@@ -219,17 +219,40 @@ public abstract class Player extends LivingEntity {
     private int currentImpulseContextResetGraceTime = 0;
     public boolean affectsSpawning = true; // Paper - Affects Spawning API
     public net.kyori.adventure.util.TriState flyingFallDamage = net.kyori.adventure.util.TriState.NOT_SET; // Paper - flying fall damage
+    public int burpDelay = 0; // Purpur - Burp delay
+    public boolean canPortalInstant = false; // Purpur - Add portal permission bypass
+    public int sixRowEnderchestSlotCount = -1; // Purpur - Barrels and enderchests 6 rows
 
     // CraftBukkit start
     public boolean fauxSleeping;
     public int oldLevel = -1;
 
+    // Purpur start - AFK API
+    public abstract void setAfk(boolean afk);
+
+    public boolean isAfk() {
+        return false;
+    }
+    // Purpur end - AFK API
     @Override
     public org.bukkit.craftbukkit.entity.CraftHumanEntity getBukkitEntity() {
         return (org.bukkit.craftbukkit.entity.CraftHumanEntity) super.getBukkitEntity();
     }
     // CraftBukkit end
 
+    // Purpur start - Ridables
+    public abstract void resetLastActionTime();
+
+    @Override
+    public boolean processClick(InteractionHand hand) {
+        Entity vehicle = getRootVehicle();
+        if (vehicle != null && vehicle.getRider() == this) {
+            return vehicle.onClick(hand);
+        }
+        return false;
+    }
+    // Purpur end - Ridables
+
     public Player(Level level, GameProfile gameProfile) {
         super(EntityType.PLAYER, level);
         this.setUUID(gameProfile.getId());
@@ -287,6 +310,12 @@ public abstract class Player extends LivingEntity {
 
     @Override
     public void tick() {
+        // Purpur start - Burp delay
+        if (this.burpDelay > 0 && --this.burpDelay == 0) {
+            this.level().playSound(null, getX(), getY(), getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 1.0F, this.level().random.nextFloat() * 0.1F + 0.9F);
+        }
+        // Purpur end - Burp delay
+
         this.noPhysics = this.isSpectator();
         if (this.isSpectator() || this.isPassenger()) {
             this.setOnGround(false);
@@ -365,6 +394,17 @@ public abstract class Player extends LivingEntity {
             this.turtleHelmetTick();
         }
 
+        // Purpur start - Full netherite armor grants fire resistance
+        if (this.level().purpurConfig.playerNetheriteFireResistanceDuration > 0 && this.level().getGameTime() % 20 == 0) {
+            if (this.getItemBySlot(EquipmentSlot.HEAD).is(Items.NETHERITE_HELMET)
+                && this.getItemBySlot(EquipmentSlot.CHEST).is(Items.NETHERITE_CHESTPLATE)
+                && this.getItemBySlot(EquipmentSlot.LEGS).is(Items.NETHERITE_LEGGINGS)
+                && this.getItemBySlot(EquipmentSlot.FEET).is(Items.NETHERITE_BOOTS)) {
+                this.addEffect(new MobEffectInstance(MobEffects.FIRE_RESISTANCE, this.level().purpurConfig.playerNetheriteFireResistanceDuration, this.level().purpurConfig.playerNetheriteFireResistanceAmplifier, this.level().purpurConfig.playerNetheriteFireResistanceAmbient, this.level().purpurConfig.playerNetheriteFireResistanceShowParticles, this.level().purpurConfig.playerNetheriteFireResistanceShowIcon), org.bukkit.event.entity.EntityPotionEffectEvent.Cause.NETHERITE_ARMOR);
+            }
+        }
+        // Purpur end - Full netherite armor grants fire resistance
+
         this.cooldowns.tick();
         this.updatePlayerPose();
         if (this.currentImpulseContextResetGraceTime > 0) {
@@ -630,7 +670,7 @@ public abstract class Player extends LivingEntity {
             List<Entity> list = Lists.newArrayList();
 
             for (Entity entity : entities) {
-                if (entity.getType() == EntityType.EXPERIENCE_ORB) {
+                if (entity.getType() == EntityType.EXPERIENCE_ORB && entity.level().purpurConfig.playerExpPickupDelay >= 0) { // Purpur - Configurable player pickup exp delay
                     list.add(entity);
                 } else if (!entity.isRemoved()) {
                     this.touch(entity);
@@ -1226,7 +1266,7 @@ public abstract class Player extends LivingEntity {
                         flag2 = flag2 && !this.level().paperConfig().entities.behavior.disablePlayerCrits; // Paper - Toggleable player crits
                         if (flag2) {
                             damageSource = damageSource.critical(); // Paper - critical damage API
-                            f *= 1.5F;
+                            f *= (float) this.level().purpurConfig.playerCriticalDamageMultiplier; // Purpur - Add config change multiplier critical damage value
                         }
 
                         float f2 = f + f1;
@@ -1831,7 +1871,23 @@ public abstract class Player extends LivingEntity {
 
     @Override
     protected int getBaseExperienceReward(ServerLevel level) {
-        return !level.getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) && !this.isSpectator() ? Math.min(this.experienceLevel * 7, 100) : 0;
+        // Purpur start - Add player death exp control options
+        if (!level.getGameRules().getBoolean(GameRules.RULE_KEEPINVENTORY) && !this.isSpectator()) {
+            int toDrop;
+            try {
+                toDrop = Math.round(((Number) scriptEngine.eval("let expLevel = " + experienceLevel + "; " +
+                    "let expTotal = " + totalExperience + "; " +
+                    "let exp = " + experienceProgress + "; " +
+                    level().purpurConfig.playerDeathExpDropEquation)).floatValue());
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                toDrop = experienceLevel * 7;
+            }
+            return Math.min(toDrop, level().purpurConfig.playerDeathExpDropMax);
+        } else {
+            return 0;
+        }
+        // Purpur end - Add player death exp control options
     }
 
     @Override
@@ -1870,6 +1926,13 @@ public abstract class Player extends LivingEntity {
         return this.inventory.add(stack);
     }
 
+    // Purpur start - Player ridable in water option
+    @Override
+    public boolean dismountsUnderwater() {
+        return !level().purpurConfig.playerRidableInWater;
+    }
+    // Purpur end - Player ridable in water option
+
     public boolean setEntityOnShoulder(CompoundTag entityCompound) {
         if (this.isPassenger() || !this.onGround() || this.isInWater() || this.isInPowderSnow) {
             return false;
diff --git a/net/minecraft/world/entity/projectile/AbstractArrow.java b/net/minecraft/world/entity/projectile/AbstractArrow.java
index 8ebad3f14c502ff949b8d5a90d3ec5ebe7e0c72a..9f54c50d59bb85ee5962c91ab875c642c424ddc1 100644
--- a/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -76,6 +76,7 @@ public abstract class AbstractArrow extends Projectile {
     public ItemStack pickupItemStack = this.getDefaultPickupItem();
     @Nullable
     public ItemStack firedFromWeapon = null;
+    public net.minecraft.world.item.enchantment.ItemEnchantments actualEnchantments = net.minecraft.world.item.enchantment.ItemEnchantments.EMPTY; // Purpur - Add an option to fix MC-3304 projectile looting
 
     protected AbstractArrow(EntityType<? extends AbstractArrow> entityType, Level level) {
         super(entityType, level);
@@ -354,7 +355,7 @@ public abstract class AbstractArrow extends Projectile {
         this.setInGround(false);
         Vec3 deltaMovement = this.getDeltaMovement();
         this.setDeltaMovement(deltaMovement.multiply(this.random.nextFloat() * 0.2F, this.random.nextFloat() * 0.2F, this.random.nextFloat() * 0.2F));
-        this.life = 0;
+        if (this.level().purpurConfig.arrowMovementResetsDespawnCounter) this.life = 0; // Purpur - Arrows should not reset despawn counter
     }
 
     public boolean isInGround() {
@@ -578,6 +579,12 @@ public abstract class AbstractArrow extends Projectile {
         return this.firedFromWeapon;
     }
 
+    // Purpur start - Add an option to fix MC-3304 projectile looting
+    public void setActualEnchantments(net.minecraft.world.item.enchantment.ItemEnchantments actualEnchantments) {
+        this.actualEnchantments = actualEnchantments;
+    }
+    // Purpur end - Add an option to fix MC-3304 projectile looting
+
     protected SoundEvent getDefaultHitGroundSoundEvent() {
         return SoundEvents.ARROW_HIT;
     }
diff --git a/net/minecraft/world/entity/projectile/LargeFireball.java b/net/minecraft/world/entity/projectile/LargeFireball.java
index dd0ec97ea4561d2dccf735580faf0d65d6ac4b0d..779879f8d678a5e45e2752e6e033cc350acac89b 100644
--- a/net/minecraft/world/entity/projectile/LargeFireball.java
+++ b/net/minecraft/world/entity/projectile/LargeFireball.java
@@ -20,20 +20,20 @@ public class LargeFireball extends Fireball {
 
     public LargeFireball(EntityType<? extends LargeFireball> entityType, Level level) {
         super(entityType, level);
-        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING); // CraftBukkit
+        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // CraftBukkit // Purpur - Add mobGriefing override to everything affected
     }
 
     public LargeFireball(Level level, LivingEntity owner, Vec3 movement, int explosionPower) {
         super(EntityType.FIREBALL, owner, movement, level);
         this.explosionPower = explosionPower;
-        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING); // CraftBukkit
+        this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // CraftBukkit // Purpur - Add mobGriefing override to everything affected
     }
 
     @Override
     protected void onHit(HitResult result) {
         super.onHit(result);
         if (this.level() instanceof ServerLevel serverLevel) {
-            boolean _boolean = serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING);
+            boolean _boolean = serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
             // CraftBukkit start - fire ExplosionPrimeEvent
             org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent((org.bukkit.entity.Explosive) this.getBukkitEntity());
             if (event.callEvent()) {
diff --git a/net/minecraft/world/entity/projectile/LlamaSpit.java b/net/minecraft/world/entity/projectile/LlamaSpit.java
index e0277e9c8037e90d0a479e8fb5013b88c214bd97..8a0374b69fbd76fa71ae33c95a671e9fae4475cb 100644
--- a/net/minecraft/world/entity/projectile/LlamaSpit.java
+++ b/net/minecraft/world/entity/projectile/LlamaSpit.java
@@ -33,6 +33,12 @@ public class LlamaSpit extends Projectile {
         );
     }
 
+    // Purpur start - Ridables
+    public void projectileTick() {
+        super.tick();
+    }
+    // Purpur end - Ridables
+
     @Override
     protected double getDefaultGravity() {
         return 0.06;
diff --git a/net/minecraft/world/entity/projectile/Projectile.java b/net/minecraft/world/entity/projectile/Projectile.java
index b6cdd02ead8ecc38afd4e76fa0c19a9433550b1d..c49f4a231cc84b2eb1601ad7f1642363b1dc931b 100644
--- a/net/minecraft/world/entity/projectile/Projectile.java
+++ b/net/minecraft/world/entity/projectile/Projectile.java
@@ -447,7 +447,7 @@ public abstract class Projectile extends Entity implements TraceableEntity {
     @Override
     public boolean mayInteract(ServerLevel level, BlockPos pos) {
         Entity owner = this.getOwner();
-        return owner instanceof Player && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(owner) ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING); // Folia - region threading
+        return owner instanceof Player && ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(owner) ? owner.mayInteract(level, pos) : owner == null || level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.projectilesMobGriefingOverride); // Folia - region threading // Purpur - Add mobGriefing override to everything affected 
     }
 
     public boolean mayBreak(ServerLevel level) {
diff --git a/net/minecraft/world/entity/projectile/SmallFireball.java b/net/minecraft/world/entity/projectile/SmallFireball.java
index ba70ce3df630532b646eab0a5fabca15d67c379b..7b7a788237077c8b6c3d7380e0df30a1f36b720b 100644
--- a/net/minecraft/world/entity/projectile/SmallFireball.java
+++ b/net/minecraft/world/entity/projectile/SmallFireball.java
@@ -25,7 +25,7 @@ public class SmallFireball extends Fireball {
         super(EntityType.SMALL_FIREBALL, owner, movement, level);
         // CraftBukkit start
         if (owner != null && this.getOwner() != null && this.getOwner() instanceof Mob) { // Folia - region threading
-            this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING);
+            this.isIncendiary = (level instanceof ServerLevel serverLevel) && serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.fireballsMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
         }
         // CraftBukkit end
     }
diff --git a/net/minecraft/world/entity/projectile/Snowball.java b/net/minecraft/world/entity/projectile/Snowball.java
index 677b4b681f9c2c09a8ae3cfdec72102265547a7b..d8f9fb603fd2e3e5c1dfc05face7f42b4844daf4 100644
--- a/net/minecraft/world/entity/projectile/Snowball.java
+++ b/net/minecraft/world/entity/projectile/Snowball.java
@@ -52,10 +52,40 @@ public class Snowball extends ThrowableItemProjectile {
     protected void onHitEntity(EntityHitResult result) {
         super.onHitEntity(result);
         Entity entity = result.getEntity();
-        int i = entity instanceof Blaze ? 3 : 0;
+        int i = entity.level().purpurConfig.snowballDamage >= 0 ? entity.level().purpurConfig.snowballDamage : entity instanceof Blaze ? 3 : 0; // Purpur - Add configurable snowball damage
         entity.hurt(this.damageSources().thrown(this, this.getOwner()), i);
     }
 
+    // Purpur start - options to extinguish fire blocks with snowballs - borrowed and modified code from ThrownPotion#onHitBlock and ThrownPotion#dowseFire
+    @Override
+    protected void onHitBlock(net.minecraft.world.phys.BlockHitResult blockHitResult) {
+        super.onHitBlock(blockHitResult);
+
+        if (!this.level().isClientSide) {
+            net.minecraft.core.BlockPos pos = blockHitResult.getBlockPos();
+            net.minecraft.core.BlockPos relativePos = pos.relative(blockHitResult.getDirection());
+
+            net.minecraft.world.level.block.state.BlockState blockState = this.level().getBlockState(pos);
+
+            if (this.level().purpurConfig.snowballExtinguishesFire && this.level().getBlockState(relativePos).is(net.minecraft.world.level.block.Blocks.FIRE)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, relativePos, net.minecraft.world.level.block.Blocks.AIR.defaultBlockState())) {
+                    this.level().removeBlock(relativePos, false);
+                }
+            } else if (this.level().purpurConfig.snowballExtinguishesCandles && net.minecraft.world.level.block.AbstractCandleBlock.isLit(blockState)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, pos, blockState.setValue(net.minecraft.world.level.block.AbstractCandleBlock.LIT, false))) {
+                    net.minecraft.world.level.block.AbstractCandleBlock.extinguish(null, blockState, this.level(), pos);
+                }
+            } else if (this.level().purpurConfig.snowballExtinguishesCampfires && net.minecraft.world.level.block.CampfireBlock.isLitCampfire(blockState)) {
+                if (org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(this, pos, blockState.setValue(net.minecraft.world.level.block.CampfireBlock.LIT, false))) {
+                    this.level().levelEvent(null, 1009, pos, 0);
+                    net.minecraft.world.level.block.CampfireBlock.dowse(this.getOwner(), this.level(), pos, blockState);
+                    this.level().setBlockAndUpdate(pos, blockState.setValue(net.minecraft.world.level.block.CampfireBlock.LIT, false));
+                }
+            }
+        }
+    }
+    // Purpur end - options to extinguish fire blocks with snowballs
+
     @Override
     protected void onHit(HitResult result) {
         super.onHit(result);
diff --git a/net/minecraft/world/entity/projectile/ThrownEnderpearl.java b/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
index bded685ed1653e9a1e2d7d4a9c4f68da58a6b06e..2789d0003441d40cf16b5a1475671c6019535ad0 100644
--- a/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
+++ b/net/minecraft/world/entity/projectile/ThrownEnderpearl.java
@@ -211,9 +211,10 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                             return;
                         }
                         // CraftBukkit end
-                        if (this.random.nextFloat() < 0.05F && serverLevel.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)) {
+                        if (this.random.nextFloat() < serverLevel.purpurConfig.enderPearlEndermiteChance && serverLevel.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)) { // Purpur - Configurable Ender Pearl RNG
                             Endermite endermite = EntityType.ENDERMITE.create(serverLevel, EntitySpawnReason.TRIGGERED);
                             if (endermite != null) {
+                                endermite.setPlayerSpawned(true); // Purpur - Add back player spawned endermite API
                                 endermite.snapTo(owner.getX(), owner.getY(), owner.getZ(), owner.getYRot(), owner.getXRot());
                                 serverLevel.addFreshEntity(endermite, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.ENDER_PEARL);
                             }
@@ -233,7 +234,7 @@ public class ThrownEnderpearl extends ThrowableItemProjectile {
                         if (serverPlayer1 != null) {
                             serverPlayer1.resetFallDistance();
                             serverPlayer1.resetCurrentImpulseContext();
-                            serverPlayer1.hurtServer(serverPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), 5.0F); // CraftBukkit // Paper - fix DamageSource API
+                            serverPlayer1.hurtServer(serverPlayer.level(), this.damageSources().enderPearl().eventEntityDamager(this), this.level().purpurConfig.enderPearlDamage); // CraftBukkit // Paper - fix DamageSource API // Purpur - Configurable Ender Pearl damage
                         }
 
                         this.playSound(serverLevel, vec3);
diff --git a/net/minecraft/world/entity/projectile/ThrownTrident.java b/net/minecraft/world/entity/projectile/ThrownTrident.java
index bc04812ec840e255c0ae8651bf7a43e0f562aa9c..b6826fc742640e7f8311bd0269aa0d8a6a9b2db4 100644
--- a/net/minecraft/world/entity/projectile/ThrownTrident.java
+++ b/net/minecraft/world/entity/projectile/ThrownTrident.java
@@ -66,7 +66,7 @@ public class ThrownTrident extends AbstractArrow {
 
         Entity owner = this.getOwner();
         int i = this.entityData.get(ID_LOYALTY);
-        if (i > 0 && (this.dealtDamage || this.isNoPhysics()) && owner != null) {
+        if (i > 0 && (this.dealtDamage || this.isNoPhysics() || (level().purpurConfig.tridentLoyaltyVoidReturnHeight < 0.0D && getY() < level().purpurConfig.tridentLoyaltyVoidReturnHeight)) && owner != null) { // Purpur - Add option to allow loyalty on tridents to work in the void
             if (!this.isAcceptibleReturnOwner()) {
                 if (this.level() instanceof ServerLevel serverLevel && this.pickup == AbstractArrow.Pickup.ALLOWED) {
                     this.spawnAtLocation(serverLevel, this.getPickupItem(), 0.1F);
diff --git a/net/minecraft/world/entity/projectile/WitherSkull.java b/net/minecraft/world/entity/projectile/WitherSkull.java
index 2419c1db39c9ffbc54352c7fa5e0ac1ef813c13a..3b68e1a73da3e70f459cdc31e8447bcee37a914d 100644
--- a/net/minecraft/world/entity/projectile/WitherSkull.java
+++ b/net/minecraft/world/entity/projectile/WitherSkull.java
@@ -94,7 +94,7 @@ public class WitherSkull extends AbstractHurtingProjectile {
         super.onHit(result);
         if (!this.level().isClientSide) {
             // CraftBukkit start
-            org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent(this.getBukkitEntity(), 1.0F, false);
+            org.bukkit.event.entity.ExplosionPrimeEvent event = new org.bukkit.event.entity.ExplosionPrimeEvent(this.getBukkitEntity(), this.level().purpurConfig.witherExplosionRadius, false); // Purpur - Config for wither explosion radius
             if (event.callEvent()) {
                 this.level().explode(this, this.getX(), this.getY(), this.getZ(), event.getRadius(), event.getFire(), Level.ExplosionInteraction.MOB);
             }
@@ -103,6 +103,21 @@ public class WitherSkull extends AbstractHurtingProjectile {
         }
     }
 
+    // Purpur start - Add canSaveToDisk to Entity
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+    // Purpur end - Add canSaveToDisk to Entity
+
+    // Purpur start - Ridables
+    @Override
+    public boolean canHitEntity(Entity target) {
+        // do not hit rider
+        return target != this.getRider() && super.canHitEntity(target);
+    }
+    // Purpur end - Ridables
+
     @Override
     protected void defineSynchedData(SynchedEntityData.Builder builder) {
         builder.define(DATA_DANGEROUS, false);
diff --git a/net/minecraft/world/entity/raid/Raider.java b/net/minecraft/world/entity/raid/Raider.java
index 3e30989c99cd11c8c94d6fd194d2969e3a7efda6..ae5bf1715c895c914c50cc1cda5f96b7c2cef18e 100644
--- a/net/minecraft/world/entity/raid/Raider.java
+++ b/net/minecraft/world/entity/raid/Raider.java
@@ -401,7 +401,7 @@ public abstract class Raider extends PatrollingMonster {
         }
 
         private boolean cannotPickUpBanner() {
-            if (!getServerLevel(this.mob).getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_MOBGRIEFING)) return true; // Paper - respect game and entity rules for picking up items
+            if (!getServerLevel(this.mob).getGameRules().getBoolean(net.minecraft.world.level.GameRules.RULE_MOBGRIEFING, this.mob.level().purpurConfig.pillagerMobGriefingOverride)) return true; // Paper - respect game and entity rules for picking up items // Purpur - Add mobGriefing override to everything affected
             if (!this.mob.hasActiveRaid()) {
                 return true;
             } else if (this.mob.getCurrentRaid().isOver()) {
diff --git a/net/minecraft/world/entity/raid/Raids.java b/net/minecraft/world/entity/raid/Raids.java
index cb383b943536c4a6c5a754f4ff2b71c48dfff103..3e07b0f0bc003d6a736d896caa1cdfaebc60f046 100644
--- a/net/minecraft/world/entity/raid/Raids.java
+++ b/net/minecraft/world/entity/raid/Raids.java
@@ -29,6 +29,7 @@ import net.minecraft.world.phys.Vec3;
 
 public class Raids extends SavedData {
     private static final String RAID_FILE_ID = "raids";
+    public final java.util.Map<java.util.UUID, Integer> playerCooldowns = com.google.common.collect.Maps.newHashMap(); // Purpur - Raid cooldown setting
     public static final Codec<Raids> CODEC = RecordCodecBuilder.create(
         instance -> instance.group(
                 Raids.RaidWithId.CODEC
@@ -90,6 +91,17 @@ public class Raids extends SavedData {
 
     public void tick(ServerLevel level) {
         // Folia end - make raids thread-safe
+        // Purpur start - Raid cooldown setting
+        if (level.purpurConfig.raidCooldownSeconds != 0 && this.tick % 20 == 0) {
+            com.google.common.collect.ImmutableMap.copyOf(playerCooldowns).forEach((uuid, i) -> {
+                if (i < 1) {
+                    playerCooldowns.remove(uuid);
+                } else {
+                    playerCooldowns.put(uuid, i - 1);
+                }
+            });
+        }
+        // Purpur end - Raid cooldown setting
         Iterator<Raid> iterator = this.raidMap.values().iterator();
 
         while (iterator.hasNext()) {
@@ -160,11 +172,13 @@ public class Raids extends SavedData {
                     // }
 
                     if (!raid.isStarted() || (raid.isInProgress() && raid.getRaidOmenLevel() < raid.getMaxRaidOmenLevel())) { // CraftBukkit - fixed a bug with raid: players could add up Bad Omen level even when the raid had finished
+                        if (serverLevel.purpurConfig.raidCooldownSeconds != 0 && playerCooldowns.containsKey(player.getUUID())) return null; // Purpur - Raid cooldown setting
                         // CraftBukkit start
                         if (!org.bukkit.craftbukkit.event.CraftEventFactory.callRaidTriggerEvent(serverLevel, raid, player)) {
                             player.removeEffect(net.minecraft.world.effect.MobEffects.RAID_OMEN);
                             return null;
                         }
+                        if (serverLevel.purpurConfig.raidCooldownSeconds != 0) playerCooldowns.put(player.getUUID(), serverLevel.purpurConfig.raidCooldownSeconds); // Purpur - Raid cooldown setting
 
                         if (!raid.isStarted() && !this.raidMap.containsValue(raid)) {
                             int id = this.getUniqueId(); this.raidMap.put(id, raid); // Folia - region threading
diff --git a/net/minecraft/world/entity/vehicle/AbstractBoat.java b/net/minecraft/world/entity/vehicle/AbstractBoat.java
index df360ff06d10fc7f996055dce5148825539e9261..d947801b616af5b5dcdcc8bb70b36f97d6a69fdd 100644
--- a/net/minecraft/world/entity/vehicle/AbstractBoat.java
+++ b/net/minecraft/world/entity/vehicle/AbstractBoat.java
@@ -436,6 +436,7 @@ public abstract class AbstractBoat extends VehicleEntity implements Leashable {
             float groundFriction = this.getGroundFriction();
             if (groundFriction > 0.0F) {
                 this.landFriction = groundFriction;
+                if (level().purpurConfig.boatEjectPlayersOnLand) ejectPassengers(); // Purpur - Add option for boats to eject players on land
                 return AbstractBoat.Status.ON_LAND;
             } else {
                 return AbstractBoat.Status.IN_AIR;
@@ -824,7 +825,13 @@ public abstract class AbstractBoat extends VehicleEntity implements Leashable {
 
     @Override
     public final ItemStack getPickResult() {
-        return new ItemStack(this.dropItem.get());
+        // Purpur start - Apply display names from item forms of entities to entities and vice versa
+        final ItemStack boat = new ItemStack(this.dropItem.get());
+        if (!this.level().purpurConfig.persistentDroppableEntityDisplayNames) {
+            boat.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, null);
+        }
+        return boat;
+        // Purpur end - Apply display names from item forms of entities to entities and vice versa
     }
 
     public static enum Status {
diff --git a/net/minecraft/world/entity/vehicle/AbstractMinecart.java b/net/minecraft/world/entity/vehicle/AbstractMinecart.java
index 7e61d68b36ca2768f70dc1fc130a8d7b95347b6b..00eb9aef52ee54f9750c44832f2b3a9321a9f81a 100644
--- a/net/minecraft/world/entity/vehicle/AbstractMinecart.java
+++ b/net/minecraft/world/entity/vehicle/AbstractMinecart.java
@@ -102,6 +102,10 @@ public abstract class AbstractMinecart extends VehicleEntity {
     private double flyingY = 0.95;
     private double flyingZ = 0.95;
     public @Nullable Double maxSpeed;
+    // Purpur start - Minecart settings and WASD controls
+    public double storedMaxSpeed;
+    public boolean isNewBehavior;
+    // Purpur end - Minecart settings and WASD controls
     public net.kyori.adventure.util.TriState frictionState = net.kyori.adventure.util.TriState.NOT_SET; // Paper - Friction API
     // CraftBukkit end
 
@@ -110,8 +114,13 @@ public abstract class AbstractMinecart extends VehicleEntity {
         this.blocksBuilding = true;
         if (useExperimentalMovement(level)) {
             this.behavior = new NewMinecartBehavior(this);
+            this.isNewBehavior = true; // Purpur - Minecart settings and WASD controls
         } else {
             this.behavior = new OldMinecartBehavior(this);
+            // Purpur start - Minecart settings and WASD controls
+            this.isNewBehavior = false;
+            maxSpeed = storedMaxSpeed = level.purpurConfig.minecartMaxSpeed;
+            // Purpur end - Minecart settings and WASD controls
         }
     }
 
@@ -276,6 +285,14 @@ public abstract class AbstractMinecart extends VehicleEntity {
 
     @Override
     public void tick() {
+        // Purpur start - Minecart settings and WASD controls
+        if (!this.isNewBehavior) {
+            if (storedMaxSpeed != level().purpurConfig.minecartMaxSpeed) {
+                maxSpeed = storedMaxSpeed = level().purpurConfig.minecartMaxSpeed;
+            }
+        }
+        // Purpur end - Minecart settings and WASD controls
+
         // CraftBukkit start
         double prevX = this.getX();
         double prevY = this.getY();
@@ -390,15 +407,61 @@ public abstract class AbstractMinecart extends VehicleEntity {
         this.behavior.moveAlongTrack(level);
     }
 
+    // Purpur start - Minecart settings and WASD controls
+    private Double lastSpeed;
+
+    public double getControllableSpeed() {
+        BlockState blockState = level().getBlockState(this.blockPosition());
+        if (!blockState.isSolid()) {
+            blockState = level().getBlockState(this.blockPosition().relative(Direction.DOWN));
+        }
+        Double speed = level().purpurConfig.minecartControllableBlockSpeeds.get(blockState.getBlock());
+        if (!blockState.isSolid()) {
+            speed = lastSpeed;
+        }
+        if (speed == null) {
+            speed = level().purpurConfig.minecartControllableBaseSpeed;
+        }
+        return lastSpeed = speed;
+    }
+    // Purpur end - Minecart settings and WASD controls
+
     protected void comeOffTrack(ServerLevel level) {
         double maxSpeed = this.getMaxSpeed(level);
         Vec3 deltaMovement = this.getDeltaMovement();
         this.setDeltaMovement(Mth.clamp(deltaMovement.x, -maxSpeed, maxSpeed), deltaMovement.y, Mth.clamp(deltaMovement.z, -maxSpeed, maxSpeed));
+
+        // Purpur start - Minecart settings and WASD controls
+        if (level().purpurConfig.minecartControllable && !isInWater() && !isInLava() && !passengers.isEmpty()) {
+            Entity passenger = passengers.get(0);
+            if (passenger instanceof net.minecraft.server.level.ServerPlayer player) {
+                net.minecraft.world.entity.player.Input lastClientInput = player.getLastClientInput();
+                float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+                if (lastClientInput.jump() && this.onGround) {
+                    setDeltaMovement(new Vec3(getDeltaMovement().x, level().purpurConfig.minecartControllableHopBoost, getDeltaMovement().z));
+                }
+                if (forward != 0.0F) {
+                    org.bukkit.util.Vector velocity = player.getBukkitEntity().getEyeLocation().getDirection().normalize().multiply(getControllableSpeed());
+                    if (forward < 0.0) {
+                        velocity.multiply(-0.5);
+                    }
+                    setDeltaMovement(new Vec3(velocity.getX(), getDeltaMovement().y, velocity.getZ()));
+                }
+                this.setYRot(passenger.getYRot() - 90);
+                maxUpStep = level().purpurConfig.minecartControllableStepHeight;
+            } else {
+                maxUpStep = 0.0F;
+            }
+        } else {
+            maxUpStep = 0.0F;
+        }
+        // Purpur end - Minecart settings and WASD controls
         if (this.onGround()) {
             // CraftBukkit start - replace magic numbers with our variables
             this.setDeltaMovement(new Vec3(this.getDeltaMovement().x * this.derailedX, this.getDeltaMovement().y * this.derailedY, this.getDeltaMovement().z * this.derailedZ));
             // CraftBukkit end
         }
+        else if (level().purpurConfig.minecartControllable) setDeltaMovement(new Vec3(getDeltaMovement().x * derailedX, getDeltaMovement().y, getDeltaMovement().z * derailedZ)); // Purpur - Minecart settings and WASD controls
 
         this.move(MoverType.SELF, this.getDeltaMovement());
         if (!this.onGround()) {
diff --git a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
index 090b19752fbfc856d9fbf118510afc6cda2b9989..325ec57df2885f5e81b8a6b61e3a9fed9484b30f 100644
--- a/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/NewMinecartBehavior.java
@@ -391,7 +391,7 @@ public class NewMinecartBehavior extends MinecartBehavior {
     private Vec3 calculateBoostTrackSpeed(Vec3 speed, BlockPos pos, BlockState state) {
         if (state.is(Blocks.POWERED_RAIL) && state.getValue(PoweredRailBlock.POWERED)) {
             if (speed.length() > 0.01) {
-                return speed.normalize().scale(speed.length() + 0.06);
+                return speed.normalize().scale(speed.length() + this.level().purpurConfig.poweredRailBoostModifier); // Purpur - Configurable powered rail boost modifier
             } else {
                 Vec3 redstoneDirection = this.minecart.getRedstoneDirection(pos);
                 return redstoneDirection.lengthSqr() <= 0.0 ? speed : redstoneDirection.scale(speed.length() + 0.2);
diff --git a/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java b/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
index 0d09b0809e7b224538cf5cfac9e36ec5ba10b709..4d224dc127d245556892e761fa4927a76e4b8e9a 100644
--- a/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
+++ b/net/minecraft/world/entity/vehicle/OldMinecartBehavior.java
@@ -243,8 +243,8 @@ public class OldMinecartBehavior extends MinecartBehavior {
             Vec3 deltaMovement1 = this.getDeltaMovement();
             double d13 = deltaMovement1.horizontalDistance();
             if (d13 > 0.01) {
-                double d14 = 0.06;
-                this.setDeltaMovement(deltaMovement1.add(deltaMovement1.x / d13 * 0.06, 0.0, deltaMovement1.z / d13 * 0.06));
+                double d14 = level.purpurConfig.poweredRailBoostModifier; // Purpur - Configurable powered rail boost modifier
+                this.setDeltaMovement(deltaMovement1.add(deltaMovement1.x / d13 * level.purpurConfig.poweredRailBoostModifier, 0.0, deltaMovement1.z / d13 * level.purpurConfig.poweredRailBoostModifier)); // Purpur - Configurable powered rail boost modifier
             } else {
                 Vec3 deltaMovement2 = this.getDeltaMovement();
                 double d15 = deltaMovement2.x;
diff --git a/net/minecraft/world/food/FoodData.java b/net/minecraft/world/food/FoodData.java
index a1b99dea0fa5860a01158897006e1065050c029b..d1080acfe91bd1ca28e21ffc68a928dc0f233be3 100644
--- a/net/minecraft/world/food/FoodData.java
+++ b/net/minecraft/world/food/FoodData.java
@@ -39,6 +39,7 @@ public class FoodData {
         int oldFoodLevel = this.foodLevel;
         org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(serverPlayer, foodProperties.nutrition() + oldFoodLevel, stack);
         if (!event.isCancelled()) {
+            if (serverPlayer.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) serverPlayer.burpDelay = serverPlayer.level().purpurConfig.playerBurpDelay; // Purpur - Burp after eating food fills hunger bar completely
             this.add(event.getFoodLevel() - oldFoodLevel, foodProperties.saturation());
         }
         serverPlayer.getBukkitEntity().sendHealthUpdate();
@@ -87,7 +88,7 @@ public class FoodData {
             this.tickTimer++;
             if (this.tickTimer >= this.starvationRate) { // CraftBukkit - add regen rate manipulation
                 if (player.getHealth() > 10.0F || difficulty == Difficulty.HARD || player.getHealth() > 1.0F && difficulty == Difficulty.NORMAL) {
-                    player.hurtServer(serverLevel, player.damageSources().starve(), 1.0F);
+                    player.hurtServer(serverLevel, player.damageSources().starve(), player.level().purpurConfig.hungerStarvationDamage); // Purpur - Configurable hunger starvation damage
                 }
 
                 this.tickTimer = 0;
diff --git a/net/minecraft/world/food/FoodProperties.java b/net/minecraft/world/food/FoodProperties.java
index 793e4528755fa5688efbad75418188e693ad0157..20f702c8266eb54a8835861188eb937f4732e078 100644
--- a/net/minecraft/world/food/FoodProperties.java
+++ b/net/minecraft/world/food/FoodProperties.java
@@ -42,9 +42,11 @@ public record FoodProperties(int nutrition, float saturation, boolean canAlwaysE
         level.playSound(null, entity.getX(), entity.getY(), entity.getZ(), consumable.sound().value(), SoundSource.NEUTRAL, 1.0F, random.triangle(1.0F, 0.4F));
         if (entity instanceof Player player) {
             player.getFoodData().eat(this, stack, (net.minecraft.server.level.ServerPlayer) player); // CraftBukkit
-            level.playSound(
-                null, player.getX(), player.getY(), player.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, Mth.randomBetween(random, 0.9F, 1.0F)
-            );
+            // Purpur start - Burp delay - moved to Player#tick()
+            //level.playSound(
+            //    null, player.getX(), player.getY(), player.getZ(), SoundEvents.PLAYER_BURP, SoundSource.PLAYERS, 0.5F, Mth.randomBetween(random, 0.9F, 1.0F)
+            //);
+            // Purpur end - Burp delay - moved to Player#tick()
         }
     }
 
diff --git a/net/minecraft/world/inventory/AbstractContainerMenu.java b/net/minecraft/world/inventory/AbstractContainerMenu.java
index f4548edae77eb86e54ba499acbb20613fd60d7bd..1f601781643945920c7522b9c6100d0a37ad535d 100644
--- a/net/minecraft/world/inventory/AbstractContainerMenu.java
+++ b/net/minecraft/world/inventory/AbstractContainerMenu.java
@@ -65,6 +65,7 @@ public abstract class AbstractContainerMenu {
     @Nullable
     private ContainerSynchronizer synchronizer;
     private boolean suppressRemoteUpdates;
+    @Nullable protected ItemStack activeQuickItem = null; // Purpur - Anvil API
     // CraftBukkit start
     public boolean checkReachable = true;
     public abstract org.bukkit.inventory.InventoryView getBukkitView();
diff --git a/net/minecraft/world/inventory/AbstractFurnaceMenu.java b/net/minecraft/world/inventory/AbstractFurnaceMenu.java
index b42d55c1c0c405ce3ce073138343e74fa036fa65..b86e49b09a036532e7dbd56bc52b13cefe77f75b 100644
--- a/net/minecraft/world/inventory/AbstractFurnaceMenu.java
+++ b/net/minecraft/world/inventory/AbstractFurnaceMenu.java
@@ -121,7 +121,13 @@ public abstract class AbstractFurnaceMenu extends RecipeBookMenu {
             } else if (index != 1 && index != 0) {
                 if (this.canSmelt(item)) {
                     if (!this.moveItemStackTo(item, 0, 1, false)) {
-                        return ItemStack.EMPTY;
+                        // Purpur start - Added the ability to add combustible items
+                        if (this.isFuel(item)) {
+                            if (!this.moveItemStackTo(item, 1, 2, false)) {
+                                return ItemStack.EMPTY;
+                            }
+                        }
+                        // Purpur end - Added the ability to add combustible items
                     }
                 } else if (this.isFuel(item)) {
                     if (!this.moveItemStackTo(item, 1, 2, false)) {
diff --git a/net/minecraft/world/inventory/AnvilMenu.java b/net/minecraft/world/inventory/AnvilMenu.java
index 2346e1fc0c94084c3bb95c00be8aac36ae5f26ae..c75ad34d2e8b51999abbbca960bdda4973e356dc 100644
--- a/net/minecraft/world/inventory/AnvilMenu.java
+++ b/net/minecraft/world/inventory/AnvilMenu.java
@@ -21,6 +21,12 @@ import net.minecraft.world.level.block.AnvilBlock;
 import net.minecraft.world.level.block.state.BlockState;
 import org.slf4j.Logger;
 
+// Purpur start - Anvil API
+import net.minecraft.network.protocol.game.ClientboundContainerSetDataPacket;
+import net.minecraft.network.protocol.game.ClientboundContainerSetSlotPacket;
+import net.minecraft.server.level.ServerPlayer;
+// Purpur end - Anvil API
+
 public class AnvilMenu extends ItemCombinerMenu {
     public static final int INPUT_SLOT = 0;
     public static final int ADDITIONAL_SLOT = 1;
@@ -50,6 +56,10 @@ public class AnvilMenu extends ItemCombinerMenu {
     private org.bukkit.craftbukkit.inventory.view.CraftAnvilView bukkitEntity;
     // CraftBukkit end
     public boolean bypassEnchantmentLevelRestriction = false; // Paper - bypass anvil level restrictions
+    // Purpur start - Anvil API
+    public boolean bypassCost = false;
+    public boolean canDoUnsafeEnchants = false;
+    // Purpur end - Anvil API
 
     public AnvilMenu(int containerId, Inventory playerInventory) {
         this(containerId, playerInventory, ContainerLevelAccess.NULL);
@@ -75,12 +85,17 @@ public class AnvilMenu extends ItemCombinerMenu {
 
     @Override
     protected boolean mayPickup(Player player, boolean hasStack) {
-        return (player.hasInfiniteMaterials() || player.experienceLevel >= this.cost.get()) && this.cost.get() > AnvilMenu.DEFAULT_DENIED_COST && hasStack; // CraftBukkit - allow cost 0 like a free item
+        return (player.hasInfiniteMaterials() || player.experienceLevel >= this.cost.get()) && (this.bypassCost || this.cost.get() > AnvilMenu.DEFAULT_DENIED_COST) && hasStack; // CraftBukkit - allow cost 0 like a free item // Purpur - Anvil API
     }
 
     @Override
     protected void onTake(Player player, ItemStack stack) {
+        // Purpur start - Anvil API
+        ItemStack itemstack = this.activeQuickItem != null ? this.activeQuickItem : stack;
+        if (org.purpurmc.purpur.event.inventory.AnvilTakeResultEvent.getHandlerList().getRegisteredListeners().length > 0) new org.purpurmc.purpur.event.inventory.AnvilTakeResultEvent(player.getBukkitEntity(), getBukkitView(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack)).callEvent();
+        // Purpur end - Anvil API
         if (!player.hasInfiniteMaterials()) {
+            if (this.bypassCost) ((ServerPlayer) player).lastSentExp = -1; else // Purpur - Anvil API
             player.giveExperienceLevels(-this.cost.get());
         }
 
@@ -133,13 +148,19 @@ public class AnvilMenu extends ItemCombinerMenu {
 
     @Override
     public void createResult() {
+        // Purpur start - Anvil API
+        this.bypassCost = false;
+        this.canDoUnsafeEnchants = false;
+        if (org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent.getHandlerList().getRegisteredListeners().length > 0) new org.purpurmc.purpur.event.inventory.AnvilUpdateResultEvent(getBukkitView()).callEvent();
+        // Purpur end - Anvil API
+
         ItemStack item = this.inputSlots.getItem(0);
         this.onlyRenaming = false;
         this.cost.set(1);
         int i = 0;
         long l = 0L;
         int i1 = 0;
-        if (!item.isEmpty() && EnchantmentHelper.canStoreEnchantments(item)) {
+        if (!item.isEmpty() && this.canDoUnsafeEnchants || EnchantmentHelper.canStoreEnchantments(item)) { // Purpur - Anvil API
             ItemStack itemStack = item.copy();
             ItemStack item1 = this.inputSlots.getItem(1);
             ItemEnchantments.Mutable mutable = new ItemEnchantments.Mutable(EnchantmentHelper.getEnchantmentsForCrafting(itemStack));
@@ -197,23 +218,34 @@ public class AnvilMenu extends ItemCombinerMenu {
                         int intValue = entry.getIntValue();
                         intValue = level == intValue ? intValue + 1 : Math.max(intValue, level);
                         Enchantment enchantment = holder.value();
-                        boolean canEnchant = enchantment.canEnchant(item);
+                        // Purpur start - Config to allow unsafe enchants
+                        boolean canEnchant = this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowInapplicableEnchants || enchantment.canEnchant(item); // whether the enchantment can be applied on specific item type
+                        boolean canEnchant1 = true; // whether two incompatible enchantments can be applied on a single item
+                        // Purpur end - Config to allow unsafe enchants
                         if (this.player.hasInfiniteMaterials() || item.is(Items.ENCHANTED_BOOK)) {
                             canEnchant = true;
                         }
 
+                        java.util.Set<Holder<Enchantment>> removedEnchantments = new java.util.HashSet<>(); // Purpur - Config to allow unsafe enchants
                         for (Holder<Enchantment> holder1 : mutable.keySet()) {
                             if (!holder1.equals(holder) && !Enchantment.areCompatible(holder, holder1)) {
-                                canEnchant = false;
+                                canEnchant1 = this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowIncompatibleEnchants; // Purpur - Anvil API // Purpur - canEnchant -> canEnchant1 - Config to allow unsafe enchants
+                                // Purpur start - Config to allow unsafe enchants
+                                if (!canEnchant1 && org.purpurmc.purpur.PurpurConfig.replaceIncompatibleEnchants) {
+                                    removedEnchantments.add(holder1);
+                                    canEnchant1 = true;
+                                }
+                                // Purpur end - Config to allow unsafe enchants
                                 i++;
                             }
                         }
+                        mutable.removeIf(removedEnchantments::contains); // Purpur - Config to allow unsafe enchants
 
-                        if (!canEnchant) {
+                        if (!canEnchant || !canEnchant1) { // Purpur - Config to allow unsafe enchants
                             flag1 = true;
                         } else {
                             flag = true;
-                            if (intValue > enchantment.getMaxLevel() && !this.bypassEnchantmentLevelRestriction) { // Paper - bypass anvil level restrictions
+                            if (!org.purpurmc.purpur.PurpurConfig.allowHigherEnchantsLevels && intValue > enchantment.getMaxLevel() && !this.bypassEnchantmentLevelRestriction) { // Paper - bypass anvil level restrictions // Purpur - Config to allow unsafe enchants
                                 intValue = enchantment.getMaxLevel();
                             }
 
@@ -242,6 +274,54 @@ public class AnvilMenu extends ItemCombinerMenu {
                 if (!this.itemName.equals(item.getHoverName().getString())) {
                     i1 = 1;
                     i += i1;
+                    // Purpur start - Allow anvil colors
+                    if (this.player != null) {
+                        org.bukkit.craftbukkit.entity.CraftHumanEntity player = this.player.getBukkitEntity();
+                        String name = this.itemName;
+                        boolean removeItalics = false;
+                        if (player.hasPermission("purpur.anvil.remove_italics")) {
+                            if (name.startsWith("&r")) {
+                                name = name.substring(2);
+                                removeItalics = true;
+                            } else if (name.startsWith("<r>")) {
+                                name = name.substring(3);
+                                removeItalics = true;
+                            } else if (name.startsWith("<reset>")) {
+                                name = name.substring(7);
+                                removeItalics = true;
+                            }
+                        }
+                        if (this.player.level().purpurConfig.anvilAllowColors) {
+                            if (player.hasPermission("purpur.anvil.color")) {
+                                java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(?i)&([0-9a-fr])").matcher(name);
+                                while (matcher.find()) {
+                                    String match = matcher.group(1);
+                                    name = name.replace("&" + match, "\u00a7" + match.toLowerCase(java.util.Locale.ROOT));
+                                }
+                                //name = name.replaceAll("(?i)&([0-9a-fr])", "\u00a7$1");
+                            }
+                            if (player.hasPermission("purpur.anvil.format")) {
+                                java.util.regex.Matcher matcher = java.util.regex.Pattern.compile("(?i)&([k-or])").matcher(name);
+                                while (matcher.find()) {
+                                    String match = matcher.group(1);
+                                    name = name.replace("&" + match, "\u00a7" + match.toLowerCase(java.util.Locale.ROOT));
+                                }
+                                //name = name.replaceAll("(?i)&([l-or])", "\u00a7$1");
+                            }
+                        }
+                        net.kyori.adventure.text.Component component;
+                        if (this.player.level().purpurConfig.anvilColorsUseMiniMessage && player.hasPermission("purpur.anvil.minimessage")) {
+                            component = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(org.bukkit.ChatColor.stripColor(name));
+                        } else {
+                            component = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(name);
+                        }
+                        if (removeItalics) {
+                            component = component.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                        }
+                        itemStack.set(DataComponents.CUSTOM_NAME, io.papermc.paper.adventure.PaperAdventure.asVanilla(component));
+                    }
+                    else
+                    // Purpur end - Allow anvil colors
                     itemStack.set(DataComponents.CUSTOM_NAME, Component.literal(this.itemName));
                 }
             } else if (item.has(DataComponents.CUSTOM_NAME)) {
@@ -266,6 +346,12 @@ public class AnvilMenu extends ItemCombinerMenu {
                 this.onlyRenaming = true;
             }
 
+            // Purpur start - Anvil API
+            if (this.bypassCost && this.cost.get() >= this.maximumRepairCost) {
+                this.cost.set(this.maximumRepairCost - 1);
+            }
+            // Purpur end - Anvil API
+
             if (this.cost.get() >= this.maximumRepairCost && !this.player.hasInfiniteMaterials()) { // CraftBukkit
                 itemStack = ItemStack.EMPTY;
             }
@@ -286,6 +372,13 @@ public class AnvilMenu extends ItemCombinerMenu {
 
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(this.getBukkitView(), itemStack); // CraftBukkit
             this.broadcastChanges();
+
+            // Purpur start - Anvil API
+            if ((this.canDoUnsafeEnchants || org.purpurmc.purpur.PurpurConfig.allowInapplicableEnchants || org.purpurmc.purpur.PurpurConfig.allowIncompatibleEnchants) && itemStack != ItemStack.EMPTY) { // Purpur - Config to allow unsafe enchants
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetSlotPacket(this.containerId, this.incrementStateId(), 2, itemStack));
+                ((ServerPlayer) this.player).connection.send(new ClientboundContainerSetDataPacket(this.containerId, 0, this.cost.get()));
+            }
+            // Purpur end - Anvil API
         } else {
             org.bukkit.craftbukkit.event.CraftEventFactory.callPrepareAnvilEvent(this.getBukkitView(), ItemStack.EMPTY); // CraftBukkit
             this.cost.set(AnvilMenu.DEFAULT_DENIED_COST); // CraftBukkit - use a variable for set a cost for denied item
@@ -294,7 +387,7 @@ public class AnvilMenu extends ItemCombinerMenu {
     }
 
     public static int calculateIncreasedRepairCost(int oldRepairCost) {
-        return (int)Math.min(oldRepairCost * 2L + 1L, 2147483647L);
+        return org.purpurmc.purpur.PurpurConfig.anvilCumulativeCost ? (int)Math.min(oldRepairCost * 2L + 1L, 2147483647L) : 0; // Purpur - Make anvil cumulative cost configurable
     }
 
     public boolean setItemName(String itemName) {
diff --git a/net/minecraft/world/inventory/ArmorSlot.java b/net/minecraft/world/inventory/ArmorSlot.java
index 0a440ea37d14cd840cf87a99264ace5ccde7c073..dec920727401de7f5bcc6c7e50f9dd325367ee90 100644
--- a/net/minecraft/world/inventory/ArmorSlot.java
+++ b/net/minecraft/world/inventory/ArmorSlot.java
@@ -47,7 +47,7 @@ class ArmorSlot extends Slot {
     @Override
     public boolean mayPickup(Player player) {
         ItemStack item = this.getItem();
-        return (item.isEmpty() || player.isCreative() || !EnchantmentHelper.has(item, EnchantmentEffectComponents.PREVENT_ARMOR_CHANGE))
+        return (item.isEmpty() || player.isCreative() || (!EnchantmentHelper.has(item, EnchantmentEffectComponents.PREVENT_ARMOR_CHANGE) || player.level().purpurConfig.playerRemoveBindingWithWeakness && player.hasEffect(net.minecraft.world.effect.MobEffects.WEAKNESS))) // Purpur - Config to remove curse of binding with weakness
             && super.mayPickup(player);
     }
 
diff --git a/net/minecraft/world/inventory/ChestMenu.java b/net/minecraft/world/inventory/ChestMenu.java
index 0fffa384f928ab84451331380968fb4650eafe26..0399092c9f7a43ac100c11505176ade6d95a39da 100644
--- a/net/minecraft/world/inventory/ChestMenu.java
+++ b/net/minecraft/world/inventory/ChestMenu.java
@@ -66,10 +66,30 @@ public class ChestMenu extends AbstractContainerMenu {
         return new ChestMenu(MenuType.GENERIC_9x6, containerId, playerInventory, 6);
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    public static ChestMenu oneRow(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x1, syncId, playerInventory, inventory, 1);
+    }
+
+    public static ChestMenu twoRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x2, syncId, playerInventory, inventory, 2);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public static ChestMenu threeRows(int containerId, Inventory playerInventory, Container container) {
         return new ChestMenu(MenuType.GENERIC_9x3, containerId, playerInventory, container, 3);
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    public static ChestMenu fourRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x4, syncId, playerInventory, inventory, 4);
+    }
+
+    public static ChestMenu fiveRows(int syncId, Inventory playerInventory, Container inventory) {
+        return new ChestMenu(MenuType.GENERIC_9x5, syncId, playerInventory, inventory, 5);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public static ChestMenu sixRows(int containerId, Inventory playerInventory, Container container) {
         return new ChestMenu(MenuType.GENERIC_9x6, containerId, playerInventory, container, 6);
     }
diff --git a/net/minecraft/world/inventory/EnchantmentMenu.java b/net/minecraft/world/inventory/EnchantmentMenu.java
index cf9ab4c9fba11f5a0b293978853e205de81d6fc7..d0d6ae9c9c432f8bd5d9c91113fc5491e321afad 100644
--- a/net/minecraft/world/inventory/EnchantmentMenu.java
+++ b/net/minecraft/world/inventory/EnchantmentMenu.java
@@ -63,6 +63,22 @@ public class EnchantmentMenu extends AbstractContainerMenu {
                 return access.getLocation();
             }
             // CraftBukkit end
+
+            // Purpur start - Enchantment Table Persists Lapis
+            @Override
+            public void onClose(org.bukkit.craftbukkit.entity.CraftHumanEntity who) {
+                super.onClose(who);
+
+                if (who.getHandle().level().purpurConfig.enchantmentTableLapisPersists) {
+                    access.execute((level, pos) -> {
+                        net.minecraft.world.level.block.entity.BlockEntity blockEntity = level.getBlockEntity(pos);
+                        if (blockEntity instanceof net.minecraft.world.level.block.entity.EnchantingTableBlockEntity enchantmentTable) {
+                            enchantmentTable.setLapis(this.getItem(1).getCount());
+                        }
+                    });
+                }
+            }
+            // Purpur end - Enchantment Table Persists Lapis
         };
         // Paper end - Add missing InventoryHolders
         this.access = access;
@@ -83,6 +99,16 @@ public class EnchantmentMenu extends AbstractContainerMenu {
                 return EnchantmentMenu.EMPTY_SLOT_LAPIS_LAZULI;
             }
         });
+        // Purpur start - Enchantment Table Persists Lapis
+        access.execute((level, pos) -> {
+            if (level.purpurConfig.enchantmentTableLapisPersists) {
+                net.minecraft.world.level.block.entity.BlockEntity blockEntity = level.getBlockEntity(pos);
+                if (blockEntity instanceof net.minecraft.world.level.block.entity.EnchantingTableBlockEntity enchantmentTable) {
+                    this.getSlot(1).set(new ItemStack(Items.LAPIS_LAZULI, enchantmentTable.getLapis()));
+                }
+            }
+        });
+        // Purpur end - Enchantment Table Persists Lapis
         this.addStandardInventorySlots(playerInventory, 8, 84);
         this.addDataSlot(DataSlot.shared(this.costs, 0));
         this.addDataSlot(DataSlot.shared(this.costs, 1));
@@ -299,7 +325,7 @@ public class EnchantmentMenu extends AbstractContainerMenu {
     @Override
     public void removed(Player player) {
         super.removed(player);
-        this.access.execute((level, blockPos) -> this.clearContainer(player, this.enchantSlots));
+        this.access.execute((level, blockPos) -> {if (level.purpurConfig.enchantmentTableLapisPersists) this.getSlot(1).set(ItemStack.EMPTY);this.clearContainer(player, this.enchantSlots);}); // Purpur - Enchantment Table Persists Lapis
     }
 
     @Override
diff --git a/net/minecraft/world/inventory/GrindstoneMenu.java b/net/minecraft/world/inventory/GrindstoneMenu.java
index 18c15a7657e6fd994a8f17d0812c822d6adc8eab..e3892bc545d614a2e9e1bbc8589f1189b1b73038 100644
--- a/net/minecraft/world/inventory/GrindstoneMenu.java
+++ b/net/minecraft/world/inventory/GrindstoneMenu.java
@@ -91,11 +91,13 @@ public class GrindstoneMenu extends AbstractContainerMenu {
             @Override
             public void onTake(Player player, ItemStack stack) {
                 access.execute((level, blockPos) -> {
+                    ItemStack itemstack = activeQuickItem == null ? stack : activeQuickItem; // Purpur - Grindstone API
                     if (level instanceof ServerLevel) {
                         // Paper start - Fire BlockExpEvent on grindstone use
                         org.bukkit.event.block.BlockExpEvent event = new org.bukkit.event.block.BlockExpEvent(org.bukkit.craftbukkit.block.CraftBlock.at(level, blockPos), this.getExperienceAmount(level));
                         event.callEvent();
-                        ExperienceOrb.awardWithDirection((ServerLevel) level, Vec3.atCenterOf(blockPos), Vec3.ZERO, event.getExpToDrop(), org.bukkit.entity.ExperienceOrb.SpawnReason.GRINDSTONE, player, null);
+                        org.purpurmc.purpur.event.inventory.GrindstoneTakeResultEvent grindstoneTakeResultEvent = new org.purpurmc.purpur.event.inventory.GrindstoneTakeResultEvent(player.getBukkitEntity(), getBukkitView(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack), event.getExpToDrop()); grindstoneTakeResultEvent.callEvent(); // Purpur - Grindstone API
+                        ExperienceOrb.awardWithDirection((ServerLevel) level, Vec3.atCenterOf(blockPos), Vec3.ZERO, grindstoneTakeResultEvent.getExperienceAmount(), org.bukkit.entity.ExperienceOrb.SpawnReason.GRINDSTONE, player, null); // Purpur - Grindstone API
                         // Paper end - Fire BlockExpEvent on grindstone use
                     }
 
@@ -124,7 +126,7 @@ public class GrindstoneMenu extends AbstractContainerMenu {
                 for (Entry<Holder<Enchantment>> entry : enchantmentsForCrafting.entrySet()) {
                     Holder<Enchantment> holder = entry.getKey();
                     int intValue = entry.getIntValue();
-                    if (!holder.is(EnchantmentTags.CURSE)) {
+                    if (!org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value())) { // Purpur - Config for grindstones
                         i += holder.value().getMinCost(intValue);
                     }
                 }
@@ -202,15 +204,75 @@ public class GrindstoneMenu extends AbstractContainerMenu {
 
             for (Entry<Holder<Enchantment>> entry : enchantmentsForCrafting.entrySet()) {
                 Holder<Enchantment> holder = entry.getKey();
-                if (!holder.is(EnchantmentTags.CURSE) || mutable.getLevel(holder) == 0) {
+                if (!org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value()) || mutable.getLevel(holder) == 0) { // Purpur - Config for grindstones
                     mutable.upgrade(holder, entry.getIntValue());
                 }
             }
         });
     }
 
+    // Purpur start - Config for grindstones
+    private java.util.List<net.minecraft.core.component.DataComponentType<?>> GRINDSTONE_REMOVE_ATTRIBUTES_REMOVAL_LIST = java.util.List.of(
+        // DataComponents.MAX_STACK_SIZE,
+        // DataComponents.DAMAGE,
+        // DataComponents.BLOCK_STATE,
+        DataComponents.CUSTOM_DATA,
+        // DataComponents.MAX_DAMAGE,
+        // DataComponents.UNBREAKABLE,
+        // DataComponents.CUSTOM_NAME,
+        // DataComponents.ITEM_NAME,
+        // DataComponents.LORE,
+        // DataComponents.RARITY,
+        // DataComponents.ENCHANTMENTS,
+        // DataComponents.CAN_PLACE_ON,
+        // DataComponents.CAN_BREAK,
+        DataComponents.ATTRIBUTE_MODIFIERS,
+        DataComponents.CUSTOM_MODEL_DATA,
+        // DataComponents.HIDE_ADDITIONAL_TOOLTIP,
+        // DataComponents.HIDE_TOOLTIP,
+        // DataComponents.REPAIR_COST,
+        // DataComponents.CREATIVE_SLOT_LOCK,
+        // DataComponents.ENCHANTMENT_GLINT_OVERRIDE,
+        // DataComponents.INTANGIBLE_PROJECTILE,
+        // DataComponents.FOOD,
+        // DataComponents.FIRE_RESISTANT,
+        // DataComponents.TOOL,
+        // DataComponents.STORED_ENCHANTMENTS,
+        DataComponents.DYED_COLOR,
+        // DataComponents.MAP_COLOR,
+        // DataComponents.MAP_ID,
+        // DataComponents.MAP_DECORATIONS,
+        // DataComponents.MAP_POST_PROCESSING,
+        // DataComponents.CHARGED_PROJECTILES,
+        // DataComponents.BUNDLE_CONTENTS,
+        // DataComponents.POTION_CONTENTS,
+        DataComponents.SUSPICIOUS_STEW_EFFECTS
+        // DataComponents.WRITABLE_BOOK_CONTENT,
+        // DataComponents.WRITTEN_BOOK_CONTENT,
+        // DataComponents.TRIM,
+        // DataComponents.DEBUG_STICK_STATE,
+        // DataComponents.ENTITY_DATA,
+        // DataComponents.BUCKET_ENTITY_DATA,
+        // DataComponents.BLOCK_ENTITY_DATA,
+        // DataComponents.INSTRUMENT,
+        // DataComponents.OMINOUS_BOTTLE_AMPLIFIER,
+        // DataComponents.RECIPES,
+        // DataComponents.LODESTONE_TRACKER,
+        // DataComponents.FIREWORK_EXPLOSION,
+        // DataComponents.FIREWORKS,
+        // DataComponents.PROFILE,
+        // DataComponents.NOTE_BLOCK_SOUND,
+        // DataComponents.BANNER_PATTERNS,
+        // DataComponents.BASE_COLOR,
+        // DataComponents.POT_DECORATIONS,
+        // DataComponents.CONTAINER,
+        // DataComponents.BEES,
+        // DataComponents.LOCK,
+        // DataComponents.CONTAINER_LOOT,
+    );
+    // Purpur end - Config for grindstones
     private ItemStack removeNonCursesFrom(ItemStack item) {
-        ItemEnchantments itemEnchantments = EnchantmentHelper.updateEnchantments(item, mutable -> mutable.removeIf(holder -> !holder.is(EnchantmentTags.CURSE)));
+        ItemEnchantments itemEnchantments = EnchantmentHelper.updateEnchantments(item, mutable -> mutable.removeIf(holder -> !org.purpurmc.purpur.PurpurConfig.grindstoneIgnoredEnchants.contains(holder.value()))); // Purpur - Config for grindstones
         if (item.is(Items.ENCHANTED_BOOK) && itemEnchantments.isEmpty()) {
             item = item.transmuteCopy(Items.BOOK);
         }
@@ -222,6 +284,23 @@ public class GrindstoneMenu extends AbstractContainerMenu {
         }
 
         item.set(DataComponents.REPAIR_COST, i);
+
+        // Purpur start - Config for grindstones
+        net.minecraft.core.component.DataComponentPatch.Builder builder = net.minecraft.core.component.DataComponentPatch.builder();
+        if (org.purpurmc.purpur.PurpurConfig.grindstoneRemoveAttributes) {
+            item.getComponents().forEach(typedDataComponent -> {
+                if (GRINDSTONE_REMOVE_ATTRIBUTES_REMOVAL_LIST.contains(typedDataComponent.type())) {
+                    builder.remove(typedDataComponent.type());
+                }
+            });
+        }
+        if (org.purpurmc.purpur.PurpurConfig.grindstoneRemoveDisplay) {
+            builder.remove(DataComponents.CUSTOM_NAME);
+            builder.remove(DataComponents.LORE);
+        }
+        item.applyComponents(builder.build());
+        // Purpur end - Config for grindstones
+
         return item;
     }
 
@@ -278,7 +357,9 @@ public class GrindstoneMenu extends AbstractContainerMenu {
                 return ItemStack.EMPTY;
             }
 
+            this.activeQuickItem = itemStack; // Purpur - Grindstone API
             slot.onTake(player, item);
+            this.activeQuickItem = null; // Purpur - Grindstone API
         }
 
         return itemStack;
diff --git a/net/minecraft/world/inventory/ItemCombinerMenu.java b/net/minecraft/world/inventory/ItemCombinerMenu.java
index 34d52c941395645e77de810855b14012c259cf02..c605bd700fd9f5a6596a2bf9648492786306b025 100644
--- a/net/minecraft/world/inventory/ItemCombinerMenu.java
+++ b/net/minecraft/world/inventory/ItemCombinerMenu.java
@@ -156,7 +156,9 @@ public abstract class ItemCombinerMenu extends AbstractContainerMenu {
                 return ItemStack.EMPTY;
             }
 
+            this.activeQuickItem = itemStack; // Purpur - Anvil API
             slot.onTake(player, item);
+            this.activeQuickItem = null; // Purpur - Anvil API
         }
 
         return itemStack;
diff --git a/net/minecraft/world/inventory/PlayerEnderChestContainer.java b/net/minecraft/world/inventory/PlayerEnderChestContainer.java
index beb74bc8398de8b48f41af7daef14d624826310e..7ae8d115b6f4af45db9309b46ed4b4fdd8e25c08 100644
--- a/net/minecraft/world/inventory/PlayerEnderChestContainer.java
+++ b/net/minecraft/world/inventory/PlayerEnderChestContainer.java
@@ -25,11 +25,18 @@ public class PlayerEnderChestContainer extends SimpleContainer {
     }
 
     public PlayerEnderChestContainer(Player owner) {
-        super(27);
+        super(org.purpurmc.purpur.PurpurConfig.enderChestSixRows ? 54 : 27); // Purpur - Barrels and enderchests 6 rows
         this.owner = owner;
         // CraftBukkit end
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    @Override
+    public int getContainerSize() {
+        return owner.sixRowEnderchestSlotCount < 0 ? super.getContainerSize() : owner.sixRowEnderchestSlotCount;
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     public void setActiveChest(EnderChestBlockEntity enderChestBlockEntity) {
         this.activeChest = enderChestBlockEntity;
     }
diff --git a/net/minecraft/world/item/ArmorStandItem.java b/net/minecraft/world/item/ArmorStandItem.java
index 962483d6f7225f13f121141882262d36dacad8cb..89d4bc00898fd8f6d40cda87c04c5983e2ea223c 100644
--- a/net/minecraft/world/item/ArmorStandItem.java
+++ b/net/minecraft/world/item/ArmorStandItem.java
@@ -51,6 +51,10 @@ public class ArmorStandItem extends Item {
                         return InteractionResult.FAIL;
                     }
                     // CraftBukkit end
+                    // Purpur start - Apply display names from item forms of entities to entities and vice versa
+                    if (!serverLevel.purpurConfig.persistentDroppableEntityDisplayNames) armorStand.setCustomName(null);
+                    if (serverLevel.purpurConfig.armorstandSetNameVisible && armorStand.getCustomName() != null) armorStand.setCustomNameVisible(true);
+                    // Purpur end - Apply display names from item forms of entities to entities and vice versa
                     serverLevel.addFreshEntityWithPassengers(armorStand);
                     level.playSound(
                         null, armorStand.getX(), armorStand.getY(), armorStand.getZ(), SoundEvents.ARMOR_STAND_PLACE, SoundSource.BLOCKS, 0.75F, 0.8F
diff --git a/net/minecraft/world/item/AxeItem.java b/net/minecraft/world/item/AxeItem.java
index bd919b9a83f9736f02783b1ba3863fd1b77c7e89..eb8d2d6f9c65185f5fe16a13ab0cdbba78a25a40 100644
--- a/net/minecraft/world/item/AxeItem.java
+++ b/net/minecraft/world/item/AxeItem.java
@@ -62,13 +62,15 @@ public class AxeItem extends Item {
         if (playerHasBlockingItemUseIntent(context)) {
             return InteractionResult.PASS;
         } else {
-            Optional<BlockState> optional = this.evaluateNewBlockState(level, clickedPos, player, level.getBlockState(clickedPos));
+            Optional<org.purpurmc.purpur.tool.Actionable> optional = this.evaluateActionable(level, clickedPos, player, level.getBlockState(clickedPos)); // Purpur - Tool actionable options
             if (optional.isEmpty()) {
                 return InteractionResult.PASS;
             } else {
+                org.purpurmc.purpur.tool.Actionable actionable = optional.get(); // Purpur - Tool actionable options
+                BlockState state = actionable.into().withPropertiesOf(level.getBlockState(clickedPos)); // Purpur - Tool actionable options
                 ItemStack itemInHand = context.getItemInHand();
                 // Paper start - EntityChangeBlockEvent
-                if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(player, clickedPos, optional.get())) {
+                if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(player, clickedPos, state)) { // Purpur - Tool actionable options
                     return InteractionResult.PASS;
                 }
                 // Paper end
@@ -76,8 +78,15 @@ public class AxeItem extends Item {
                     CriteriaTriggers.ITEM_USED_ON_BLOCK.trigger((ServerPlayer)player, clickedPos, itemInHand);
                 }
 
-                level.setBlock(clickedPos, optional.get(), 11);
-                level.gameEvent(GameEvent.BLOCK_CHANGE, clickedPos, GameEvent.Context.of(player, optional.get()));
+                // Purpur start - Tool actionable options
+                level.setBlock(clickedPos, state, 11);
+                actionable.drops().forEach((drop, chance) -> {
+                    if (level.random.nextDouble() < chance) {
+                        Block.popResourceFromFace(level, clickedPos, context.getClickedFace(), new ItemStack(drop));
+                    }
+                });
+                level.gameEvent(GameEvent.BLOCK_CHANGE, clickedPos, GameEvent.Context.of(player, state));
+                // Purpur end - Tool actionable options
                 if (player != null) {
                     itemInHand.hurtAndBreak(1, player, LivingEntity.getSlotForHand(context.getHand()));
                 }
@@ -94,22 +103,24 @@ public class AxeItem extends Item {
             && !player.isSecondaryUseActive();
     }
 
-    private Optional<BlockState> evaluateNewBlockState(Level level, BlockPos pos, @Nullable Player player, BlockState state) {
-        Optional<BlockState> stripped = this.getStripped(state);
+    private Optional<org.purpurmc.purpur.tool.Actionable> evaluateActionable(Level level, BlockPos pos, @Nullable Player player, BlockState state) { // Purpur - Tool actionable options
+        Optional<org.purpurmc.purpur.tool.Actionable> stripped = Optional.ofNullable(level.purpurConfig.axeStrippables.get(state.getBlock())); // Purpur - Tool actionable options
         if (stripped.isPresent()) {
-            level.playSound(player, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F);
+            level.playSound(STRIPPABLES.containsKey(state.getBlock()) ? player : null, pos, SoundEvents.AXE_STRIP, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - force sound
             return stripped;
         } else {
-            Optional<BlockState> previous = WeatheringCopper.getPrevious(state);
+            Optional<org.purpurmc.purpur.tool.Actionable> previous = Optional.ofNullable(level.purpurConfig.axeWeatherables.get(state.getBlock())); // Purpur - Tool actionable options
             if (previous.isPresent()) {
-                level.playSound(player, pos, SoundEvents.AXE_SCRAPE, SoundSource.BLOCKS, 1.0F, 1.0F);
+                level.playSound(WeatheringCopper.getPrevious(state).isPresent() ? player : null, pos, SoundEvents.AXE_SCRAPE, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - Tool actionable options - force sound
                 level.levelEvent(player, 3005, pos, 0);
                 return previous;
             } else {
-                Optional<BlockState> optional = Optional.ofNullable(HoneycombItem.WAX_OFF_BY_BLOCK.get().get(state.getBlock()))
-                    .map(block -> block.withPropertiesOf(state));
+                // Purpur start - Tool actionable options
+                Optional<org.purpurmc.purpur.tool.Actionable> optional = Optional.ofNullable(level.purpurConfig.axeWaxables.get(state.getBlock()));
+                //    .map(block -> block.withPropertiesOf(state));
+                // Purpur end - Tool actionable options
                 if (optional.isPresent()) {
-                    level.playSound(player, pos, SoundEvents.AXE_WAX_OFF, SoundSource.BLOCKS, 1.0F, 1.0F);
+                    level.playSound(HoneycombItem.WAX_OFF_BY_BLOCK.get().containsKey(state.getBlock()) ? player : null, pos, SoundEvents.AXE_WAX_OFF, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - Tool actionable options - force sound
                     level.levelEvent(player, 3004, pos, 0);
                     return optional;
                 } else {
diff --git a/net/minecraft/world/item/BlockItem.java b/net/minecraft/world/item/BlockItem.java
index b5b53168755525eccaa0a4361172006522cf4e05..2860d49c072d4b9e473390a84e45171b984b198e 100644
--- a/net/minecraft/world/item/BlockItem.java
+++ b/net/minecraft/world/item/BlockItem.java
@@ -145,7 +145,16 @@ public class BlockItem extends Item {
     }
 
     protected boolean updateCustomBlockEntityTag(BlockPos pos, Level level, @Nullable Player player, ItemStack stack, BlockState state) {
-        return updateCustomBlockEntityTag(level, player, pos, stack);
+        // Purpur start - Persistent BlockEntity Lore and DisplayName
+        boolean handled = updateCustomBlockEntityTag(level, player, pos, stack);
+        if (level.purpurConfig.persistentTileEntityLore) {
+            BlockEntity blockEntity1 = level.getBlockEntity(pos);
+            if (blockEntity1 != null) {
+                blockEntity1.setPersistentLore(stack.getOrDefault(DataComponents.LORE, net.minecraft.world.item.component.ItemLore.EMPTY));
+            }
+        }
+        return handled;
+        // Purpur end - Persistent BlockEntity Lore and DisplayName
     }
 
     @Nullable
@@ -212,6 +221,7 @@ public class BlockItem extends Item {
                     }
 
                     if (!type.onlyOpCanSetNbt() || player != null && (player.canUseGameMasterBlocks() || (player.getAbilities().instabuild && player.getBukkitEntity().hasPermission("minecraft.nbt.place")))) { // Spigot - add permission
+                        if (!(level.purpurConfig.silkTouchEnabled && blockEntity instanceof net.minecraft.world.level.block.entity.SpawnerBlockEntity && player.getBukkitEntity().hasPermission("purpur.drop.spawners"))) // Purpur - Silk touch spawners
                         return customData.loadInto(blockEntity, level.registryAccess());
                     }
 
@@ -253,6 +263,7 @@ public class BlockItem extends Item {
     public void onDestroyed(ItemEntity itemEntity) {
         ItemContainerContents itemContainerContents = itemEntity.getItem().set(DataComponents.CONTAINER, ItemContainerContents.EMPTY);
         if (itemContainerContents != null) {
+            if (itemEntity.level().purpurConfig.shulkerBoxItemDropContentsWhenDestroyed && this.getBlock() instanceof ShulkerBoxBlock) // Purpur - option to disable shulker box items from dropping contents when destroyed
             ItemUtils.onContainerDestroyed(itemEntity, itemContainerContents.nonEmptyItemsCopy());
         }
     }
diff --git a/net/minecraft/world/item/BoatItem.java b/net/minecraft/world/item/BoatItem.java
index 13ce174e4f7e406f57a68ea0d3ef0ee3367f3f3b..ca86122e38688b29340cd8413ccf1746315e292a 100644
--- a/net/minecraft/world/item/BoatItem.java
+++ b/net/minecraft/world/item/BoatItem.java
@@ -63,6 +63,7 @@ public class BoatItem extends Item {
                     return InteractionResult.FAIL;
                 } else {
                     boat.setYRot(player.getYRot());
+                    if (!level.purpurConfig.persistentDroppableEntityDisplayNames) boat.setCustomName(null); // Purpur - Apply display names from item forms of entities to entities and vice versa
                     if (!level.noCollision(boat, boat.getBoundingBox())) {
                         return InteractionResult.FAIL;
                     } else {
diff --git a/net/minecraft/world/item/BowItem.java b/net/minecraft/world/item/BowItem.java
index c4c8775de328d40bb8218d993872be5249e8174d..ce1ce18410fc1d47d999c918a8f880b43bf9797c 100644
--- a/net/minecraft/world/item/BowItem.java
+++ b/net/minecraft/world/item/BowItem.java
@@ -28,6 +28,11 @@ public class BowItem extends ProjectileWeaponItem {
             return false;
         } else {
             ItemStack projectile = player.getProjectile(stack);
+            //  Purpur start - Infinity bow settings
+            if (level.purpurConfig.infinityWorksWithoutArrows && projectile.isEmpty() && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.INFINITY, stack) > 0) {
+                projectile = new ItemStack(Items.ARROW);
+            }
+            // Purpur end - Infinity bow settings
             if (projectile.isEmpty()) {
                 return false;
             } else {
@@ -38,7 +43,7 @@ public class BowItem extends ProjectileWeaponItem {
                 } else {
                     List<ItemStack> list = draw(stack, projectile, player);
                     if (level instanceof ServerLevel serverLevel && !list.isEmpty()) {
-                        this.shoot(serverLevel, player, player.getUsedItemHand(), stack, list, powerForTime * 3.0F, 1.0F, powerForTime == 1.0F, null, powerForTime); // Paper - Pass draw strength
+                        this.shoot(serverLevel, player, player.getUsedItemHand(), stack, list, powerForTime * 3.0F, (float) serverLevel.purpurConfig.bowProjectileOffset, powerForTime == 1.0F, null, powerForTime); // Paper - Pass draw strength // Purpur - Projectile offset config
                     }
 
                     level.playSound(
@@ -89,7 +94,7 @@ public class BowItem extends ProjectileWeaponItem {
     public InteractionResult use(Level level, Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         boolean flag = !player.getProjectile(itemInHand).isEmpty();
-        if (!player.hasInfiniteMaterials() && !flag) {
+        if (!player.hasInfiniteMaterials() && !flag && !(level.purpurConfig.infinityWorksWithoutArrows && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.INFINITY, itemInHand) > 0)) { // Purpur - Infinity bow settings
             return InteractionResult.FAIL;
         } else {
             player.startUsingItem(hand);
diff --git a/net/minecraft/world/item/BucketItem.java b/net/minecraft/world/item/BucketItem.java
index de287715568f358dd83383d68f845df9a7b5a117..8c7be8a71348a3e66c8bf6b6cb39fe002c20bdb0 100644
--- a/net/minecraft/world/item/BucketItem.java
+++ b/net/minecraft/world/item/BucketItem.java
@@ -147,7 +147,7 @@ public class BucketItem extends Item implements DispensibleContainerItem {
             // CraftBukkit end
             if (!flag) {
                 return hitResult != null && this.emptyContents(entity, level, hitResult.getBlockPos().relative(hitResult.getDirection()), null, direction, clicked, itemstack, hand); // CraftBukkit
-            } else if (level.dimensionType().ultraWarm() && this.content.is(FluidTags.WATER)) {
+            } else if ((level.dimensionType().ultraWarm() || (level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd)) && this.content.is(FluidTags.WATER)) { // Purpur - Add allow water in end world option
                 int x = pos.getX();
                 int y = pos.getY();
                 int z = pos.getZ();
@@ -156,7 +156,7 @@ public class BucketItem extends Item implements DispensibleContainerItem {
                 );
 
                 for (int i = 0; i < 8; i++) {
-                    level.addParticle(ParticleTypes.LARGE_SMOKE, x + Math.random(), y + Math.random(), z + Math.random(), 0.0, 0.0, 0.0);
+                    ((net.minecraft.server.level.ServerLevel) level).sendParticlesSource(null, ParticleTypes.LARGE_SMOKE, true, false, x + Math.random(), y + Math.random(), z + Math.random(), 1, 0.0D, 0.0D, 0.0D, 0.0D); // Purpur - Add allow water in end world option
                 }
 
                 return true;
diff --git a/net/minecraft/world/item/CrossbowItem.java b/net/minecraft/world/item/CrossbowItem.java
index 45fc973971d00c35e5b715bfa6ae5042822ed35f..2ab3da301f7edbb811c2e055f75434a799ef093a 100644
--- a/net/minecraft/world/item/CrossbowItem.java
+++ b/net/minecraft/world/item/CrossbowItem.java
@@ -66,7 +66,7 @@ public class CrossbowItem extends ProjectileWeaponItem {
         ItemStack itemInHand = player.getItemInHand(hand);
         ChargedProjectiles chargedProjectiles = itemInHand.get(DataComponents.CHARGED_PROJECTILES);
         if (chargedProjectiles != null && !chargedProjectiles.isEmpty()) {
-            this.performShooting(level, player, hand, itemInHand, getShootingPower(chargedProjectiles), 1.0F, null);
+            this.performShooting(level, player, hand, itemInHand, getShootingPower(chargedProjectiles), (float) level.purpurConfig.crossbowProjectileOffset, null); // Purpur - Projectile offset config
             return InteractionResult.CONSUME;
         } else if (!player.getProjectile(itemInHand).isEmpty()) {
             this.startSoundPlayed = false;
diff --git a/net/minecraft/world/item/DyeColor.java b/net/minecraft/world/item/DyeColor.java
index 76bb211843eee94334fbba87e5fa5ba5430f89ba..c9cde255117b46690b2b6670d009a00b051af016 100644
--- a/net/minecraft/world/item/DyeColor.java
+++ b/net/minecraft/world/item/DyeColor.java
@@ -126,4 +126,10 @@ public enum DyeColor implements StringRepresentable {
     private static CraftingInput makeCraftColorInput(DyeColor first, DyeColor second) {
         return CraftingInput.of(2, 1, List.of(new ItemStack(DyeItem.byColor(first)), new ItemStack(DyeItem.byColor(second))));
     }
+
+    // Purpur start - Shulker spawn from bullet options
+    public static DyeColor random(net.minecraft.util.RandomSource random) {
+        return values()[random.nextInt(values().length)];
+    }
+    // Purpur end - Shulker spawn from bullet options
 }
diff --git a/net/minecraft/world/item/EggItem.java b/net/minecraft/world/item/EggItem.java
index ccae6089cdc4fffca7d759252006a13c2c14691a..c4097bd6acf671ddf857350154e6e1a04e76d64b 100644
--- a/net/minecraft/world/item/EggItem.java
+++ b/net/minecraft/world/item/EggItem.java
@@ -24,7 +24,7 @@ public class EggItem extends Item implements ProjectileItem {
     public InteractionResult use(Level level, Player player, InteractionHand hand) {
         ItemStack itemInHand = player.getItemInHand(hand);
         // Paper start
-        final Projectile.Delayed<ThrownEgg> thrownEgg = Projectile.spawnProjectileFromRotationDelayed(ThrownEgg::new, (ServerLevel) level, itemInHand, player, 0.0F, EggItem.PROJECTILE_SHOOT_POWER, 1.0F);
+        final Projectile.Delayed<ThrownEgg> thrownEgg = Projectile.spawnProjectileFromRotationDelayed(ThrownEgg::new, (ServerLevel) level, itemInHand, player, 0.0F, EggItem.PROJECTILE_SHOOT_POWER, (float) level.purpurConfig.eggProjectileOffset); // Purpur - Projectile offset config
         com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownEgg.projectile().getBukkitEntity());
         if (event.callEvent() && thrownEgg.attemptSpawn()) {
             if (event.shouldConsume()) {
diff --git a/net/minecraft/world/item/EndCrystalItem.java b/net/minecraft/world/item/EndCrystalItem.java
index 05ec512839898f96d9769bb0d00f6ba11dda0c4b..6e4a3c9c090a68bf5785a01d815c275411859c7b 100644
--- a/net/minecraft/world/item/EndCrystalItem.java
+++ b/net/minecraft/world/item/EndCrystalItem.java
@@ -24,7 +24,7 @@ public class EndCrystalItem extends Item {
         Level level = context.getLevel();
         BlockPos clickedPos = context.getClickedPos();
         BlockState blockState = level.getBlockState(clickedPos);
-        if (!blockState.is(Blocks.OBSIDIAN) && !blockState.is(Blocks.BEDROCK)) {
+        if (!level.purpurConfig.endCrystalPlaceAnywhere && !blockState.is(Blocks.OBSIDIAN) && !blockState.is(Blocks.BEDROCK)) { // Purpur - place end crystal on any block
             return InteractionResult.FAIL;
         } else {
             BlockPos blockPos = clickedPos.above(); final BlockPos aboveBlockPos = blockPos; // Paper - OBFHELPER
diff --git a/net/minecraft/world/item/EnderpearlItem.java b/net/minecraft/world/item/EnderpearlItem.java
index 3becd19d3264fa631497e967656cc7ca39252586..f824f155549857d5205ba67eb5916e0b0b65efb4 100644
--- a/net/minecraft/world/item/EnderpearlItem.java
+++ b/net/minecraft/world/item/EnderpearlItem.java
@@ -24,7 +24,7 @@ public class EnderpearlItem extends Item {
         if (level instanceof ServerLevel serverLevel) {
             // CraftBukkit start
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<ThrownEnderpearl> thrownEnderpearl = Projectile.spawnProjectileFromRotationDelayed(ThrownEnderpearl::new, serverLevel, itemInHand, player, 0.0F, EnderpearlItem.PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<ThrownEnderpearl> thrownEnderpearl = Projectile.spawnProjectileFromRotationDelayed(ThrownEnderpearl::new, serverLevel, itemInHand, player, 0.0F, EnderpearlItem.PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.enderPearlProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownEnderpearl.projectile().getBukkitEntity());
             if (event.callEvent() && thrownEnderpearl.attemptSpawn()) {
                 if (event.shouldConsume()) {
@@ -44,6 +44,7 @@ public class EnderpearlItem extends Item {
                     0.4F / (level.getRandom().nextFloat() * 0.4F + 0.8F)
                 );
                 player.awardStat(Stats.ITEM_USED.get(this));
+                player.getCooldowns().addCooldown(itemInHand, player.getAbilities().instabuild ? level.purpurConfig.enderPearlCooldownCreative : level.purpurConfig.enderPearlCooldown); // Purpur - Configurable Ender Pearl cooldown
             } else {
                 if (player instanceof net.minecraft.server.level.ServerPlayer serverPlayer) {
                     serverPlayer.deregisterEnderPearl(thrownEnderpearl.projectile());
diff --git a/net/minecraft/world/item/FireworkRocketItem.java b/net/minecraft/world/item/FireworkRocketItem.java
index 83cfe63b0245f79d0873477ab3aae75f690ecb68..f32370217735b5e9556a0df7652682d89f23c595 100644
--- a/net/minecraft/world/item/FireworkRocketItem.java
+++ b/net/minecraft/world/item/FireworkRocketItem.java
@@ -72,6 +72,17 @@ public class FireworkRocketItem extends Item implements ProjectileItem {
                     if (player.dropAllLeashConnections(null)) {
                         level.playSound(null, player, SoundEvents.LEAD_BREAK, SoundSource.NEUTRAL, 1.0F, 1.0F);
                     }
+                    // Purpur start - Implement elytra settings
+                    if (level.purpurConfig.elytraDamagePerFireworkBoost > 0) {
+                        java.util.List<net.minecraft.world.entity.EquipmentSlot> list = net.minecraft.world.entity.EquipmentSlot.VALUES.stream().filter((enumitemslot) -> net.minecraft.world.entity.LivingEntity.canGlideUsing(player.getItemBySlot(enumitemslot), enumitemslot)).toList();
+                        net.minecraft.world.entity.EquipmentSlot enumitemslot = net.minecraft.Util.getRandom(list, player.random);
+
+                        ItemStack glideItem = player.getItemBySlot(enumitemslot);
+                        if (player.canGlide()) {
+                            glideItem.hurtAndBreak(level.purpurConfig.elytraDamagePerFireworkBoost, player, enumitemslot);
+                        }
+                    }
+                    // Purpur end - Implement elytra settings
                     if (event.shouldConsume() && !player.hasInfiniteMaterials()) {
                         itemInHand.shrink(1); // Moved up from below
                     } else {
diff --git a/net/minecraft/world/item/HangingEntityItem.java b/net/minecraft/world/item/HangingEntityItem.java
index 5f9c166b8ba9e9dcabb7398308e7520a88335eae..e9e3a036290a5facc36cf6a484d03d4d3bfb65a5 100644
--- a/net/minecraft/world/item/HangingEntityItem.java
+++ b/net/minecraft/world/item/HangingEntityItem.java
@@ -59,7 +59,7 @@ public class HangingEntityItem extends Item {
                 hangingEntity = new GlowItemFrame(level, blockPos, clickedFace);
             }
 
-            EntityType.<HangingEntity>createDefaultStackConfig(level, itemInHand, player).accept(hangingEntity);
+            EntityType.<HangingEntity>appendDefaultStackConfig(entity -> {if (!level.purpurConfig.persistentDroppableEntityDisplayNames) entity.setCustomName(null);}, level, itemInHand, player).accept(hangingEntity); // Purpur - Apply display names from item forms of entities to entities and vice versa
             if (hangingEntity.survives()) {
                 if (!level.isClientSide) {
                     // CraftBukkit start - fire HangingPlaceEvent
diff --git a/net/minecraft/world/item/HoeItem.java b/net/minecraft/world/item/HoeItem.java
index 3bf3d4030c4da65fa386a8b8083d259a6046d15e..77a8d5d334cd93d23149afa8e58f4114412632df 100644
--- a/net/minecraft/world/item/HoeItem.java
+++ b/net/minecraft/world/item/HoeItem.java
@@ -45,15 +45,25 @@ public class HoeItem extends Item {
     public InteractionResult useOn(UseOnContext context) {
         Level level = context.getLevel();
         BlockPos clickedPos = context.getClickedPos();
-        Pair<Predicate<UseOnContext>, Consumer<UseOnContext>> pair = TILLABLES.get(level.getBlockState(clickedPos).getBlock());
-        if (pair == null) {
+        // Purpur start - Tool actionable options
+        Block clickedBlock = level.getBlockState(clickedPos).getBlock();
+        org.purpurmc.purpur.tool.Tillable tillable = level.purpurConfig.hoeTillables.get(clickedBlock);
+        if (tillable == null) {
             return InteractionResult.PASS;
         } else {
-            Predicate<UseOnContext> predicate = pair.getFirst();
-            Consumer<UseOnContext> consumer = pair.getSecond();
+            Predicate<UseOnContext> predicate = tillable.condition().predicate();
+            Consumer<UseOnContext> consumer = (ctx) -> {
+                level.setBlock(clickedPos, tillable.into().defaultBlockState(), 11);
+                tillable.drops().forEach((drop, chance) -> {
+                    if (level.random.nextDouble() < chance) {
+                        Block.popResourceFromFace(level, clickedPos, ctx.getClickedFace(), new ItemStack(drop));
+                    }
+                });
+            };
+            // Purpur end - Tool actionable options
             if (predicate.test(context)) {
                 Player player = context.getPlayer();
-                level.playSound(player, clickedPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F);
+                if (!TILLABLES.containsKey(clickedBlock)) level.playSound(null, clickedPos, SoundEvents.HOE_TILL, SoundSource.BLOCKS, 1.0F, 1.0F); // Purpur - Tool actionable options - force sound
                 if (!level.isClientSide) {
                     consumer.accept(context);
                     if (player != null) {
diff --git a/net/minecraft/world/item/ItemStack.java b/net/minecraft/world/item/ItemStack.java
index 2c15a382dcbd1087dc06b562149239c8bf4e035e..a1a9f7d182a82c682a9287d079e2d08c8e24ad43 100644
--- a/net/minecraft/world/item/ItemStack.java
+++ b/net/minecraft/world/item/ItemStack.java
@@ -451,6 +451,7 @@ public final class ItemStack implements DataComponentHolder {
                     // revert back all captured blocks
                     for (org.bukkit.block.BlockState blockstate : blocks) {
                         ((org.bukkit.craftbukkit.block.CraftBlockState) blockstate).revertPlace();
+                        ((org.bukkit.craftbukkit.block.CraftBlock) blockstate.getBlock()).getNMS().getBlock().forgetPlacer(); // Purpur - Store placer on Block when placed
                     }
 
                     SignItem.openSign.set(null); // SPIGOT-6758 - Reset on early return // Folia - region threading
@@ -474,6 +475,7 @@ public final class ItemStack implements DataComponentHolder {
                         if (!(block.getBlock() instanceof net.minecraft.world.level.block.BaseEntityBlock)) { // Containers get placed automatically
                             block.onPlace(serverLevel, newPos, oldBlock, true, context);
                         }
+                        block.getBlock().forgetPlacer(); // Purpur - Store placer on Block when placed
 
                         serverLevel.notifyAndUpdatePhysics(newPos, null, oldBlock, block, serverLevel.getBlockState(newPos), updateFlags, net.minecraft.world.level.block.Block.UPDATE_LIMIT); // send null chunk as chunk.k() returns false by this point
                     }
@@ -594,6 +596,26 @@ public final class ItemStack implements DataComponentHolder {
         return this.isDamageableItem() && this.getDamageValue() > 0;
     }
 
+    // Purpur start - Add option to mend the most damaged equipment first
+    public float getDamagePercent() {
+        if (this.has(DataComponents.UNBREAKABLE)) {
+            return 0.0F;
+        }
+
+        final int maxDamage = this.getOrDefault(DataComponents.MAX_DAMAGE, 0);
+        if (maxDamage == 0) {
+            return 0.0F;
+        }
+
+        final int damage = this.getOrDefault(DataComponents.DAMAGE, 0);
+        if (damage == 0) {
+            return 0.0F;
+        }
+
+        return (float) damage / maxDamage;
+    }
+    // Purpur end - Add option to mend the most damaged equipment first
+
     public int getDamageValue() {
         return Mth.clamp(this.getOrDefault(DataComponents.DAMAGE, 0), 0, this.getMaxDamage());
     }
@@ -679,6 +701,14 @@ public final class ItemStack implements DataComponentHolder {
                 org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerItemBreakEvent(serverPlayer, this); // Paper - Add EntityDamageItemEvent
             }
             // CraftBukkit end
+
+            // Purpur start - Implement elytra settings
+            if (this.has(DataComponents.GLIDER)) {
+                setDamageValue(this.getMaxDamage() - 1);
+                return;
+            }
+            // Purpur end - Implement elytra settings
+
             this.shrink(1);
             onBreak.accept(item);
         }
@@ -1211,6 +1241,12 @@ public final class ItemStack implements DataComponentHolder {
         return !this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).isEmpty();
     }
 
+    // Purpur start - Config to allow unsafe enchants
+    public boolean hasEnchantment(Holder<Enchantment> enchantment) {
+        return this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY).getLevel(enchantment) > 0;
+    }
+    // Purpur end - Config to allow unsafe enchants
+
     public ItemEnchantments getEnchantments() {
         return this.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
     }
diff --git a/net/minecraft/world/item/Items.java b/net/minecraft/world/item/Items.java
index b89a7fae0321cbce09faf1503ddc57ca5acaa148..4d5a0b1bc794a3029b0724c6dddeffa6f549a7d5 100644
--- a/net/minecraft/world/item/Items.java
+++ b/net/minecraft/world/item/Items.java
@@ -383,7 +383,7 @@ public class Items {
     public static final Item PURPUR_BLOCK = registerBlock(Blocks.PURPUR_BLOCK);
     public static final Item PURPUR_PILLAR = registerBlock(Blocks.PURPUR_PILLAR);
     public static final Item PURPUR_STAIRS = registerBlock(Blocks.PURPUR_STAIRS);
-    public static final Item SPAWNER = registerBlock(Blocks.SPAWNER);
+    public static final Item SPAWNER = registerBlock(Blocks.SPAWNER, org.purpurmc.purpur.item.SpawnerItem::new, new Item.Properties().rarity(Rarity.EPIC)); // Purpur - Silk touch spawners
     public static final Item CREAKING_HEART = registerBlock(Blocks.CREAKING_HEART);
     public static final Item CHEST = registerBlock(Blocks.CHEST, properties -> properties.component(DataComponents.CONTAINER, ItemContainerContents.EMPTY));
     public static final Item CRAFTING_TABLE = registerBlock(Blocks.CRAFTING_TABLE);
@@ -2092,7 +2092,7 @@ public class Items {
         "sweet_berries", createBlockItemWithCustomItemName(Blocks.SWEET_BERRY_BUSH), new Item.Properties().food(Foods.SWEET_BERRIES)
     );
     public static final Item GLOW_BERRIES = registerItem(
-        "glow_berries", createBlockItemWithCustomItemName(Blocks.CAVE_VINES), new Item.Properties().food(Foods.GLOW_BERRIES)
+        "glow_berries", settings -> new org.purpurmc.purpur.item.GlowBerryItem(Blocks.CAVE_VINES, settings.useItemDescriptionPrefix()), new Item.Properties().food(Foods.GLOW_BERRIES) // Purpur - Eating glow berries adds glow effect
     );
     public static final Item CAMPFIRE = registerBlock(
         Blocks.CAMPFIRE, properties -> properties.component(DataComponents.CONTAINER, ItemContainerContents.EMPTY)
diff --git a/net/minecraft/world/item/MapItem.java b/net/minecraft/world/item/MapItem.java
index fc1337a5ca7ebed7ad93e077779a95affe467366..d6e0dcb4c8ac4d81b042d4910d6eb0bfdc4cc0b1 100644
--- a/net/minecraft/world/item/MapItem.java
+++ b/net/minecraft/world/item/MapItem.java
@@ -197,6 +197,7 @@ public class MapItem extends Item {
         MapItemSavedData savedData = getSavedData(stack, serverLevel);
         if (savedData != null) {
             synchronized (savedData) { // Folia - make map data thread-safe
+            savedData.isExplorerMap = true; // Purpur - Explorer Map API
             if (serverLevel.dimension() == savedData.dimension) {
                 int i = 1 << savedData.scale;
                 int i1 = savedData.centerX;
diff --git a/net/minecraft/world/item/MinecartItem.java b/net/minecraft/world/item/MinecartItem.java
index 620069daba04d48b57fc933328eda77f6ca9333e..0403b9b01994269d394820e8c8710ba1b9808bf0 100644
--- a/net/minecraft/world/item/MinecartItem.java
+++ b/net/minecraft/world/item/MinecartItem.java
@@ -30,8 +30,9 @@ public class MinecartItem extends Item {
         BlockPos clickedPos = context.getClickedPos();
         BlockState blockState = level.getBlockState(clickedPos);
         if (!blockState.is(BlockTags.RAILS)) {
-            return InteractionResult.FAIL;
-        } else {
+            if (!level.purpurConfig.minecartPlaceAnywhere) return InteractionResult.FAIL; // Purpur - Minecart settings and WASD controls
+            if (blockState.isSolid()) clickedPos = clickedPos.relative(context.getClickedFace());
+        } // else { // Purpur - Minecart settings and WASD controls
             ItemStack itemInHand = context.getItemInHand();
             RailShape railShape = blockState.getBlock() instanceof BaseRailBlock
                 ? blockState.getValue(((BaseRailBlock)blockState.getBlock()).getShapeProperty())
@@ -72,6 +73,6 @@ public class MinecartItem extends Item {
                 itemInHand.shrink(1);
                 return InteractionResult.SUCCESS;
             }
-        }
+        // } // Purpur - Minecart settings and WASD controls
     }
 }
diff --git a/net/minecraft/world/item/NameTagItem.java b/net/minecraft/world/item/NameTagItem.java
index a928124ee46a10e9033f771970198e36712917a6..65ff8078474d5039238e9398d8cfc12e79cc6524 100644
--- a/net/minecraft/world/item/NameTagItem.java
+++ b/net/minecraft/world/item/NameTagItem.java
@@ -24,6 +24,7 @@ public class NameTagItem extends Item {
 
                 LivingEntity newEntity = ((org.bukkit.craftbukkit.entity.CraftLivingEntity) event.getEntity()).getHandle();
                 newEntity.setCustomName(event.getName() != null ? io.papermc.paper.adventure.PaperAdventure.asVanilla(event.getName()) : null);
+                if (player.level().purpurConfig.armorstandFixNametags && target instanceof net.minecraft.world.entity.decoration.ArmorStand) target.setCustomNameVisible(true); // Purpur - Set name visible when using a Name Tag on an Armor Stand
                 if (event.isPersistent() && newEntity instanceof Mob mob) {
                     // Paper end - Add PlayerNameEntityEvent
                     mob.setPersistenceRequired();
diff --git a/net/minecraft/world/item/ProjectileWeaponItem.java b/net/minecraft/world/item/ProjectileWeaponItem.java
index 1a9f91f3ee9c4d3902106eebd2639cc85a0dc34c..fb5077450aa9f7b7a03dd20c27a68dfdaab5ef06 100644
--- a/net/minecraft/world/item/ProjectileWeaponItem.java
+++ b/net/minecraft/world/item/ProjectileWeaponItem.java
@@ -109,6 +109,8 @@ public abstract class ProjectileWeaponItem extends Item {
             abstractArrow.setCritArrow(true);
         }
 
+        abstractArrow.setActualEnchantments(weapon.getEnchantments()); // Purpur - Add an option to fix MC-3304 projectile looting
+
         return abstractArrow;
     }
 
diff --git a/net/minecraft/world/item/ShovelItem.java b/net/minecraft/world/item/ShovelItem.java
index 887ac9f547ceaf76fd533ae47239a64c29a64b18..a290ad578498da07093ea31080cc3fbc87aa3778 100644
--- a/net/minecraft/world/item/ShovelItem.java
+++ b/net/minecraft/world/item/ShovelItem.java
@@ -46,9 +46,12 @@ public class ShovelItem extends Item {
             BlockState blockState1 = FLATTENABLES.get(blockState.getBlock());
             BlockState blockState2 = null;
             Runnable afterAction = null; // Paper
+            org.purpurmc.purpur.tool.Flattenable flattenable = level.purpurConfig.shovelFlattenables.get(blockState.getBlock()); // Purpur - Tool actionable options
             if (blockState1 != null && level.getBlockState(clickedPos.above()).isAir()) {
-                afterAction = () -> level.playSound(player, clickedPos, SoundEvents.SHOVEL_FLATTEN, SoundSource.BLOCKS, 1.0F, 1.0F); // Paper
-                blockState2 = blockState1;
+                // Purpur start - Tool actionable options
+                afterAction = () -> {if (!FLATTENABLES.containsKey(blockState.getBlock())) level.playSound(player, clickedPos, SoundEvents.SHOVEL_FLATTEN, SoundSource.BLOCKS, 1.0F, 1.0F);}; // Paper
+                blockState2 = flattenable.into().defaultBlockState();
+                // Purpur end - Tool actionable options
             } else if (blockState.getBlock() instanceof CampfireBlock && blockState.getValue(CampfireBlock.LIT)) {
                 afterAction = () -> { // Paper
                 if (!level.isClientSide()) {
diff --git a/net/minecraft/world/item/SnowballItem.java b/net/minecraft/world/item/SnowballItem.java
index 8eec16040fb9ae6bcccbd71bbe93521cdce5ccce..38b82537209449407922491506a7ca6224229ca9 100644
--- a/net/minecraft/world/item/SnowballItem.java
+++ b/net/minecraft/world/item/SnowballItem.java
@@ -26,7 +26,7 @@ public class SnowballItem extends Item implements ProjectileItem {
         // CraftBukkit start - moved down
         if (level instanceof ServerLevel serverLevel) {
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<Snowball> snowball = Projectile.spawnProjectileFromRotationDelayed(Snowball::new, serverLevel, itemInHand, player, 0.0F, SnowballItem.PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<Snowball> snowball = Projectile.spawnProjectileFromRotationDelayed(Snowball::new, serverLevel, itemInHand, player, 0.0F, SnowballItem.PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.snowballProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) snowball.projectile().getBukkitEntity());
             if (event.callEvent() && snowball.attemptSpawn()) {
                 player.awardStat(Stats.ITEM_USED.get(this));
diff --git a/net/minecraft/world/item/SpawnEggItem.java b/net/minecraft/world/item/SpawnEggItem.java
index 7a961e5ebbdac061f6e73e4ed07fe957ba759066..d48c1dedbd39770ccf3c9c3ff3351b391601cd77 100644
--- a/net/minecraft/world/item/SpawnEggItem.java
+++ b/net/minecraft/world/item/SpawnEggItem.java
@@ -57,6 +57,23 @@ public class SpawnEggItem extends Item {
             if (level.getBlockEntity(clickedPos) instanceof Spawner spawner) {
                 if (level.paperConfig().entities.spawning.disableMobSpawnerSpawnEggTransformation) return InteractionResult.FAIL; // Paper - Allow disabling mob spawner spawn egg transformation
                 EntityType<?> type = this.getType(level.registryAccess(), itemInHand);
+                // Purpur start - PlayerSetSpawnerTypeWithEggEvent
+                if (spawner instanceof net.minecraft.world.level.block.entity.SpawnerBlockEntity) {
+                    org.bukkit.block.Block bukkitBlock = level.getWorld().getBlockAt(clickedPos.getX(), clickedPos.getY(), clickedPos.getZ());
+                    org.purpurmc.purpur.event.PlayerSetSpawnerTypeWithEggEvent event = new org.purpurmc.purpur.event.PlayerSetSpawnerTypeWithEggEvent((org.bukkit.entity.Player) context.getPlayer().getBukkitEntity(), bukkitBlock, (org.bukkit.block.CreatureSpawner) bukkitBlock.getState(), org.bukkit.entity.EntityType.fromName(type.getName()));
+                    if (!event.callEvent()) {
+                        return InteractionResult.FAIL;
+                    }
+                    type = EntityType.getFromBukkitType(event.getEntityType());
+                } else if (spawner instanceof net.minecraft.world.level.block.entity.TrialSpawnerBlockEntity) {
+                    org.bukkit.block.Block bukkitBlock = level.getWorld().getBlockAt(clickedPos.getX(), clickedPos.getY(), clickedPos.getZ());
+                    org.purpurmc.purpur.event.PlayerSetTrialSpawnerTypeWithEggEvent event = new org.purpurmc.purpur.event.PlayerSetTrialSpawnerTypeWithEggEvent((org.bukkit.entity.Player) context.getPlayer().getBukkitEntity(), bukkitBlock, (org.bukkit.block.TrialSpawner) bukkitBlock.getState(), org.bukkit.entity.EntityType.fromName(type.getName()));
+                    if (!event.callEvent()) {
+                        return InteractionResult.FAIL;
+                    }
+                    type = EntityType.getFromBukkitType(event.getEntityType());
+                }
+                // Purpur end - PlayerSetSpawnerTypeWithEggEvent
                 spawner.setEntityId(type, level.getRandom());
                 level.sendBlockUpdated(clickedPos, blockState, blockState, 3);
                 level.gameEvent(context.getPlayer(), GameEvent.BLOCK_CHANGE, clickedPos);
diff --git a/net/minecraft/world/item/ThrowablePotionItem.java b/net/minecraft/world/item/ThrowablePotionItem.java
index 86198fb3150409b4b3e123982d8d3ba40b774621..6495c82fb88062875024c59a7c29d6d18b7a2f41 100644
--- a/net/minecraft/world/item/ThrowablePotionItem.java
+++ b/net/minecraft/world/item/ThrowablePotionItem.java
@@ -24,7 +24,7 @@ public abstract class ThrowablePotionItem extends PotionItem implements Projecti
         ItemStack itemInHand = player.getItemInHand(hand);
         if (level instanceof ServerLevel serverLevel) {
             // Paper start - PlayerLaunchProjectileEvent
-            final Projectile.Delayed<AbstractThrownPotion> thrownPotion = Projectile.spawnProjectileFromRotationDelayed(this::createPotion, serverLevel, itemInHand, player, -20.0F, PROJECTILE_SHOOT_POWER, 1.0F);
+            final Projectile.Delayed<AbstractThrownPotion> thrownPotion = Projectile.spawnProjectileFromRotationDelayed(this::createPotion, serverLevel, itemInHand, player, -20.0F, PROJECTILE_SHOOT_POWER, (float) serverLevel.purpurConfig.throwablePotionProjectileOffset); // Purpur - Projectile offset config
             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemInHand), (org.bukkit.entity.Projectile) thrownPotion.projectile().getBukkitEntity());
             if (event.callEvent() && thrownPotion.attemptSpawn()) {
                 if (event.shouldConsume()) {
diff --git a/net/minecraft/world/item/TridentItem.java b/net/minecraft/world/item/TridentItem.java
index df629e3f2defce5e65aaf874d7c5ddff71f39c28..34d15412b8f68ed1bae45b81ecf759c9c4d7e20c 100644
--- a/net/minecraft/world/item/TridentItem.java
+++ b/net/minecraft/world/item/TridentItem.java
@@ -83,7 +83,7 @@ public class TridentItem extends Item implements ProjectileItem {
                         if (tridentSpinAttackStrength == 0.0F) {
                             ItemStack itemStack = stack.copyWithCount(1); // Paper
                             Projectile.Delayed<ThrownTrident> tridentDelayed = Projectile.spawnProjectileFromRotationDelayed( // Paper - PlayerLaunchProjectileEvent(
-                                ThrownTrident::new, serverLevel, itemStack, player, 0.0F, 2.5F, 1.0F
+                                ThrownTrident::new, serverLevel, itemStack, player, 0.0F, 2.5F, (float) serverLevel.purpurConfig.tridentProjectileOffset  // Purpur - Projectile offset config
                             );
                             // Paper start - PlayerLaunchProjectileEvent
                             com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent event = new com.destroystokyo.paper.event.player.PlayerLaunchProjectileEvent((org.bukkit.entity.Player) player.getBukkitEntity(), org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(stack), (org.bukkit.entity.Projectile) tridentDelayed.projectile().getBukkitEntity());
@@ -94,6 +94,7 @@ public class TridentItem extends Item implements ProjectileItem {
                                 return false;
                             }
                             ThrownTrident thrownTrident = tridentDelayed.projectile(); // Paper - PlayerLaunchProjectileEvent
+                            thrownTrident.setActualEnchantments(stack.getEnchantments()); // Purpur - Add an option to fix MC-3304 projectile looting
                             if (event.shouldConsume()) {
                                 stack.hurtWithoutBreaking(1, player); // Paper - PlayerLaunchProjectileEvent
                             }
@@ -126,6 +127,18 @@ public class TridentItem extends Item implements ProjectileItem {
                         f1 *= tridentSpinAttackStrength / squareRoot;
                         f2 *= tridentSpinAttackStrength / squareRoot;
                         org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerRiptideEvent(player, stack, f, f1, f2); // CraftBukkit
+
+                        // Purpur start - Implement elytra settings
+                        List<net.minecraft.world.entity.EquipmentSlot> list = net.minecraft.world.entity.EquipmentSlot.VALUES.stream().filter((enumitemslot) -> LivingEntity.canGlideUsing(entity.getItemBySlot(enumitemslot), enumitemslot)).toList();
+                        if (!list.isEmpty()) {
+                            net.minecraft.world.entity.EquipmentSlot enumitemslot = net.minecraft.Util.getRandom(list, entity.random);
+                            ItemStack glideItem = entity.getItemBySlot(enumitemslot);
+                            if (glideItem.has(net.minecraft.core.component.DataComponents.GLIDER) && level.purpurConfig.elytraDamagePerTridentBoost > 0) {
+                                glideItem.hurtAndBreak(level.purpurConfig.elytraDamagePerTridentBoost, entity, enumitemslot);
+                            }
+                        }
+                        // Purpur end - Implement elytra settings
+
                         player.push(f, f1, f2);
                         player.startAutoSpinAttack(20, 8.0F, stack);
                         if (player.onGround()) {
diff --git a/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java b/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
index 41e1e076a4567d3d3202cf8e426a1ebb391d85e8..2d710dd3f20cbea06c16f14a558b575b369c6ca2 100644
--- a/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
+++ b/net/minecraft/world/item/consume_effects/ClearAllStatusEffectsConsumeEffect.java
@@ -20,6 +20,12 @@ public record ClearAllStatusEffectsConsumeEffect() implements ConsumeEffect {
     @Override
     // CraftBukkit start
     public boolean apply(Level level, ItemStack stack, LivingEntity entity, org.bukkit.event.entity.EntityPotionEffectEvent.Cause cause) {
+        // Purpur start - Option to toggle milk curing bad omen
+        net.minecraft.world.effect.MobEffectInstance badOmen = entity.getEffect(net.minecraft.world.effect.MobEffects.BAD_OMEN);
+        if (!level.purpurConfig.milkCuresBadOmen && stack.is(net.minecraft.world.item.Items.MILK_BUCKET) && badOmen != null) {
+            return entity.removeAllEffects(cause) && entity.addEffect(badOmen);
+        }
+        // Purpur end - Option to toggle milk curing bad omen
         return entity.removeAllEffects(cause);
         // CraftBukkit end
     }
diff --git a/net/minecraft/world/item/crafting/Ingredient.java b/net/minecraft/world/item/crafting/Ingredient.java
index 879c8fe1f20decc793cfa39e686b61d521bd76ba..9c383a1028988cdd3de8b29ba72a4d7bd2a37c7e 100644
--- a/net/minecraft/world/item/crafting/Ingredient.java
+++ b/net/minecraft/world/item/crafting/Ingredient.java
@@ -36,6 +36,7 @@ public final class Ingredient implements StackedContents.IngredientInfo<io.paper
     // CraftBukkit start
     @javax.annotation.Nullable
     private java.util.Set<ItemStack> itemStacks; // Paper - Improve exact choice recipe ingredients
+    public Predicate<org.bukkit.inventory.ItemStack> predicate; // Purpur - Add predicate to recipe's ExactChoice ingredient
 
     public boolean isExact() {
         return this.itemStacks != null;
@@ -88,6 +89,11 @@ public final class Ingredient implements StackedContents.IngredientInfo<io.paper
             return this.itemStacks.contains(stack); // Paper - Improve exact choice recipe ingredients (hashing FTW!)
         }
         // CraftBukkit end
+        // Purpur start - Add predicate to recipe's ExactChoice ingredient
+        if (predicate != null) {
+            return predicate.test(stack.asBukkitCopy());
+        }
+        // Purpur end - Add predicate to recipe's ExactChoice ingredient
         return stack.is(this.values);
     }
 
diff --git a/net/minecraft/world/item/enchantment/EnchantmentHelper.java b/net/minecraft/world/item/enchantment/EnchantmentHelper.java
index 66234431b265e0596275ca468cd40f8da98c22e2..e0cc0b49ea47bb38f7f4fe5ef3c793b0009d03c9 100644
--- a/net/minecraft/world/item/enchantment/EnchantmentHelper.java
+++ b/net/minecraft/world/item/enchantment/EnchantmentHelper.java
@@ -606,4 +606,58 @@ public class EnchantmentHelper {
     interface EnchantmentVisitor {
         void accept(Holder<Enchantment> enchantment, int level);
     }
+
+    // Purpur start - Enchantment convenience methods
+    public static Holder.Reference<Enchantment> getEnchantmentHolder(ResourceKey<Enchantment> enchantment) {
+        return net.minecraft.server.MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.ENCHANTMENT).getOrThrow(enchantment);
+    }
+
+    public static int getItemEnchantmentLevel(ResourceKey<Enchantment> enchantment, ItemStack stack) {
+        return getItemEnchantmentLevel(getEnchantmentHolder(enchantment), stack);
+    }
+    // Purpur end - Enchantment convenience methods
+
+    // Purpur start - Add option to mend the most damaged equipment first
+    public static Optional<EnchantedItemInUse> getMostDamagedItemWith(DataComponentType<?> componentType, LivingEntity entity) {
+        ItemStack maxStack = null;
+        EquipmentSlot maxSlot = null;
+        float maxPercent = 0.0F;
+
+        equipmentSlotLoop:
+        for (EquipmentSlot equipmentSlot : EquipmentSlot.values()) {
+            ItemStack stack = entity.getItemBySlot(equipmentSlot);
+
+            // do not even check enchantments for item with lower or equal damage percent
+            float percent = stack.getDamagePercent();
+            if (percent <= maxPercent) {
+                continue;
+            }
+
+            ItemEnchantments itemEnchantments = stack.getOrDefault(DataComponents.ENCHANTMENTS, ItemEnchantments.EMPTY);
+
+            for (Entry<Holder<Enchantment>> entry : itemEnchantments.entrySet()) {
+                Enchantment enchantment = entry.getKey().value();
+
+                net.minecraft.core.component.DataComponentMap effects = enchantment.effects();
+                if (!effects.has(componentType)) {
+                    // try with another enchantment
+                    continue;
+                }
+
+                if (enchantment.matchingSlot(equipmentSlot)) {
+                    maxStack = stack;
+                    maxSlot = equipmentSlot;
+                    maxPercent = percent;
+
+                    // check another slot now
+                    continue equipmentSlotLoop;
+                }
+            }
+        }
+
+        return maxStack != null
+            ? Optional.of(new EnchantedItemInUse(maxStack, maxSlot, entity))
+            : Optional.empty();
+    }
+    // Purpur end - Add option to mend the most damaged equipment first
 }
diff --git a/net/minecraft/world/item/enchantment/ItemEnchantments.java b/net/minecraft/world/item/enchantment/ItemEnchantments.java
index 6040b73a5351c3eb166250566b5c2385cee39ee0..29619b87fe19c66934fe5aaee8a9641960091bf5 100644
--- a/net/minecraft/world/item/enchantment/ItemEnchantments.java
+++ b/net/minecraft/world/item/enchantment/ItemEnchantments.java
@@ -32,7 +32,7 @@ public class ItemEnchantments implements TooltipProvider {
     private static final java.util.Comparator<Holder<Enchantment>> ENCHANTMENT_ORDER = java.util.Comparator.comparing(Holder::getRegisteredName);
     public static final ItemEnchantments EMPTY = new ItemEnchantments(new it.unimi.dsi.fastutil.objects.Object2IntAVLTreeMap<>(ENCHANTMENT_ORDER));
     // Paper end - sort enchantments
-    private static final Codec<Integer> LEVEL_CODEC = Codec.intRange(1, 255);
+    private static final Codec<Integer> LEVEL_CODEC = Codec.intRange(1, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)); // Purpur - Add toggle for enchant level clamping
     public static final Codec<ItemEnchantments> CODEC = Codec.unboundedMap(Enchantment.CODEC, LEVEL_CODEC)
         .xmap(
             map -> new net.minecraft.world.item.enchantment.ItemEnchantments(net.minecraft.Util.make(new it.unimi.dsi.fastutil.objects.Object2IntAVLTreeMap<>(ENCHANTMENT_ORDER), m -> m.putAll(map))), // Paper - sort enchantments
@@ -50,7 +50,7 @@ public class ItemEnchantments implements TooltipProvider {
 
         for (Entry<Holder<Enchantment>> entry : enchantments.object2IntEntrySet()) {
             int intValue = entry.getIntValue();
-            if (intValue < 0 || intValue > 255) {
+            if (intValue < 0 || intValue > (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)) { // Purpur - Add toggle for enchant level clamping
                 throw new IllegalArgumentException("Enchantment " + entry.getKey() + " has invalid level " + intValue);
             }
         }
@@ -133,13 +133,13 @@ public class ItemEnchantments implements TooltipProvider {
             if (level <= 0) {
                 this.enchantments.removeInt(enchantment);
             } else {
-                this.enchantments.put(enchantment, Math.min(level, 255));
+                this.enchantments.put(enchantment, Math.min(level, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767))); // Purpur - Add toggle for enchant level clamping
             }
         }
 
         public void upgrade(Holder<Enchantment> enchantment, int level) {
             if (level > 0) {
-                this.enchantments.merge(enchantment, Math.min(level, 255), Integer::max);
+                this.enchantments.merge(enchantment, Math.min(level, (org.purpurmc.purpur.PurpurConfig.clampEnchantLevels ? 255 : 32767)), Integer::max); // Purpur - Add toggle for enchant level clamping
             }
         }
 
diff --git a/net/minecraft/world/item/trading/MerchantOffer.java b/net/minecraft/world/item/trading/MerchantOffer.java
index 64c99df8ff305fa28c75dc03fc5ef8c61634ad84..e1452d0694cad3db1800f8610fc095bf98f5f15f 100644
--- a/net/minecraft/world/item/trading/MerchantOffer.java
+++ b/net/minecraft/world/item/trading/MerchantOffer.java
@@ -143,8 +143,13 @@ public class MerchantOffer {
     }
 
     public void updateDemand() {
+        // Purpur start - Configurable minimum demand for trades
+        this.updateDemand(0);
+    }
+    public void updateDemand(int minimumDemand) {
+        // Purpur end - Configurable minimum demand for trades
         this.demand = this.demand + this.uses - (this.maxUses - this.uses);
-        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.preventNegativeVillagerDemand) this.demand = Math.max(0, this.demand); // Paper - Fix MC-163962
+        if (io.papermc.paper.configuration.GlobalConfiguration.get().misc.preventNegativeVillagerDemand) this.demand = Math.max(minimumDemand, this.demand); // Paper - Fix MC-163962 // Purpur - Configurable minimum demand for trades
     }
 
     public ItemStack assemble() {
diff --git a/net/minecraft/world/level/BaseSpawner.java b/net/minecraft/world/level/BaseSpawner.java
index 42f44222a8dd61f70d4583b0ca82a16400baaa5a..41ba9f234e840fadee3c8a52ba9655b97a8b7381 100644
--- a/net/minecraft/world/level/BaseSpawner.java
+++ b/net/minecraft/world/level/BaseSpawner.java
@@ -61,6 +61,7 @@ public abstract class BaseSpawner {
     }
 
     public boolean isNearPlayer(Level level, BlockPos pos) {
+        if (level.purpurConfig.spawnerDeactivateByRedstone && level.hasNeighborSignal(pos)) return false; // Purpur - Redstone deactivates spawners
         return level.hasNearbyAlivePlayerThatAffectsSpawning(pos.getX() + 0.5, pos.getY() + 0.5, pos.getZ() + 0.5, this.requiredPlayerRange); // Paper - Affects Spawning API
     }
 
diff --git a/net/minecraft/world/level/EntityGetter.java b/net/minecraft/world/level/EntityGetter.java
index 639afaf7c492b43241e919489ba8e7b549dee530..7760f4c147b8f9d28547d64bafefdde9c645bfba 100644
--- a/net/minecraft/world/level/EntityGetter.java
+++ b/net/minecraft/world/level/EntityGetter.java
@@ -191,7 +191,7 @@ public interface EntityGetter extends ca.spottedleaf.moonrise.patches.chunk_syst
 
     default boolean hasNearbyAlivePlayer(double x, double y, double z, double distance) {
         for (Player player : this.getLocalPlayers()) { // Folia - region threading
-            if (EntitySelector.NO_SPECTATORS.test(player) && EntitySelector.LIVING_ENTITY_STILL_ALIVE.test(player)) {
+            if (EntitySelector.NO_SPECTATORS.test(player) && EntitySelector.LIVING_ENTITY_STILL_ALIVE.test(player) && EntitySelector.notAfk.test(player)) { // Purpur - AFK API
                 double d = player.distanceToSqr(x, y, z);
                 if (distance < 0.0 || d < distance * distance) {
                     return true;
diff --git a/net/minecraft/world/level/GameRules.java b/net/minecraft/world/level/GameRules.java
index d5536dd40a1e9a2e05967652f690abbbca287852..d510503a8ad272255aeba20a916642828023fd19 100644
--- a/net/minecraft/world/level/GameRules.java
+++ b/net/minecraft/world/level/GameRules.java
@@ -354,6 +354,13 @@ public class GameRules {
         this.<T>getRule(key).setFrom(rule, level); // CraftBukkit - per-world
     }
 
+    public boolean getBoolean(GameRules.Key<GameRules.BooleanValue> key, Boolean gameRuleOverride) {
+        if (gameRuleOverride != null) {
+            return gameRuleOverride;
+        }
+        return this.getBoolean(key);
+    }
+
     public boolean getBoolean(GameRules.Key<GameRules.BooleanValue> key) {
         return this.getRule(key).get();
     }
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 5fe048ce442957a534d44454e0bb908afe8ad3a6..6ea9ba60aba568ce07bb9d35406f42edbaf490dc 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -150,11 +150,56 @@ public abstract class Level implements LevelAccessor, UUIDLookup<Entity>, AutoCl
     }
     // Paper end - add paper world config
 
+    public final org.purpurmc.purpur.PurpurWorldConfig purpurConfig; // Purpur - Purpur config files
     public static @Nullable BlockPos lastPhysicsProblem; // Spigot
     //private int tileTickPosition; // Folia - region threading
     //public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new java.util.HashMap<>(); // Paper - Optimize explosions // Folia - region threading
     //public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos; // Paper - Faster redstone torch rapid clock removal; Move from Map in BlockRedstoneTorch to here // Folia - region threading
 
+    // Purpur start - Add adjustable breeding cooldown to config
+    private com.google.common.cache.Cache<BreedingCooldownPair, Object> playerBreedingCooldowns;
+
+    private com.google.common.cache.Cache<BreedingCooldownPair, Object> getNewBreedingCooldownCache() {
+        return com.google.common.cache.CacheBuilder.newBuilder().expireAfterWrite(this.purpurConfig.animalBreedingCooldownSeconds, java.util.concurrent.TimeUnit.SECONDS).build();
+    }
+
+    public void resetBreedingCooldowns() {
+        this.playerBreedingCooldowns = this.getNewBreedingCooldownCache();
+    }
+
+    public boolean hasBreedingCooldown(java.util.UUID player, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) { // Purpur
+        return this.playerBreedingCooldowns.getIfPresent(new BreedingCooldownPair(player, animalType)) != null;
+    }
+
+    public void addBreedingCooldown(java.util.UUID player, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) {
+        this.playerBreedingCooldowns.put(new BreedingCooldownPair(player, animalType), new Object());
+    }
+
+    private static final class BreedingCooldownPair {
+        private final java.util.UUID playerUUID;
+        private final Class<? extends net.minecraft.world.entity.animal.Animal> animalType;
+
+        public BreedingCooldownPair(java.util.UUID playerUUID, Class<? extends net.minecraft.world.entity.animal.Animal> animalType) {
+            this.playerUUID = playerUUID;
+            this.animalType = animalType;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+            BreedingCooldownPair that = (BreedingCooldownPair) o;
+            return playerUUID.equals(that.playerUUID) && animalType.equals(that.animalType);
+        }
+
+        @Override
+        public int hashCode() {
+            return java.util.Objects.hash(playerUUID, animalType);
+        }
+    }
+    // Purpur end - Add adjustable breeding cooldown to config
+
+
     public CraftWorld getWorld() {
         return this.world;
     }
@@ -859,6 +904,8 @@ public abstract class Level implements LevelAccessor, UUIDLookup<Entity>, AutoCl
         // Paper end - getblock optimisations - cache world height/sections
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
+        this.purpurConfig = new org.purpurmc.purpur.PurpurWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) levelData).getLevelName(), environment); // Purpur - Purpur config files
+        this.playerBreedingCooldowns = this.getNewBreedingCooldownCache(); // Purpur - Add adjustable breeding cooldown to config
         this.generator = generator;
         this.world = new CraftWorld((ServerLevel) this, generator, biomeProvider, environment);
 
@@ -2203,4 +2250,14 @@ public abstract class Level implements LevelAccessor, UUIDLookup<Entity>, AutoCl
             return this.id;
         }
     }
+
+    // Purpur start - Add allow water in end world option
+    public boolean isNether() {
+        return getWorld().getEnvironment() == org.bukkit.World.Environment.NETHER;
+    }
+
+    public boolean isTheEnd() {
+        return getWorld().getEnvironment() == org.bukkit.World.Environment.THE_END;
+    }
+    // Purpur end - Add allow water in end world option
 }
diff --git a/net/minecraft/world/level/NaturalSpawner.java b/net/minecraft/world/level/NaturalSpawner.java
index f324a74a191d3fe3e270556d07c4543ec34e0195..da20ca6b89d3cf4183dea389321410df8a0b6ccd 100644
--- a/net/minecraft/world/level/NaturalSpawner.java
+++ b/net/minecraft/world/level/NaturalSpawner.java
@@ -261,7 +261,7 @@ public final class NaturalSpawner {
                     mutableBlockPos.set(x, y, z);
                     double d = x + 0.5;
                     double d1 = z + 0.5;
-                    Player nearestPlayer = level.getNearestPlayer(d, y, d1, -1.0, false);
+                    Player nearestPlayer = level.getNearestPlayer(d, y, d1, -1.0, level.purpurConfig.mobSpawningIgnoreCreativePlayers); // Purpur - mob spawning option to ignore creative players
                     if (nearestPlayer != null) {
                         double d2 = nearestPlayer.distanceToSqr(d, y, d1);
                         if (level.isLoadedAndInBounds(mutableBlockPos) && isRightDistanceToPlayerAndSpawnPoint(level, chunk, mutableBlockPos, d2)) { // Paper - don't load chunks for mob spawn
diff --git a/net/minecraft/world/level/ServerExplosion.java b/net/minecraft/world/level/ServerExplosion.java
index b3e897a4afee742b5055d652ad7047a660d8ea04..178b34d6c61818bcd2e1f7d273ef4638df17e480 100644
--- a/net/minecraft/world/level/ServerExplosion.java
+++ b/net/minecraft/world/level/ServerExplosion.java
@@ -648,6 +648,23 @@ public class ServerExplosion implements Explosion {
         this.directMappedBlockCache = new ca.spottedleaf.moonrise.patches.collisions.ExplosionBlockCache[BLOCK_EXPLOSION_CACHE_WIDTH * BLOCK_EXPLOSION_CACHE_WIDTH * BLOCK_EXPLOSION_CACHE_WIDTH];
         this.mutablePos = new BlockPos.MutableBlockPos();
         // Paper end - collision optimisations
+        // Purpur start - add PreExplodeEvents
+        if (this.source != null) {
+            Location location = new Location(this.level.getWorld(), this.center.x, this.center.y, this.center.z);
+            if(!new org.purpurmc.purpur.event.entity.PreEntityExplodeEvent(this.source.getBukkitEntity(), location, this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, org.bukkit.craftbukkit.CraftExplosionResult.toExplosionResult(getBlockInteraction())).callEvent()) {
+                this.wasCanceled = true;
+                return;
+            }
+        } else {
+            Location location = new Location(this.level.getWorld(), this.center.x, this.center.y, this.center.z);
+            org.bukkit.block.Block block = location.getBlock();
+            org.bukkit.block.BlockState blockState = (this.damageSource.causingBlockSnapshot() != null) ? this.damageSource.causingBlockSnapshot() : block.getState();
+            if(!new org.purpurmc.purpur.event.PreBlockExplodeEvent(location.getBlock(), this.blockInteraction == Explosion.BlockInteraction.DESTROY_WITH_DECAY ? 1.0F / this.radius : 1.0F, blockState, org.bukkit.craftbukkit.CraftExplosionResult.toExplosionResult(getBlockInteraction())).callEvent()) {
+                this.wasCanceled = true;
+                return;
+            }
+        }
+        // Purpur end - Add PreExplodeEvents
         this.level.gameEvent(this.source, GameEvent.EXPLODE, this.center);
         List<BlockPos> list = this.calculateExplodedPositions();
         this.hurtEntities();
diff --git a/net/minecraft/world/level/block/AnvilBlock.java b/net/minecraft/world/level/block/AnvilBlock.java
index e8bac6deb63e0f94fb5f8b38602b2e3333e5fa8d..b14736c25cfdd94c6e3f159e53865150b06edef6 100644
--- a/net/minecraft/world/level/block/AnvilBlock.java
+++ b/net/minecraft/world/level/block/AnvilBlock.java
@@ -54,6 +54,53 @@ public class AnvilBlock extends FallingBlock {
         return this.defaultBlockState().setValue(FACING, context.getHorizontalDirection().getClockWise());
     }
 
+    // Purpur start - Anvil repair/damage options
+    @Override
+    protected net.minecraft.world.InteractionResult useItemOn(final net.minecraft.world.item.ItemStack stack, final BlockState state, final Level world, final BlockPos pos, final Player player, final net.minecraft.world.InteractionHand hand, final BlockHitResult hit) {
+        if (world.purpurConfig.anvilRepairIngotsAmount > 0 && stack.is(net.minecraft.world.item.Items.IRON_INGOT)) {
+            if (stack.getCount() < world.purpurConfig.anvilRepairIngotsAmount) {
+                // not enough iron ingots, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (state.is(Blocks.DAMAGED_ANVIL)) {
+                world.setBlock(pos, Blocks.CHIPPED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.CHIPPED_ANVIL)) {
+                world.setBlock(pos, Blocks.ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.ANVIL)) {
+                // anvil is already fully repaired, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(world.purpurConfig.anvilRepairIngotsAmount);
+            }
+            world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_PLACE, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+        if (world.purpurConfig.anvilDamageObsidianAmount > 0 && stack.is(net.minecraft.world.item.Items.OBSIDIAN)) {
+            if (stack.getCount() < world.purpurConfig.anvilDamageObsidianAmount) {
+                // not enough obsidian, play "error" sound and consume
+                world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_HIT, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+                return net.minecraft.world.InteractionResult.CONSUME;
+            }
+            if (state.is(Blocks.DAMAGED_ANVIL)) {
+                world.destroyBlock(pos, false);
+            } else if (state.is(Blocks.CHIPPED_ANVIL)) {
+                world.setBlock(pos, Blocks.DAMAGED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            } else if (state.is(Blocks.ANVIL)) {
+                world.setBlock(pos, Blocks.CHIPPED_ANVIL.defaultBlockState().setValue(FACING, state.getValue(FACING)), 3);
+            }
+            if (!player.getAbilities().instabuild) {
+                stack.shrink(world.purpurConfig.anvilDamageObsidianAmount);
+            }
+            world.playSound(null, pos, net.minecraft.sounds.SoundEvents.ANVIL_LAND, net.minecraft.sounds.SoundSource.BLOCKS, 1.0F, 1.0F);
+            return net.minecraft.world.InteractionResult.CONSUME;
+        }
+        return net.minecraft.world.InteractionResult.TRY_WITH_EMPTY_HAND;
+    }
+    // Purpur end - Anvil repair/damage options
+
     @Override
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         if (!level.isClientSide) {
diff --git a/net/minecraft/world/level/block/AzaleaBlock.java b/net/minecraft/world/level/block/AzaleaBlock.java
index 435a455ad2ec3dfb142d570a51a720bc6c49dac3..32a1dc20202bad7a15794e98cdc1bf2fb2ad5308 100644
--- a/net/minecraft/world/level/block/AzaleaBlock.java
+++ b/net/minecraft/world/level/block/AzaleaBlock.java
@@ -50,6 +50,20 @@ public class AzaleaBlock extends VegetationBlock implements BonemealableBlock {
 
     @Override
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
+        // Purpur start - Chance for azalea blocks to grow into trees naturally
+        growTree(level, random, pos, state);
+    }
+
+    @Override
+    public void randomTick(net.minecraft.world.level.block.state.BlockState state, ServerLevel world, BlockPos pos, RandomSource random) {
+        double chance = state.getBlock() == Blocks.FLOWERING_AZALEA ? world.purpurConfig.floweringAzaleaGrowthChance : world.purpurConfig.azaleaGrowthChance;
+        if (chance > 0.0D && world.getMaxLocalRawBrightness(pos.above()) > 9 && random.nextDouble() < chance) {
+            growTree(world, random, pos, state);
+        }
+    }
+
+    private void growTree(ServerLevel level, RandomSource random, BlockPos pos, net.minecraft.world.level.block.state.BlockState state) {
+        // Purpur end - Chance for azalea blocks to grow into trees naturally
         TreeGrower.AZALEA.growTree(level, level.getChunkSource().getGenerator(), pos, state, random);
     }
 
diff --git a/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java b/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
index fb6e9194440b85487660f91aea7e34fdf086187b..2653ae5bf66f2b117f86e4df04d9cc307ba09011 100644
--- a/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
+++ b/net/minecraft/world/level/block/BaseCoralPlantTypeBlock.java
@@ -39,6 +39,7 @@ public abstract class BaseCoralPlantTypeBlock extends Block implements SimpleWat
     }
 
     protected static boolean scanForWater(BlockState state, BlockGetter level, BlockPos pos) {
+        if (!((net.minecraft.world.level.LevelAccessor) level).getMinecraftWorld().purpurConfig.coralDieOutsideWater) return true; // Purpur - Config to not let coral die
         if (state.getValue(WATERLOGGED)) {
             return true;
         } else {
diff --git a/net/minecraft/world/level/block/BedBlock.java b/net/minecraft/world/level/block/BedBlock.java
index 65c586322b4b695184a1314b973931a41f1ceb58..c6e26b25955b3e97c3a0e2d8bbe9c853b13e330e 100644
--- a/net/minecraft/world/level/block/BedBlock.java
+++ b/net/minecraft/world/level/block/BedBlock.java
@@ -98,7 +98,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
                 }
 
                 Vec3 center = pos.getCenter();
-                level.explode(null, level.damageSources().badRespawnPointExplosion(center), null, center, 5.0F, true, Level.ExplosionInteraction.BLOCK);
+                if (level.purpurConfig.bedExplode) level.explode(null, level.damageSources().badRespawnPointExplosion(center), null, center, (float) level.purpurConfig.bedExplosionPower, level.purpurConfig.bedExplosionFire, level.purpurConfig.bedExplosionEffect); // Purpur - Implement bed explosion options
                 return InteractionResult.SUCCESS_SERVER;
             } else if (state.getValue(OCCUPIED)) {
                 if (!BedBlock.canSetSpawn(level)) return this.explodeBed(state, level, pos); // Paper - check explode first
@@ -146,7 +146,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
         }
 
         Vec3 center = pos.getCenter();
-        level.explode(null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), null, center, 5.0F, true, Level.ExplosionInteraction.BLOCK); // CraftBukkit - add state
+        if (level.purpurConfig.bedExplode) level.explode(null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), null, center, (float) level.purpurConfig.bedExplosionPower, level.purpurConfig.bedExplosionFire, level.purpurConfig.bedExplosionEffect); // CraftBukkit - add state // Purpur - Implement bed explosion options
         return InteractionResult.SUCCESS_SERVER;
      }
     // CraftBukkit end
@@ -167,7 +167,7 @@ public class BedBlock extends HorizontalDirectionalBlock implements EntityBlock
 
     @Override
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        super.fallOn(level, state, pos, entity, fallDistance * 0.5);
+        super.fallOn(level, state, pos, entity, fallDistance); // Purpur - Configurable block fall damage modifiers
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/BigDripleafBlock.java b/net/minecraft/world/level/block/BigDripleafBlock.java
index e1193bcb666b7d38c511df7c1ebddb5897cefa8f..29248afa290b3143375f0538b4dfc80a63f8945f 100644
--- a/net/minecraft/world/level/block/BigDripleafBlock.java
+++ b/net/minecraft/world/level/block/BigDripleafBlock.java
@@ -254,7 +254,7 @@ public class BigDripleafBlock extends HorizontalDirectionalBlock implements Bone
             playTiltSound(level, pos, sound);
         }
 
-        int _int = DELAY_UNTIL_NEXT_TILT_STATE.getInt(tilt);
+        int _int = level.purpurConfig.bigDripleafTiltDelay.getOrDefault(tilt, -1); // Purpur - Big dripleaf tilt delay
         if (_int != -1) {
             level.scheduleTick(pos, this, _int);
         }
diff --git a/net/minecraft/world/level/block/Block.java b/net/minecraft/world/level/block/Block.java
index 644b9fab1d6729bf3964ebee0d6e9c46f89b8c46..a95bb049f1b3f05257e1e86a267375349a259c64 100644
--- a/net/minecraft/world/level/block/Block.java
+++ b/net/minecraft/world/level/block/Block.java
@@ -99,6 +99,10 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static final int UPDATE_LIMIT = 512;
     protected final StateDefinition<Block, BlockState> stateDefinition;
     private BlockState defaultBlockState;
+    // Purpur start - Configurable block fall damage modifiers
+    public float fallDamageMultiplier = 1.0F;
+    public float fallDistanceMultiplier = 1.0F;
+    // Purpur end - Configurable block fall damage modifiers
     // Paper start - Protect Bedrock and End Portal/Frames from being destroyed
     public final boolean isDestroyable() {
         return io.papermc.paper.configuration.GlobalConfiguration.get().unsupportedSettings.allowPermanentBlockBreakExploits ||
@@ -345,7 +349,7 @@ public class Block extends BlockBehaviour implements ItemLike {
             event.setExpToDrop(block.getExpDrop(state, serverLevel, pos, net.minecraft.world.item.ItemStack.EMPTY, true)); // Paper - Properly handle xp dropping
             event.callEvent();
             for (org.bukkit.inventory.ItemStack drop : event.getDrops()) {
-                popResource(serverLevel, pos, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(drop));
+                popResource(serverLevel, pos, applyLoreFromTile(org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(drop), blockEntity)); // Purpur - Persistent BlockEntity Lore and DisplayName
             }
             state.spawnAfterBreak(serverLevel, pos, ItemStack.EMPTY, false); // Paper - Properly handle xp dropping
             block.popExperience(serverLevel, pos, event.getExpToDrop()); // Paper - Properly handle xp dropping
@@ -363,7 +367,7 @@ public class Block extends BlockBehaviour implements ItemLike {
 
     public static void dropResources(BlockState state, LevelAccessor level, BlockPos pos, @Nullable BlockEntity blockEntity) {
         if (level instanceof ServerLevel) {
-            getDrops(state, (ServerLevel)level, pos, blockEntity).forEach(stack -> popResource((ServerLevel)level, pos, stack));
+            getDrops(state, (ServerLevel)level, pos, blockEntity).forEach(stack -> popResource((ServerLevel)level, pos, applyLoreFromTile(stack, blockEntity))); // Purpur - Persistent BlockEntity Lore and DisplayName
             state.spawnAfterBreak((ServerLevel)level, pos, ItemStack.EMPTY, true);
         }
     }
@@ -375,11 +379,30 @@ public class Block extends BlockBehaviour implements ItemLike {
     public static void dropResources(BlockState state, Level level, BlockPos pos, @Nullable BlockEntity blockEntity, @Nullable Entity entity, ItemStack tool, boolean dropExperience) {
     // Paper end - Properly handle xp dropping
         if (level instanceof ServerLevel) {
-            getDrops(state, (ServerLevel)level, pos, blockEntity, entity, tool).forEach(stack -> popResource(level, pos, stack));
+            getDrops(state, (ServerLevel)level, pos, blockEntity, entity, tool).forEach(stack -> popResource(level, pos, applyLoreFromTile(stack, blockEntity))); // Purpur - Persistent BlockEntity Lore and DisplayName
             state.spawnAfterBreak((ServerLevel)level, pos, tool, dropExperience); // Paper - Properly handle xp dropping
         }
     }
 
+    // Purpur start - Persistent BlockEntity Lore and DisplayName
+    private static ItemStack applyLoreFromTile(ItemStack stack, @Nullable BlockEntity blockEntity) {
+        if (stack.getItem() instanceof BlockItem) {
+            if (blockEntity != null && blockEntity.getLevel() instanceof ServerLevel) {
+                net.minecraft.world.item.component.ItemLore lore = blockEntity.getPersistentLore();
+                net.minecraft.core.component.DataComponentPatch.Builder builder = net.minecraft.core.component.DataComponentPatch.builder();
+                if (blockEntity.getLevel().purpurConfig.persistentTileEntityLore && lore != null) {
+                    builder.set(net.minecraft.core.component.DataComponents.LORE, lore);
+                }
+                if (!blockEntity.getLevel().purpurConfig.persistentTileEntityDisplayName) {
+                    builder.remove(net.minecraft.core.component.DataComponents.CUSTOM_NAME);
+                }
+                stack.applyComponents(builder.build());
+            }
+        }
+        return stack;
+    }
+    // Purpur end - Persistent BlockEntity Lore and DisplayName
+
     public static void popResource(Level level, BlockPos pos, ItemStack stack) {
         double d = EntityType.ITEM.getHeight() / 2.0;
         double d1 = pos.getX() + 0.5 + Mth.nextDouble(level.random, -0.25, 0.25);
@@ -460,7 +483,15 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public void setPlacedBy(Level level, BlockPos pos, BlockState state, @Nullable LivingEntity placer, ItemStack stack) {
+        this.placer = placer; // Purpur - Store placer on Block when placed
+    }
+
+    // Purpur start - Store placer on Block when placed
+    @Nullable protected LivingEntity placer = null;
+    public void forgetPlacer() {
+        this.placer = null;
     }
+    // Purpur end - Store placer on Block when placed
 
     public boolean isPossibleToRespawnInThis(BlockState state) {
         return !state.isSolid() && !state.liquid();
@@ -471,7 +502,7 @@ public class Block extends BlockBehaviour implements ItemLike {
     }
 
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        entity.causeFallDamage(fallDistance, 1.0F, entity.damageSources().fall());
+        entity.causeFallDamage(fallDistance * fallDistanceMultiplier, fallDamageMultiplier, entity.damageSources().fall()); // Purpur - Configurable block fall damage modifiers
     }
 
     public void updateEntityMovementAfterFallOn(BlockGetter level, Entity entity) {
diff --git a/net/minecraft/world/level/block/Blocks.java b/net/minecraft/world/level/block/Blocks.java
index ff2743d808f3c309bf098b98a6fcba7d019f54c1..941c57083803d69503e83c3ccbbb2759ba3db605 100644
--- a/net/minecraft/world/level/block/Blocks.java
+++ b/net/minecraft/world/level/block/Blocks.java
@@ -6571,6 +6571,7 @@ public class Blocks {
         BlockBehaviour.Properties.of()
             .mapColor(MapColor.PLANT)
             .forceSolidOff()
+            .randomTicks() // Purpur - Chance for azalea blocks to grow into trees naturally
             .instabreak()
             .sound(SoundType.AZALEA)
             .noOcclusion()
@@ -6582,6 +6583,7 @@ public class Blocks {
         BlockBehaviour.Properties.of()
             .mapColor(MapColor.PLANT)
             .forceSolidOff()
+            .randomTicks() // Purpur - Chance for azalea blocks to grow into trees naturally
             .instabreak()
             .sound(SoundType.FLOWERING_AZALEA)
             .noOcclusion()
diff --git a/net/minecraft/world/level/block/BubbleColumnBlock.java b/net/minecraft/world/level/block/BubbleColumnBlock.java
index ab93da06d9e9858668aa796db497f282afa7020a..23a9c30baf8d33855703d45c2739fd5072d81adc 100644
--- a/net/minecraft/world/level/block/BubbleColumnBlock.java
+++ b/net/minecraft/world/level/block/BubbleColumnBlock.java
@@ -98,9 +98,9 @@ public class BubbleColumnBlock extends Block implements BucketPickup {
         if (blockState.is(Blocks.BUBBLE_COLUMN)) {
             return blockState;
         } else if (blockState.is(Blocks.SOUL_SAND)) {
-            return Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, false);
+            return Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, org.purpurmc.purpur.PurpurConfig.soulSandBlockReverseBubbleColumnFlow); // Purpur - Config to reverse bubble column flow
         } else {
-            return blockState.is(Blocks.MAGMA_BLOCK) ? Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, true) : Blocks.WATER.defaultBlockState();
+            return blockState.is(Blocks.MAGMA_BLOCK) ? Blocks.BUBBLE_COLUMN.defaultBlockState().setValue(DRAG_DOWN, !org.purpurmc.purpur.PurpurConfig.magmaBlockReverseBubbleColumnFlow) : Blocks.WATER.defaultBlockState(); // Purpur - Config to reverse bubble column flow
         }
     }
 
diff --git a/net/minecraft/world/level/block/CactusBlock.java b/net/minecraft/world/level/block/CactusBlock.java
index d4fbf130e23a959be8268085067b3bea1541be9a..2e79ce7e02aaa4abcef1507bba71e0305b6c696f 100644
--- a/net/minecraft/world/level/block/CactusBlock.java
+++ b/net/minecraft/world/level/block/CactusBlock.java
@@ -22,7 +22,7 @@ import net.minecraft.world.level.pathfinder.PathComputationType;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class CactusBlock extends Block {
+public class CactusBlock extends Block implements BonemealableBlock { // Purpur - bonemealable cactus
     public static final MapCodec<CactusBlock> CODEC = simpleCodec(CactusBlock::new);
     public static final IntegerProperty AGE = BlockStateProperties.AGE_15;
     public static final int MAX_AGE = 15;
@@ -117,7 +117,7 @@ public class CactusBlock extends Block {
     protected boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
         for (Direction direction : Direction.Plane.HORIZONTAL) {
             BlockState blockState = level.getBlockState(pos.relative(direction));
-            if (blockState.isSolid() || level.getFluidState(pos.relative(direction)).is(FluidTags.LAVA)) {
+            if ((level.getWorldBorder().world.purpurConfig.cactusBreaksFromSolidNeighbors && blockState.isSolid()) || level.getFluidState(pos.relative(direction)).is(FluidTags.LAVA)) { // Purpur - Cactus breaks from solid neighbors config
                 return false;
             }
         }
@@ -141,4 +141,34 @@ public class CactusBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return false;
     }
+
+    // Purpur start - bonemealable cactus
+    @Override
+    public boolean isValidBonemealTarget(final LevelReader world, final BlockPos pos, final BlockState state) {
+        if (!((Level) world).purpurConfig.cactusAffectedByBonemeal || !world.isEmptyBlock(pos.above())) return false;
+
+        int cactusHeight = 0;
+        while (world.getBlockState(pos.below(cactusHeight)).is(this)) {
+            cactusHeight++;
+        }
+
+        return cactusHeight < ((Level) world).paperConfig().maxGrowthHeight.cactus;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int cactusHeight = 0;
+        while (world.getBlockState(pos.below(cactusHeight)).is(this)) {
+            cactusHeight++;
+        }
+        for (int i = 0; i <= world.paperConfig().maxGrowthHeight.cactus - cactusHeight; i++) {
+            world.setBlockAndUpdate(pos.above(i), state.setValue(CactusBlock.AGE, 0));
+        }
+    }
+    // Purpur end - bonemealable cactus
 }
diff --git a/net/minecraft/world/level/block/CakeBlock.java b/net/minecraft/world/level/block/CakeBlock.java
index 72236993ebc4fbfc8b6316577caaa9c780bd447b..7c3b5170690af3bbdc856af96c3e01b0e55d6412 100644
--- a/net/minecraft/world/level/block/CakeBlock.java
+++ b/net/minecraft/world/level/block/CakeBlock.java
@@ -109,6 +109,7 @@ public class CakeBlock extends Block {
             org.bukkit.event.entity.FoodLevelChangeEvent event = org.bukkit.craftbukkit.event.CraftEventFactory.callFoodLevelChangeEvent(player, 2 + oldFoodLevel);
 
             if (!event.isCancelled()) {
+                if (player.level().purpurConfig.playerBurpWhenFull && event.getFoodLevel() == 20 && oldFoodLevel < 20) player.burpDelay = player.level().purpurConfig.playerBurpDelay; // Purpur - Burp after eating food fills hunger bar completely
                 player.getFoodData().eat(event.getFoodLevel() - oldFoodLevel, 0.1F);
             }
 
diff --git a/net/minecraft/world/level/block/CampfireBlock.java b/net/minecraft/world/level/block/CampfireBlock.java
index 028e2ad8bcb23b3f9f80a5ec551204bb2d7db1ae..642550d59e17330437028a84830520f394a41728 100644
--- a/net/minecraft/world/level/block/CampfireBlock.java
+++ b/net/minecraft/world/level/block/CampfireBlock.java
@@ -124,7 +124,7 @@ public class CampfireBlock extends BaseEntityBlock implements SimpleWaterloggedB
         return this.defaultBlockState()
             .setValue(WATERLOGGED, flag)
             .setValue(SIGNAL_FIRE, this.isSmokeSource(level.getBlockState(clickedPos.below())))
-            .setValue(LIT, !flag)
+            .setValue(LIT, level.getMinecraftWorld().purpurConfig.campFireLitWhenPlaced && !flag) // Purpur - Campfire option for lit when placed
             .setValue(FACING, context.getHorizontalDirection());
     }
 
diff --git a/net/minecraft/world/level/block/CarvedPumpkinBlock.java b/net/minecraft/world/level/block/CarvedPumpkinBlock.java
index 7cdf16c7216878350537b5331081cb30f44d6dbb..a4854370dfdcbc7ec4c27975e4feb69d4cb48a11 100644
--- a/net/minecraft/world/level/block/CarvedPumpkinBlock.java
+++ b/net/minecraft/world/level/block/CarvedPumpkinBlock.java
@@ -64,7 +64,7 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
         if (blockPatternMatch != null) {
             SnowGolem snowGolem = EntityType.SNOW_GOLEM.create(level, EntitySpawnReason.TRIGGERED);
             if (snowGolem != null) {
-                spawnGolemInWorld(level, blockPatternMatch, snowGolem, blockPatternMatch.getBlock(0, 2, 0).getPos());
+                spawnGolemInWorld(level, blockPatternMatch, snowGolem, blockPatternMatch.getBlock(0, 2, 0).getPos(), this.placer); // Purpur - Summoner API
             }
         } else {
             BlockPattern.BlockPatternMatch blockPatternMatch1 = this.getOrCreateIronGolemFull().find(level, pos);
@@ -72,13 +72,23 @@ public class CarvedPumpkinBlock extends HorizontalDirectionalBlock {
                 IronGolem ironGolem = EntityType.IRON_GOLEM.create(level, EntitySpawnReason.TRIGGERED);
                 if (ironGolem != null) {
                     ironGolem.setPlayerCreated(true);
-                    spawnGolemInWorld(level, blockPatternMatch1, ironGolem, blockPatternMatch1.getBlock(1, 2, 0).getPos());
+                    spawnGolemInWorld(level, blockPatternMatch1, ironGolem, blockPatternMatch1.getBlock(1, 2, 0).getPos(), this.placer); // Purpur - Summoner API
                 }
             }
         }
     }
 
     private static void spawnGolemInWorld(Level level, BlockPattern.BlockPatternMatch patternMatch, Entity golem, BlockPos pos) {
+        // Purpur start - Summoner API
+        spawnGolemInWorld(level, patternMatch, golem, pos, null);
+    }
+    private static void spawnGolemInWorld(Level level, BlockPattern.BlockPatternMatch patternMatch, Entity golem, BlockPos pos, net.minecraft.world.entity.LivingEntity placer) {
+        if (golem instanceof SnowGolem snowGolem) {
+            snowGolem.setSummoner(placer == null ? null : placer.getUUID());
+        } else if (golem instanceof IronGolem ironGolem) {
+            ironGolem.setSummoner(placer == null ? null : placer.getUUID());
+        }
+        // Purpur end - Summoner API
         // clearPatternBlocks(level, patternMatch); // Paper - moved down
         golem.snapTo(pos.getX() + 0.5, pos.getY() + 0.05, pos.getZ() + 0.5, 0.0F, 0.0F);
         // Paper start
diff --git a/net/minecraft/world/level/block/CauldronBlock.java b/net/minecraft/world/level/block/CauldronBlock.java
index d58b49e550cfa683f753db2a913fddf307a1bba2..62ee64b97dfb2f1426d43cf1f8b0b0b6ec63b5b1 100644
--- a/net/minecraft/world/level/block/CauldronBlock.java
+++ b/net/minecraft/world/level/block/CauldronBlock.java
@@ -32,8 +32,8 @@ public class CauldronBlock extends AbstractCauldronBlock {
 
     protected static boolean shouldHandlePrecipitation(Level level, Biome.Precipitation precipitation) {
         return precipitation == Biome.Precipitation.RAIN
-            ? level.getRandom().nextFloat() < 0.05F
-            : precipitation == Biome.Precipitation.SNOW && level.getRandom().nextFloat() < 0.1F;
+            ? level.getRandom().nextFloat() < level.purpurConfig.cauldronRainChance // Purpur - Cauldron fill chances
+            : precipitation == Biome.Precipitation.SNOW && level.getRandom().nextFloat() < level.purpurConfig.cauldronPowderSnowChance; // Purpur - Cauldron fill chances
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/CaveVinesBlock.java b/net/minecraft/world/level/block/CaveVinesBlock.java
index 4e1a81c01a5c51a977e4fe9d2465e4ef20aab6d4..d67f278e8cb630b680cad22f4117a9545576bf0f 100644
--- a/net/minecraft/world/level/block/CaveVinesBlock.java
+++ b/net/minecraft/world/level/block/CaveVinesBlock.java
@@ -92,4 +92,11 @@ public class CaveVinesBlock extends GrowingPlantHeadBlock implements CaveVines {
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
         level.setBlock(pos, state.setValue(BERRIES, true), 2);
     }
+
+    // Purpur start - cave vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.caveVinesMaxGrowthAge;
+    }
+    // Purpur end - cave vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/ChangeOverTimeBlock.java b/net/minecraft/world/level/block/ChangeOverTimeBlock.java
index ba7dbfa3f95bf93f3e50b17aa48b772a3047b74d..d42062a86c1278b71bc085cc3fb29a69039873de 100644
--- a/net/minecraft/world/level/block/ChangeOverTimeBlock.java
+++ b/net/minecraft/world/level/block/ChangeOverTimeBlock.java
@@ -51,7 +51,7 @@ public interface ChangeOverTimeBlock<T extends Enum<T>> {
         }
 
         float f = (float)(i1 + 1) / (i1 + i + 1);
-        float f1 = f * f * this.getChanceModifier();
+        float f1 = level.purpurConfig.disableOxidationProximityPenalty ? this.getChanceModifier() :f * f * this.getChanceModifier();// Purpur - option to disable the copper oxidation proximity penalty
         return random.nextFloat() < f1 ? this.getNext(state) : Optional.empty();
     }
 }
diff --git a/net/minecraft/world/level/block/ChestBlock.java b/net/minecraft/world/level/block/ChestBlock.java
index c4937d1b482e2ec60961bda62ad6cc155f0ce8f7..43f9d4b8a7ab4cd0a1a5dee9d0c0c7790894a2ae 100644
--- a/net/minecraft/world/level/block/ChestBlock.java
+++ b/net/minecraft/world/level/block/ChestBlock.java
@@ -337,6 +337,7 @@ public class ChestBlock extends AbstractChestBlock<ChestBlockEntity> implements
     }
 
     public static boolean isBlockedChestByBlock(BlockGetter level, BlockPos pos) {
+        if (level instanceof Level level1 && level1.purpurConfig.chestOpenWithBlockOnTop) return false; // Purpur - Option for chests to open even with a solid block on top
         BlockPos blockPos = pos.above();
         return level.getBlockState(blockPos).isRedstoneConductor(level, blockPos);
     }
diff --git a/net/minecraft/world/level/block/ComposterBlock.java b/net/minecraft/world/level/block/ComposterBlock.java
index a647d76d365a60b95a3eb7927ac426bf70d417f3..3eb11df5d14ec63911be630ca99d8d9903723f9b 100644
--- a/net/minecraft/world/level/block/ComposterBlock.java
+++ b/net/minecraft/world/level/block/ComposterBlock.java
@@ -250,17 +250,27 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
     ) {
         int levelValue = state.getValue(LEVEL);
         if (levelValue < 8 && COMPOSTABLES.containsKey(stack.getItem())) {
-            if (levelValue < 7 && !level.isClientSide) {
-                BlockState blockState = addItem(player, state, level, pos, stack);
-                // Paper start - handle cancelled events
-                if (blockState == null) {
-                    return InteractionResult.PASS;
-                }
-                // Paper end
-                level.levelEvent(1500, pos, state != blockState ? 1 : 0);
-                player.awardStat(Stats.ITEM_USED.get(stack.getItem()));
-                stack.consume(1, player);
+            // Purpur start - sneak to bulk process composter
+            BlockState newState = process(levelValue, player, state, level, pos, stack);
+            if (newState == null) {
+                return InteractionResult.PASS;
+            }
+            if (level.purpurConfig.composterBulkProcess && player.isShiftKeyDown() && newState != state) {
+                BlockState oldState;
+                int oldCount, newCount, oldLevel, newLevel;
+                do {
+                    oldState = newState;
+                    oldCount = stack.getCount();
+                    oldLevel = oldState.getValue(ComposterBlock.LEVEL);
+                    newState = process(oldLevel, player, oldState, level, pos, stack);
+                    if (newState == null) {
+                        return InteractionResult.PASS;
+                    }
+                    newCount = stack.getCount();
+                    newLevel = newState.getValue(ComposterBlock.LEVEL);
+                } while (newCount > 0 && (newCount != oldCount || newLevel != oldLevel || newState != oldState));
             }
+            // Purpur end - Sneak to bulk process composter
 
             return InteractionResult.SUCCESS;
         } else {
@@ -268,6 +278,25 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
         }
     }
 
+    // Purpur start - sneak to bulk process composter
+    private static @Nullable BlockState process(int levelValue, Player player, BlockState state, Level level, BlockPos pos, ItemStack stack) {
+        if (levelValue < 7 && !level.isClientSide) {
+            BlockState iblockdata1 = ComposterBlock.addItem(player, state, level, pos, stack);
+            // Paper start - handle cancelled events
+            if (iblockdata1 == null) {
+                return null;
+            }
+            // Paper end
+
+            level.levelEvent(1500, pos, state != iblockdata1 ? 1 : 0);
+            player.awardStat(Stats.ITEM_USED.get(stack.getItem()));
+            stack.consume(1, player);
+            return iblockdata1;
+        }
+        return state;
+    }
+    // Purpur end - Sneak to bulk process composter
+
     @Override
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         int levelValue = state.getValue(LEVEL);
diff --git a/net/minecraft/world/level/block/CoralBlock.java b/net/minecraft/world/level/block/CoralBlock.java
index e0be02eaa07d40d0738931383426517d20fe3b0b..b747af5f3c65f4b79a304b0e903f7b824fb03d8d 100644
--- a/net/minecraft/world/level/block/CoralBlock.java
+++ b/net/minecraft/world/level/block/CoralBlock.java
@@ -65,6 +65,7 @@ public class CoralBlock extends Block {
     }
 
     protected boolean scanForWater(BlockGetter level, BlockPos pos) {
+        if (!((net.minecraft.world.level.LevelAccessor) level).getMinecraftWorld().purpurConfig.coralDieOutsideWater) return true; // Purpur - Config to not let coral die
         for (Direction direction : Direction.values()) {
             FluidState fluidState = level.getFluidState(pos.relative(direction));
             if (fluidState.is(FluidTags.WATER)) {
diff --git a/net/minecraft/world/level/block/CropBlock.java b/net/minecraft/world/level/block/CropBlock.java
index a38ce03a4dab6c83a0b54f47fd3c36d6da46fa24..d345235db5a8d5f1ebbeb5bbb5e7924cb1a75518 100644
--- a/net/minecraft/world/level/block/CropBlock.java
+++ b/net/minecraft/world/level/block/CropBlock.java
@@ -169,7 +169,7 @@ public class CropBlock extends VegetationBlock implements BonemealableBlock {
     @Override
     protected void entityInside(BlockState state, Level level, BlockPos pos, Entity entity, InsideBlockEffectApplier effectApplier) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(level, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
-        if (level instanceof ServerLevel serverLevel && entity instanceof Ravager && org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.AIR.defaultBlockState(), !serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING))) { // CraftBukkit
+        if (level instanceof ServerLevel serverLevel && entity instanceof Ravager && serverLevel.purpurConfig.ravagerGriefableBlocks.contains(serverLevel.getBlockState(pos).getBlock()) && org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.AIR.defaultBlockState(), !serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.ravagerMobGriefingOverride))) { // CraftBukkit // Purpur - Configurable ravager griefable blocks list // Purpur - Add mobGriefing override to everything affected
             serverLevel.destroyBlock(pos, true, entity);
         }
 
@@ -204,4 +204,15 @@ public class CropBlock extends VegetationBlock implements BonemealableBlock {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - Ability for hoe to replant crops
+    @Override
+    public void playerDestroy(Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, ItemStack itemInHand, boolean includeDrops, boolean dropExp) {
+        if (world.purpurConfig.hoeReplantsCrops && itemInHand.getItem() instanceof net.minecraft.world.item.HoeItem) {
+            super.playerDestroyAndReplant(world, player, pos, state, blockEntity, itemInHand, getBaseSeedId());
+        } else {
+            super.playerDestroy(world, player, pos, state, blockEntity, itemInHand, includeDrops, dropExp);
+        }
+    }
+    // Purpur end - Ability for hoe to replant crops
 }
diff --git a/net/minecraft/world/level/block/DoorBlock.java b/net/minecraft/world/level/block/DoorBlock.java
index 7f40ccfe379ab284424d730213b343e17239dc0c..2fa6a85b0f1694d0989905a421198c6495271beb 100644
--- a/net/minecraft/world/level/block/DoorBlock.java
+++ b/net/minecraft/world/level/block/DoorBlock.java
@@ -199,6 +199,7 @@ public class DoorBlock extends Block {
     protected InteractionResult useWithoutItem(BlockState state, Level level, BlockPos pos, Player player, BlockHitResult hitResult) {
         if (!this.type.canOpenByHand()) {
             return InteractionResult.PASS;
+        } else if (requiresRedstone(level, state, pos)) { return InteractionResult.CONSUME; // Purpur - Option to make doors require redstone
         } else {
             state = state.cycle(OPEN);
             level.setBlock(pos, state, 10);
@@ -287,4 +288,18 @@ public class DoorBlock extends Block {
     public static boolean isWoodenDoor(BlockState state) {
         return state.getBlock() instanceof DoorBlock doorBlock && doorBlock.type().canOpenByHand();
     }
+
+    // Purpur start - Option to make doors require redstone
+    public static boolean requiresRedstone(Level level, BlockState state, BlockPos pos) {
+        if (level.purpurConfig.doorRequiresRedstone.contains(state.getBlock())) {
+            // force update client
+            BlockPos otherPos = pos.relative(state.getValue(DoorBlock.HALF) == DoubleBlockHalf.LOWER ? Direction.UP : Direction.DOWN);
+            BlockState otherState = level.getBlockState(otherPos);
+            level.sendBlockUpdated(pos, state, state, 3);
+            level.sendBlockUpdated(otherPos, otherState, otherState, 3);
+            return true;
+        }
+        return false;
+    }
+    // Purpur end - Option to make doors require redstone
 }
diff --git a/net/minecraft/world/level/block/DragonEggBlock.java b/net/minecraft/world/level/block/DragonEggBlock.java
index 5c2f10486e3aed090c6545a86276e6927e424cb2..9ed7ffb10e0a172fe5f3dd4613922428af82e5db 100644
--- a/net/minecraft/world/level/block/DragonEggBlock.java
+++ b/net/minecraft/world/level/block/DragonEggBlock.java
@@ -46,6 +46,7 @@ public class DragonEggBlock extends FallingBlock {
     }
 
     private void teleport(BlockState state, Level level, BlockPos pos) {
+        if (!level.purpurConfig.dragonEggTeleport) return; // Purpur - Option to disable dragon egg teleporting
         WorldBorder worldBorder = level.getWorldBorder();
 
         for (int i = 0; i < 1000; i++) {
diff --git a/net/minecraft/world/level/block/EnchantingTableBlock.java b/net/minecraft/world/level/block/EnchantingTableBlock.java
index 523082c69aad8269cd058ad6864184c3ab51dbeb..4f4e81a845c4d3dc0e7d82ba323a8595581535e2 100644
--- a/net/minecraft/world/level/block/EnchantingTableBlock.java
+++ b/net/minecraft/world/level/block/EnchantingTableBlock.java
@@ -119,4 +119,16 @@ public class EnchantingTableBlock extends BaseEntityBlock {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return false;
     }
+
+    // Purpur start - Enchantment Table Persists Lapis
+    @Override
+    protected void affectNeighborsAfterRemoval(BlockState state, net.minecraft.server.level.ServerLevel level, BlockPos pos, boolean movedByPiston) {
+        BlockEntity blockEntity = level.getBlockEntity(pos);
+
+        if (level.purpurConfig.enchantmentTableLapisPersists && blockEntity instanceof EnchantingTableBlockEntity enchantmentTable) {
+            net.minecraft.world.Containers.dropItemStack(level, pos.getX(), pos.getY(), pos.getZ(), new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.LAPIS_LAZULI, enchantmentTable.getLapis()));
+            net.minecraft.world.Containers.updateNeighboursAfterDestroy(state, level, pos);
+        }
+    }
+    // Purpur end - Enchantment Table Persists Lapis
 }
diff --git a/net/minecraft/world/level/block/EndGatewayBlock.java b/net/minecraft/world/level/block/EndGatewayBlock.java
index f36dafbe1e816736e1c0aeb7cf830b120292a8f5..669f818e9a863a4016b95fbe0d69b8f3aee4c508 100644
--- a/net/minecraft/world/level/block/EndGatewayBlock.java
+++ b/net/minecraft/world/level/block/EndGatewayBlock.java
@@ -99,6 +99,13 @@ public class EndGatewayBlock extends BaseEntityBlock implements Portal {
             org.bukkit.event.entity.EntityPortalEnterEvent event = new org.bukkit.event.entity.EntityPortalEnterEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level), org.bukkit.PortalType.END_GATEWAY); // Paper - add portal type
             if (!event.callEvent()) return;
             // Paper end - call EntityPortalEnterEvent
+            // Purpur start - Add EntityTeleportHinderedEvent
+            if (level.purpurConfig.imposeTeleportRestrictionsOnGateways && (entity.isVehicle() || entity.isPassenger())) {
+                if (!new org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent(entity.getBukkitEntity(), entity.isPassenger() ? org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_PASSENGER : org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_VEHICLE, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_GATEWAY).callEvent()) {
+                    return;
+                }
+            }
+            // Purpur end - Add EntityTeleportHinderedEvent
             entity.setAsInsidePortal(this, pos);
             TheEndGatewayBlockEntity.triggerCooldown(level, pos, state, theEndGatewayBlockEntity);
         }
diff --git a/net/minecraft/world/level/block/EndPortalBlock.java b/net/minecraft/world/level/block/EndPortalBlock.java
index 6e495b2c4176d5a30ea911f8e44a22655df92ef6..de668bb399e4e8adb3bdc6d2b27390035202c6f0 100644
--- a/net/minecraft/world/level/block/EndPortalBlock.java
+++ b/net/minecraft/world/level/block/EndPortalBlock.java
@@ -60,6 +60,13 @@ public class EndPortalBlock extends BaseEntityBlock implements Portal {
     protected void entityInside(BlockState state, Level level, BlockPos pos, Entity entity, InsideBlockEffectApplier effectApplier) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(level, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
         if (entity.canUsePortal(false)) {
+            // Purpur start - Add EntityTeleportHinderedEvent
+            if (level.purpurConfig.imposeTeleportRestrictionsOnEndPortals && (entity.isVehicle() || entity.isPassenger())) {
+                if (!new org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent(entity.getBukkitEntity(), entity.isPassenger() ? org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_PASSENGER : org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_VEHICLE, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.END_PORTAL).callEvent()) {
+                    return;
+                }
+            }
+            // Purpur end - Add EntityTeleportHinderedEvent
             // CraftBukkit start - Entity in portal
             org.bukkit.event.entity.EntityPortalEnterEvent event = new org.bukkit.event.entity.EntityPortalEnterEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level), org.bukkit.PortalType.ENDER); // Paper - add portal type
             level.getCraftServer().getPluginManager().callEvent(event);
diff --git a/net/minecraft/world/level/block/EnderChestBlock.java b/net/minecraft/world/level/block/EnderChestBlock.java
index 5077a9ff7b78801bdc53536a37aee07b8d86ee4d..72794e204f7fcc31ece94913b7fd9f36ae022b10 100644
--- a/net/minecraft/world/level/block/EnderChestBlock.java
+++ b/net/minecraft/world/level/block/EnderChestBlock.java
@@ -85,8 +85,8 @@ public class EnderChestBlock extends AbstractChestBlock<EnderChestBlockEntity> i
                 enderChestInventory.setActiveChest(enderChestBlockEntity); // Needs to happen before ChestMenu.threeRows as it is required for opening animations
                 if (level instanceof ServerLevel serverLevel && player.openMenu(
                     new SimpleMenuProvider(
-                        (containerId, playerInventory, player1) -> ChestMenu.threeRows(containerId, playerInventory, enderChestInventory), CONTAINER_TITLE
-                    )
+                        (containerId, playerInventory, player1) -> org.purpurmc.purpur.PurpurConfig.enderChestSixRows ? getEnderChestSixRows(containerId, playerInventory, player, enderChestInventory) : ChestMenu.threeRows(containerId, playerInventory, enderChestInventory), CONTAINER_TITLE
+                    ) // Purpur - Barrels and enderchests 6 rows
                 ).isPresent()) {
                 // Paper end - Fix InventoryOpenEvent cancellation - moved up;
                     player.awardStat(Stats.OPEN_ENDERCHEST);
@@ -100,6 +100,35 @@ public class EnderChestBlock extends AbstractChestBlock<EnderChestBlockEntity> i
         }
     }
 
+    // Purpur start - Barrels and enderchests 6 rows
+    private ChestMenu getEnderChestSixRows(int syncId, net.minecraft.world.entity.player.Inventory inventory, Player player, PlayerEnderChestContainer playerEnderChestContainer) {
+        if (org.purpurmc.purpur.PurpurConfig.enderChestPermissionRows) {
+            org.bukkit.craftbukkit.entity.CraftHumanEntity bukkitPlayer = player.getBukkitEntity();
+            if (bukkitPlayer.hasPermission("purpur.enderchest.rows.six")) {
+                player.sixRowEnderchestSlotCount = 54;
+                return ChestMenu.sixRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.five")) {
+                player.sixRowEnderchestSlotCount = 45;
+                return ChestMenu.fiveRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.four")) {
+                player.sixRowEnderchestSlotCount = 36;
+                return ChestMenu.fourRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.three")) {
+                player.sixRowEnderchestSlotCount = 27;
+                return ChestMenu.threeRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.two")) {
+                player.sixRowEnderchestSlotCount = 18;
+                return ChestMenu.twoRows(syncId, inventory, playerEnderChestContainer);
+            } else if (bukkitPlayer.hasPermission("purpur.enderchest.rows.one")) {
+                player.sixRowEnderchestSlotCount = 9;
+                return ChestMenu.oneRow(syncId, inventory, playerEnderChestContainer);
+            }
+        }
+        player.sixRowEnderchestSlotCount = -1;
+        return ChestMenu.sixRows(syncId, inventory, playerEnderChestContainer);
+    }
+    // Purpur end - Barrels and enderchests 6 rows
+
     @Override
     public BlockEntity newBlockEntity(BlockPos pos, BlockState state) {
         return new EnderChestBlockEntity(pos, state);
diff --git a/net/minecraft/world/level/block/FarmBlock.java b/net/minecraft/world/level/block/FarmBlock.java
index c9c643f6313a051738ae3b27299c9c7bfb2d7195..f0c25221ca29fe136e67079b57f27eace56f0d65 100644
--- a/net/minecraft/world/level/block/FarmBlock.java
+++ b/net/minecraft/world/level/block/FarmBlock.java
@@ -112,9 +112,9 @@ public class FarmBlock extends Block {
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
         super.fallOn(level, state, pos, entity, fallDistance); // CraftBukkit - moved here as game rules / events shouldn't affect fall damage.
         if (level instanceof ServerLevel serverLevel
-            && level.random.nextFloat() < fallDistance - 0.5
+            && (serverLevel.purpurConfig.farmlandTrampleHeight >= 0D ? fallDistance >= serverLevel.purpurConfig.farmlandTrampleHeight : level.random.nextFloat() < fallDistance - 0.5) // Purpur - Configurable farmland trample height
             && entity instanceof LivingEntity
-            && (entity instanceof Player || serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING))
+            && (entity instanceof Player || serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.farmlandMobGriefingOverride)) // Purpur - Add mobGriefing override to everything affected
             && entity.getBbWidth() * entity.getBbWidth() * entity.getBbHeight() > 0.512F) {
                 // CraftBukkit start - Interact soil
                 org.bukkit.event.Cancellable cancellable;
@@ -129,6 +129,28 @@ public class FarmBlock extends Block {
                     return;
                 }
 
+                if (level.purpurConfig.farmlandTramplingDisabled) return; // Purpur - Farmland trampling changes
+                if (level.purpurConfig.farmlandTramplingOnlyPlayers && !(entity instanceof Player)) return; // Purpur - Farmland trampling changes
+
+                // Purpur start - Ability to re-add farmland mechanics from Alpha
+                if (level.purpurConfig.farmlandAlpha) {
+                    Block block = level.getBlockState(pos.below()).getBlock();
+                    if (block instanceof FenceBlock || block instanceof WallBlock) {
+                        return;
+                    }
+                }
+                // Purpur end - Ability to re-add farmland mechanics from Alpha
+
+                // Purpur start - Farmland trampling changes
+                if (level.purpurConfig.farmlandTramplingFeatherFalling) {
+                    net.minecraft.world.item.ItemStack bootsItem = ((net.minecraft.world.entity.LivingEntity) entity).getItemBySlot(net.minecraft.world.entity.EquipmentSlot.FEET);
+
+                    if (bootsItem != net.minecraft.world.item.ItemStack.EMPTY && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.FEATHER_FALLING, bootsItem) >= (int) entity.fallDistance) {
+                        return;
+                    }
+                }
+                // Purpur end - Farmland trampling changes
+
                 if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity, pos, Blocks.DIRT.defaultBlockState())) {
                     return;
                 }
@@ -177,7 +199,7 @@ public class FarmBlock extends Block {
             }
         }
 
-        return false;
+        return ((ServerLevel) level).purpurConfig.farmlandGetsMoistFromBelow && level.getFluidState(pos.relative(Direction.DOWN)).is(FluidTags.WATER); // Purpur - Allow soil to moisten from water directly under it
         // Paper end - Perf: remove abstract block iteration
     }
 
diff --git a/net/minecraft/world/level/block/GrowingPlantHeadBlock.java b/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
index fe11f3ec82ebdbdf3d024d7273fb16b6823b1ece..daaf0ddee9192fa24a70954ce52b381560fcbc1f 100644
--- a/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
+++ b/net/minecraft/world/level/block/GrowingPlantHeadBlock.java
@@ -34,12 +34,12 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
 
     @Override
     public BlockState getStateForPlacement(RandomSource random) {
-        return this.defaultBlockState().setValue(AGE, random.nextInt(25));
+        return this.defaultBlockState().setValue(AGE, getMaxGrowthAge() == 0 ? 0 : random.nextInt(getMaxGrowthAge())); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     @Override
     protected boolean isRandomlyTicking(BlockState state) {
-        return state.getValue(AGE) < 25;
+        return state.getValue(AGE) < getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     @Override
@@ -55,7 +55,7 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
         } else if (this == Blocks.CAVE_VINES) {
             modifier = level.spigotConfig.caveVinesModifier;
         }
-        if (state.getValue(AGE) < 25 && random.nextDouble() < ((modifier / 100.0D) * this.growPerTickProbability)) { // Spigot - SPIGOT-7159: Better modifier resolution
+        if (state.getValue(AGE) < getMaxGrowthAge() && random.nextDouble() < ((modifier / 100.0D) * this.growPerTickProbability)) { // Spigot - SPIGOT-7159: Better modifier resolution // Purpur - kelp, cave, weeping, and twisting configurable max growth age
             // Spigot end
             BlockPos blockPos = pos.relative(this.growthDirection);
             if (this.canGrowInto(level.getBlockState(blockPos))) {
@@ -75,11 +75,11 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     }
 
     public BlockState getMaxAgeState(BlockState state) {
-        return state.setValue(AGE, 25);
+        return state.setValue(AGE, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     public boolean isMaxAge(BlockState state) {
-        return state.getValue(AGE) == 25;
+        return state.getValue(AGE) >= getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
     }
 
     protected BlockState updateBodyAfterConvertedFromHead(BlockState head, BlockState body) {
@@ -137,13 +137,13 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     @Override
     public void performBonemeal(ServerLevel level, RandomSource random, BlockPos pos, BlockState state) {
         BlockPos blockPos = pos.relative(this.growthDirection);
-        int min = Math.min(state.getValue(AGE) + 1, 25);
+        int min = Math.min(state.getValue(AGE) + 1, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
         int blocksToGrowWhenBonemealed = this.getBlocksToGrowWhenBonemealed(random);
 
         for (int i = 0; i < blocksToGrowWhenBonemealed && this.canGrowInto(level.getBlockState(blockPos)); i++) {
             level.setBlockAndUpdate(blockPos, state.setValue(AGE, min));
             blockPos = blockPos.relative(this.growthDirection);
-            min = Math.min(min + 1, 25);
+            min = Math.min(min + 1, getMaxGrowthAge()); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
         }
     }
 
@@ -155,4 +155,6 @@ public abstract class GrowingPlantHeadBlock extends GrowingPlantBlock implements
     protected GrowingPlantHeadBlock getHeadBlock() {
         return this;
     }
+
+    public abstract int getMaxGrowthAge(); // Purpur - kelp, cave, weeping, and twisting configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/HayBlock.java b/net/minecraft/world/level/block/HayBlock.java
index cdde0a25e0a499d7575c00796143a033feb1f22f..999ecf16180b0a862cf8527ce532acf725ba869a 100644
--- a/net/minecraft/world/level/block/HayBlock.java
+++ b/net/minecraft/world/level/block/HayBlock.java
@@ -23,6 +23,6 @@ public class HayBlock extends RotatedPillarBlock {
 
     @Override
     public void fallOn(Level level, BlockState state, BlockPos pos, Entity entity, double fallDistance) {
-        entity.causeFallDamage(fallDistance, 0.2F, level.damageSources().fall());
+        super.fallOn(level, state, pos, entity, fallDistance); // Purpur - Configurable block fall damage modifiers
     }
 }
diff --git a/net/minecraft/world/level/block/IceBlock.java b/net/minecraft/world/level/block/IceBlock.java
index be7141a4009036bcf3f92bba5d0ad74459e99bfa..a4d735a4365fdaf9e602315aa1176dfd5db77ff5 100644
--- a/net/minecraft/world/level/block/IceBlock.java
+++ b/net/minecraft/world/level/block/IceBlock.java
@@ -40,7 +40,7 @@ public class IceBlock extends HalfTransparentBlock {
     public void afterDestroy(Level level, BlockPos pos, ItemStack stack) {
         // Paper end - Improve Block#breakNaturally API
         if (!EnchantmentHelper.hasTag(stack, EnchantmentTags.PREVENTS_ICE_MELTING)) {
-            if (level.dimensionType().ultraWarm()) {
+            if (level.isNether() || (level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd)) { // Purpur - Add allow water in end world option
                 level.removeBlock(pos, false);
                 return;
             }
@@ -65,7 +65,7 @@ public class IceBlock extends HalfTransparentBlock {
             return;
         }
         // CraftBukkit end
-        if (level.dimensionType().ultraWarm()) {
+        if (level.isNether() || (level.isTheEnd() && !org.purpurmc.purpur.PurpurConfig.allowWaterPlacementInTheEnd)) { // Purpur - Add allow water in end world option
             level.removeBlock(pos, false);
         } else {
             level.setBlockAndUpdate(pos, meltsInto());
diff --git a/net/minecraft/world/level/block/KelpBlock.java b/net/minecraft/world/level/block/KelpBlock.java
index 8e3f2518e705a4b8988a1c9da730f0c89f21bdce..6e6212fd891dcaea0d0a398a73416f31d2cb2406 100644
--- a/net/minecraft/world/level/block/KelpBlock.java
+++ b/net/minecraft/world/level/block/KelpBlock.java
@@ -72,4 +72,11 @@ public class KelpBlock extends GrowingPlantHeadBlock implements LiquidBlockConta
     protected FluidState getFluidState(BlockState state) {
         return Fluids.WATER.getSource(false);
     }
+
+    // Purpur start - kelp vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.kelpMaxGrowthAge;
+    }
+    // Purpur end - kelp vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/LiquidBlock.java b/net/minecraft/world/level/block/LiquidBlock.java
index 7320b416e8d660419018b0699f49ab6f45a3373b..ae609e0603a78423c4c89b7efb9c41ab8fe7aa52 100644
--- a/net/minecraft/world/level/block/LiquidBlock.java
+++ b/net/minecraft/world/level/block/LiquidBlock.java
@@ -134,7 +134,7 @@ public class LiquidBlock extends Block implements BucketPickup {
 
     @Override
     protected void onPlace(BlockState state, Level level, BlockPos pos, BlockState oldState, boolean isMoving) {
-        if (this.shouldSpreadLiquid(level, pos, state)) {
+        if (level.purpurConfig.tickFluids && this.shouldSpreadLiquid(level, pos, state)) { // Purpur - Tick fluids config
             level.scheduleTick(pos, state.getFluidState().getType(), this.getFlowSpeed(level, pos)); // Paper - Configurable speed for water flowing over lava
         }
     }
@@ -169,7 +169,7 @@ public class LiquidBlock extends Block implements BucketPickup {
         BlockState neighborState,
         RandomSource random
     ) {
-        if (state.getFluidState().isSource() || neighborState.getFluidState().isSource()) {
+        if (level.getWorldBorder().world.purpurConfig.tickFluids && state.getFluidState().isSource() || neighborState.getFluidState().isSource()) { // Purpur - Tick fluids config
             scheduledTickAccess.scheduleTick(pos, state.getFluidState().getType(), this.fluid.getTickDelay(level));
         }
 
@@ -178,7 +178,7 @@ public class LiquidBlock extends Block implements BucketPickup {
 
     @Override
     protected void neighborChanged(BlockState state, Level level, BlockPos pos, Block neighborBlock, @Nullable Orientation orientation, boolean movedByPiston) {
-        if (this.shouldSpreadLiquid(level, pos, state)) {
+        if (level.purpurConfig.tickFluids && this.shouldSpreadLiquid(level, pos, state)) { // Purpur - Tick fluids config
             level.scheduleTick(pos, state.getFluidState().getType(), this.getFlowSpeed(level, pos)); // Paper - Configurable speed for water flowing over lava
         }
     }
diff --git a/net/minecraft/world/level/block/MagmaBlock.java b/net/minecraft/world/level/block/MagmaBlock.java
index db83c3630064a6875b477021a1f78bdf59c4ddc3..bbf8447cf986015f8a2e55f39d7b4f0dd9abcb23 100644
--- a/net/minecraft/world/level/block/MagmaBlock.java
+++ b/net/minecraft/world/level/block/MagmaBlock.java
@@ -28,7 +28,7 @@ public class MagmaBlock extends Block {
 
     @Override
     public void stepOn(Level level, BlockPos pos, BlockState state, Entity entity) {
-        if (!entity.isSteppingCarefully() && entity instanceof LivingEntity) {
+        if ((!entity.isSteppingCarefully() || level.purpurConfig.magmaBlockDamageWhenSneaking) && entity instanceof LivingEntity) { // Purpur - Configurable damage settings for magma blocks
             entity.hurt(level.damageSources().hotFloor().eventBlockDamager(level, pos), 1.0F); // CraftBukkit
         }
 
diff --git a/net/minecraft/world/level/block/NetherPortalBlock.java b/net/minecraft/world/level/block/NetherPortalBlock.java
index d0b09c4588bf8ba4aac93d2895a585ef63360148..35b6fb202edb457acc78c14b9f41d378e8dbb8a4 100644
--- a/net/minecraft/world/level/block/NetherPortalBlock.java
+++ b/net/minecraft/world/level/block/NetherPortalBlock.java
@@ -67,7 +67,7 @@ public class NetherPortalBlock extends Block implements Portal {
     protected void randomTick(BlockState state, ServerLevel level, BlockPos pos, RandomSource random) {
         if (level.spigotConfig.enableZombiePigmenPortalSpawns && level.dimensionType().natural() // Spigot
             && level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING)
-            && random.nextInt(2000) < level.getDifficulty().getId()
+            && random.nextInt(level.purpurConfig.piglinPortalSpawnModifier) < level.getDifficulty().getId() // Purpur - Piglin portal spawn modifier
             && level.anyPlayerCloseEnoughForSpawning(pos)) {
             while (level.getBlockState(pos).is(this)) {
                 pos = pos.below();
@@ -113,6 +113,13 @@ public class NetherPortalBlock extends Block implements Portal {
     protected void entityInside(BlockState state, Level level, BlockPos pos, Entity entity, InsideBlockEffectApplier effectApplier) {
         if (!new io.papermc.paper.event.entity.EntityInsideBlockEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.block.CraftBlock.at(level, pos)).callEvent()) { return; } // Paper - Add EntityInsideBlockEvent
         if (entity.canUsePortal(false)) {
+            // Purpur start - Add EntityTeleportHinderedEvent
+            if (level.purpurConfig.imposeTeleportRestrictionsOnNetherPortals && (entity.isVehicle() || entity.isPassenger())) {
+                if (!new org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent(entity.getBukkitEntity(), entity.isPassenger() ? org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_PASSENGER : org.purpurmc.purpur.event.entity.EntityTeleportHinderedEvent.Reason.IS_VEHICLE, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.NETHER_PORTAL).callEvent()) {
+                    return;
+                }
+            }
+            // Purpur end - Add EntityTeleportHinderedEvent
             // CraftBukkit start - Entity in portal
             org.bukkit.event.entity.EntityPortalEnterEvent event = new org.bukkit.event.entity.EntityPortalEnterEvent(entity.getBukkitEntity(), org.bukkit.craftbukkit.util.CraftLocation.toBukkit(pos, level), org.bukkit.PortalType.NETHER); // Paper - add portal type
             level.getCraftServer().getPluginManager().callEvent(event);
@@ -125,7 +132,7 @@ public class NetherPortalBlock extends Block implements Portal {
     @Override
     public int getPortalTransitionTime(ServerLevel level, Entity entity) {
         return entity instanceof Player player
-            ? Math.max(
+            ? player.canPortalInstant ? 1 : Math.max( // Purpur - Add portal permission bypass
                 0,
                 level.getGameRules()
                     .getInt(
diff --git a/net/minecraft/world/level/block/NetherWartBlock.java b/net/minecraft/world/level/block/NetherWartBlock.java
index a8cb58de6223006150bc49b95e5964b8fc42cecc..d25e2a37abb5e4c98116048fe2e96194149763ca 100644
--- a/net/minecraft/world/level/block/NetherWartBlock.java
+++ b/net/minecraft/world/level/block/NetherWartBlock.java
@@ -16,7 +16,7 @@ import net.minecraft.world.level.block.state.properties.IntegerProperty;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class NetherWartBlock extends VegetationBlock {
+public class NetherWartBlock extends VegetationBlock implements BonemealableBlock { // Purpur - bonemealable netherwart
     public static final MapCodec<NetherWartBlock> CODEC = simpleCodec(NetherWartBlock::new);
     public static final int MAX_AGE = 3;
     public static final IntegerProperty AGE = BlockStateProperties.AGE_3;
@@ -65,4 +65,34 @@ public class NetherWartBlock extends VegetationBlock {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - Ability for hoe to replant nether warts
+    @Override
+    public void playerDestroy(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, ItemStack itemInHand, boolean includeDrops, boolean dropExp) {
+        if (world.purpurConfig.hoeReplantsNetherWarts && itemInHand.getItem() instanceof net.minecraft.world.item.HoeItem) {
+            super.playerDestroyAndReplant(world, player, pos, state, blockEntity, itemInHand, Items.NETHER_WART);
+        } else {
+            super.playerDestroy(world, player, pos, state, blockEntity, itemInHand, includeDrops, dropExp);
+        }
+    }
+    // Purpur end - Ability for hoe to replant nether warts
+
+    // Purpur start - bonemealable netherwart
+    @Override
+    public boolean isValidBonemealTarget(final net.minecraft.world.level.LevelReader world, final BlockPos pos, final BlockState state) {
+        return ((net.minecraft.world.level.Level) world).purpurConfig.netherWartAffectedByBonemeal && state.getValue(NetherWartBlock.AGE) < 3;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(net.minecraft.world.level.Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int i = Math.min(3, state.getValue(NetherWartBlock.AGE) + 1);
+        state = state.setValue(NetherWartBlock.AGE, i);
+        org.bukkit.craftbukkit.event.CraftEventFactory.handleBlockGrowEvent(world, pos, state, 2); // CraftBukkit
+    }
+    // Purpur end - bonemealable netherwart
 }
diff --git a/net/minecraft/world/level/block/NoteBlock.java b/net/minecraft/world/level/block/NoteBlock.java
index 9467d5226797f67565edf8a46fd5b48135337410..7560d49b1952dba22e88758b15a24540ca576bbb 100644
--- a/net/minecraft/world/level/block/NoteBlock.java
+++ b/net/minecraft/world/level/block/NoteBlock.java
@@ -101,7 +101,7 @@ public class NoteBlock extends Block {
     }
 
     private void playNote(@Nullable Entity entity, BlockState state, Level level, BlockPos pos) {
-        if (state.getValue(INSTRUMENT).worksAboveNoteBlock() || level.getBlockState(pos.above()).isAir()) {
+        if (level.purpurConfig.noteBlockIgnoreAbove || state.getValue(INSTRUMENT).worksAboveNoteBlock() || level.getBlockState(pos.above()).isAir()) { // Purpur - Config to allow Note Block sounds when blocked
             level.blockEvent(pos, this, 0, 0);
             level.gameEvent(entity, GameEvent.NOTE_BLOCK_PLAY, pos);
         }
diff --git a/net/minecraft/world/level/block/ObserverBlock.java b/net/minecraft/world/level/block/ObserverBlock.java
index bd2aa00ce8b78c16f6107064dd00bfbb072df0df..9fa1ed439ef9adba44f3d4738688a95fb4625b68 100644
--- a/net/minecraft/world/level/block/ObserverBlock.java
+++ b/net/minecraft/world/level/block/ObserverBlock.java
@@ -81,6 +81,7 @@ public class ObserverBlock extends DirectionalBlock {
         RandomSource random
     ) {
         if (state.getValue(FACING) == direction && !state.getValue(POWERED)) {
+            if (!level.getWorldBorder().world.purpurConfig.disableObserverClocks || !(neighborState.getBlock() instanceof ObserverBlock) || neighborState.getValue(ObserverBlock.FACING).getOpposite() != direction) // Purpur - Add Option for disable observer clocks
             this.startSignal(level, scheduledTickAccess, pos);
         }
 
diff --git a/net/minecraft/world/level/block/PointedDripstoneBlock.java b/net/minecraft/world/level/block/PointedDripstoneBlock.java
index ef164fb4f24412e506b8abce74d509e8be6c4676..85e9aecc2045e1599488d6a137f5f9713fb1a245 100644
--- a/net/minecraft/world/level/block/PointedDripstoneBlock.java
+++ b/net/minecraft/world/level/block/PointedDripstoneBlock.java
@@ -193,20 +193,20 @@ public class PointedDripstoneBlock extends Block implements Fallable, SimpleWate
 
     @VisibleForTesting
     public static void maybeTransferFluid(BlockState state, ServerLevel level, BlockPos pos, float randChance) {
-        if (!(randChance > 0.17578125F) || !(randChance > 0.05859375F)) {
+        if (!(randChance > level.purpurConfig.cauldronDripstoneWaterFillChance) || !(randChance > level.purpurConfig.cauldronDripstoneLavaFillChance)) { // Purpur - Cauldron fill chances
             if (isStalactiteStartPos(state, level, pos)) {
                 Optional<PointedDripstoneBlock.FluidInfo> fluidAboveStalactite = getFluidAboveStalactite(level, pos, state);
                 if (!fluidAboveStalactite.isEmpty()) {
                     Fluid fluid = fluidAboveStalactite.get().fluid;
                     float f;
                     if (fluid == Fluids.WATER) {
-                        f = 0.17578125F;
+                        f = level.purpurConfig.cauldronDripstoneWaterFillChance; // Purpur - Cauldron fill chances
                     } else {
                         if (fluid != Fluids.LAVA) {
                             return;
                         }
 
-                        f = 0.05859375F;
+                        f = level.purpurConfig.cauldronDripstoneLavaFillChance; // Purpur - Cauldron fill chances
                     }
 
                     if (!(randChance >= f)) {
diff --git a/net/minecraft/world/level/block/PowderSnowBlock.java b/net/minecraft/world/level/block/PowderSnowBlock.java
index 248ac9bc820a96fc7653471308b18834fc735a77..ef70ba88e492904c426c7d35df442fa6f8d68844 100644
--- a/net/minecraft/world/level/block/PowderSnowBlock.java
+++ b/net/minecraft/world/level/block/PowderSnowBlock.java
@@ -89,7 +89,7 @@ public class PowderSnowBlock extends Block implements BucketPickup {
                         // CraftBukkit - move down
                     && entity1.mayInteract(serverLevel, blockPos)) {
                     // CraftBukkit start
-                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity1, pos, Blocks.AIR.defaultBlockState(), !(serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING) || entity1 instanceof Player))) {
+                    if (!org.bukkit.craftbukkit.event.CraftEventFactory.callEntityChangeBlockEvent(entity1, pos, Blocks.AIR.defaultBlockState(), !(serverLevel.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, serverLevel.purpurConfig.powderSnowMobGriefingOverride) || entity1 instanceof Player))) { // Purpur - Add mobGriefing override to everything affected
                         return;
                     }
                     // CraftBukkit end
diff --git a/net/minecraft/world/level/block/PoweredRailBlock.java b/net/minecraft/world/level/block/PoweredRailBlock.java
index abc39a31b29ed4f68398851de7a1209fef895769..a4df7f413cd0519f4b9885ba6c8a799e6a03d751 100644
--- a/net/minecraft/world/level/block/PoweredRailBlock.java
+++ b/net/minecraft/world/level/block/PoweredRailBlock.java
@@ -28,7 +28,7 @@ public class PoweredRailBlock extends BaseRailBlock {
     }
 
     protected boolean findPoweredRailSignal(Level level, BlockPos pos, BlockState state, boolean searchForward, int recursionCount) {
-        if (recursionCount >= 8) {
+        if (recursionCount >= level.purpurConfig.railActivationRange) { // Purpur - Config for powered rail activation distance
             return false;
         } else {
             int x = pos.getX();
diff --git a/net/minecraft/world/level/block/RespawnAnchorBlock.java b/net/minecraft/world/level/block/RespawnAnchorBlock.java
index 5b9d67d671ea70d4a8920a7f190d240c920971ac..f0b4ea2065f98f5430bba89f1a86ea5e8791aa1f 100644
--- a/net/minecraft/world/level/block/RespawnAnchorBlock.java
+++ b/net/minecraft/world/level/block/RespawnAnchorBlock.java
@@ -160,7 +160,7 @@ public class RespawnAnchorBlock extends Block {
         };
         Vec3 center = pos2.getCenter();
         level.explode(
-            null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), explosionDamageCalculator, center, 5.0F, true, Level.ExplosionInteraction.BLOCK // CraftBukkit - add state
+            null, level.damageSources().badRespawnPointExplosion(center).causingBlockSnapshot(blockState), explosionDamageCalculator, center, (float) level.purpurConfig.respawnAnchorExplosionPower, level.purpurConfig.respawnAnchorExplosionFire, level.purpurConfig.respawnAnchorExplosionEffect // CraftBukkit - add state // Purpur - Implement respawn anchor explosion options
         );
     }
 
diff --git a/net/minecraft/world/level/block/SculkShriekerBlock.java b/net/minecraft/world/level/block/SculkShriekerBlock.java
index 757f8453e147875ab9f14d9726bb734ef27447c9..f8c9a6d7c9f1a9d2afd820244017a709db79e080 100644
--- a/net/minecraft/world/level/block/SculkShriekerBlock.java
+++ b/net/minecraft/world/level/block/SculkShriekerBlock.java
@@ -118,7 +118,7 @@ public class SculkShriekerBlock extends BaseEntityBlock implements SimpleWaterlo
     @Nullable
     @Override
     public BlockState getStateForPlacement(BlockPlaceContext context) {
-        return this.defaultBlockState().setValue(WATERLOGGED, context.getLevel().getFluidState(context.getClickedPos()).getType() == Fluids.WATER);
+        return this.defaultBlockState().setValue(WATERLOGGED, context.getLevel().getFluidState(context.getClickedPos()).getType() == Fluids.WATER).setValue(SculkShriekerBlock.CAN_SUMMON, context.getLevel().purpurConfig.sculkShriekerCanSummonDefault); // Purpur - Config for sculk shrieker can_summon state
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/SlabBlock.java b/net/minecraft/world/level/block/SlabBlock.java
index a71d72147db9766fa16bdb6254d8eb6f2f7dba7b..66b9862563932faf0044810bde7bd3fb522c109b 100644
--- a/net/minecraft/world/level/block/SlabBlock.java
+++ b/net/minecraft/world/level/block/SlabBlock.java
@@ -144,4 +144,25 @@ public class SlabBlock extends Block implements SimpleWaterloggedBlock {
                 return false;
         }
     }
+
+    // Purpur start - Break individual slabs when sneaking
+    public boolean halfBreak(BlockState state, BlockPos pos, net.minecraft.server.level.ServerPlayer player) {
+        if (state.getValue(SlabBlock.TYPE) != SlabType.DOUBLE) {
+            return false;
+        }
+        net.minecraft.world.phys.HitResult result = player.getRayTrace(16, net.minecraft.world.level.ClipContext.Fluid.NONE);
+        if (result.getType() != net.minecraft.world.phys.HitResult.Type.BLOCK) {
+            return false;
+        }
+        double hitY = result.getLocation().y();
+        int blockY = org.bukkit.util.NumberConversions.floor(hitY);
+        player.level().setBlock(pos, state.setValue(SlabBlock.TYPE, (hitY - blockY > 0.5 || blockY - pos.getY() == 1) ? SlabType.BOTTOM : SlabType.TOP), 3);
+        if (!player.getAbilities().instabuild) {
+            net.minecraft.world.entity.item.ItemEntity item = new net.minecraft.world.entity.item.ItemEntity(player.level(), pos.getX(), pos.getY(), pos.getZ(), new ItemStack(asItem()));
+            item.setDefaultPickUpDelay();
+            player.level().addFreshEntity(item);
+        }
+        return true;
+    }
+    // Purpur end - Break individual slabs when sneaking
 }
diff --git a/net/minecraft/world/level/block/SnowLayerBlock.java b/net/minecraft/world/level/block/SnowLayerBlock.java
index 9131098e3ae4e6ffdf1491eb62537e385f75b6b2..ddedc08a96e500a390421d39be36590f37f49d24 100644
--- a/net/minecraft/world/level/block/SnowLayerBlock.java
+++ b/net/minecraft/world/level/block/SnowLayerBlock.java
@@ -76,6 +76,7 @@ public class SnowLayerBlock extends Block {
     @Override
     protected boolean canSurvive(BlockState state, LevelReader level, BlockPos pos) {
         BlockState blockState = level.getBlockState(pos.below());
+        if (blockState.is(Blocks.BLUE_ICE) && !level.getWorldBorder().world.purpurConfig.snowOnBlueIce) return false; // Purpur - Add config for snow on blue ice
         return !blockState.is(BlockTags.SNOW_LAYER_CANNOT_SURVIVE_ON)
             && (
                 blockState.is(BlockTags.SNOW_LAYER_CAN_SURVIVE_ON)
diff --git a/net/minecraft/world/level/block/SpawnerBlock.java b/net/minecraft/world/level/block/SpawnerBlock.java
index e8d7b6adbcb84e8d89067b54318e0feb3c3276a6..dc2846e26e778b2885fd9c558081c7677d48169a 100644
--- a/net/minecraft/world/level/block/SpawnerBlock.java
+++ b/net/minecraft/world/level/block/SpawnerBlock.java
@@ -14,6 +14,7 @@ import net.minecraft.world.level.block.state.BlockBehaviour;
 import net.minecraft.world.level.block.state.BlockState;
 
 public class SpawnerBlock extends BaseEntityBlock {
+    private static final org.slf4j.Logger LOGGER = com.mojang.logging.LogUtils.getLogger();
     public static final MapCodec<SpawnerBlock> CODEC = simpleCodec(SpawnerBlock::new);
 
     @Override
@@ -38,6 +39,62 @@ public class SpawnerBlock extends BaseEntityBlock {
         );
     }
 
+    // Purpur start - Silk touch spawners
+    @Override
+    public void playerDestroy(Level level, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @Nullable BlockEntity blockEntity, ItemStack stack, boolean includeDrops, boolean dropExp) {
+        if (level.purpurConfig.silkTouchEnabled && player.getBukkitEntity().hasPermission("purpur.drop.spawners") && isSilkTouch(level, stack)) {
+            ItemStack item = new ItemStack(Blocks.SPAWNER.asItem());
+
+            net.minecraft.world.level.SpawnData nextSpawnData = blockEntity instanceof SpawnerBlockEntity spawnerBlock ? spawnerBlock.getSpawner().nextSpawnData : null;
+            java.util.Optional<net.minecraft.world.entity.EntityType<?>> type = java.util.Optional.empty();
+            if (nextSpawnData != null) {
+                try (net.minecraft.util.ProblemReporter.ScopedCollector scopedCollector = new net.minecraft.util.ProblemReporter.ScopedCollector(blockEntity.problemPath(), LOGGER)) {
+                    net.minecraft.world.level.storage.ValueInput valueInput = net.minecraft.world.level.storage.TagValueInput.create(scopedCollector, player.level().registryAccess(), nextSpawnData.entityToSpawn());
+                    type = net.minecraft.world.entity.EntityType.by(valueInput);
+                }
+                net.minecraft.nbt.CompoundTag spawnDataTag = new net.minecraft.nbt.CompoundTag();
+                spawnDataTag.storeNullable("SpawnData", net.minecraft.world.level.SpawnData.CODEC, nextSpawnData);
+                item.set(net.minecraft.core.component.DataComponents.CUSTOM_DATA, net.minecraft.world.item.component.CustomData.EMPTY.update(compoundTag -> compoundTag.put("Purpur.SpawnData", spawnDataTag)));
+            }
+
+            if (type.isPresent()) {
+                final net.kyori.adventure.text.Component mobName = io.papermc.paper.adventure.PaperAdventure.asAdventure(type.get().getDescription());
+
+                String name = level.purpurConfig.silkTouchSpawnerName;
+                if (name != null && !name.isEmpty() && !name.equals("Monster Spawner")) {
+                    net.kyori.adventure.text.Component displayName = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(name, net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("mob", mobName));
+                    if (name.startsWith("<reset>")) {
+                        displayName = displayName.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                    }
+                    item.set(net.minecraft.core.component.DataComponents.CUSTOM_NAME, io.papermc.paper.adventure.PaperAdventure.asVanilla(displayName));
+                }
+
+                java.util.List<String> lore = level.purpurConfig.silkTouchSpawnerLore;
+                if (lore != null && !lore.isEmpty()) {
+
+                    java.util.List<net.minecraft.network.chat.Component> loreComponentList = new java.util.ArrayList<>();
+                    for (String line : lore) {
+                        net.kyori.adventure.text.Component lineComponent = net.kyori.adventure.text.minimessage.MiniMessage.miniMessage().deserialize(line, net.kyori.adventure.text.minimessage.tag.resolver.Placeholder.component("mob", mobName));
+                        if (line.startsWith("<reset>")) {
+                            lineComponent = lineComponent.decoration(net.kyori.adventure.text.format.TextDecoration.ITALIC, false);
+                        }
+                        loreComponentList.add(io.papermc.paper.adventure.PaperAdventure.asVanilla(lineComponent));
+                    }
+
+                    item.set(net.minecraft.core.component.DataComponents.LORE, new net.minecraft.world.item.component.ItemLore(loreComponentList, loreComponentList));
+                }
+                item.set(net.minecraft.core.component.DataComponents.TOOLTIP_DISPLAY, net.minecraft.world.item.component.TooltipDisplay.DEFAULT.withHidden(net.minecraft.core.component.DataComponents.BLOCK_ENTITY_DATA, true));
+            }
+            popResource(level, pos, item);
+        }
+        super.playerDestroy(level, player, pos, state, blockEntity, stack, includeDrops, dropExp);
+    }
+
+    private boolean isSilkTouch(Level level, ItemStack stack) {
+        return stack != null && level.purpurConfig.silkTouchTools.contains(stack.getItem()) && net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.SILK_TOUCH, stack) >= level.purpurConfig.minimumSilkTouchSpawnerRequire;
+    }
+    // Purpur end - Silk touch spawners
+
     @Override
     protected void spawnAfterBreak(BlockState state, ServerLevel level, BlockPos pos, ItemStack stack, boolean dropExperience) {
         super.spawnAfterBreak(state, level, pos, stack, dropExperience);
@@ -46,6 +103,7 @@ public class SpawnerBlock extends BaseEntityBlock {
 
     @Override
     public int getExpDrop(BlockState state, ServerLevel level, BlockPos pos, ItemStack stack, boolean dropExperience) {
+        if (level.purpurConfig.silkTouchEnabled && isSilkTouch(level, stack)) return 0; // Purpur - Silk touch spawners
         if (dropExperience) {
             int i = 15 + level.random.nextInt(15) + level.random.nextInt(15);
             // this.popExperience(level, pos, i);
diff --git a/net/minecraft/world/level/block/SpongeBlock.java b/net/minecraft/world/level/block/SpongeBlock.java
index 6764a77998e23de08eaf3a82a0cc0006868e1c3e..f7b6c0029e8d35ebf0fad380b8bc3b1530e2f8f1 100644
--- a/net/minecraft/world/level/block/SpongeBlock.java
+++ b/net/minecraft/world/level/block/SpongeBlock.java
@@ -53,8 +53,8 @@ public class SpongeBlock extends Block {
         org.bukkit.craftbukkit.util.BlockStateListPopulator blockList = new org.bukkit.craftbukkit.util.BlockStateListPopulator(level); // CraftBukkit - Use BlockStateListPopulator
         BlockPos.breadthFirstTraversal(
                 pos,
-                6,
-                65,
+                level.purpurConfig.spongeAbsorptionRadius, // Purpur - Configurable sponge absorption
+                level.purpurConfig.spongeAbsorptionArea, // Purpur - Configurable sponge absorption
                 (validPos, queueAdder) -> {
                     for (Direction direction : ALL_DIRECTIONS) {
                         queueAdder.accept(validPos.relative(direction));
@@ -68,7 +68,7 @@ public class SpongeBlock extends Block {
                         BlockState blockState = blockList.getBlockState(blockPos);
                         FluidState fluidState = blockList.getFluidState(blockPos);
                         // CraftBukkit end
-                        if (!fluidState.is(FluidTags.WATER)) {
+                        if (!fluidState.is(FluidTags.WATER) && (!level.purpurConfig.spongeAbsorbsLava || !fluidState.is(FluidTags.LAVA)) && (!level.purpurConfig.spongeAbsorbsWaterFromMud || !blockState.is(Blocks.MUD))) { // Purpur - Option for sponges to work on lava and mud
                             return BlockPos.TraversalNodeStatus.SKIP;
                         } else if (blockState.getBlock() instanceof BucketPickup bucketPickup
                             && !bucketPickup.pickupBlock(null, blockList, blockPos, blockState).isEmpty()) { // CraftBukkit
@@ -76,6 +76,10 @@ public class SpongeBlock extends Block {
                         } else {
                             if (blockState.getBlock() instanceof LiquidBlock) {
                                 blockList.setBlock(blockPos, Blocks.AIR.defaultBlockState(), 3); // CraftBukkit
+                            // Purpur start - Option for sponges to work on lava and mud
+                            } else if (blockState.is(Blocks.MUD)) {
+                                blockList.setBlock(blockPos, Blocks.CLAY.defaultBlockState(), 3);
+                            // Purpur end - Option for sponges to work on lava and mud
                             } else {
                                 if (!blockState.is(Blocks.KELP)
                                     && !blockState.is(Blocks.KELP_PLANT)
diff --git a/net/minecraft/world/level/block/StonecutterBlock.java b/net/minecraft/world/level/block/StonecutterBlock.java
index 6d1ab251e7d09ada7edcde7f52ca49ae5efe16b6..a58c94a40bad1d60b970b06decde9851692a8b63 100644
--- a/net/minecraft/world/level/block/StonecutterBlock.java
+++ b/net/minecraft/world/level/block/StonecutterBlock.java
@@ -93,4 +93,14 @@ public class StonecutterBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return false;
     }
+
+    // Purpur start - Stonecutter damage
+    @Override
+    public void stepOn(Level level, BlockPos pos, BlockState state, net.minecraft.world.entity.Entity entity) {
+        if (level.purpurConfig.stonecutterDamage > 0.0F && entity instanceof net.minecraft.world.entity.LivingEntity) {
+            entity.hurtServer((net.minecraft.server.level.ServerLevel) level, entity.damageSources().stonecutter().eventBlockDamager(level, pos), level.purpurConfig.stonecutterDamage);
+        }
+        super.stepOn(level, pos, state, entity);
+    }
+    // Purpur end - Stonecutter damage
 }
diff --git a/net/minecraft/world/level/block/SugarCaneBlock.java b/net/minecraft/world/level/block/SugarCaneBlock.java
index a8de37e173e244d7a16c19ac8805e0e4327c837a..baa56c6422c0924bb8b7c5a78db17acf784f28d6 100644
--- a/net/minecraft/world/level/block/SugarCaneBlock.java
+++ b/net/minecraft/world/level/block/SugarCaneBlock.java
@@ -19,7 +19,7 @@ import net.minecraft.world.level.material.FluidState;
 import net.minecraft.world.phys.shapes.CollisionContext;
 import net.minecraft.world.phys.shapes.VoxelShape;
 
-public class SugarCaneBlock extends Block {
+public class SugarCaneBlock extends Block implements BonemealableBlock { // Purpur - bonemealable sugarcane
     public static final MapCodec<SugarCaneBlock> CODEC = simpleCodec(SugarCaneBlock::new);
     public static final IntegerProperty AGE = BlockStateProperties.AGE_15;
     private static final VoxelShape SHAPE = Block.column(12.0, 0.0, 16.0);
@@ -112,4 +112,34 @@ public class SugarCaneBlock extends Block {
     protected void createBlockStateDefinition(StateDefinition.Builder<Block, BlockState> builder) {
         builder.add(AGE);
     }
+
+    // Purpur start - bonemealable sugarcane
+    @Override
+    public boolean isValidBonemealTarget(final LevelReader world, final BlockPos pos, final BlockState state) {
+        if (!((net.minecraft.world.level.Level) world).purpurConfig.sugarCanAffectedByBonemeal || !world.isEmptyBlock(pos.above())) return false;
+
+        int reedHeight = 0;
+        while (world.getBlockState(pos.below(reedHeight)).is(this)) {
+            reedHeight++;
+        }
+
+        return reedHeight < ((net.minecraft.world.level.Level) world).paperConfig().maxGrowthHeight.reeds;
+    }
+
+    @Override
+    public boolean isBonemealSuccess(net.minecraft.world.level.Level world, RandomSource random, BlockPos pos, BlockState state) {
+        return true;
+    }
+
+    @Override
+    public void performBonemeal(ServerLevel world, RandomSource random, BlockPos pos, BlockState state) {
+        int reedHeight = 0;
+        while (world.getBlockState(pos.below(reedHeight)).is(this)) {
+            reedHeight++;
+        }
+        for (int i = 0; i <= world.paperConfig().maxGrowthHeight.reeds - reedHeight; i++) {
+            world.setBlockAndUpdate(pos.above(i), state.setValue(SugarCaneBlock.AGE, 0));
+        }
+    }
+    // Purpur end - bonemealable sugarcane
 }
diff --git a/net/minecraft/world/level/block/TurtleEggBlock.java b/net/minecraft/world/level/block/TurtleEggBlock.java
index 8ee103e2752290db4cb4b22bb3552bf80e2ceb92..41e51cb4f1a2443361b52c8523688e2c307a1d75 100644
--- a/net/minecraft/world/level/block/TurtleEggBlock.java
+++ b/net/minecraft/world/level/block/TurtleEggBlock.java
@@ -156,7 +156,7 @@ public class TurtleEggBlock extends Block {
 
     private boolean shouldUpdateHatchLevel(Level level) {
         float timeOfDay = level.getTimeOfDay(1.0F);
-        return timeOfDay < 0.69 && timeOfDay > 0.65 || level.random.nextInt(500) == 0;
+        return timeOfDay < 0.69 && timeOfDay > 0.65 || level.random.nextInt(level.purpurConfig.turtleEggsRandomTickCrackChance) == 0; // Purpur - Turtle eggs random tick crack chance
     }
 
     @Override
@@ -189,9 +189,32 @@ public class TurtleEggBlock extends Block {
     }
 
     private boolean canDestroyEgg(ServerLevel level, Entity entity) {
-        return !(entity instanceof Turtle)
-            && !(entity instanceof Bat)
-            && entity instanceof LivingEntity
-            && (entity instanceof Player || level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING));
+        // Purpur start - Add turtle egg block options
+        if (entity instanceof Turtle || entity instanceof Bat) {
+            return false;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromExpOrbs && entity instanceof net.minecraft.world.entity.ExperienceOrb) {
+            return true;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromItems && entity instanceof net.minecraft.world.entity.item.ItemEntity) {
+            return true;
+        }
+        if (level.purpurConfig.turtleEggsBreakFromMinecarts && entity instanceof net.minecraft.world.entity.vehicle.AbstractMinecart) {
+            return true;
+        }
+        if (!(entity instanceof LivingEntity)) {
+            return false;
+        }
+        // Purpur start - Option to disable turtle egg trampling with feather falling
+        if (level.purpurConfig.turtleEggsTramplingFeatherFalling) {
+            net.minecraft.world.item.ItemStack bootsItem = ((net.minecraft.world.entity.LivingEntity) entity).getItemBySlot(net.minecraft.world.entity.EquipmentSlot.FEET);
+
+            return bootsItem != net.minecraft.world.item.ItemStack.EMPTY || net.minecraft.world.item.enchantment.EnchantmentHelper.getItemEnchantmentLevel(net.minecraft.world.item.enchantment.Enchantments.FEATHER_FALLING, bootsItem) < (int) entity.fallDistance;
+        }
+        // Purpur end - Option to disable turtle egg trampling with feather falling
+        if (entity instanceof Player) return true;
+
+        return level.getGameRules().getBoolean(GameRules.RULE_MOBGRIEFING, level.purpurConfig.turtleEggsMobGriefingOverride); // Purpur - Add mobGriefing override to everything affected
+        // Purpur end - Add turtle egg block options
     }
 }
diff --git a/net/minecraft/world/level/block/TwistingVinesBlock.java b/net/minecraft/world/level/block/TwistingVinesBlock.java
index afb77747ea6966c435aca4b667bfbbc909f52232..361aaca76ae0375782310af0e03241625f08f7bd 100644
--- a/net/minecraft/world/level/block/TwistingVinesBlock.java
+++ b/net/minecraft/world/level/block/TwistingVinesBlock.java
@@ -34,4 +34,11 @@ public class TwistingVinesBlock extends GrowingPlantHeadBlock {
     protected boolean canGrowInto(BlockState state) {
         return NetherVines.isValidGrowthState(state);
     }
+
+    // Purpur start - twisting vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.twistingVinesMaxGrowthAge;
+    }
+    // Purpur end - twisting vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/VegetationBlock.java b/net/minecraft/world/level/block/VegetationBlock.java
index 55beb3206f499d6802e6eb011e8636190f36ab31..44cf31c36c95bdb284e96a50ebbfda0ee64fb856 100644
--- a/net/minecraft/world/level/block/VegetationBlock.java
+++ b/net/minecraft/world/level/block/VegetationBlock.java
@@ -61,4 +61,24 @@ public abstract class VegetationBlock extends Block {
     protected boolean isPathfindable(BlockState state, PathComputationType pathComputationType) {
         return pathComputationType == PathComputationType.AIR && !this.hasCollision || super.isPathfindable(state, pathComputationType);
     }
+
+    // Purpur start - Ability for hoe to replant crops
+    public void playerDestroyAndReplant(net.minecraft.world.level.Level world, net.minecraft.world.entity.player.Player player, BlockPos pos, BlockState state, @javax.annotation.Nullable net.minecraft.world.level.block.entity.BlockEntity blockEntity, net.minecraft.world.item.ItemStack itemInHand, net.minecraft.world.level.ItemLike itemToReplant) {
+        player.awardStat(net.minecraft.stats.Stats.BLOCK_MINED.get(this));
+        player.causeFoodExhaustion(0.005F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.BLOCK_MINED);
+        java.util.List<net.minecraft.world.item.ItemStack> dropList = Block.getDrops(state, (net.minecraft.server.level.ServerLevel) world, pos, blockEntity, player, itemInHand);
+
+        boolean planted = false;
+        for (net.minecraft.world.item.ItemStack itemToDrop : dropList) {
+            if (!planted && itemToDrop.getItem() == itemToReplant) {
+                world.setBlock(pos, defaultBlockState(), 3);
+                itemToDrop.setCount(itemToDrop.getCount() - 1);
+                planted = true;
+            }
+            Block.popResource(world, pos, itemToDrop);
+        }
+
+        state.spawnAfterBreak((net.minecraft.server.level.ServerLevel) world, pos, itemInHand, true);
+    }
+    // Purpur end - Ability for hoe to replant crops
 }
diff --git a/net/minecraft/world/level/block/WeepingVinesBlock.java b/net/minecraft/world/level/block/WeepingVinesBlock.java
index f4ff810cdd4206711312a4fffba18f4b30a5701f..96fb69aaf9ed020a328ff609d49f88ab29a69952 100644
--- a/net/minecraft/world/level/block/WeepingVinesBlock.java
+++ b/net/minecraft/world/level/block/WeepingVinesBlock.java
@@ -34,4 +34,11 @@ public class WeepingVinesBlock extends GrowingPlantHeadBlock {
     protected boolean canGrowInto(BlockState state) {
         return NetherVines.isValidGrowthState(state);
     }
+
+    // Purpur start - weeping vines configurable max growth age
+    @Override
+    public int getMaxGrowthAge() {
+        return org.purpurmc.purpur.PurpurConfig.weepingVinesMaxGrowthAge;
+    }
+    // Purpur end - weeping vines configurable max growth age
 }
diff --git a/net/minecraft/world/level/block/WitherSkullBlock.java b/net/minecraft/world/level/block/WitherSkullBlock.java
index 1c172802b065d644823d4a9e89fbc912b2ccff3c..43115cd2273e670452094771bfbb0ab4c1c5723f 100644
--- a/net/minecraft/world/level/block/WitherSkullBlock.java
+++ b/net/minecraft/world/level/block/WitherSkullBlock.java
@@ -71,6 +71,7 @@ public class WitherSkullBlock extends SkullBlock {
                         );
                         witherBoss.yBodyRot = blockPatternMatch.getForwards().getAxis() == Direction.Axis.X ? 0.0F : 90.0F;
                         witherBoss.makeInvulnerable();
+                        witherBoss.setSummoner(blockState.getBlock().placer == null ? null : blockState.getBlock().placer.getUUID()); // Purpur - Summoner API
                         // CraftBukkit start
                         if (!level.addFreshEntity(witherBoss, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.BUILD_WITHER)) {
                             return;
diff --git a/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java b/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
index 36a72a11d28f99bfe85868461925b778cc01478e..57eae0dbb614f57e2a352613c7490145bbfeb5a1 100644
--- a/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/AbstractFurnaceBlockEntity.java
@@ -186,6 +186,21 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         }
 
         ItemStack itemStack = furnace.items.get(1);
+        // Purpur start - Furnace uses lava from underneath
+        boolean usedLavaFromUnderneath = false;
+        if (level.purpurConfig.furnaceUseLavaFromUnderneath && !furnace.isLit() && itemStack.isEmpty() && !furnace.items.get(0).isEmpty() && level.getGameTime() % 20 == 0) {
+            BlockPos below = furnace.getBlockPos().below();
+            BlockState belowState = level.getBlockStateIfLoaded(below);
+            if (belowState != null && belowState.is(Blocks.LAVA)) {
+                net.minecraft.world.level.material.FluidState fluidState = belowState.getFluidState();
+                if (fluidState != null && fluidState.isSource()) {
+                    level.setBlock(below, Blocks.AIR.defaultBlockState(), 3);
+                    itemStack = Items.LAVA_BUCKET.getDefaultInstance();
+                    usedLavaFromUnderneath = true;
+                }
+            }
+        }
+        // Purpur end - Furnace uses lava from underneath
         ItemStack itemStack1 = furnace.items.get(0);
         boolean flag1 = !itemStack1.isEmpty();
         boolean flag2 = !itemStack.isEmpty();
@@ -269,6 +284,8 @@ public abstract class AbstractFurnaceBlockEntity extends BaseContainerBlockEntit
         if (flag) {
             setChanged(level, pos, state);
         }
+
+        if (usedLavaFromUnderneath) furnace.items.set(1, ItemStack.EMPTY); // Purpur - Furnace uses lava from underneath
     }
 
     private static boolean canBurn(
diff --git a/net/minecraft/world/level/block/entity/BarrelBlockEntity.java b/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
index d679ab599dfd0bdbdc3ab5530d7fcd1c38baf7fa..0e4f6455ec48c5a7fcd4613c1c5b79d599e4960a 100644
--- a/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BarrelBlockEntity.java
@@ -56,7 +56,17 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
     }
     // CraftBukkit end
 
-    private NonNullList<ItemStack> items = NonNullList.withSize(27, ItemStack.EMPTY);
+    // Purpur start - Barrels and enderchests 6 rows
+    private NonNullList<ItemStack> items = NonNullList.withSize(switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+        case 6 -> 54;
+        case 5 -> 45;
+        case 4 -> 36;
+        case 2 -> 18;
+        case 1 -> 9;
+        default -> 27;
+    }, ItemStack.EMPTY);
+    // Purpur end - Barrels and enderchests 6 rows
+
     public final ContainerOpenersCounter openersCounter = new ContainerOpenersCounter() {
         @Override
         protected void onOpen(Level level, BlockPos pos, BlockState state) {
@@ -108,7 +118,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
 
     @Override
     public int getContainerSize() {
-        return 27;
+        // Purpur start - Barrels and enderchests 6 rows
+        return switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+            case 6 -> 54;
+            case 5 -> 45;
+            case 4 -> 36;
+            case 2 -> 18;
+            case 1 -> 9;
+            default -> 27;
+        };
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     @Override
@@ -128,7 +147,16 @@ public class BarrelBlockEntity extends RandomizableContainerBlockEntity {
 
     @Override
     protected AbstractContainerMenu createMenu(int id, Inventory player) {
-        return ChestMenu.threeRows(id, player, this);
+        // Purpur start - Barrels and enderchests 6 rows
+        return switch (org.purpurmc.purpur.PurpurConfig.barrelRows) {
+            case 6 -> ChestMenu.sixRows(id, player, this);
+            case 5 -> ChestMenu.fiveRows(id, player, this);
+            case 4 -> ChestMenu.fourRows(id, player, this);
+            case 2 -> ChestMenu.twoRows(id, player, this);
+            case 1 -> ChestMenu.oneRow(id, player, this);
+            default -> ChestMenu.threeRows(id, player, this);
+        };
+        // Purpur end - Barrels and enderchests 6 rows
     }
 
     @Override
diff --git a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
index b27a40e69046414d5302882b72ac8b3f848e18df..1cf950182e9f9bb54cae95a8f2365fa3291eac3d 100644
--- a/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BeaconBlockEntity.java
@@ -143,6 +143,16 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
 
     public double getEffectRange() {
         if (this.effectRange < 0) {
+            // Purpur start - Beacon Activation Range Configurable
+            if (this.level != null) {
+                switch (this.levels) {
+                    case 1: return this.level.purpurConfig.beaconLevelOne;
+                    case 2: return this.level.purpurConfig.beaconLevelTwo;
+                    case 3: return this.level.purpurConfig.beaconLevelThree;
+                    case 4: return this.level.purpurConfig.beaconLevelFour;
+                }
+            }
+            // Purpur end - Beacon Activation Range Configurable
             return this.levels * 10 + 10;
         } else {
             return effectRange;
@@ -172,6 +182,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
         int y = pos.getY();
         int z = pos.getZ();
         BlockPos blockPos;
+        boolean isTintedGlass = false; // Purpur - allow beacon effects when covered by tinted glass
         if (blockEntity.lastCheckY < y) {
             blockPos = pos;
             blockEntity.checkingBeamSections = Lists.newArrayList();
@@ -201,6 +212,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
                     }
                 }
             } else {
+                if (level.purpurConfig.beaconAllowEffectsWithTintedGlass && blockState.getBlock().equals(Blocks.TINTED_GLASS)) {isTintedGlass = true;} // Purpur - allow beacon effects when covered by tinted glass
                 if (section == null || blockState.getLightBlock() >= 15 && !blockState.is(Blocks.BEDROCK)) {
                     blockEntity.checkingBeamSections.clear();
                     blockEntity.lastCheckY = height;
@@ -220,7 +232,7 @@ public class BeaconBlockEntity extends BlockEntity implements MenuProvider, Name
                 blockEntity.levels = updateBase(level, x, y, z);
             }
 
-            if (blockEntity.levels > 0 && !blockEntity.beamSections.isEmpty()) {
+            if (blockEntity.levels > 0 && (!blockEntity.beamSections.isEmpty() || (level.purpurConfig.beaconAllowEffectsWithTintedGlass && isTintedGlass))) { // Purpur - allow beacon effects when covered by tinted glass
                 applyEffects(level, pos, blockEntity.levels, blockEntity.primaryPower, blockEntity.secondaryPower, blockEntity); // Paper - Custom beacon ranges
                 playSound(level, pos, SoundEvents.BEACON_AMBIENT);
             }
diff --git a/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java b/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
index 91f7ee163107d846e7f6a5783be6eff96e783886..b1b49fa83794f4237994e9b985816ddf6d20b7e9 100644
--- a/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BeehiveBlockEntity.java
@@ -75,7 +75,7 @@ public class BeehiveBlockEntity extends BlockEntity {
         "leash",
         "UUID"
     );
-    public static final int MAX_OCCUPANTS = 3;
+    public static final int MAX_OCCUPANTS = org.purpurmc.purpur.PurpurConfig.beeInsideBeeHive; // Purpur - Config to change max number of bees
     private static final int MIN_TICKS_BEFORE_REENTERING_HIVE = 400;
     private static final int MIN_OCCUPATION_TICKS_NECTAR = 2400;
     public static final int MIN_OCCUPATION_TICKS_NECTARLESS = 600;
@@ -150,11 +150,33 @@ public class BeehiveBlockEntity extends BlockEntity {
         return list;
     }
 
+    // Purpur start - Stored Bee API
+    public List<Entity> releaseBee(BlockState iblockdata, BeehiveBlockEntity.BeeData data, BeehiveBlockEntity.BeeReleaseStatus tileentitybeehive_releasestatus, boolean force) {
+        List<Entity> list = Lists.newArrayList();
+
+        BeehiveBlockEntity.releaseOccupant(this.level, this.worldPosition, iblockdata, data.occupant, list, tileentitybeehive_releasestatus, this.savedFlowerPos, force);
+
+        if (!list.isEmpty()) {
+            stored.remove(data);
+
+            super.setChanged();
+        }
+
+        return list;
+    }
+    // Purpur end - Stored Bee API
+
     @VisibleForDebug
     public int getOccupantCount() {
         return this.stored.size();
     }
 
+    // Purpur start - Stored Bee API
+    public List<BeeData> getStored() {
+        return stored;
+    }
+    // Purpur end - Stored Bee API
+
     // Paper start - Add EntityBlockStorage clearEntities
     public void clearBees() {
         this.stored.clear();
@@ -392,8 +414,8 @@ public class BeehiveBlockEntity extends BlockEntity {
         return this.stored.stream().map(BeehiveBlockEntity.BeeData::toOccupant).toList();
     }
 
-    static class BeeData {
-        private final BeehiveBlockEntity.Occupant occupant;
+    public static class BeeData { // Purpur - make public - Stored Bee API
+        public final BeehiveBlockEntity.Occupant occupant; // Purpur - make public - Stored Bee API
         private int exitTickCounter; // Paper - Fix bees aging inside hives; separate counter for checking if bee should exit to reduce exit attempts
         private int ticksInHive;
 
diff --git a/net/minecraft/world/level/block/entity/BlockEntity.java b/net/minecraft/world/level/block/entity/BlockEntity.java
index 63ac5759a8a4b59297d5eb1abd362fb2a54353d7..99833033b62c024c4b249687cf96487741745eec 100644
--- a/net/minecraft/world/level/block/entity/BlockEntity.java
+++ b/net/minecraft/world/level/block/entity/BlockEntity.java
@@ -111,6 +111,10 @@ public abstract class BlockEntity {
         input.read("PublicBukkitValues", CompoundTag.CODEC)
             .ifPresent(this.persistentDataContainer::putAll);
         // Paper end - read persistent data container
+
+
+        this.persistentLore = input.read("Purpur.persistentLore", net.minecraft.world.item.component.ItemLore.CODEC).orElse(null); // Purpur - Persistent BlockEntity Lore and DisplayName
+
     }
 
     public final void loadWithComponents(ValueInput input) {
@@ -123,6 +127,11 @@ public abstract class BlockEntity {
     }
 
     protected void saveAdditional(ValueOutput output) {
+        // Purpur start - Persistent BlockEntity Lore and DisplayName
+        if (this.persistentLore != null) {
+            output.store("Purpur.persistentLore", net.minecraft.world.item.component.ItemLore.CODEC, this.persistentLore);
+        }
+        // Purpur end - Persistent BlockEntity Lore and DisplayName
     }
 
     public final CompoundTag saveWithFullMetadata(HolderLookup.Provider registries) {
@@ -408,4 +417,17 @@ public abstract class BlockEntity {
             return this.blockEntity.getNameForReporting() + "@" + this.blockEntity.getBlockPos();
         }
     }
+
+    // Purpur start - Persistent BlockEntity Lore and DisplayName
+    @Nullable
+    private net.minecraft.world.item.component.ItemLore persistentLore = null;
+
+    public void setPersistentLore(net.minecraft.world.item.component.ItemLore lore) {
+        this.persistentLore = lore;
+    }
+
+    public @org.jetbrains.annotations.Nullable net.minecraft.world.item.component.ItemLore getPersistentLore() {
+        return this.persistentLore;
+    }
+    // Purpur end - Persistent BlockEntity Lore and DisplayName
 }
diff --git a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
index 0d7d2fe54628ae6ef3d579d6c3d031b915d65cd2..46d555f79d7df86e9e7b7f0c9b582f734fc6ca91 100644
--- a/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/ConduitBlockEntity.java
@@ -151,7 +151,7 @@ public class ConduitBlockEntity extends BlockEntity {
                         BlockPos blockPos1 = pos.offset(i, i1, i2x);
                         BlockState blockState = level.getBlockState(blockPos1);
 
-                        for (Block block : VALID_BLOCKS) {
+                        for (Block block : level.purpurConfig.conduitBlocks) { // Purpur - Conduit behavior configuration
                             if (blockState.is(block)) {
                                 positions.add(blockPos1);
                             }
@@ -166,13 +166,13 @@ public class ConduitBlockEntity extends BlockEntity {
 
     private static void applyEffects(Level level, BlockPos pos, List<BlockPos> positions) {
         // CraftBukkit start
-        ConduitBlockEntity.applyEffects(level, pos, ConduitBlockEntity.getRange(positions));
+        ConduitBlockEntity.applyEffects(level, pos, ConduitBlockEntity.getRange(positions, level)); // Purpur - Conduit behavior configuration
     }
 
-    public static int getRange(List<BlockPos> positions) {
+    public static int getRange(List<BlockPos> positions, Level level) { // Purpur - Conduit behavior configuration
         // CraftBukkit end
         int size = positions.size();
-        int i = size / 7 * 16;
+        int i = size / 7 * level.purpurConfig.conduitDistance; // Purpur - Conduit behavior configuration
         // CraftBukkit start
         return i;
     }
@@ -202,7 +202,7 @@ public class ConduitBlockEntity extends BlockEntity {
         EntityReference<LivingEntity> entityReference = updateDestroyTarget(blockEntity.destroyTarget, level, pos, canDestroy);
         LivingEntity livingEntity = EntityReference.get(entityReference, level, LivingEntity.class);
         if (damageTarget && livingEntity != null) { // CraftBukkit
-            if (livingEntity.hurtServer(level, level.damageSources().magic().eventBlockDamager(level, pos), 4.0F)) // CraftBukkit - move up
+            if (livingEntity.hurtServer(level, level.damageSources().magic().eventBlockDamager(level, pos), level.purpurConfig.conduitDamageAmount)) // CraftBukkit - move up // Purpur - Conduit behavior configuration
             level.playSound(
                 null, livingEntity.getX(), livingEntity.getY(), livingEntity.getZ(), SoundEvents.CONDUIT_ATTACK_TARGET, SoundSource.BLOCKS, 1.0F, 1.0F
             );
@@ -224,20 +224,26 @@ public class ConduitBlockEntity extends BlockEntity {
             return selectNewTarget(level, pos);
         } else {
             LivingEntity livingEntity = EntityReference.get(destroyTarget, level, LivingEntity.class);
-            return livingEntity != null && livingEntity.isAlive() && pos.closerThan(livingEntity.blockPosition(), 8.0) ? destroyTarget : null;
+            return livingEntity != null && livingEntity.isAlive() && pos.closerThan(livingEntity.blockPosition(), level.purpurConfig.conduitDamageDistance) ? destroyTarget : null; // Purpur - Conduit behavior configuration
         }
     }
 
     @Nullable
     private static EntityReference<LivingEntity> selectNewTarget(ServerLevel level, BlockPos pos) {
         List<LivingEntity> entitiesOfClass = level.getEntitiesOfClass(
-            LivingEntity.class, getDestroyRangeAABB(pos), livingEntity -> livingEntity instanceof Enemy && livingEntity.isInWaterOrRain()
+            LivingEntity.class, getDestroyRangeAABB(pos, level), livingEntity -> livingEntity instanceof Enemy && livingEntity.isInWaterOrRain() // Purpur - Conduit behavior configuration
         );
         return entitiesOfClass.isEmpty() ? null : new EntityReference<>(Util.getRandom(entitiesOfClass, level.random));
     }
 
     public static AABB getDestroyRangeAABB(BlockPos pos) {
-        return new AABB(pos).inflate(8.0);
+        // Purpur start - Conduit behavior configuration
+        return getDestroyRangeAABB(pos, null);
+    }
+
+    private static AABB getDestroyRangeAABB(BlockPos pos, Level level) {
+        // Purpur end - Conduit behavior configuration
+        return new AABB(pos).inflate(level == null ? 8.0 : level.purpurConfig.conduitDamageDistance); // Purpur - Conduit behavior configuration
     }
 
     private static void animationTick(Level level, BlockPos pos, List<BlockPos> positions, @Nullable Entity entity, int tickCount) {
diff --git a/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java b/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
index 5dd044c13e09423af43330df565bfe6ce88a883c..93f34bbfae6f8f02ff4ea92d6745cd1d288c8dbd 100644
--- a/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/EnchantingTableBlockEntity.java
@@ -30,6 +30,7 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     private static final RandomSource RANDOM = RandomSource.create();
     @Nullable
     private Component name;
+    private int lapis = 0; // Purpur - Enchantment Table Persists Lapis
 
     public EnchantingTableBlockEntity(BlockPos pos, BlockState state) {
         super(BlockEntityType.ENCHANTING_TABLE, pos, state);
@@ -39,12 +40,14 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     protected void saveAdditional(ValueOutput output) {
         super.saveAdditional(output);
         output.storeNullable("CustomName", ComponentSerialization.CODEC, this.name);
+        output.putInt("Purpur.Lapis", this.lapis); // Purpur - Enchantment Table Persists Lapis
     }
 
     @Override
     protected void loadAdditional(ValueInput input) {
         super.loadAdditional(input);
         this.name = parseCustomNameSafe(input, "CustomName");
+        this.lapis = input.getIntOr("Purpur.Lapis", 0); // Purpur - Enchantment Table Persists Lapis
     }
 
     public static void bookAnimationTick(Level level, BlockPos pos, BlockState state, EnchantingTableBlockEntity enchantingTable) {
@@ -136,4 +139,14 @@ public class EnchantingTableBlockEntity extends BlockEntity implements Nameable
     public void removeComponentsFromTag(ValueOutput output) {
         output.discard("CustomName");
     }
+
+    // Purpur start - Enchantment Table Persists Lapis
+    public int getLapis() {
+        return this.lapis;
+    }
+
+    public void setLapis(int lapis) {
+        this.lapis = lapis;
+    }
+    // Purpur end - Enchantment Table Persists Lapis
 }
diff --git a/net/minecraft/world/level/block/entity/SignBlockEntity.java b/net/minecraft/world/level/block/entity/SignBlockEntity.java
index be1b138a78d8cb87956d531a801d85e677ca6f4a..2e0b2b55031343e32b4972c0f0017e950d56652d 100644
--- a/net/minecraft/world/level/block/entity/SignBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/SignBlockEntity.java
@@ -148,16 +148,32 @@ public class SignBlockEntity extends BlockEntity {
         return this.setText(updater.apply(text), isFrontText);
     }
 
+    // Purpur start - Signs allow color codes
+    private Component translateColors(org.bukkit.entity.Player player, String line, Style style) {
+        if (level.purpurConfig.signAllowColors) {
+            if (player.hasPermission("purpur.sign.color")) line = line.replaceAll("(?i)&([0-9a-fr])", "\u00a7$1");
+            if (player.hasPermission("purpur.sign.style")) line = line.replaceAll("(?i)&([l-or])", "\u00a7$1");
+            if (player.hasPermission("purpur.sign.magic")) line = line.replaceAll("(?i)&([kr])", "\u00a7$1");
+
+            return io.papermc.paper.adventure.PaperAdventure.asVanilla(net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacySection().deserialize(line));
+        } else {
+            return Component.literal(line).setStyle(style);
+        }
+    }
+    // Purpur end - Signs allow color codes
+
     private SignText setMessages(Player player, List<FilteredText> filteredText, SignText text, boolean front) { // CraftBukkit
         SignText originalText = text; // CraftBukkit
         for (int i = 0; i < filteredText.size(); i++) {
             FilteredText filteredText1 = filteredText.get(i);
             Style style = text.getMessage(i, player.isTextFilteringEnabled()).getStyle();
+
+            org.bukkit.entity.Player craftPlayer =  (org.bukkit.craftbukkit.entity.CraftPlayer) player.getBukkitEntity(); // Purpur - Signs allow color codes
             if (player.isTextFilteringEnabled()) {
-                text = text.setMessage(i, Component.literal(net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty())).setStyle(style)); // Paper - filter sign text to chat only
+                text = text.setMessage(i, translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty()), style)); // Paper - filter sign text to chat only // Purpur - Signs allow color codes
             } else {
                 text = text.setMessage(
-                    i, Component.literal(filteredText1.raw()).setStyle(style), Component.literal(net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty())).setStyle(style) // Paper - filter sign text to chat only
+                    i, translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.raw()), style), translateColors(craftPlayer, net.minecraft.util.StringUtil.filterText(filteredText1.filteredOrEmpty()), style) // Paper - filter sign text to chat only // Purpur - Signs allow color codes
                 );
             }
         }
@@ -307,6 +323,27 @@ public class SignBlockEntity extends BlockEntity {
         return new CommandSourceStack(commandSource, Vec3.atCenterOf(pos), Vec2.ZERO, level, 2, string, component, level.getServer(), player); // Paper - Fix commands from signs not firing command events
     }
 
+    // Purpur start - Signs allow color codes
+    public ClientboundBlockEntityDataPacket getTranslatedUpdatePacket(boolean filtered, boolean front) {
+        try (net.minecraft.util.ProblemReporter.ScopedCollector scopedCollector = new net.minecraft.util.ProblemReporter.ScopedCollector(this.problemPath(), LOGGER)) {
+            net.minecraft.world.level.storage.TagValueOutput tagValueOutput = net.minecraft.world.level.storage.TagValueOutput.createWithContext(scopedCollector, this.getLevel().registryAccess());
+            this.saveAdditional(tagValueOutput);
+
+            final Component[] lines = front ? frontText.getMessages(filtered) : backText.getMessages(filtered);
+            final String side = front ? "front_text" : "back_text";
+            net.minecraft.world.level.storage.ValueOutput sideNbt = tagValueOutput.child(side);
+            net.minecraft.world.level.storage.ValueOutput.TypedOutputList<String> messagesNbt = sideNbt.list("messages", com.mojang.serialization.Codec.STRING);
+            for (int i = 0; i < 4; i++) {
+                final net.kyori.adventure.text.Component component = io.papermc.paper.adventure.PaperAdventure.asAdventure(lines[i]);
+                final String line = net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer.legacyAmpersand().serialize(component);
+                messagesNbt.add(line);
+            }
+            tagValueOutput.putString("PurpurEditor", "true");
+            return ClientboundBlockEntityDataPacket.create(this, (blockEntity, registryAccess) -> tagValueOutput.buildResult());
+        }
+    }
+    // Purpur end - Signs allow color codes
+
     @Override
     public ClientboundBlockEntityDataPacket getUpdatePacket() {
         return ClientboundBlockEntityDataPacket.create(this);
diff --git a/net/minecraft/world/level/block/piston/PistonStructureResolver.java b/net/minecraft/world/level/block/piston/PistonStructureResolver.java
index ad143a92569f5b420ccaa2089758b2fb3b4ab7c5..5a3660e02bc805e9a35a81b8a61f07b3f20b5ba9 100644
--- a/net/minecraft/world/level/block/piston/PistonStructureResolver.java
+++ b/net/minecraft/world/level/block/piston/PistonStructureResolver.java
@@ -81,7 +81,7 @@ public class PistonStructureResolver {
             return true;
         } else {
             int i = 1;
-            if (i + this.toPush.size() > 12) {
+            if (i + this.toPush.size() > this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                 return false;
             } else {
                 while (isSticky(blockState)) {
@@ -95,7 +95,7 @@ public class PistonStructureResolver {
                         break;
                     }
 
-                    if (++i + this.toPush.size() > 12) {
+                    if (++i + this.toPush.size() > this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                         return false;
                     }
                 }
@@ -140,7 +140,7 @@ public class PistonStructureResolver {
                         return true;
                     }
 
-                    if (this.toPush.size() >= 12) {
+                    if (this.toPush.size() >= this.level.purpurConfig.pistonBlockPushLimit) { // Purpur - Configurable piston push limit
                         return false;
                     }
 
diff --git a/net/minecraft/world/level/chunk/storage/EntityStorage.java b/net/minecraft/world/level/chunk/storage/EntityStorage.java
index f1f8575a4b37114ced3cdb1d2ea33a36a2db44fd..2afe96a69c09decbe972332d2d38f67427d880d8 100644
--- a/net/minecraft/world/level/chunk/storage/EntityStorage.java
+++ b/net/minecraft/world/level/chunk/storage/EntityStorage.java
@@ -108,6 +108,7 @@ public class EntityStorage implements EntityPersistentStorage<Entity> {
                     }
                     // Paper end - Entity load/save limit per chunk
                     TagValueOutput tagValueOutput = TagValueOutput.createWithContext(scopedCollector.forChild(entity.problemPath()), entity.registryAccess());
+                    if (!entity.canSaveToDisk()) return; // Purpur - Add canSaveToDisk to Entity
                     if (entity.save(tagValueOutput)) {
                         CompoundTag compoundTag1 = tagValueOutput.buildResult();
                         listTag.add(compoundTag1);
diff --git a/net/minecraft/world/level/chunk/storage/RegionFileStorage.java b/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
index 384f2cd090d6d23bd1308d6e82c24338f2bf55d1..77db68349aa73d33b86a867099c9395c96d5a02d 100644
--- a/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
+++ b/net/minecraft/world/level/chunk/storage/RegionFileStorage.java
@@ -308,7 +308,7 @@ public class RegionFileStorage implements AutoCloseable, ca.spottedleaf.moonrise
 
     // Paper start
     private static void printOversizedLog(String msg, Path file, int x, int z) {
-        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PAPER - You may ask for help on Discord, but do not file an issue. These error messages can not be removed.");
+        org.apache.logging.log4j.LogManager.getLogger().fatal(msg + " (" + file.toString().replaceAll(".+[\\\\/]", "") + " - " + x + "," + z + ") Go clean it up to remove this message. /minecraft:tp " + (x<<4)+" 128 "+(z<<4) + " - DO NOT REPORT THIS TO PURPUR - You may ask for help on Discord, but do not file an issue. These error messages can not be removed."); // Purpur - Rebrand
     }
 
     private static CompoundTag readOversizedChunk(RegionFile regionfile, ChunkPos chunkCoordinate) throws IOException {
diff --git a/net/minecraft/world/level/levelgen/DensityFunctions.java b/net/minecraft/world/level/levelgen/DensityFunctions.java
index 04527a5c65ad630f794fed9071d485aedd02257a..77731406cb3dc417aa2fe1cb4352f3d2d7d498aa 100644
--- a/net/minecraft/world/level/levelgen/DensityFunctions.java
+++ b/net/minecraft/world/level/levelgen/DensityFunctions.java
@@ -528,7 +528,7 @@ public final class DensityFunctions {
             int i1 = z / 2;
             int i2 = x % 2;
             int i3 = z % 2;
-            float f = 100.0F - Mth.sqrt((long)x * (long)x + (long)z * (long)z) * 8.0F; // Paper - cast ints to long to avoid integer overflow
+            float f = 100.0F - Mth.sqrt(org.purpurmc.purpur.PurpurConfig.generateEndVoidRings ? x * x + z * z : (long)x * (long)x + (long)z * (long)z) * 8.0F; // Paper - cast ints to long to avoid integer overflow // Purpur - Setting to reintroduce end void rings
             f = Mth.clamp(f, -100.0F, 80.0F);
 
             NoiseCache cache = noiseCache.get().computeIfAbsent(noise, noiseKey -> new NoiseCache()); // Paper - Perf: Optimize end generation
diff --git a/net/minecraft/world/level/levelgen/PhantomSpawner.java b/net/minecraft/world/level/levelgen/PhantomSpawner.java
index 0cafe46e9a1b053c5e70f20a26b4402632d0f8bf..9ab64a29f4b3cd68c584ce7915e22314c9d46634 100644
--- a/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -39,13 +39,13 @@ public class PhantomSpawner implements CustomSpawner {
                     int spawnAttemptMaxSeconds = level.paperConfig().entities.behavior.phantomsSpawnAttemptMaxSeconds;
                     worldData.phantomSpawnerNextTick += (spawnAttemptMinSeconds + randomSource.nextInt(spawnAttemptMaxSeconds - spawnAttemptMinSeconds + 1)) * 20; // Folia - region threading
                     // Paper end - Ability to control player's insomnia and phantoms
-                    if (level.getSkyDarken() >= 5 || !level.dimensionType().hasSkyLight()) {
+                    if (level.getSkyDarken() >= level.purpurConfig.phantomSpawnMinSkyDarkness || !level.dimensionType().hasSkyLight()) { // Purpur - Add phantom spawning options
                         for (ServerPlayer serverPlayer : level.getLocalPlayers()) { // Folia - region threading
                             if (!serverPlayer.isSpectator() && (!level.paperConfig().entities.behavior.phantomsDoNotSpawnOnCreativePlayers || !serverPlayer.isCreative())) { // Paper - Add phantom creative and insomniac controls
                                 BlockPos blockPos = serverPlayer.blockPosition();
-                                if (!level.dimensionType().hasSkyLight() || blockPos.getY() >= level.getSeaLevel() && level.canSeeSky(blockPos)) {
+                                if (!level.dimensionType().hasSkyLight() ||(!level.purpurConfig.phantomSpawnOnlyAboveSeaLevel || blockPos.getY() >= level.getSeaLevel() && level.canSeeSky(blockPos))) { // Purpur - Add phantom spawning options
                                     DifficultyInstance currentDifficultyAt = level.getCurrentDifficultyAt(blockPos);
-                                    if (currentDifficultyAt.isHarderThan(randomSource.nextFloat() * 3.0F)) {
+                                    if (currentDifficultyAt.isHarderThan(randomSource.nextFloat() * (float) level.purpurConfig.phantomSpawnLocalDifficultyChance)) { // Purpur - Add phantom spawning options
                                         ServerStatsCounter stats = serverPlayer.getStats();
                                         int i = Mth.clamp(stats.getValue(Stats.CUSTOM.get(Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE);
                                         int i1 = 24000;
@@ -57,7 +57,7 @@ public class PhantomSpawner implements CustomSpawner {
                                             FluidState fluidState = level.getFluidState(blockPos1);
                                             if (NaturalSpawner.isValidEmptySpawnBlock(level, blockPos1, blockState, fluidState, EntityType.PHANTOM)) {
                                                 SpawnGroupData spawnGroupData = null;
-                                                int i2 = 1 + randomSource.nextInt(currentDifficultyAt.getDifficulty().getId() + 1);
+                                                int i2 = level.purpurConfig.phantomSpawnMinPerAttempt + randomSource.nextInt((level.purpurConfig.phantomSpawnMaxPerAttempt < 0 ? currentDifficultyAt.getDifficulty().getId() : level.purpurConfig.phantomSpawnMaxPerAttempt - level.purpurConfig.phantomSpawnMinPerAttempt) + 1); // Purpur - Add phantom spawning options
 
                                                 for (int i3 = 0; i3 < i2; i3++) {
                                                     // Paper start - PhantomPreSpawnEvent
diff --git a/net/minecraft/world/level/material/FlowingFluid.java b/net/minecraft/world/level/material/FlowingFluid.java
index 6bac3fb751e114855b9b072a7880ab370f111218..c4675d51bd459fcdc411b48115d512f77a232cef 100644
--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -232,7 +232,7 @@ public abstract class FlowingFluid extends Fluid {
             }
         }
 
-        if (i1 >= 2 && this.canConvertToSource(level)) {
+        if (i1 >= this.getRequiredSources(level) && this.canConvertToSource(level)) { // Purpur - Implement infinite liquids
             BlockState blockState1 = level.getBlockState(mutableBlockPos.setWithOffset(pos, Direction.DOWN));
             FluidState fluidState1 = blockState1.getFluidState();
             if (blockState1.isSolid() || this.isSourceBlockOfThisType(fluidState1)) {
@@ -320,6 +320,12 @@ public abstract class FlowingFluid extends Fluid {
 
     protected abstract boolean canConvertToSource(ServerLevel level);
 
+    // Purpur start - Implement infinite liquids
+    protected int getRequiredSources(Level level) {
+        return 2;
+    }
+    // Purpur end - Implement infinite liquids
+
     protected void spreadTo(LevelAccessor level, BlockPos pos, BlockState blockState, Direction direction, FluidState fluidState) {
         if (blockState.getBlock() instanceof LiquidBlockContainer liquidBlockContainer) {
             liquidBlockContainer.placeLiquid(level, pos, blockState, fluidState);
diff --git a/net/minecraft/world/level/material/LavaFluid.java b/net/minecraft/world/level/material/LavaFluid.java
index 033f252248b671e35135269dd2df6e7ca4585604..43cdc2f8fdfdeb1426e386e0084087779ef62754 100644
--- a/net/minecraft/world/level/material/LavaFluid.java
+++ b/net/minecraft/world/level/material/LavaFluid.java
@@ -189,7 +189,7 @@ public abstract class LavaFluid extends FlowingFluid {
 
     @Override
     public int getTickDelay(LevelReader level) {
-        return level.dimensionType().ultraWarm() ? 10 : 30;
+        return level.dimensionType().ultraWarm() ? level.getWorldBorder().world.purpurConfig.lavaSpeedNether : level.getWorldBorder().world.purpurConfig.lavaSpeedNotNether; // Purpur - Make lava flow speed configurable
     }
 
     @Override
@@ -211,6 +211,13 @@ public abstract class LavaFluid extends FlowingFluid {
         level.levelEvent(1501, pos, 0);
     }
 
+    // Purpur start - Implement infinite liquids
+    @Override
+    protected int getRequiredSources(Level level) {
+        return level.purpurConfig.lavaInfiniteRequiredSources;
+    }
+    // Purpur end - Implement infinite liquids
+
     @Override
     protected boolean canConvertToSource(ServerLevel level) {
         return level.getGameRules().getBoolean(GameRules.RULE_LAVA_SOURCE_CONVERSION);
diff --git a/net/minecraft/world/level/material/WaterFluid.java b/net/minecraft/world/level/material/WaterFluid.java
index 10e3c644e31650b0e1aad6349a83a763cf744ec8..b248fe1d66940c05d56fc322df61c52ece72e77f 100644
--- a/net/minecraft/world/level/material/WaterFluid.java
+++ b/net/minecraft/world/level/material/WaterFluid.java
@@ -78,6 +78,13 @@ public abstract class WaterFluid extends FlowingFluid {
         return level.getGameRules().getBoolean(GameRules.RULE_WATER_SOURCE_CONVERSION);
     }
 
+    // Purpur start - Implement infinite liquids
+    @Override
+    protected int getRequiredSources(Level level) {
+        return level.purpurConfig.waterInfiniteRequiredSources;
+    }
+    // Purpur end - Implement infinite liquids
+
     // Paper start - Add BlockBreakBlockEvent
      @Override
     protected void beforeDestroyingBlock(LevelAccessor level, BlockPos pos, BlockState state, BlockPos source) {
diff --git a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
index 9e6b2bbc1f83d32d0332f036be4f1a0e18b826bf..db6baaa698fe93aba3fbd595158b568badd6cb8a 100644
--- a/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
+++ b/net/minecraft/world/level/pathfinder/WalkNodeEvaluator.java
@@ -240,7 +240,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
                 if ((node == null || node.costMalus < 0.0F)
                     && verticalDeltaLimit > 0
                     && (cachedPathType != PathType.FENCE || this.canWalkOverFences())
-                    && cachedPathType != PathType.UNPASSABLE_RAIL
+                    && (this.mob.level().purpurConfig.mobsIgnoreRails || cachedPathType != PathType.UNPASSABLE_RAIL) // Purpur - Config to allow mobs to pathfind over rails
                     && cachedPathType != PathType.TRAPDOOR
                     && cachedPathType != PathType.POWDER_SNOW) {
                     node = this.tryJumpOn(x, y, z, verticalDeltaLimit, nodeFloorLevel, direction, pathType, mutableBlockPos);
@@ -493,7 +493,7 @@ public class WalkNodeEvaluator extends NodeEvaluator {
             return PathType.TRAPDOOR;
         } else if (blockState.is(Blocks.POWDER_SNOW)) {
             return PathType.POWDER_SNOW;
-        } else if (blockState.is(Blocks.CACTUS) || blockState.is(Blocks.SWEET_BERRY_BUSH)) {
+        } else if (blockState.is(Blocks.CACTUS) || blockState.is(Blocks.SWEET_BERRY_BUSH) || blockState.is(Blocks.STONECUTTER)) { // Purpur - Stonecutter damage
             return PathType.DAMAGE_OTHER;
         } else if (blockState.is(Blocks.HONEY_BLOCK)) {
             return PathType.STICKY_HONEY;
diff --git a/net/minecraft/world/level/portal/PortalShape.java b/net/minecraft/world/level/portal/PortalShape.java
index b19260f442fe272efed8e61d1316bf0d6ff38023..0ecc5a49de322d531c33042858f8420d370f3805 100644
--- a/net/minecraft/world/level/portal/PortalShape.java
+++ b/net/minecraft/world/level/portal/PortalShape.java
@@ -28,7 +28,7 @@ public class PortalShape {
     public static final int MAX_WIDTH = 21;
     private static final int MIN_HEIGHT = 3;
     public static final int MAX_HEIGHT = 21;
-    private static final BlockBehaviour.StatePredicate FRAME = (state, level, pos) -> state.is(Blocks.OBSIDIAN);
+    private static final BlockBehaviour.StatePredicate FRAME = (state, level, pos) -> state.is(Blocks.OBSIDIAN) || (org.purpurmc.purpur.PurpurConfig.cryingObsidianValidForPortalFrame && state.is(Blocks.CRYING_OBSIDIAN)); // Purpur - Crying obsidian valid for portal frames
     private static final float SAFE_TRAVEL_MAX_ENTITY_XY = 4.0F;
     private static final double SAFE_TRAVEL_MAX_VERTICAL_DELTA = 1.0;
     private final Direction.Axis axis;
diff --git a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
index 9f359db7ff21e6e80366b42ddfd98fa6ade100b1..587753a29896e3c85c939507316cb846087bd8b6 100644
--- a/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
+++ b/net/minecraft/world/level/saveddata/maps/MapItemSavedData.java
@@ -81,6 +81,7 @@ public class MapItemSavedData extends SavedData {
     public final Map<String, MapDecoration> decorations = Maps.newLinkedHashMap();
     private final Map<String, MapFrame> frameMarkers = Maps.newHashMap();
     private int trackedDecorationCount;
+    public boolean isExplorerMap; // Purpur - Explorer Map API
 
     // CraftBukkit start
     public final org.bukkit.craftbukkit.map.CraftMapView mapView;
diff --git a/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java b/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
index c4f29da30d63deb3f9eabafcf62a946ff148b6b7..f3083702286dfb7932f08e0b811eded7988cbab4 100644
--- a/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
+++ b/net/minecraft/world/level/storage/loot/functions/EnchantedCountIncreaseFunction.java
@@ -66,6 +66,11 @@ public class EnchantedCountIncreaseFunction extends LootItemConditionalFunction
         Entity entity = context.getOptionalParameter(LootContextParams.ATTACKING_ENTITY);
         if (entity instanceof LivingEntity livingEntity) {
             int enchantmentLevel = EnchantmentHelper.getEnchantmentLevel(this.enchantment, livingEntity);
+            // Purpur start - Add an option to fix MC-3304 projectile looting
+            if (org.purpurmc.purpur.PurpurConfig.fixProjectileLootingTransfer && context.getOptionalParameter(LootContextParams.DIRECT_ATTACKING_ENTITY) instanceof net.minecraft.world.entity.projectile.AbstractArrow arrow) {
+                enchantmentLevel = arrow.actualEnchantments.getLevel(this.enchantment);
+            }
+            // Purpur end - Add an option to fix MC-3304 projectile looting
             if (enchantmentLevel == 0) {
                 return stack;
             }
diff --git a/net/minecraft/world/phys/AABB.java b/net/minecraft/world/phys/AABB.java
index 84f3073444ae9e11e5d11224d6af6474ced925e2..e53398996bbb278c6e06024d8ca945b364a44c10 100644
--- a/net/minecraft/world/phys/AABB.java
+++ b/net/minecraft/world/phys/AABB.java
@@ -476,4 +476,10 @@ public class AABB {
             return new AABB(this.minX, this.minY, this.minZ, this.maxX, this.maxY, this.maxZ);
         }
     }
+
+    // Purpur start - Stop squids floating on top of water - tuinity added method
+    public final AABB offsetY(double dy) {
+        return new AABB(this.minX, this.minY + dy, this.minZ, this.maxX, this.maxY + dy, this.maxZ);
+    }
+    // Purpur end - Stop squids floating on top of water
 }
diff --git a/org/purpurmc/purpur/PurpurConfig.java b/org/purpurmc/purpur/PurpurConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..31bf765d2dfa75d854f7f8e55bab7792ace843ab
--- /dev/null
+++ b/org/purpurmc/purpur/PurpurConfig.java
@@ -0,0 +1,623 @@
+package org.purpurmc.purpur;
+
+import com.google.common.base.Throwables;
+import com.google.common.collect.ImmutableMap;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.regex.Pattern;
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.minecraft.core.Registry;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.core.registries.Registries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EntityDimensions;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.item.enchantment.Enchantment;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import org.bukkit.Bukkit;
+import org.bukkit.command.Command;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+import org.purpurmc.purpur.command.PurpurCommand;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.logging.Level;
+import org.purpurmc.purpur.task.TPSBarTask;
+
+@SuppressWarnings("unused")
+public class PurpurConfig {
+    private static final String HEADER = "This is the main configuration file for Purpur.\n"
+            + "As you can see, there's tons to configure. Some options may impact gameplay, so use\n"
+            + "with caution, and make sure you know what each option does before configuring.\n"
+            + "\n"
+            + "If you need help with the configuration or have any questions related to Purpur,\n"
+            + "join us in our Discord guild.\n"
+            + "\n"
+            + "Website: https://purpurmc.org \n"
+            + "Docs: https://purpurmc.org/docs \n";
+    private static File CONFIG_FILE;
+    public static YamlConfiguration config;
+
+    private static Map<String, Command> commands;
+
+    public static int version;
+    static boolean verbose;
+
+    public static void init(File configFile) {
+        CONFIG_FILE = configFile;
+        config = new YamlConfiguration();
+        try {
+            config.load(CONFIG_FILE);
+        } catch (IOException ignore) {
+        } catch (InvalidConfigurationException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not load purpur.yml, please correct your syntax errors", ex);
+            throw Throwables.propagate(ex);
+        }
+        config.options().header(HEADER);
+        config.options().copyDefaults(true);
+        verbose = getBoolean("verbose", false);
+
+        commands = new HashMap<>();
+        commands.put("purpur", new PurpurCommand("purpur"));
+
+        version = getInt("config-version", 43);
+        set("config-version", 43);
+
+        readConfig(PurpurConfig.class, null);
+
+        Block.BLOCK_STATE_REGISTRY.forEach(BlockBehaviour.BlockStateBase::initCache);
+    }
+
+    protected static void log(String s) {
+        if (verbose) {
+            log(Level.INFO, s);
+        }
+    }
+
+    protected static void log(Level level, String s) {
+        Bukkit.getLogger().log(level, s);
+    }
+
+    public static void registerCommands() {
+        for (Map.Entry<String, Command> entry : commands.entrySet()) {
+            MinecraftServer.getServer().server.getCommandMap().register(entry.getKey(), "Purpur", entry.getValue());
+        }
+    }
+
+    static void readConfig(Class<?> clazz, Object instance) {
+        for (Method method : clazz.getDeclaredMethods()) {
+            if (Modifier.isPrivate(method.getModifiers())) {
+                if (method.getParameterTypes().length == 0 && method.getReturnType() == Void.TYPE) {
+                    try {
+                        method.setAccessible(true);
+                        method.invoke(instance);
+                    } catch (InvocationTargetException ex) {
+                        throw Throwables.propagate(ex.getCause());
+                    } catch (Exception ex) {
+                        Bukkit.getLogger().log(Level.SEVERE, "Error invoking " + method, ex);
+                    }
+                }
+            }
+        }
+
+        try {
+            config.save(CONFIG_FILE);
+        } catch (IOException ex) {
+            Bukkit.getLogger().log(Level.SEVERE, "Could not save " + CONFIG_FILE, ex);
+        }
+    }
+
+    private static void set(String path, Object val) {
+        config.addDefault(path, val);
+        config.set(path, val);
+    }
+
+    private static String getString(String path, String def) {
+        config.addDefault(path, def);
+        return config.getString(path, config.getString(path));
+    }
+
+    private static boolean getBoolean(String path, boolean def) {
+        config.addDefault(path, def);
+        return config.getBoolean(path, config.getBoolean(path));
+    }
+
+    private static double getDouble(String path, double def) {
+        config.addDefault(path, def);
+        return config.getDouble(path, config.getDouble(path));
+    }
+
+    private static int getInt(String path, int def) {
+        config.addDefault(path, def);
+        return config.getInt(path, config.getInt(path));
+    }
+
+    private static <T> List<?> getList(String path, T def) {
+        config.addDefault(path, def);
+        return config.getList(path, config.getList(path));
+    }
+
+    static Map<String, Object> getMap(String path, Map<String, Object> def) {
+        if (def != null && config.getConfigurationSection(path) == null) {
+            config.addDefault(path, def);
+            return def;
+        }
+        return toMap(config.getConfigurationSection(path));
+    }
+
+    private static Map<String, Object> toMap(ConfigurationSection section) {
+        ImmutableMap.Builder<String, Object> builder = ImmutableMap.builder();
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Object obj = section.get(key);
+                if (obj != null) {
+                    builder.put(key, obj instanceof ConfigurationSection val ? toMap(val) : obj);
+                }
+            }
+        }
+        return builder.build();
+    }
+
+    public static String cannotRideMob = "<red>You cannot mount that mob";
+    public static String afkBroadcastAway = "<yellow><italic>%s is now AFK";
+    public static String afkBroadcastBack = "<yellow><italic>%s is no longer AFK";
+    public static boolean afkBroadcastUseDisplayName = false;
+    public static String afkTabListPrefix = "[AFK] ";
+    public static String afkTabListSuffix = "";
+    public static String creditsCommandOutput = "<green>%s has been shown the end credits";
+    public static String demoCommandOutput = "<green>%s has been shown the demo screen";
+    public static String pingCommandOutput = "<green>%s's ping is %sms";
+    public static String ramCommandOutput = "<green>Ram Usage: <used>/<xmx> (<percent>)";
+    public static String rambarCommandOutput = "<green>Rambar toggled <onoff> for <target>";
+    public static String tpsbarCommandOutput = "<green>Tpsbar toggled <onoff> for <target>";
+    public static String dontRunWithScissors = "<red><italic>Don't run with scissors!";
+    public static String uptimeCommandOutput = "<green>Server uptime is <uptime>";
+    public static String unverifiedUsername = "default";
+    public static String sleepSkippingNight = "default";
+    public static String sleepingPlayersPercent = "default";
+    public static String sleepNotPossible = "default";
+    private static void messages() {
+        cannotRideMob = getString("settings.messages.cannot-ride-mob", cannotRideMob);
+        afkBroadcastAway = getString("settings.messages.afk-broadcast-away", afkBroadcastAway);
+        afkBroadcastBack = getString("settings.messages.afk-broadcast-back", afkBroadcastBack);
+        afkBroadcastUseDisplayName = getBoolean("settings.messages.afk-broadcast-use-display-name", afkBroadcastUseDisplayName);
+        afkTabListPrefix = MiniMessage.miniMessage().serialize(MiniMessage.miniMessage().deserialize(getString("settings.messages.afk-tab-list-prefix", afkTabListPrefix)));
+        afkTabListSuffix = MiniMessage.miniMessage().serialize(MiniMessage.miniMessage().deserialize(getString("settings.messages.afk-tab-list-suffix", afkTabListSuffix)));
+        creditsCommandOutput = getString("settings.messages.credits-command-output", creditsCommandOutput);
+        demoCommandOutput = getString("settings.messages.demo-command-output", demoCommandOutput);
+        pingCommandOutput = getString("settings.messages.ping-command-output", pingCommandOutput);
+        ramCommandOutput = getString("settings.messages.ram-command-output", ramCommandOutput);
+        rambarCommandOutput = getString("settings.messages.rambar-command-output", rambarCommandOutput);
+        tpsbarCommandOutput = getString("settings.messages.tpsbar-command-output", tpsbarCommandOutput);
+        dontRunWithScissors = getString("settings.messages.dont-run-with-scissors", dontRunWithScissors);
+        uptimeCommandOutput = getString("settings.messages.uptime-command-output", uptimeCommandOutput);
+        unverifiedUsername = getString("settings.messages.unverified-username", unverifiedUsername);
+        sleepSkippingNight = getString("settings.messages.sleep-skipping-night", sleepSkippingNight);
+        sleepingPlayersPercent = getString("settings.messages.sleeping-players-percent", sleepingPlayersPercent);
+        sleepNotPossible = getString("settings.messages.sleep-not-possible", sleepNotPossible);
+    }
+
+    public static String deathMsgRunWithScissors = "<player> slipped and fell on their shears";
+    public static String deathMsgStonecutter = "<player> has sawed themself in half";
+    private static void deathMessages() {
+        deathMsgRunWithScissors = getString("settings.messages.death-message.run-with-scissors", deathMsgRunWithScissors);
+        deathMsgStonecutter = getString("settings.messages.death-message.stonecutter", deathMsgStonecutter);
+    }
+
+    public static boolean advancementOnlyBroadcastToAffectedPlayer = false;
+    public static boolean deathMessageOnlyBroadcastToAffectedPlayer = false;
+    private static void broadcastSettings() {
+        if (version < 13) {
+            boolean oldValue = getBoolean("settings.advancement.only-broadcast-to-affected-player", false);
+            set("settings.broadcasts.advancement.only-broadcast-to-affected-player", oldValue);
+            set("settings.advancement.only-broadcast-to-affected-player", null);
+        }
+        advancementOnlyBroadcastToAffectedPlayer  = getBoolean("settings.broadcasts.advancement.only-broadcast-to-affected-player", advancementOnlyBroadcastToAffectedPlayer);
+        deathMessageOnlyBroadcastToAffectedPlayer = getBoolean("settings.broadcasts.death.only-broadcast-to-affected-player", deathMessageOnlyBroadcastToAffectedPlayer);
+    }
+
+    public static String serverModName = io.papermc.paper.ServerBuildInfo.buildInfo().brandName();
+    private static void serverModName() {
+        serverModName = getString("settings.server-mod-name", serverModName);
+    }
+
+    public static double laggingThreshold = 19.0D;
+    private static void tickLoopSettings() {
+        laggingThreshold = getDouble("settings.lagging-threshold", laggingThreshold);
+    }
+
+    public static boolean useAlternateKeepAlive = false;
+    private static void useAlternateKeepAlive() {
+        useAlternateKeepAlive = getBoolean("settings.use-alternate-keepalive", useAlternateKeepAlive);
+    }
+
+    public static boolean disableGiveCommandDrops = false;
+    private static void disableGiveCommandDrops() {
+        disableGiveCommandDrops = getBoolean("settings.disable-give-dropping", disableGiveCommandDrops);
+    }
+
+    public static String commandRamBarTitle = "<gray>Ram<yellow>:</yellow> <used>/<xmx> (<percent>)";
+    public static BossBar.Overlay commandRamBarProgressOverlay = BossBar.Overlay.NOTCHED_20;
+    public static BossBar.Color commandRamBarProgressColorGood = BossBar.Color.GREEN;
+    public static BossBar.Color commandRamBarProgressColorMedium = BossBar.Color.YELLOW;
+    public static BossBar.Color commandRamBarProgressColorLow = BossBar.Color.RED;
+    public static String commandRamBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+    public static String commandRamBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+    public static String commandRamBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+    public static int commandRamBarTickInterval = 20;
+    public static String commandTPSBarTitle = "<gray>TPS<yellow>:</yellow> <tps> MSPT<yellow>:</yellow> <mspt> Ping<yellow>:</yellow> <ping>ms";
+    public static BossBar.Overlay commandTPSBarProgressOverlay = BossBar.Overlay.NOTCHED_20;
+    public static TPSBarTask.FillMode commandTPSBarProgressFillMode = TPSBarTask.FillMode.MSPT;
+    public static BossBar.Color commandTPSBarProgressColorGood = BossBar.Color.GREEN;
+    public static BossBar.Color commandTPSBarProgressColorMedium = BossBar.Color.YELLOW;
+    public static BossBar.Color commandTPSBarProgressColorLow = BossBar.Color.RED;
+    public static String commandTPSBarTextColorGood = "<gradient:#55ff55:#00aa00><text></gradient>";
+    public static String commandTPSBarTextColorMedium = "<gradient:#ffff55:#ffaa00><text></gradient>";
+    public static String commandTPSBarTextColorLow = "<gradient:#ff5555:#aa0000><text></gradient>";
+    public static int commandTPSBarTickInterval = 20;
+    public static String commandCompassBarTitle = "S  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  W  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  N  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  E  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  S  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  W  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NW  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  N  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  NE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  E  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  SE  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  \u25C8  \u00B7  ";
+    public static BossBar.Overlay commandCompassBarProgressOverlay = BossBar.Overlay.PROGRESS;
+    public static BossBar.Color commandCompassBarProgressColor = BossBar.Color.BLUE;
+    public static float commandCompassBarProgressPercent = 1.0F;
+    public static int commandCompassBarTickInterval = 5;
+    public static boolean commandGamemodeRequiresPermission = false;
+    public static boolean hideHiddenPlayersFromEntitySelector = false;
+    public static String uptimeFormat = "<days><hours><minutes><seconds>";
+    public static String uptimeDay = "%02d day, ";
+    public static String uptimeDays = "%02d days, ";
+    public static String uptimeHour = "%02d hour, ";
+    public static String uptimeHours = "%02d hours, ";
+    public static String uptimeMinute = "%02d minute, and ";
+    public static String uptimeMinutes = "%02d minutes, and ";
+    public static String uptimeSecond = "%02d second";
+    public static String uptimeSeconds = "%02d seconds";
+    private static void commandSettings() {
+        commandRamBarTitle = getString("settings.command.rambar.title", commandRamBarTitle);
+        commandRamBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.rambar.overlay", commandRamBarProgressOverlay.name()));
+        commandRamBarProgressColorGood = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.good", commandRamBarProgressColorGood.name()));
+        commandRamBarProgressColorMedium = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.medium", commandRamBarProgressColorMedium.name()));
+        commandRamBarProgressColorLow = BossBar.Color.valueOf(getString("settings.command.rambar.progress-color.low", commandRamBarProgressColorLow.name()));
+        commandRamBarTextColorGood = getString("settings.command.rambar.text-color.good", commandRamBarTextColorGood);
+        commandRamBarTextColorMedium = getString("settings.command.rambar.text-color.medium", commandRamBarTextColorMedium);
+        commandRamBarTextColorLow = getString("settings.command.rambar.text-color.low", commandRamBarTextColorLow);
+        commandRamBarTickInterval = getInt("settings.command.rambar.tick-interval", commandRamBarTickInterval);
+
+        commandTPSBarTitle = getString("settings.command.tpsbar.title", commandTPSBarTitle);
+        commandTPSBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.tpsbar.overlay", commandTPSBarProgressOverlay.name()));
+        commandTPSBarProgressFillMode = TPSBarTask.FillMode.valueOf(getString("settings.command.tpsbar.fill-mode", commandTPSBarProgressFillMode.name()));
+        commandTPSBarProgressColorGood = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.good", commandTPSBarProgressColorGood.name()));
+        commandTPSBarProgressColorMedium = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.medium", commandTPSBarProgressColorMedium.name()));
+        commandTPSBarProgressColorLow = BossBar.Color.valueOf(getString("settings.command.tpsbar.progress-color.low", commandTPSBarProgressColorLow.name()));
+        commandTPSBarTextColorGood = getString("settings.command.tpsbar.text-color.good", commandTPSBarTextColorGood);
+        commandTPSBarTextColorMedium = getString("settings.command.tpsbar.text-color.medium", commandTPSBarTextColorMedium);
+        commandTPSBarTextColorLow = getString("settings.command.tpsbar.text-color.low", commandTPSBarTextColorLow);
+        commandTPSBarTickInterval = getInt("settings.command.tpsbar.tick-interval", commandTPSBarTickInterval);
+
+        commandCompassBarTitle = getString("settings.command.compass.title", commandCompassBarTitle);
+        commandCompassBarProgressOverlay = BossBar.Overlay.valueOf(getString("settings.command.compass.overlay", commandCompassBarProgressOverlay.name()));
+        commandCompassBarProgressColor = BossBar.Color.valueOf(getString("settings.command.compass.progress-color", commandCompassBarProgressColor.name()));
+        commandCompassBarProgressPercent = (float) getDouble("settings.command.compass.percent", commandCompassBarProgressPercent);
+        commandCompassBarTickInterval = getInt("settings.command.compass.tick-interval", commandCompassBarTickInterval);
+
+        commandGamemodeRequiresPermission = getBoolean("settings.command.gamemode.requires-specific-permission", commandGamemodeRequiresPermission);
+        hideHiddenPlayersFromEntitySelector = getBoolean("settings.command.hide-hidden-players-from-entity-selector", hideHiddenPlayersFromEntitySelector);
+        uptimeFormat = getString("settings.command.uptime.format", uptimeFormat);
+        uptimeDay = getString("settings.command.uptime.day", uptimeDay);
+        uptimeDays = getString("settings.command.uptime.days", uptimeDays);
+        uptimeHour = getString("settings.command.uptime.hour", uptimeHour);
+        uptimeHours = getString("settings.command.uptime.hours", uptimeHours);
+        uptimeMinute = getString("settings.command.uptime.minute", uptimeMinute);
+        uptimeMinutes = getString("settings.command.uptime.minutes", uptimeMinutes);
+        uptimeSecond = getString("settings.command.uptime.second", uptimeSecond);
+        uptimeSeconds = getString("settings.command.uptime.seconds", uptimeSeconds);
+    }
+
+    public static int barrelRows = 3;
+    public static boolean enderChestSixRows = false;
+    public static boolean enderChestPermissionRows = false;
+    public static boolean cryingObsidianValidForPortalFrame = false;
+    public static int beeInsideBeeHive = 3;
+    public static boolean anvilCumulativeCost = true;
+    public static int smoothSnowAccumulationStep = 0;
+    public static int lightningRodRange = 128;
+    public static Set<Enchantment> grindstoneIgnoredEnchants = new HashSet<>();
+    public static boolean grindstoneRemoveAttributes = false;
+    public static boolean grindstoneRemoveDisplay = false;
+    public static int caveVinesMaxGrowthAge = 25;
+    public static int kelpMaxGrowthAge = 25;
+    public static int twistingVinesMaxGrowthAge = 25;
+    public static int weepingVinesMaxGrowthAge = 25;
+    public static boolean magmaBlockReverseBubbleColumnFlow = false;
+    public static boolean soulSandBlockReverseBubbleColumnFlow = false;
+    private static void blockSettings() {
+        if (version < 3) {
+            boolean oldValue = getBoolean("settings.barrel.packed-barrels", true);
+            set("settings.blocks.barrel.six-rows", oldValue);
+            set("settings.packed-barrels", null);
+            oldValue = getBoolean("settings.large-ender-chests", true);
+            set("settings.blocks.ender_chest.six-rows", oldValue);
+            set("settings.large-ender-chests", null);
+        }
+        if (version < 20) {
+            boolean oldValue = getBoolean("settings.blocks.barrel.six-rows", false);
+            set("settings.blocks.barrel.rows", oldValue ? 6 : 3);
+            set("settings.blocks.barrel.six-rows", null);
+        }
+        barrelRows = getInt("settings.blocks.barrel.rows", barrelRows);
+        if (barrelRows < 1 || barrelRows > 6) {
+            Bukkit.getLogger().severe("settings.blocks.barrel.rows must be 1-6, resetting to default");
+            barrelRows = 3;
+        }
+        org.bukkit.event.inventory.InventoryType.BARREL.setDefaultSize(switch (barrelRows) {
+            case 6 -> 54;
+            case 5 -> 45;
+            case 4 -> 36;
+            case 2 -> 18;
+            case 1 -> 9;
+            default -> 27;
+        });
+        enderChestSixRows = getBoolean("settings.blocks.ender_chest.six-rows", enderChestSixRows);
+        org.bukkit.event.inventory.InventoryType.ENDER_CHEST.setDefaultSize(enderChestSixRows ? 54 : 27);
+        enderChestPermissionRows = getBoolean("settings.blocks.ender_chest.use-permissions-for-rows", enderChestPermissionRows);
+        cryingObsidianValidForPortalFrame = getBoolean("settings.blocks.crying_obsidian.valid-for-portal-frame", cryingObsidianValidForPortalFrame);
+        beeInsideBeeHive = getInt("settings.blocks.beehive.max-bees-inside", beeInsideBeeHive);
+        anvilCumulativeCost = getBoolean("settings.blocks.anvil.cumulative-cost", anvilCumulativeCost);
+        smoothSnowAccumulationStep = getInt("settings.blocks.snow.smooth-accumulation-step", smoothSnowAccumulationStep);
+        if (smoothSnowAccumulationStep > 7) {
+            smoothSnowAccumulationStep = 7;
+            log(Level.WARNING, "blocks.snow.smooth-accumulation-step is set to above maximum allowed value of 7");
+            log(Level.WARNING, "Using value of 7 to prevent issues");
+        } else if (smoothSnowAccumulationStep < 0) {
+            smoothSnowAccumulationStep = 0;
+            log(Level.WARNING, "blocks.snow.smooth-accumulation-step is set to below minimum allowed value of 0");
+            log(Level.WARNING, "Using value of 0 to prevent issues");
+        }
+        lightningRodRange = getInt("settings.blocks.lightning_rod.range", lightningRodRange);
+        ArrayList<String> defaultCurses = new ArrayList<>(){{
+            add("minecraft:binding_curse");
+            add("minecraft:vanishing_curse");
+        }};
+        if (version < 24 && !getBoolean("settings.blocks.grindstone.ignore-curses", true)) {
+            defaultCurses.clear();
+        }
+        getList("settings.blocks.grindstone.ignored-enchants", defaultCurses).forEach(key -> {
+            Registry<Enchantment> registry = MinecraftServer.getServer().registryAccess().lookupOrThrow(Registries.ENCHANTMENT);
+            Enchantment enchantment = registry.getValue(ResourceLocation.parse(key.toString()));
+            if (enchantment == null) return;
+            grindstoneIgnoredEnchants.add(enchantment);
+        });
+        grindstoneRemoveAttributes = getBoolean("settings.blocks.grindstone.remove-attributes", grindstoneRemoveAttributes);
+        grindstoneRemoveDisplay = getBoolean("settings.blocks.grindstone.remove-name-and-lore", grindstoneRemoveDisplay);
+        caveVinesMaxGrowthAge = getInt("settings.blocks.cave_vines.max-growth-age", caveVinesMaxGrowthAge);
+        if (caveVinesMaxGrowthAge > 25) {
+            caveVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.cave_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        kelpMaxGrowthAge = getInt("settings.blocks.kelp.max-growth-age", kelpMaxGrowthAge);
+        if (kelpMaxGrowthAge > 25) {
+            kelpMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.kelp.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        twistingVinesMaxGrowthAge = getInt("settings.blocks.twisting_vines.max-growth-age", twistingVinesMaxGrowthAge);
+        if (twistingVinesMaxGrowthAge > 25) {
+            twistingVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.twisting_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        weepingVinesMaxGrowthAge = getInt("settings.blocks.weeping_vines.max-growth-age", weepingVinesMaxGrowthAge);
+        if (weepingVinesMaxGrowthAge > 25) {
+            weepingVinesMaxGrowthAge = 25;
+            log(Level.WARNING, "blocks.weeping_vines.max-growth-age is set to above maximum allowed value of 25");
+            log(Level.WARNING, "Using value of 25 to prevent issues");
+        }
+        magmaBlockReverseBubbleColumnFlow = getBoolean("settings.blocks.magma-block.reverse-bubble-column-flow", magmaBlockReverseBubbleColumnFlow);
+        soulSandBlockReverseBubbleColumnFlow = getBoolean("settings.blocks.soul-sand.reverse-bubble-column-flow", soulSandBlockReverseBubbleColumnFlow);
+    }
+
+    public static boolean allowInapplicableEnchants = false;
+    public static boolean allowIncompatibleEnchants = false;
+    public static boolean allowHigherEnchantsLevels = false;
+    public static boolean allowUnsafeEnchantCommand = false;
+    public static boolean replaceIncompatibleEnchants = false;
+    public static boolean clampEnchantLevels = true;
+    private static void enchantmentSettings() {
+        if (version < 30) {
+            boolean oldValue = getBoolean("settings.enchantment.allow-unsafe-enchants", false);
+            set("settings.enchantment.anvil.allow-unsafe-enchants", oldValue);
+            set("settings.enchantment.anvil.allow-inapplicable-enchants", true);
+            set("settings.enchantment.anvil.allow-incompatible-enchants", true);
+            set("settings.enchantment.anvil.allow-higher-enchants-levels", true);
+            set("settings.enchantment.allow-unsafe-enchants", null);
+        }
+        if (version < 37) {
+            boolean allowUnsafeEnchants = getBoolean("settings.enchantment.anvil.allow-unsafe-enchants", false);
+            if (!allowUnsafeEnchants) {
+                set("settings.enchantment.anvil.allow-inapplicable-enchants", false);
+                set("settings.enchantment.anvil.allow-incompatible-enchants", false);
+                set("settings.enchantment.anvil.allow-higher-enchants-levels", false);
+            }
+            set("settings.enchantment.anvil.allow-unsafe-enchants", null);
+        }
+        allowInapplicableEnchants = getBoolean("settings.enchantment.anvil.allow-inapplicable-enchants", allowInapplicableEnchants);
+        allowIncompatibleEnchants = getBoolean("settings.enchantment.anvil.allow-incompatible-enchants", allowIncompatibleEnchants);
+        allowHigherEnchantsLevels = getBoolean("settings.enchantment.anvil.allow-higher-enchants-levels", allowHigherEnchantsLevels);
+        allowUnsafeEnchantCommand = getBoolean("settings.enchantment.allow-unsafe-enchant-command", allowUnsafeEnchantCommand);
+        replaceIncompatibleEnchants = getBoolean("settings.enchantment.anvil.replace-incompatible-enchants", replaceIncompatibleEnchants);
+        clampEnchantLevels = getBoolean("settings.enchantment.clamp-levels", clampEnchantLevels);
+    }
+
+    public static boolean endermanShortHeight = false;
+    private static void entitySettings() {
+        endermanShortHeight = getBoolean("settings.entity.enderman.short-height", endermanShortHeight);
+        if (endermanShortHeight) EntityType.ENDERMAN.dimensions = EntityDimensions.scalable(0.6F, 1.9F);
+    }
+
+    public static boolean allowWaterPlacementInTheEnd = true;
+    private static void allowWaterPlacementInEnd() {
+        allowWaterPlacementInTheEnd = getBoolean("settings.allow-water-placement-in-the-end", allowWaterPlacementInTheEnd);
+    }
+
+    public static boolean beeCountPayload = false;
+    private static void beeCountPayload() {
+        beeCountPayload = getBoolean("settings.bee-count-payload", beeCountPayload);
+    }
+
+    public static boolean loggerSuppressInitLegacyMaterialError = false;
+    public static boolean loggerSuppressIgnoredAdvancementWarnings = false;
+    public static boolean loggerSuppressUnrecognizedRecipeErrors = false;
+    public static boolean loggerSuppressSetBlockFarChunk = false;
+    public static boolean loggerSuppressLibraryLoader = false;
+    private static void loggerSettings() {
+        loggerSuppressInitLegacyMaterialError = getBoolean("settings.logger.suppress-init-legacy-material-errors", loggerSuppressInitLegacyMaterialError);
+        loggerSuppressIgnoredAdvancementWarnings = getBoolean("settings.logger.suppress-ignored-advancement-warnings", loggerSuppressIgnoredAdvancementWarnings);
+        loggerSuppressUnrecognizedRecipeErrors = getBoolean("settings.logger.suppress-unrecognized-recipe-errors", loggerSuppressUnrecognizedRecipeErrors);
+        loggerSuppressSetBlockFarChunk = getBoolean("settings.logger.suppress-setblock-in-far-chunk-errors", loggerSuppressSetBlockFarChunk);
+        loggerSuppressLibraryLoader = getBoolean("settings.logger.suppress-library-loader", loggerSuppressLibraryLoader);
+        org.bukkit.plugin.java.JavaPluginLoader.SuppressLibraryLoaderLogger = loggerSuppressLibraryLoader;
+    }
+
+    public static boolean tpsCatchup = true;
+    private static void tpsCatchup() {
+        tpsCatchup = getBoolean("settings.tps-catchup", tpsCatchup);
+    }
+
+    public static boolean useUPnP = false;
+    public static boolean maxJoinsPerSecond = false;
+    public static boolean kickForOutOfOrderChat = true;
+    private static void networkSettings() {
+        useUPnP = getBoolean("settings.network.upnp-port-forwarding", useUPnP);
+        maxJoinsPerSecond = getBoolean("settings.network.max-joins-per-second", maxJoinsPerSecond);
+        kickForOutOfOrderChat = getBoolean("settings.network.kick-for-out-of-order-chat", kickForOutOfOrderChat);
+    }
+
+    public static Pattern usernameValidCharactersPattern;
+    private static void usernameValidationSettings() {
+        String defaultPattern = "^[a-zA-Z0-9_.]*$";
+        String setPattern = getString("settings.username-valid-characters", defaultPattern);
+        usernameValidCharactersPattern = Pattern.compile(setPattern == null || setPattern.isBlank() ? defaultPattern : setPattern);
+    }
+
+    public static boolean fixProjectileLootingTransfer = false;
+    private static void fixProjectileLootingTransfer() {
+        fixProjectileLootingTransfer = getBoolean("settings.fix-projectile-looting-transfer", fixProjectileLootingTransfer);
+    }
+
+    public static boolean clampAttributes = true;
+    private static void clampAttributes() {
+        clampAttributes = getBoolean("settings.clamp-attributes", clampAttributes);
+    }
+
+    public static boolean limitArmor = true;
+    private static void limitArmor() {
+        limitArmor = getBoolean("settings.limit-armor", limitArmor);
+    }
+
+    private static void blastResistanceSettings() {
+        getMap("settings.blast-resistance-overrides", Collections.emptyMap()).forEach((blockId, value) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) {
+                log(Level.SEVERE, "Invalid block for `settings.blast-resistance-overrides`: " + blockId);
+                return;
+            }
+            if (!(value instanceof Number blastResistance)) {
+                log(Level.SEVERE, "Invalid blast resistance for `settings.blast-resistance-overrides." + blockId + "`: " + value);
+                return;
+            }
+            block.explosionResistance = blastResistance.floatValue();
+        });
+    }
+    private static void blockFallMultiplierSettings() {
+        getMap("settings.block-fall-multipliers", Map.ofEntries(
+                Map.entry("minecraft:hay_block", Map.of("damage", 0.2F)),
+                Map.entry("minecraft:white_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:light_gray_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:gray_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:black_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:brown_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:pink_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:red_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:orange_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:yellow_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:green_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:lime_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:cyan_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:light_blue_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:blue_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:purple_bed", Map.of("distance", 0.5F)),
+                Map.entry("minecraft:magenta_bed", Map.of("distance", 0.5F))
+        )).forEach((blockId, value) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) {
+                log(Level.SEVERE, "Invalid block for `settings.block-fall-multipliers`: " + blockId);
+                return;
+            }
+            if (!(value instanceof Map<?, ?> map)) {
+                log(Level.SEVERE, "Invalid fall multiplier for `settings.block-fall-multipliers." + blockId + "`: " + value
+                        + ", expected a map with keys `damage` and `distance` to floats.");
+                return;
+            }
+            Object rawFallDamageMultiplier = map.get("damage");
+            if (rawFallDamageMultiplier == null) rawFallDamageMultiplier = 1F;
+            if (!(rawFallDamageMultiplier instanceof Number fallDamageMultiplier)) {
+                log(Level.SEVERE, "Invalid multiplier for `settings.block-fall-multipliers." + blockId + ".damage`: " + map.get("damage"));
+                return;
+            }
+            Object rawFallDistanceMultiplier = map.get("distance");
+            if (rawFallDistanceMultiplier == null) rawFallDistanceMultiplier = 1F;
+            if (!(rawFallDistanceMultiplier instanceof Number fallDistanceMultiplier)) {
+                log(Level.SEVERE, "Invalid multiplier for `settings.block-fall-multipliers." + blockId + ".distance`: " + map.get("distance"));
+                return;
+            }
+            block.fallDamageMultiplier = fallDamageMultiplier.floatValue();
+            block.fallDistanceMultiplier = fallDistanceMultiplier.floatValue();
+        });
+    }
+
+    public static boolean playerDeathsAlwaysShowItem = false;
+    private static void playerDeathsAlwaysShowItem() {
+        playerDeathsAlwaysShowItem = getBoolean("settings.player-deaths-always-show-item", playerDeathsAlwaysShowItem);
+    }
+
+    public static boolean registerMinecraftDebugCommands = false;
+    private static void registerMinecraftDebugCommands() {
+        registerMinecraftDebugCommands = getBoolean("settings.register-minecraft-debug-commands", registerMinecraftDebugCommands);
+    }
+
+    public static boolean registerMinecraftDisabledCommands = false;
+    private static void registerMinecraftDisabledCommands() {
+        registerMinecraftDisabledCommands = getBoolean("settings.register-minecraft-disabled-commands", registerMinecraftDebugCommands);
+    }
+
+    public static List<String> startupCommands = new ArrayList<>();
+    private static void startupCommands() {
+        startupCommands.clear();
+        getList("settings.startup-commands", new ArrayList<String>()).forEach(line -> {
+            String command = line.toString();
+            if (command.startsWith("/")) {
+                command = command.substring(1);
+            }
+            startupCommands.add(command);
+        });
+    }
+    
+    public static boolean generateEndVoidRings = false;
+    private static void generateEndVoidRings() {
+        generateEndVoidRings = getBoolean("settings.generate-end-void-rings", generateEndVoidRings);
+    }
+}
diff --git a/org/purpurmc/purpur/PurpurWorldConfig.java b/org/purpurmc/purpur/PurpurWorldConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..a03e166b490952534e8050654c1afa975795f731
--- /dev/null
+++ b/org/purpurmc/purpur/PurpurWorldConfig.java
@@ -0,0 +1,3614 @@
+package org.purpurmc.purpur;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.logging.Level;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.resources.ResourceLocation;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.monster.Shulker;
+import net.minecraft.world.item.DyeColor;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.Items;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.Blocks;
+import net.minecraft.world.level.block.state.properties.Tilt;
+import org.apache.commons.lang3.BooleanUtils;
+import org.bukkit.ChatColor;
+import org.bukkit.World;
+import org.bukkit.configuration.ConfigurationSection;
+import java.util.List;
+import java.util.Map;
+import org.purpurmc.purpur.tool.Flattenable;
+import org.purpurmc.purpur.tool.Strippable;
+import org.purpurmc.purpur.tool.Tillable;
+import org.purpurmc.purpur.tool.Waxable;
+import org.purpurmc.purpur.tool.Weatherable;
+
+import static org.purpurmc.purpur.PurpurConfig.log;
+
+@SuppressWarnings("unused")
+public class PurpurWorldConfig {
+
+    private final String worldName;
+    private final World.Environment environment;
+
+    public PurpurWorldConfig(String worldName, World.Environment environment) {
+        this.worldName = worldName;
+        this.environment = environment;
+        init();
+    }
+
+    public void init() {
+        log("-------- World Settings For [" + worldName + "] --------");
+        PurpurConfig.readConfig(PurpurWorldConfig.class, this);
+    }
+
+    private void set(String path, Object val) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null || val == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, val);
+            PurpurConfig.config.set("world-settings.default." + path, val);
+        }
+        if (PurpurConfig.config.get("world-settings." + worldName + "." + path) != null) {
+            PurpurConfig.config.addDefault("world-settings." + worldName + "." + path, val);
+            PurpurConfig.config.set("world-settings." + worldName + "." + path, val);
+        }
+    }
+
+    private ConfigurationSection getConfigurationSection(String path) {
+        ConfigurationSection section = PurpurConfig.config.getConfigurationSection("world-settings." + worldName + "." + path);
+        return section != null ? section : PurpurConfig.config.getConfigurationSection("world-settings.default." + path);
+    }
+
+    private String getString(String path, String def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getString("world-settings." + worldName + "." + path, PurpurConfig.config.getString("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, boolean def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getBoolean("world-settings." + worldName + "." + path, PurpurConfig.config.getBoolean("world-settings.default." + path));
+    }
+
+    private boolean getBoolean(String path, Predicate<Boolean> predicate) {
+        String val = getString(path, "default").toLowerCase();
+        Boolean bool = BooleanUtils.toBooleanObject(val, "true", "false", "default");
+        return predicate.test(bool);
+    }
+
+    private Boolean getBooleanOrDefault(String path, Boolean def) {
+        String val = getString(path, BooleanUtils.toString(def, "true", "false", "default")).toLowerCase();
+        return BooleanUtils.toBooleanObject(val, "true", "false", "default");
+    }
+
+    private double getDouble(String path, double def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getDouble("world-settings." + worldName + "." + path, PurpurConfig.config.getDouble("world-settings.default." + path));
+    }
+
+    private int getInt(String path, int def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getInt("world-settings." + worldName + "." + path, PurpurConfig.config.getInt("world-settings.default." + path));
+    }
+
+    private <T> List<?> getList(String path, T def) {
+        if (PurpurConfig.config.get("world-settings.default." + path) == null) {
+            PurpurConfig.config.addDefault("world-settings.default." + path, def);
+        }
+        return PurpurConfig.config.getList("world-settings." + worldName + "." + path, PurpurConfig.config.getList("world-settings.default." + path));
+    }
+
+    private Map<String, Object> getMap(String path, Map<String, Object> def) {
+        final Map<String, Object> fallback = PurpurConfig.getMap("world-settings.default." + path, def);
+        final Map<String, Object> value = PurpurConfig.getMap("world-settings." + worldName + "." + path, null);
+        return value.isEmpty() ? fallback : value;
+    }
+
+    public float armorstandStepHeight = 0.0F;
+    public boolean armorstandSetNameVisible = false;
+    public boolean armorstandFixNametags = false;
+    public boolean armorstandMovement = true;
+    public boolean armorstandWaterMovement = true;
+    public boolean armorstandWaterFence = true;
+    public boolean armorstandPlaceWithArms = false;
+    private void armorstandSettings() {
+        armorstandStepHeight = (float) getDouble("gameplay-mechanics.armorstand.step-height", armorstandStepHeight);
+        armorstandSetNameVisible = getBoolean("gameplay-mechanics.armorstand.set-name-visible-when-placing-with-custom-name", armorstandSetNameVisible);
+        armorstandFixNametags = getBoolean("gameplay-mechanics.armorstand.fix-nametags", armorstandFixNametags);
+        armorstandMovement = getBoolean("gameplay-mechanics.armorstand.can-movement-tick", armorstandMovement);
+        armorstandWaterMovement = getBoolean("gameplay-mechanics.armorstand.can-move-in-water", armorstandWaterMovement);
+        armorstandWaterFence = getBoolean("gameplay-mechanics.armorstand.can-move-in-water-over-fence", armorstandWaterFence);
+        armorstandPlaceWithArms = getBoolean("gameplay-mechanics.armorstand.place-with-arms-visible", armorstandPlaceWithArms);
+    }
+
+    public boolean arrowMovementResetsDespawnCounter = true;
+    private void arrowSettings() {
+        arrowMovementResetsDespawnCounter = getBoolean("gameplay-mechanics.arrow.movement-resets-despawn-counter", arrowMovementResetsDespawnCounter);
+    }
+
+    public boolean useBetterMending = false;
+    public boolean alwaysTameInCreative = false;
+    public boolean boatEjectPlayersOnLand = false;
+    public boolean boatsDoFallDamage = false;
+    public boolean disableDropsOnCrammingDeath = false;
+    public boolean milkCuresBadOmen = true;
+    public double tridentLoyaltyVoidReturnHeight = 0.0D;
+    public boolean entitiesCanUsePortals = true;
+    public int raidCooldownSeconds = 0;
+    public int animalBreedingCooldownSeconds = 0;
+    public boolean persistentDroppableEntityDisplayNames = true;
+    public Boolean entitiesPickUpLootMobGriefingOverride = null;
+    public Boolean fireballsMobGriefingOverride = null;
+    public Boolean projectilesMobGriefingOverride = null;
+    public boolean noteBlockIgnoreAbove = false;
+    public boolean imposeTeleportRestrictionsOnGateways = false;
+    public boolean imposeTeleportRestrictionsOnNetherPortals = false;
+    public boolean imposeTeleportRestrictionsOnEndPortals = false;
+    public boolean tickFluids = true;
+    public double mobsBlindnessMultiplier = 1;
+    public boolean mobsIgnoreRails = false;
+    public boolean rainStopsAfterSleep = true;
+    public boolean thunderStopsAfterSleep = true;
+    public boolean persistentTileEntityLore = false;
+    public boolean persistentTileEntityDisplayName = true;
+    public int mobLastHurtByPlayerTime = 100;
+    public boolean milkClearsBeneficialEffects = true;
+    public boolean disableOxidationProximityPenalty = false;
+    private void miscGameplayMechanicsSettings() {
+        useBetterMending = getBoolean("gameplay-mechanics.use-better-mending", useBetterMending);
+        alwaysTameInCreative = getBoolean("gameplay-mechanics.always-tame-in-creative", alwaysTameInCreative);
+        boatEjectPlayersOnLand = getBoolean("gameplay-mechanics.boat.eject-players-on-land", boatEjectPlayersOnLand);
+        boatsDoFallDamage = getBoolean("gameplay-mechanics.boat.do-fall-damage", boatsDoFallDamage);
+        disableDropsOnCrammingDeath = getBoolean("gameplay-mechanics.disable-drops-on-cramming-death", disableDropsOnCrammingDeath);
+        milkCuresBadOmen = getBoolean("gameplay-mechanics.milk-cures-bad-omen", milkCuresBadOmen);
+        tridentLoyaltyVoidReturnHeight = getDouble("gameplay-mechanics.trident-loyalty-void-return-height", tridentLoyaltyVoidReturnHeight);
+        entitiesCanUsePortals = getBoolean("gameplay-mechanics.entities-can-use-portals", entitiesCanUsePortals);
+        raidCooldownSeconds = getInt("gameplay-mechanics.raid-cooldown-seconds", raidCooldownSeconds);
+        animalBreedingCooldownSeconds = getInt("gameplay-mechanics.animal-breeding-cooldown-seconds", animalBreedingCooldownSeconds);
+        persistentDroppableEntityDisplayNames = getBoolean("gameplay-mechanics.persistent-droppable-entity-display-names", persistentDroppableEntityDisplayNames);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("gameplay-mechanics.entities-pick-up-loot-bypass-mob-griefing", false);
+            set("gameplay-mechanics.entities-pick-up-loot-bypass-mob-griefing", null);
+            set("gameplay-mechanics.entities-pick-up-loot-mob-griefing-override", oldVal ? true : "default");
+            boolean oldVal2 = getBoolean("gameplay-mechanics.fireballs-bypass-mob-griefing", false);
+            set("gameplay-mechanics.fireballs-bypass-mob-griefing", null);
+            set("gameplay-mechanics.fireballs-mob-griefing-override", oldVal2 ? true : "default");
+            boolean oldVal3 = getBoolean("gameplay-mechanics.projectiles-bypass-mob-griefing", false);
+            set("gameplay-mechanics.projectiles-bypass-mob-griefing", null);
+            set("gameplay-mechanics.projectiles-mob-griefing-override", oldVal3 ? true : "default");
+        }
+        entitiesPickUpLootMobGriefingOverride = getBooleanOrDefault("gameplay-mechanics.entities-pick-up-loot-mob-griefing-override", entitiesPickUpLootMobGriefingOverride);
+        fireballsMobGriefingOverride = getBooleanOrDefault("gameplay-mechanics.fireballs-mob-griefing-override", fireballsMobGriefingOverride);
+        projectilesMobGriefingOverride = getBooleanOrDefault("gameplay-mechanics.projectiles-mob-griefing-override", projectilesMobGriefingOverride);
+        noteBlockIgnoreAbove = getBoolean("gameplay-mechanics.note-block-ignore-above", noteBlockIgnoreAbove);
+        imposeTeleportRestrictionsOnGateways = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-gateways", imposeTeleportRestrictionsOnGateways);
+        imposeTeleportRestrictionsOnNetherPortals = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-nether-portals", imposeTeleportRestrictionsOnNetherPortals);
+        imposeTeleportRestrictionsOnEndPortals = getBoolean("gameplay-mechanics.impose-teleport-restrictions-on-end-portals", imposeTeleportRestrictionsOnEndPortals);
+        tickFluids = getBoolean("gameplay-mechanics.tick-fluids", tickFluids);
+        mobsBlindnessMultiplier = getDouble("gameplay-mechanics.entity-blindness-multiplier", mobsBlindnessMultiplier);
+        mobsIgnoreRails = getBoolean("gameplay-mechanics.mobs-ignore-rails", mobsIgnoreRails);
+        rainStopsAfterSleep = getBoolean("gameplay-mechanics.rain-stops-after-sleep", rainStopsAfterSleep);
+        thunderStopsAfterSleep = getBoolean("gameplay-mechanics.thunder-stops-after-sleep", thunderStopsAfterSleep);
+        if (PurpurConfig.version < 35) {
+            boolean oldVal = getBoolean("gameplay-mechanics.persistent-tileentity-display-names-and-lore", persistentTileEntityLore);
+            set("gameplay-mechanics.persistent-tileentity-display-names-and-lore", null);
+            set("gameplay-mechanics.persistent-tileentity-lore", oldVal);
+            set("gameplay-mechanics.persistent-tileentity-display-name", !oldVal);
+        }
+        persistentTileEntityLore = getBoolean("gameplay-mechanics.persistent-tileentity-lore", persistentTileEntityLore);
+        persistentTileEntityDisplayName = getBoolean("gameplay-mechanics.persistent-tileentity-display-name", persistentTileEntityDisplayName);
+        mobLastHurtByPlayerTime = getInt("gameplay-mechanics.mob-last-hurt-by-player-time", mobLastHurtByPlayerTime);
+        milkClearsBeneficialEffects = getBoolean("gameplay-mechanics.milk-clears-beneficial-effects", milkClearsBeneficialEffects);
+        disableOxidationProximityPenalty = getBoolean("gameplay-mechanics.disable-oxidation-proximity-penalty", disableOxidationProximityPenalty);
+    }
+
+    public int daytimeTicks = 12000;
+    public int nighttimeTicks = 12000;
+    private void daytimeCycleSettings() {
+        daytimeTicks = getInt("gameplay-mechanics.daylight-cycle-ticks.daytime", daytimeTicks);
+        nighttimeTicks = getInt("gameplay-mechanics.daylight-cycle-ticks.nighttime", nighttimeTicks);
+    }
+
+    public int drowningAirTicks = 300;
+    public int drowningDamageInterval = 20;
+    public double damageFromDrowning = 2.0F;
+    private void drowningSettings() {
+        drowningAirTicks = getInt("gameplay-mechanics.drowning.air-ticks", drowningAirTicks);
+        drowningDamageInterval = getInt("gameplay-mechanics.drowning.ticks-per-damage", drowningDamageInterval);
+        damageFromDrowning = getDouble("gameplay-mechanics.drowning.damage-from-drowning", damageFromDrowning);
+    }
+
+    public int elytraDamagePerSecond = 1;
+    public double elytraDamageMultiplyBySpeed = 0;
+    public int elytraDamagePerFireworkBoost = 0;
+    public int elytraDamagePerTridentBoost = 0;
+    public boolean elytraKineticDamage = true;
+    private void elytraSettings() {
+        elytraDamagePerSecond = getInt("gameplay-mechanics.elytra.damage-per-second", elytraDamagePerSecond);
+        elytraDamageMultiplyBySpeed = getDouble("gameplay-mechanics.elytra.damage-multiplied-by-speed", elytraDamageMultiplyBySpeed);
+        elytraDamagePerFireworkBoost = getInt("gameplay-mechanics.elytra.damage-per-boost.firework", elytraDamagePerFireworkBoost);
+        elytraDamagePerTridentBoost = getInt("gameplay-mechanics.elytra.damage-per-boost.trident", elytraDamagePerTridentBoost);
+        elytraKineticDamage = getBoolean("gameplay-mechanics.elytra.kinetic-damage", elytraKineticDamage);
+    }
+
+    public int entityLifeSpan = 0;
+    public float entityLeftHandedChance = 0.05f;
+    public boolean entitySharedRandom = true;
+    private void entitySettings() {
+        entityLifeSpan = getInt("gameplay-mechanics.entity-lifespan", entityLifeSpan);
+        entityLeftHandedChance = (float) getDouble("gameplay-mechanics.entity-left-handed-chance", entityLeftHandedChance);
+        entitySharedRandom = getBoolean("settings.entity.shared-random", entitySharedRandom);
+    }
+
+    public boolean infinityWorksWithoutArrows = false;
+    private void infinityArrowsSettings() {
+        infinityWorksWithoutArrows = getBoolean("gameplay-mechanics.infinity-bow.works-without-arrows", infinityWorksWithoutArrows);
+    }
+
+    public List<Item> itemImmuneToCactus = new ArrayList<>();
+    public List<Item> itemImmuneToExplosion = new ArrayList<>();
+    public List<Item> itemImmuneToFire = new ArrayList<>();
+    public List<Item> itemImmuneToLightning = new ArrayList<>();
+    public boolean dontRunWithScissors = false;
+    public ResourceLocation dontRunWithScissorsItemModelReference = ResourceLocation.parse("purpurmc:scissors");
+    public boolean ignoreScissorsInWater = false;
+    public boolean ignoreScissorsInLava = false;
+    public double scissorsRunningDamage = 1D;
+    public float enderPearlDamage = 5.0F;
+    public int enderPearlCooldown = 20;
+    public int enderPearlCooldownCreative = 20;
+    public float enderPearlEndermiteChance = 0.05F;
+    public int glowBerriesEatGlowDuration = 0;
+    public boolean shulkerBoxItemDropContentsWhenDestroyed = true;
+    public boolean compassItemShowsBossBar = false;
+    public boolean snowballExtinguishesFire = false;
+    public boolean snowballExtinguishesCandles = false;
+    public boolean snowballExtinguishesCampfires = false;
+    private void itemSettings() {
+        itemImmuneToCactus.clear();
+        getList("gameplay-mechanics.item.immune.cactus", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToCactus.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToCactus.add(item);
+        });
+        itemImmuneToExplosion.clear();
+        getList("gameplay-mechanics.item.immune.explosion", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToExplosion.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToExplosion.add(item);
+        });
+        itemImmuneToFire.clear();
+        getList("gameplay-mechanics.item.immune.fire", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToFire.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToFire.add(item);
+        });
+        itemImmuneToLightning.clear();
+        getList("gameplay-mechanics.item.immune.lightning", new ArrayList<>()).forEach(key -> {
+            if (key.toString().equals("*")) {
+                BuiltInRegistries.ITEM.stream().filter(item -> item != Items.AIR).forEach((item) -> itemImmuneToLightning.add(item));
+                return;
+            }
+            Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(key.toString()));
+            if (item != Items.AIR) itemImmuneToLightning.add(item);
+        });
+        dontRunWithScissors = getBoolean("gameplay-mechanics.item.shears.damage-if-sprinting", dontRunWithScissors);
+        dontRunWithScissorsItemModelReference = ResourceLocation.parse(getString("gameplay-mechanics.item.shears.damage-if-sprinting-item-model", "purpurmc:scissors"));
+        ignoreScissorsInWater = getBoolean("gameplay-mechanics.item.shears.ignore-in-water", ignoreScissorsInWater);
+        ignoreScissorsInLava = getBoolean("gameplay-mechanics.item.shears.ignore-in-lava", ignoreScissorsInLava);
+        scissorsRunningDamage = getDouble("gameplay-mechanics.item.shears.sprinting-damage", scissorsRunningDamage);
+        enderPearlDamage = (float) getDouble("gameplay-mechanics.item.ender-pearl.damage", enderPearlDamage);
+        enderPearlCooldown = getInt("gameplay-mechanics.item.ender-pearl.cooldown", enderPearlCooldown);
+        enderPearlCooldownCreative = getInt("gameplay-mechanics.item.ender-pearl.creative-cooldown", enderPearlCooldownCreative);
+        enderPearlEndermiteChance = (float) getDouble("gameplay-mechanics.item.ender-pearl.endermite-spawn-chance", enderPearlEndermiteChance);
+        glowBerriesEatGlowDuration = getInt("gameplay-mechanics.item.glow_berries.eat-glow-duration", glowBerriesEatGlowDuration);
+        shulkerBoxItemDropContentsWhenDestroyed = getBoolean("gameplay-mechanics.item.shulker_box.drop-contents-when-destroyed", shulkerBoxItemDropContentsWhenDestroyed);
+        compassItemShowsBossBar = getBoolean("gameplay-mechanics.item.compass.holding-shows-bossbar", compassItemShowsBossBar);
+        snowballExtinguishesFire = getBoolean("gameplay-mechanics.item.snowball.extinguish.fire", snowballExtinguishesFire);
+        snowballExtinguishesCandles = getBoolean("gameplay-mechanics.item.snowball.extinguish.candles", snowballExtinguishesCandles);
+        snowballExtinguishesCampfires = getBoolean("gameplay-mechanics.item.snowball.extinguish.campfires", snowballExtinguishesCampfires);
+    }
+
+    public double minecartMaxSpeed = 0.4D;
+    public boolean minecartPlaceAnywhere = false;
+    public boolean minecartControllable = false;
+    public float minecartControllableStepHeight = 1.0F;
+    public double minecartControllableHopBoost = 0.5D;
+    public boolean minecartControllableFallDamage = true;
+    public double minecartControllableBaseSpeed = 0.1D;
+    public Map<Block, Double> minecartControllableBlockSpeeds = new HashMap<>();
+    public double poweredRailBoostModifier = 0.06;
+    private void minecartSettings() {
+        if (PurpurConfig.version < 12) {
+            boolean oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.place-anywhere", minecartPlaceAnywhere);
+            set("gameplay-mechanics.controllable-minecarts.place-anywhere", null);
+            set("gameplay-mechanics.minecart.place-anywhere", oldBool);
+            oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.enabled", minecartControllable);
+            set("gameplay-mechanics.controllable-minecarts.enabled", null);
+            set("gameplay-mechanics.minecart.controllable.enabled", oldBool);
+            double oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.step-height", minecartControllableStepHeight);
+            set("gameplay-mechanics.controllable-minecarts.step-height", null);
+            set("gameplay-mechanics.minecart.controllable.step-height", oldDouble);
+            oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.hop-boost", minecartControllableHopBoost);
+            set("gameplay-mechanics.controllable-minecarts.hop-boost", null);
+            set("gameplay-mechanics.minecart.controllable.hop-boost", oldDouble);
+            oldBool = getBoolean("gameplay-mechanics.controllable-minecarts.fall-damage", minecartControllableFallDamage);
+            set("gameplay-mechanics.controllable-minecarts.fall-damage", null);
+            set("gameplay-mechanics.minecart.controllable.fall-damage", oldBool);
+            oldDouble = getDouble("gameplay-mechanics.controllable-minecarts.base-speed", minecartControllableBaseSpeed);
+            set("gameplay-mechanics.controllable-minecarts.base-speed", null);
+            set("gameplay-mechanics.minecart.controllable.base-speed", oldDouble);
+            ConfigurationSection section = getConfigurationSection("gameplay-mechanics.controllable-minecarts.block-speed");
+            if (section != null) {
+                for (String key : section.getKeys(false)) {
+                    if ("grass-block".equals(key)) key = "grass_block"; // oopsie
+                    oldDouble = section.getDouble(key, minecartControllableBaseSpeed);
+                    set("gameplay-mechanics.controllable-minecarts.block-speed." + key, null);
+                    set("gameplay-mechanics.minecart.controllable.block-speed." + key, oldDouble);
+                }
+                set("gameplay-mechanics.controllable-minecarts.block-speed", null);
+            }
+            set("gameplay-mechanics.controllable-minecarts", null);
+        }
+
+        minecartMaxSpeed = getDouble("gameplay-mechanics.minecart.max-speed", minecartMaxSpeed);
+        minecartPlaceAnywhere = getBoolean("gameplay-mechanics.minecart.place-anywhere", minecartPlaceAnywhere);
+        minecartControllable = getBoolean("gameplay-mechanics.minecart.controllable.enabled", minecartControllable);
+        minecartControllableStepHeight = (float) getDouble("gameplay-mechanics.minecart.controllable.step-height", minecartControllableStepHeight);
+        minecartControllableHopBoost = getDouble("gameplay-mechanics.minecart.controllable.hop-boost", minecartControllableHopBoost);
+        minecartControllableFallDamage = getBoolean("gameplay-mechanics.minecart.controllable.fall-damage", minecartControllableFallDamage);
+        minecartControllableBaseSpeed = getDouble("gameplay-mechanics.minecart.controllable.base-speed", minecartControllableBaseSpeed);
+        ConfigurationSection section = getConfigurationSection("gameplay-mechanics.minecart.controllable.block-speed");
+        if (section != null) {
+            for (String key : section.getKeys(false)) {
+                Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(key));
+                if (block != Blocks.AIR) {
+                    minecartControllableBlockSpeeds.put(block, section.getDouble(key, minecartControllableBaseSpeed));
+                }
+            }
+        } else {
+            set("gameplay-mechanics.minecart.controllable.block-speed.grass_block", 0.3D);
+            set("gameplay-mechanics.minecart.controllable.block-speed.stone", 0.5D);
+        }
+        poweredRailBoostModifier = getDouble("gameplay-mechanics.minecart.powered-rail.boost-modifier", poweredRailBoostModifier);
+    }
+
+    public float entityHealthRegenAmount = 1.0F;
+    public float entityMinimalHealthPoison = 1.0F;
+    public float entityPoisonDegenerationAmount = 1.0F;
+    public float entityWitherDegenerationAmount = 1.0F;
+    public float humanHungerExhaustionAmount = 0.005F;
+    public float humanSaturationRegenAmount = 1.0F;
+    private void mobEffectSettings() {
+        entityHealthRegenAmount = (float) getDouble("gameplay-mechanics.mob-effects.health-regen-amount", entityHealthRegenAmount);
+        entityMinimalHealthPoison = (float) getDouble("gameplay-mechanics.mob-effects.minimal-health-poison-amount", entityMinimalHealthPoison);
+        entityPoisonDegenerationAmount = (float) getDouble("gameplay-mechanics.mob-effects.poison-degeneration-amount", entityPoisonDegenerationAmount);
+        entityWitherDegenerationAmount = (float) getDouble("gameplay-mechanics.mob-effects.wither-degeneration-amount", entityWitherDegenerationAmount);
+        humanHungerExhaustionAmount = (float) getDouble("gameplay-mechanics.mob-effects.hunger-exhaustion-amount", humanHungerExhaustionAmount);
+        humanSaturationRegenAmount = (float) getDouble("gameplay-mechanics.mob-effects.saturation-regen-amount", humanSaturationRegenAmount);
+    }
+
+    public boolean catSpawning;
+    public boolean patrolSpawning;
+    public boolean phantomSpawning;
+    public boolean villagerTraderSpawning;
+    public boolean villageSiegeSpawning;
+    public boolean mobSpawningIgnoreCreativePlayers = false;
+    private void mobSpawnerSettings() {
+        // values of "default" or null will default to true only if the world environment is normal (aka overworld)
+        Predicate<Boolean> predicate = (bool) -> (bool != null && bool) || (bool == null && environment == World.Environment.NORMAL);
+        catSpawning = getBoolean("gameplay-mechanics.mob-spawning.village-cats", predicate);
+        patrolSpawning = getBoolean("gameplay-mechanics.mob-spawning.raid-patrols", predicate);
+        phantomSpawning = getBoolean("gameplay-mechanics.mob-spawning.phantoms", predicate);
+        villagerTraderSpawning = getBoolean("gameplay-mechanics.mob-spawning.wandering-traders", predicate);
+        villageSiegeSpawning = getBoolean("gameplay-mechanics.mob-spawning.village-sieges", predicate);
+        mobSpawningIgnoreCreativePlayers = getBoolean("gameplay-mechanics.mob-spawning.ignore-creative-players", mobSpawningIgnoreCreativePlayers);
+    }
+
+    public boolean disableObserverClocks = false;
+    private void observerSettings() {
+        disableObserverClocks = getBoolean("blocks.observer.disable-clock", disableObserverClocks);
+    }
+
+    public int playerNetheriteFireResistanceDuration = 0;
+    public int playerNetheriteFireResistanceAmplifier = 0;
+    public boolean playerNetheriteFireResistanceAmbient = false;
+    public boolean playerNetheriteFireResistanceShowParticles = false;
+    public boolean playerNetheriteFireResistanceShowIcon = true;
+    private void playerNetheriteFireResistance() {
+        playerNetheriteFireResistanceDuration = getInt("gameplay-mechanics.player.netherite-fire-resistance.duration", playerNetheriteFireResistanceDuration);
+        playerNetheriteFireResistanceAmplifier = getInt("gameplay-mechanics.player.netherite-fire-resistance.amplifier", playerNetheriteFireResistanceAmplifier);
+        playerNetheriteFireResistanceAmbient = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.ambient", playerNetheriteFireResistanceAmbient);
+        playerNetheriteFireResistanceShowParticles = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.show-particles", playerNetheriteFireResistanceShowParticles);
+        playerNetheriteFireResistanceShowIcon = getBoolean("gameplay-mechanics.player.netherite-fire-resistance.show-icon", playerNetheriteFireResistanceShowIcon);
+    }
+
+    public boolean idleTimeoutKick = true;
+    public boolean idleTimeoutTickNearbyEntities = true;
+    public boolean idleTimeoutCountAsSleeping = false;
+    public boolean idleTimeoutUpdateTabList = false;
+    public boolean idleTimeoutTargetPlayer = true;
+    public String playerDeathExpDropEquation = "expLevel * 7";
+    public int playerDeathExpDropMax = 100;
+    public boolean teleportIfOutsideBorder = false;
+    public boolean teleportOnNetherCeilingDamage = false;
+    public boolean totemOfUndyingWorksInInventory = false;
+    public boolean playerFixStuckPortal = false;
+    public boolean creativeOnePunch = false;
+    public boolean playerSleepNearMonsters = false;
+    public boolean playersSkipNight = true;
+    public double playerCriticalDamageMultiplier = 1.5D;
+    public int playerBurpDelay = 10;
+    public boolean playerBurpWhenFull = false;
+    public boolean playerRidableInWater = false;
+    public boolean playerRemoveBindingWithWeakness = false;
+    public int shiftRightClickRepairsMendingPoints = 0;
+    public int playerExpPickupDelay = 2;
+    public boolean playerVoidTrading = false;
+    private void playerSettings() {
+        if (PurpurConfig.version < 19) {
+            boolean oldVal = getBoolean("gameplay-mechanics.player.idle-timeout.mods-target", idleTimeoutTargetPlayer);
+            set("gameplay-mechanics.player.idle-timeout.mods-target", null);
+            set("gameplay-mechanics.player.idle-timeout.mobs-target", oldVal);
+        }
+        idleTimeoutKick = System.getenv("PURPUR_FORCE_IDLE_KICK") == null ? getBoolean("gameplay-mechanics.player.idle-timeout.kick-if-idle", idleTimeoutKick) : Boolean.parseBoolean(System.getenv("PURPUR_FORCE_IDLE_KICK"));
+        idleTimeoutTickNearbyEntities = getBoolean("gameplay-mechanics.player.idle-timeout.tick-nearby-entities", idleTimeoutTickNearbyEntities);
+        idleTimeoutCountAsSleeping = getBoolean("gameplay-mechanics.player.idle-timeout.count-as-sleeping", idleTimeoutCountAsSleeping);
+        idleTimeoutUpdateTabList = getBoolean("gameplay-mechanics.player.idle-timeout.update-tab-list", idleTimeoutUpdateTabList);
+        idleTimeoutTargetPlayer = getBoolean("gameplay-mechanics.player.idle-timeout.mobs-target", idleTimeoutTargetPlayer);
+        playerDeathExpDropEquation = getString("gameplay-mechanics.player.exp-dropped-on-death.equation", playerDeathExpDropEquation);
+        playerDeathExpDropMax = getInt("gameplay-mechanics.player.exp-dropped-on-death.maximum", playerDeathExpDropMax);
+        teleportIfOutsideBorder = getBoolean("gameplay-mechanics.player.teleport-if-outside-border", teleportIfOutsideBorder);
+        teleportOnNetherCeilingDamage = getBoolean("gameplay-mechanics.player.teleport-on-nether-ceiling-damage", teleportOnNetherCeilingDamage);
+        totemOfUndyingWorksInInventory = getBoolean("gameplay-mechanics.player.totem-of-undying-works-in-inventory", totemOfUndyingWorksInInventory);
+        playerFixStuckPortal = getBoolean("gameplay-mechanics.player.fix-stuck-in-portal", playerFixStuckPortal);
+        creativeOnePunch = getBoolean("gameplay-mechanics.player.one-punch-in-creative", creativeOnePunch);
+        playerSleepNearMonsters = getBoolean("gameplay-mechanics.player.sleep-ignore-nearby-mobs", playerSleepNearMonsters);
+        playersSkipNight = getBoolean("gameplay-mechanics.player.can-skip-night", playersSkipNight);
+        playerCriticalDamageMultiplier = getDouble("gameplay-mechanics.player.critical-damage-multiplier", playerCriticalDamageMultiplier);
+        playerBurpDelay = getInt("gameplay-mechanics.player.burp-delay", playerBurpDelay);
+        playerBurpWhenFull = getBoolean("gameplay-mechanics.player.burp-when-full", playerBurpWhenFull);
+        playerRidableInWater = getBoolean("gameplay-mechanics.player.ridable-in-water", playerRidableInWater);
+        playerRemoveBindingWithWeakness = getBoolean("gameplay-mechanics.player.curse-of-binding.remove-with-weakness", playerRemoveBindingWithWeakness);
+        shiftRightClickRepairsMendingPoints = getInt("gameplay-mechanics.player.shift-right-click-repairs-mending-points", shiftRightClickRepairsMendingPoints);
+        playerExpPickupDelay = getInt("gameplay-mechanics.player.exp-pickup-delay-ticks", playerExpPickupDelay);
+        playerVoidTrading = getBoolean("gameplay-mechanics.player.allow-void-trading", playerVoidTrading);
+    }
+
+    public boolean silkTouchEnabled = false;
+    public String silkTouchSpawnerName = "<reset><white>Monster Spawner";
+    public List<String> silkTouchSpawnerLore = new ArrayList<>();
+    public List<Item> silkTouchTools = new ArrayList<>();
+    public int minimumSilkTouchSpawnerRequire = 1;
+    private void silkTouchSettings() {
+        if (PurpurConfig.version < 21) {
+            String oldName = getString("gameplay-mechanics.silk-touch.spawner-name", silkTouchSpawnerName);
+            set("gameplay-mechanics.silk-touch.spawner-name", "<reset>" + ChatColor.toMM(oldName.replace("{mob}", "<mob>")));
+            List<String> list = new ArrayList<>();
+            getList("gameplay-mechanics.silk-touch.spawner-lore", List.of("Spawns a <mob>"))
+                    .forEach(line -> list.add("<reset>" + ChatColor.toMM(line.toString().replace("{mob}", "<mob>"))));
+            set("gameplay-mechanics.silk-touch.spawner-lore", list);
+        }
+        silkTouchEnabled = getBoolean("gameplay-mechanics.silk-touch.enabled", silkTouchEnabled);
+        silkTouchSpawnerName = getString("gameplay-mechanics.silk-touch.spawner-name", silkTouchSpawnerName);
+        minimumSilkTouchSpawnerRequire = getInt("gameplay-mechanics.silk-touch.minimal-level", minimumSilkTouchSpawnerRequire);
+        silkTouchSpawnerLore.clear();
+        getList("gameplay-mechanics.silk-touch.spawner-lore", List.of("Spawns a <mob>"))
+                .forEach(line -> silkTouchSpawnerLore.add(line.toString()));
+        silkTouchTools.clear();
+        getList("gameplay-mechanics.silk-touch.tools", List.of(
+                "minecraft:iron_pickaxe",
+                "minecraft:golden_pickaxe",
+                "minecraft:diamond_pickaxe",
+                "minecraft:netherite_pickaxe"
+        )).forEach(key -> {
+            Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(key.toString()));
+            if (item != Items.AIR) silkTouchTools.add(item);
+        });
+    }
+
+    public double bowProjectileOffset = 1.0D;
+    public double crossbowProjectileOffset = 1.0D;
+    public double eggProjectileOffset = 1.0D;
+    public double enderPearlProjectileOffset = 1.0D;
+    public double throwablePotionProjectileOffset = 1.0D;
+    public double tridentProjectileOffset = 1.0D;
+    public double snowballProjectileOffset = 1.0D;
+    private void projectileOffsetSettings() {
+        bowProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.bow", bowProjectileOffset);
+        crossbowProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.crossbow", crossbowProjectileOffset);
+        eggProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.egg", eggProjectileOffset);
+        enderPearlProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.ender-pearl", enderPearlProjectileOffset);
+        throwablePotionProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.throwable-potion", throwablePotionProjectileOffset);
+        tridentProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.trident", tridentProjectileOffset);
+        snowballProjectileOffset = getDouble("gameplay-mechanics.projectile-offset.snowball", snowballProjectileOffset);
+    }
+
+    public int snowballDamage = -1;
+    private void snowballSettings() {
+        snowballDamage = getInt("gameplay-mechanics.projectile-damage.snowball", snowballDamage);
+    }
+
+    public Map<Block, Strippable> axeStrippables = new HashMap<>();
+    public Map<Block, Waxable> axeWaxables = new HashMap<>();
+    public Map<Block, Weatherable> axeWeatherables = new HashMap<>();
+    public Map<Block, Tillable> hoeTillables = new HashMap<>();
+    public Map<Block, Flattenable> shovelFlattenables = new HashMap<>();
+    public boolean hoeReplantsCrops = false;
+    public boolean hoeReplantsNetherWarts = false;
+    private void toolSettings() {
+        axeStrippables.clear();
+        axeWaxables.clear();
+        axeWeatherables.clear();
+        hoeTillables.clear();
+        shovelFlattenables.clear();
+        if (PurpurConfig.version < 18) {
+            ConfigurationSection section = PurpurConfig.config.getConfigurationSection("world-settings." + worldName + ".tools.hoe.tilling");
+            if (section != null) {
+                PurpurConfig.config.set("world-settings." + worldName + ".tools.hoe.tillables", section);
+                PurpurConfig.config.set("world-settings." + worldName + ".tools.hoe.tilling", null);
+            }
+            section = PurpurConfig.config.getConfigurationSection("world-settings.default.tools.hoe.tilling");
+            if (section != null) {
+                PurpurConfig.config.set("world-settings.default.tools.hoe.tillables", section);
+                PurpurConfig.config.set("world-settings.default.tools.hoe.tilling", null);
+            }
+        }
+        if (PurpurConfig.version < 29) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:mangrove_log", Map.of("into", "minecraft:stripped_mangrove_log", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:mangrove_wood", Map.of("into", "minecraft:stripped_mangrove_wood", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 32) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:cherry_log", Map.of("into", "minecraft:stripped_cherry_log", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:cherry_wood", Map.of("into", "minecraft:stripped_cherry_wood", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:bamboo_block", Map.of("into", "minecraft:stripped_bamboo_block", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 33) {
+            getList("gameplay-mechanics.shovel-turns-block-to-grass-path", new ArrayList<String>(){{
+                add("minecraft:coarse_dirt");
+                add("minecraft:dirt");
+                add("minecraft:grass_block");
+                add("minecraft:mycelium");
+                add("minecraft:podzol");
+                add("minecraft:rooted_dirt");
+            }}).forEach(key -> {
+                PurpurConfig.config.set("world-settings.default.tools.shovel.flattenables." + key.toString(), Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>()));
+            });
+            set("gameplay-mechanics.shovel-turns-block-to-grass-path", null);
+        }
+        if (PurpurConfig.version < 34) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_chiseled_copper", Map.of("into", "minecraft:oxidized_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_door", Map.of("into", "minecraft:oxidized_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_trapdoor", Map.of("into", "minecraft:oxidized_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_grate", Map.of("into", "minecraft:oxidized_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_exposed_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_weathered_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.waxables.minecraft:waxed_oxidized_copper_bulb", Map.of("into", "minecraft:oxidized_copper_bulb", "drops", new HashMap<String, Double>()));
+
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:exposed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:weathered_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.weatherables.minecraft:oxidized_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>()));
+        }
+        if (PurpurConfig.version < 39) {
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:pale_oak_wood", Map.of("into", "minecraft:stripped_pale_oak_wood", "drops", new HashMap<String, Double>()));
+            PurpurConfig.config.set("world-settings.default.tools.axe.strippables.minecraft:pale_oak_log", Map.of("into", "minecraft:stripped_pale_oak_log", "drops", new HashMap<String, Double>()));
+        }
+        getMap("tools.axe.strippables", Map.ofEntries(
+                Map.entry("minecraft:oak_wood", Map.of("into", "minecraft:stripped_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oak_log", Map.of("into", "minecraft:stripped_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dark_oak_wood", Map.of("into", "minecraft:stripped_dark_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dark_oak_log", Map.of("into", "minecraft:stripped_dark_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:pale_oak_wood", Map.of("into", "minecraft:stripped_pale_oak_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:pale_oak_log", Map.of("into", "minecraft:stripped_pale_oak_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:acacia_wood", Map.of("into", "minecraft:stripped_acacia_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:acacia_log", Map.of("into", "minecraft:stripped_acacia_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:cherry_wood", Map.of("into", "minecraft:stripped_cherry_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:cherry_log", Map.of("into", "minecraft:stripped_cherry_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:birch_wood", Map.of("into", "minecraft:stripped_birch_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:birch_log", Map.of("into", "minecraft:stripped_birch_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:jungle_wood", Map.of("into", "minecraft:stripped_jungle_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:jungle_log", Map.of("into", "minecraft:stripped_jungle_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:spruce_wood", Map.of("into", "minecraft:stripped_spruce_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:spruce_log", Map.of("into", "minecraft:stripped_spruce_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:warped_stem", Map.of("into", "minecraft:stripped_warped_stem", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:warped_hyphae", Map.of("into", "minecraft:stripped_warped_hyphae", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:crimson_stem", Map.of("into", "minecraft:stripped_crimson_stem", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:crimson_hyphae", Map.of("into", "minecraft:stripped_crimson_hyphae", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mangrove_wood", Map.of("into", "minecraft:stripped_mangrove_wood", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mangrove_log", Map.of("into", "minecraft:stripped_mangrove_log", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:bamboo_block", Map.of("into", "minecraft:stripped_bamboo_block", "drops", new HashMap<String, Double>()))
+            )
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.strippables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.strippables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.strippables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.strippables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.strippables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeStrippables.put(block, new Strippable(into, drops));
+        });
+        getMap("tools.axe.waxables", Map.ofEntries(
+                Map.entry("minecraft:waxed_copper_block", Map.of("into", "minecraft:copper_block", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper", Map.of("into", "minecraft:exposed_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper", Map.of("into", "minecraft:weathered_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper", Map.of("into", "minecraft:oxidized_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper", Map.of("into", "minecraft:cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper", Map.of("into", "minecraft:exposed_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper", Map.of("into", "minecraft:weathered_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper", Map.of("into", "minecraft:oxidized_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper_slab", Map.of("into", "minecraft:cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper_slab", Map.of("into", "minecraft:exposed_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper_slab", Map.of("into", "minecraft:weathered_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper_slab", Map.of("into", "minecraft:oxidized_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_cut_copper_stairs", Map.of("into", "minecraft:cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_cut_copper_stairs", Map.of("into", "minecraft:exposed_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_cut_copper_stairs", Map.of("into", "minecraft:oxidized_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_chiseled_copper", Map.of("into", "minecraft:oxidized_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_door", Map.of("into", "minecraft:oxidized_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_trapdoor", Map.of("into", "minecraft:oxidized_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_grate", Map.of("into", "minecraft:oxidized_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_exposed_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_weathered_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:waxed_oxidized_copper_bulb", Map.of("into", "minecraft:oxidized_copper_bulb", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.waxables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.waxables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.waxables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.waxables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.waxables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeWaxables.put(block, new Waxable(into, drops));
+        });
+        getMap("tools.axe.weatherables", Map.ofEntries(
+                Map.entry("minecraft:exposed_copper", Map.of("into", "minecraft:copper_block", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper", Map.of("into", "minecraft:exposed_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper", Map.of("into", "minecraft:weathered_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper", Map.of("into", "minecraft:cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper", Map.of("into", "minecraft:exposed_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper", Map.of("into", "minecraft:weathered_cut_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_chiseled_copper", Map.of("into", "minecraft:chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_chiseled_copper", Map.of("into", "minecraft:exposed_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_chiseled_copper", Map.of("into", "minecraft:weathered_chiseled_copper", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper_slab", Map.of("into", "minecraft:cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper_slab", Map.of("into", "minecraft:exposed_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper_slab", Map.of("into", "minecraft:weathered_cut_copper_slab", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_cut_copper_stairs", Map.of("into", "minecraft:cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_cut_copper_stairs", Map.of("into", "minecraft:exposed_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_cut_copper_stairs", Map.of("into", "minecraft:weathered_cut_copper_stairs", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_door", Map.of("into", "minecraft:copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_door", Map.of("into", "minecraft:exposed_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_door", Map.of("into", "minecraft:weathered_copper_door", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_trapdoor", Map.of("into", "minecraft:copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_trapdoor", Map.of("into", "minecraft:exposed_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_trapdoor", Map.of("into", "minecraft:weathered_copper_trapdoor", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_grate", Map.of("into", "minecraft:copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_grate", Map.of("into", "minecraft:exposed_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_grate", Map.of("into", "minecraft:weathered_copper_grate", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:exposed_copper_bulb", Map.of("into", "minecraft:copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:weathered_copper_bulb", Map.of("into", "minecraft:exposed_copper_bulb", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:oxidized_copper_bulb", Map.of("into", "minecraft:weathered_copper_bulb", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.weatherables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.weatherables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.axe.weatherables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.axe.weatherables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.axe.weatherables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            axeWeatherables.put(block, new Weatherable(into, drops));
+        });
+        getMap("tools.hoe.tillables", Map.ofEntries(
+                Map.entry("minecraft:grass_block", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt_path", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt", Map.of("condition", "air_above", "into", "minecraft:farmland", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:coarse_dirt", Map.of("condition", "air_above", "into", "minecraft:dirt", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:rooted_dirt", Map.of("condition", "always", "into", "minecraft:dirt", "drops", Map.of("minecraft:hanging_roots", 1.0D))))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tillables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.hoe.tillables." + blockId + "`"); return; }
+            String conditionId = (String) map.get("condition");
+            Tillable.Condition condition = Tillable.Condition.get(conditionId);
+            if (condition == null) { PurpurConfig.log(Level.SEVERE, "Invalid condition for `tools.hoe.tillables." + blockId + ".condition`: " + conditionId); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.hoe.tillables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.hoe.tillables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.hoe.tillables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            hoeTillables.put(block, new Tillable(condition, into, drops));
+        });
+        getMap("tools.shovel.flattenables", Map.ofEntries(
+                Map.entry("minecraft:grass_block", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:podzol", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:coarse_dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:mycelium", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())),
+                Map.entry("minecraft:rooted_dirt", Map.of("into", "minecraft:dirt_path", "drops", new HashMap<String, Double>())))
+        ).forEach((blockId, obj) -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(blockId));
+            if (block == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.shovel.flattenables`: " + blockId); return; }
+            if (!(obj instanceof Map<?, ?> map)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.shovel.flattenables." + blockId + "`"); return; }
+            String intoId = (String) map.get("into");
+            Block into = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(intoId));
+            if (into == Blocks.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid block for `tools.shovel.flattenables." + blockId + ".into`: " + intoId); return; }
+            Object dropsObj = map.get("drops");
+            if (!(dropsObj instanceof Map<?, ?> dropsMap)) { PurpurConfig.log(Level.SEVERE, "Invalid yaml for `tools.shovel.flattenables." + blockId + ".drops`"); return; }
+            Map<Item, Double> drops = new HashMap<>();
+            dropsMap.forEach((itemId, chance) -> {
+                Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(itemId.toString()));
+                if (item == Items.AIR) { PurpurConfig.log(Level.SEVERE, "Invalid item for `tools.shovel.flattenables." + blockId + ".drops`: " + itemId); return; }
+                drops.put(item, (double) chance);
+            });
+            shovelFlattenables.put(block, new Flattenable(into, drops));
+        });
+        hoeReplantsCrops = getBoolean("tools.hoe.replant-crops", hoeReplantsCrops);
+        hoeReplantsNetherWarts = getBoolean("tools.hoe.replant-nether-warts", hoeReplantsNetherWarts);
+    }
+
+    public boolean anvilAllowColors = false;
+    public boolean anvilColorsUseMiniMessage;
+    public int anvilRepairIngotsAmount = 0;
+    public int anvilDamageObsidianAmount = 0;
+    private void anvilSettings() {
+        anvilAllowColors = getBoolean("blocks.anvil.allow-colors", anvilAllowColors);
+        anvilColorsUseMiniMessage = getBoolean("blocks.anvil.use-mini-message", anvilColorsUseMiniMessage);
+        anvilRepairIngotsAmount = getInt("blocks.anvil.iron-ingots-used-for-repair", anvilRepairIngotsAmount);
+        anvilDamageObsidianAmount = getInt("blocks.anvil.obsidian-used-for-damage", anvilDamageObsidianAmount);
+    }
+
+    public double azaleaGrowthChance = 0.0D;
+    private void azaleaSettings() {
+        azaleaGrowthChance = getDouble("blocks.azalea.growth-chance", azaleaGrowthChance);
+    }
+
+    public int beaconLevelOne = 20;
+    public int beaconLevelTwo = 30;
+    public int beaconLevelThree = 40;
+    public int beaconLevelFour = 50;
+    public boolean beaconAllowEffectsWithTintedGlass = false;
+    private void beaconSettings() {
+        beaconLevelOne = getInt("blocks.beacon.effect-range.level-1", beaconLevelOne);
+        beaconLevelTwo = getInt("blocks.beacon.effect-range.level-2", beaconLevelTwo);
+        beaconLevelThree = getInt("blocks.beacon.effect-range.level-3", beaconLevelThree);
+        beaconLevelFour = getInt("blocks.beacon.effect-range.level-4", beaconLevelFour);
+        beaconAllowEffectsWithTintedGlass = getBoolean("blocks.beacon.allow-effects-with-tinted-glass", beaconAllowEffectsWithTintedGlass);
+    }
+
+    public boolean bedExplode = true;
+    public boolean bedExplodeOnVillagerSleep = false;
+    public double bedExplosionPower = 5.0D;
+    public boolean bedExplosionFire = true;
+    public net.minecraft.world.level.Level.ExplosionInteraction bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    private void bedSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.bed.explosion-effect", bedExplosionEffect.name()))) {
+                set("blocks.bed.explosion-effect", "BLOCK");
+            }
+        }
+        bedExplode = getBoolean("blocks.bed.explode", bedExplode);
+        bedExplodeOnVillagerSleep = getBoolean("blocks.bed.explode-on-villager-sleep", bedExplodeOnVillagerSleep);
+        bedExplosionPower = getDouble("blocks.bed.explosion-power", bedExplosionPower);
+        bedExplosionFire = getBoolean("blocks.bed.explosion-fire", bedExplosionFire);
+        try {
+            bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.bed.explosion-effect", bedExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.bed.explosion-effect`! Using default of `BLOCK`");
+            bedExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+    }
+
+    public Map<Tilt, Integer> bigDripleafTiltDelay = new HashMap<>();
+    private void bigDripleafSettings() {
+        bigDripleafTiltDelay.clear();
+        getMap("blocks.big_dripleaf.tilt-delay", Map.ofEntries(
+                Map.entry("UNSTABLE", 10),
+                Map.entry("PARTIAL", 10),
+                Map.entry("FULL", 100))
+        ).forEach((tilt, delay) -> {
+            try {
+                bigDripleafTiltDelay.put(Tilt.valueOf(tilt), (int) delay);
+            } catch (IllegalArgumentException e) {
+                PurpurConfig.log(Level.SEVERE, "Invalid big_dripleaf tilt key: " + tilt);
+            }
+        });
+    }
+
+    public boolean cactusBreaksFromSolidNeighbors = true;
+    public boolean cactusAffectedByBonemeal = false;
+    private void cactusSettings() {
+        cactusBreaksFromSolidNeighbors = getBoolean("blocks.cactus.breaks-from-solid-neighbors", cactusBreaksFromSolidNeighbors);
+        cactusAffectedByBonemeal = getBoolean("blocks.cactus.affected-by-bonemeal", cactusAffectedByBonemeal);
+    }
+
+    public boolean sugarCanAffectedByBonemeal = false;
+    private void sugarCaneSettings() {
+        sugarCanAffectedByBonemeal = getBoolean("blocks.sugar_cane.affected-by-bonemeal", sugarCanAffectedByBonemeal);
+    }
+
+    public boolean netherWartAffectedByBonemeal = false;
+    private void netherWartSettings() {
+        netherWartAffectedByBonemeal = getBoolean("blocks.nether_wart.affected-by-bonemeal", netherWartAffectedByBonemeal);
+    }
+
+    public boolean campFireLitWhenPlaced = true;
+    private void campFireSettings() {
+        campFireLitWhenPlaced = getBoolean("blocks.campfire.lit-when-placed", campFireLitWhenPlaced);
+    }
+
+    public boolean chestOpenWithBlockOnTop = false;
+    private void chestSettings() {
+        chestOpenWithBlockOnTop = getBoolean("blocks.chest.open-with-solid-block-on-top", chestOpenWithBlockOnTop);
+    }
+
+    public boolean composterBulkProcess = false;
+    private void composterSettings() {
+        composterBulkProcess = getBoolean("blocks.composter.sneak-to-bulk-process", composterBulkProcess);
+    }
+
+    public boolean coralDieOutsideWater = true;
+    private void coralSettings() {
+        coralDieOutsideWater = getBoolean("blocks.coral.die-outside-water", coralDieOutsideWater);
+    }
+
+    public boolean dispenserApplyCursedArmor = true;
+    public boolean dispenserPlaceAnvils = false;
+    private void dispenserSettings() {
+        dispenserApplyCursedArmor = getBoolean("blocks.dispenser.apply-cursed-to-armor-slots", dispenserApplyCursedArmor);
+        dispenserPlaceAnvils = getBoolean("blocks.dispenser.place-anvils", dispenserPlaceAnvils);
+    }
+
+    public List<Block> doorRequiresRedstone = new ArrayList<>();
+    private void doorSettings() {
+        getList("blocks.door.requires-redstone", new ArrayList<String>()).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                doorRequiresRedstone.add(block);
+            }
+        });
+    }
+
+    public boolean dragonEggTeleport = true;
+    private void dragonEggSettings() {
+        dragonEggTeleport = getBoolean("blocks.dragon_egg.teleport", dragonEggTeleport);
+    }
+
+    public boolean baselessEndCrystalExplode = true;
+    public double baselessEndCrystalExplosionPower = 6.0D;
+    public boolean baselessEndCrystalExplosionFire = false;
+    public net.minecraft.world.level.Level.ExplosionInteraction baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    public boolean basedEndCrystalExplode = true;
+    public double basedEndCrystalExplosionPower = 6.0D;
+    public boolean basedEndCrystalExplosionFire = false;
+    public net.minecraft.world.level.Level.ExplosionInteraction basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    public int endCrystalCramming = 0;
+    public boolean endCrystalPlaceAnywhere = false;
+    private void endCrystalSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.end-crystal.baseless.explosion-effect", baselessEndCrystalExplosionEffect.name()))) {
+                set("blocks.end-crystal.baseless.explosion-effect", "BLOCK");
+            }
+            if ("DESTROY".equals(getString("blocks.end-crystal.base.explosion-effect", basedEndCrystalExplosionEffect.name()))) {
+                set("blocks.end-crystal.base.explosion-effect", "BLOCK");
+            }
+        }
+        baselessEndCrystalExplode = getBoolean("blocks.end-crystal.baseless.explode", baselessEndCrystalExplode);
+        baselessEndCrystalExplosionPower = getDouble("blocks.end-crystal.baseless.explosion-power", baselessEndCrystalExplosionPower);
+        baselessEndCrystalExplosionFire = getBoolean("blocks.end-crystal.baseless.explosion-fire", baselessEndCrystalExplosionFire);
+        try {
+            baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.end-crystal.baseless.explosion-effect", baselessEndCrystalExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.end-crystal.baseless.explosion-effect`! Using default of `BLOCK`");
+            baselessEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+        basedEndCrystalExplode = getBoolean("blocks.end-crystal.base.explode", basedEndCrystalExplode);
+        basedEndCrystalExplosionPower = getDouble("blocks.end-crystal.base.explosion-power", basedEndCrystalExplosionPower);
+        basedEndCrystalExplosionFire = getBoolean("blocks.end-crystal.base.explosion-fire", basedEndCrystalExplosionFire);
+        try {
+            basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.end-crystal.base.explosion-effect", basedEndCrystalExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.end-crystal.base.explosion-effect`! Using default of `BLOCK`");
+            basedEndCrystalExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+        endCrystalCramming = getInt("blocks.end-crystal.cramming-amount", endCrystalCramming);
+        endCrystalPlaceAnywhere = getBoolean("gameplay-mechanics.item.end-crystal.place-anywhere", endCrystalPlaceAnywhere);
+    }
+
+    public Boolean farmlandMobGriefingOverride = null;
+    public boolean farmlandGetsMoistFromBelow = false;
+    public boolean farmlandAlpha = false;
+    public boolean farmlandTramplingDisabled = false;
+    public boolean farmlandTramplingOnlyPlayers = false;
+    public boolean farmlandTramplingFeatherFalling = false;
+    public double farmlandTrampleHeight = -1D;
+    private void farmlandSettings() {
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.farmland.bypass-mob-griefing", false);
+            set("blocks.farmland.bypass-mob-griefing", null);
+            set("blocks.farmland.mob-griefing-override", oldVal ? true : "default");
+        }
+        farmlandMobGriefingOverride = getBooleanOrDefault("blocks.farmland.mob-griefing-override", farmlandMobGriefingOverride);
+        farmlandGetsMoistFromBelow = getBoolean("blocks.farmland.gets-moist-from-below", farmlandGetsMoistFromBelow);
+        farmlandAlpha = getBoolean("blocks.farmland.use-alpha-farmland", farmlandAlpha);
+        farmlandTramplingDisabled = getBoolean("blocks.farmland.disable-trampling", farmlandTramplingDisabled);
+        farmlandTramplingOnlyPlayers = getBoolean("blocks.farmland.only-players-trample", farmlandTramplingOnlyPlayers);
+        farmlandTramplingFeatherFalling = getBoolean("blocks.farmland.feather-fall-distance-affects-trampling", farmlandTramplingFeatherFalling);
+        farmlandTrampleHeight = getDouble("blocks.farmland.trample-height", farmlandTrampleHeight);
+    }
+
+    public double floweringAzaleaGrowthChance = 0.0D;
+    private void floweringAzaleaSettings() {
+        floweringAzaleaGrowthChance = getDouble("blocks.flowering_azalea.growth-chance", floweringAzaleaGrowthChance);
+    }
+
+    public boolean furnaceUseLavaFromUnderneath = false;
+    private void furnaceSettings() {
+        if (PurpurConfig.version < 17) {
+            furnaceUseLavaFromUnderneath = getBoolean("blocks.furnace.infinite-fuel", furnaceUseLavaFromUnderneath);
+            boolean oldValue = getBoolean("blocks.furnace.infinite-fuel", furnaceUseLavaFromUnderneath);
+            set("blocks.furnace.infinite-fuel", null);
+            set("blocks.furnace.use-lava-from-underneath", oldValue);
+        }
+        furnaceUseLavaFromUnderneath = getBoolean("blocks.furnace.use-lava-from-underneath", furnaceUseLavaFromUnderneath);
+    }
+
+    public boolean mobsSpawnOnPackedIce = true;
+    public boolean mobsSpawnOnBlueIce = true;
+    public boolean snowOnBlueIce = true;
+    private void iceSettings() {
+        mobsSpawnOnPackedIce = getBoolean("blocks.packed_ice.allow-mob-spawns", mobsSpawnOnPackedIce);
+        mobsSpawnOnBlueIce = getBoolean("blocks.blue_ice.allow-mob-spawns", mobsSpawnOnBlueIce);
+        snowOnBlueIce = getBoolean("blocks.blue_ice.allow-snow-formation", snowOnBlueIce);
+    }
+
+    public int lavaInfiniteRequiredSources = 2;
+    public int lavaSpeedNether = 10;
+    public int lavaSpeedNotNether = 30;
+    private void lavaSettings() {
+        lavaInfiniteRequiredSources = getInt("blocks.lava.infinite-required-sources", lavaInfiniteRequiredSources);
+        lavaSpeedNether = getInt("blocks.lava.speed.nether", lavaSpeedNether);
+        lavaSpeedNotNether = getInt("blocks.lava.speed.not-nether", lavaSpeedNotNether);
+    }
+
+    public int pistonBlockPushLimit = 12;
+    private void pistonSettings() {
+        pistonBlockPushLimit = getInt("blocks.piston.block-push-limit", pistonBlockPushLimit);
+    }
+
+    public boolean magmaBlockDamageWhenSneaking = false;
+    private void magmaBlockSettings() {
+        magmaBlockDamageWhenSneaking = getBoolean("blocks.magma-block.damage-when-sneaking", magmaBlockDamageWhenSneaking);
+    }
+
+    public Boolean powderSnowMobGriefingOverride = null;
+    private void powderSnowSettings() {
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.powder_snow.bypass-mob-griefing", false);
+            set("blocks.powder_snow.bypass-mob-griefing", null);
+            set("blocks.powder_snow.mob-griefing-override", oldVal ? true : "default");
+        }
+        powderSnowMobGriefingOverride = getBooleanOrDefault("blocks.powder_snow.mob-griefing-override", powderSnowMobGriefingOverride);
+    }
+
+    public int railActivationRange = 8;
+    private void railSettings() {
+        railActivationRange = getInt("blocks.powered-rail.activation-range", railActivationRange);
+    }
+
+    public boolean respawnAnchorExplode = true;
+    public double respawnAnchorExplosionPower = 5.0D;
+    public boolean respawnAnchorExplosionFire = true;
+    public net.minecraft.world.level.Level.ExplosionInteraction respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+    private void respawnAnchorSettings() {
+        if (PurpurConfig.version < 31) {
+            if ("DESTROY".equals(getString("blocks.respawn_anchor.explosion-effect", respawnAnchorExplosionEffect.name()))) {
+                set("blocks.respawn_anchor.explosion-effect", "BLOCK");
+            }
+        }
+        respawnAnchorExplode = getBoolean("blocks.respawn_anchor.explode", respawnAnchorExplode);
+        respawnAnchorExplosionPower = getDouble("blocks.respawn_anchor.explosion-power", respawnAnchorExplosionPower);
+        respawnAnchorExplosionFire = getBoolean("blocks.respawn_anchor.explosion-fire", respawnAnchorExplosionFire);
+        try {
+            respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.valueOf(getString("blocks.respawn_anchor.explosion-effect", respawnAnchorExplosionEffect.name()));
+        } catch (IllegalArgumentException e) {
+            log(Level.SEVERE, "Unknown value for `blocks.respawn_anchor.explosion-effect`! Using default of `BLOCK`");
+            respawnAnchorExplosionEffect = net.minecraft.world.level.Level.ExplosionInteraction.BLOCK;
+        }
+    }
+
+    public boolean sculkShriekerCanSummonDefault = false;
+    private void sculkShriekerSettings() {
+        sculkShriekerCanSummonDefault = getBoolean("blocks.sculk_shrieker.can-summon-default", sculkShriekerCanSummonDefault);
+    }
+
+    public boolean signAllowColors = false;
+    private void signSettings() {
+        signAllowColors = getBoolean("blocks.sign.allow-colors", signAllowColors);
+    }
+
+    public boolean slabHalfBreak = false;
+    private void slabSettings() {
+        slabHalfBreak = getBoolean("blocks.slab.break-individual-slabs-when-sneaking", slabHalfBreak);
+    }
+
+    public boolean spawnerDeactivateByRedstone = false;
+    public boolean spawnerFixMC238526 = false;
+    private void spawnerSettings() {
+        spawnerDeactivateByRedstone = getBoolean("blocks.spawner.deactivate-by-redstone", spawnerDeactivateByRedstone);
+        spawnerFixMC238526 = getBoolean("blocks.spawner.fix-mc-238526", spawnerFixMC238526);
+    }
+
+    public int spongeAbsorptionArea = 65;
+    public int spongeAbsorptionRadius = 6;
+    public boolean spongeAbsorbsLava = false;
+    public boolean spongeAbsorbsWaterFromMud = false;
+    private void spongeSettings() {
+        spongeAbsorptionArea = getInt("blocks.sponge.absorption.area", spongeAbsorptionArea);
+        spongeAbsorptionRadius = getInt("blocks.sponge.absorption.radius", spongeAbsorptionRadius);
+        spongeAbsorbsLava = getBoolean("blocks.sponge.absorbs-lava", spongeAbsorbsLava);
+        spongeAbsorbsWaterFromMud = getBoolean("blocks.sponge.absorbs-water-from-mud", spongeAbsorbsWaterFromMud);
+    }
+
+    public float stonecutterDamage = 0.0F;
+    private void stonecutterSettings() {
+        stonecutterDamage = (float) getDouble("blocks.stonecutter.damage", stonecutterDamage);
+    }
+
+    public boolean turtleEggsBreakFromExpOrbs = false;
+    public boolean turtleEggsBreakFromItems = false;
+    public boolean turtleEggsBreakFromMinecarts = false;
+    public Boolean turtleEggsMobGriefingOverride = null;
+    public int turtleEggsRandomTickCrackChance = 500;
+    public boolean turtleEggsTramplingFeatherFalling = false;
+    private void turtleEggSettings() {
+        turtleEggsBreakFromExpOrbs = getBoolean("blocks.turtle_egg.break-from-exp-orbs", turtleEggsBreakFromExpOrbs);
+        turtleEggsBreakFromItems = getBoolean("blocks.turtle_egg.break-from-items", turtleEggsBreakFromItems);
+        turtleEggsBreakFromMinecarts = getBoolean("blocks.turtle_egg.break-from-minecarts", turtleEggsBreakFromMinecarts);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("blocks.turtle_egg.bypass-mob-griefing", false);
+            set("blocks.turtle_egg.bypass-mob-griefing", null);
+            set("blocks.turtle_egg.mob-griefing-override", oldVal ? true : "default");
+        }
+        turtleEggsMobGriefingOverride = getBooleanOrDefault("blocks.turtle_egg.mob-griefing-override", turtleEggsMobGriefingOverride);
+        turtleEggsRandomTickCrackChance = getInt("blocks.turtle_egg.random-tick-crack-chance", turtleEggsRandomTickCrackChance);
+        turtleEggsTramplingFeatherFalling = getBoolean("blocks.turtle_egg.feather-fall-distance-affects-trampling", turtleEggsTramplingFeatherFalling);
+    }
+
+    public int waterInfiniteRequiredSources = 2;
+    private void waterSources() {
+        waterInfiniteRequiredSources = getInt("blocks.water.infinite-required-sources", waterInfiniteRequiredSources);
+    }
+
+    public boolean babiesAreRidable = true;
+    public boolean untamedTamablesAreRidable = true;
+    public boolean useNightVisionWhenRiding = false;
+    public boolean useDismountsUnderwaterTag = true;
+    private void ridableSettings() {
+        babiesAreRidable = getBoolean("ridable-settings.babies-are-ridable", babiesAreRidable);
+        untamedTamablesAreRidable = getBoolean("ridable-settings.untamed-tamables-are-ridable", untamedTamablesAreRidable);
+        useNightVisionWhenRiding = getBoolean("ridable-settings.use-night-vision", useNightVisionWhenRiding);
+        useDismountsUnderwaterTag = getBoolean("ridable-settings.use-dismounts-underwater-tag", useDismountsUnderwaterTag);
+    }
+
+    public boolean allayRidable = false;
+    public boolean allayRidableInWater = true;
+    public boolean allayControllable = true;
+    public double allayMaxHealth = 20.0D;
+    public double allayScale = 1.0D;
+    private void allaySettings() {
+        allayRidable = getBoolean("mobs.allay.ridable", allayRidable);
+        allayRidableInWater = getBoolean("mobs.allay.ridable-in-water", allayRidableInWater);
+        allayControllable = getBoolean("mobs.allay.controllable", allayControllable);
+        allayMaxHealth = getDouble("mobs.allay.attributes.max_health", allayMaxHealth);
+        allayScale = Mth.clamp(getDouble("mobs.allay.attributes.scale", allayScale), 0.0625D, 16.0D);
+    }
+
+    public boolean armadilloRidable = false;
+    public boolean armadilloRidableInWater = true;
+    public boolean armadilloControllable = true;
+    public double armadilloMaxHealth = 12.0D;
+    public double armadilloScale = 1.0D;
+    public int armadilloBreedingTicks = 6000;
+    private void armadilloSettings() {
+        armadilloRidable = getBoolean("mobs.armadillo.ridable", armadilloRidable);
+        armadilloRidableInWater = getBoolean("mobs.armadillo.ridable-in-water", armadilloRidableInWater);
+        armadilloControllable = getBoolean("mobs.armadillo.controllable", armadilloControllable);
+        armadilloMaxHealth = getDouble("mobs.armadillo.attributes.max_health", armadilloMaxHealth);
+        armadilloScale = Mth.clamp(getDouble("mobs.armadillo.attributes.scale", armadilloScale), 0.0625D, 16.0D);
+        armadilloBreedingTicks = getInt("mobs.armadillo.breeding-delay-ticks", armadilloBreedingTicks);
+    }
+
+    public boolean axolotlRidable = false;
+    public boolean axolotlControllable = true;
+    public double axolotlMaxHealth = 14.0D;
+    public double axolotlScale = 1.0D;
+    public int axolotlBreedingTicks = 6000;
+    public boolean axolotlTakeDamageFromWater = false;
+    public boolean axolotlAlwaysDropExp = false;
+    private void axolotlSettings() {
+        axolotlRidable = getBoolean("mobs.axolotl.ridable", axolotlRidable);
+        axolotlControllable = getBoolean("mobs.axolotl.controllable", axolotlControllable);
+        axolotlMaxHealth = getDouble("mobs.axolotl.attributes.max_health", axolotlMaxHealth);
+        axolotlScale = Mth.clamp(getDouble("mobs.axolotl.attributes.scale", axolotlScale), 0.0625D, 16.0D);
+        axolotlBreedingTicks = getInt("mobs.axolotl.breeding-delay-ticks", axolotlBreedingTicks);
+        axolotlTakeDamageFromWater = getBoolean("mobs.axolotl.takes-damage-from-water", axolotlTakeDamageFromWater);
+        axolotlAlwaysDropExp = getBoolean("mobs.axolotl.always-drop-exp", axolotlAlwaysDropExp);
+    }
+
+    public boolean batRidable = false;
+    public boolean batRidableInWater = true;
+    public boolean batControllable = true;
+    public double batMaxY = 320D;
+    public double batMaxHealth = 6.0D;
+    public double batScale = 1.0D;
+    public double batFollowRange = 16.0D;
+    public double batKnockbackResistance = 0.0D;
+    public double batMovementSpeed = 0.6D;
+    public double batFlyingSpeed = 0.6D;
+    public double batArmor = 0.0D;
+    public double batArmorToughness = 0.0D;
+    public double batAttackKnockback = 0.0D;
+    public boolean batTakeDamageFromWater = false;
+    public boolean batAlwaysDropExp = false;
+    private void batSettings() {
+        batRidable = getBoolean("mobs.bat.ridable", batRidable);
+        batRidableInWater = getBoolean("mobs.bat.ridable-in-water", batRidableInWater);
+        batControllable = getBoolean("mobs.bat.controllable", batControllable);
+        batMaxY = getDouble("mobs.bat.ridable-max-y", batMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.bat.attributes.max-health", batMaxHealth);
+            set("mobs.bat.attributes.max-health", null);
+            set("mobs.bat.attributes.max_health", oldValue);
+        }
+        batMaxHealth = getDouble("mobs.bat.attributes.max_health", batMaxHealth);
+        batScale = Mth.clamp(getDouble("mobs.bat.attributes.scale", batScale), 0.0625D, 16.0D);
+        batFollowRange = getDouble("mobs.bat.attributes.follow_range", batFollowRange);
+        batKnockbackResistance = getDouble("mobs.bat.attributes.knockback_resistance", batKnockbackResistance);
+        batMovementSpeed = getDouble("mobs.bat.attributes.movement_speed", batMovementSpeed);
+        batFlyingSpeed = getDouble("mobs.bat.attributes.flying_speed", batFlyingSpeed);
+        batArmor = getDouble("mobs.bat.attributes.armor", batArmor);
+        batArmorToughness = getDouble("mobs.bat.attributes.armor_toughness", batArmorToughness);
+        batAttackKnockback = getDouble("mobs.bat.attributes.attack_knockback", batAttackKnockback);
+        batTakeDamageFromWater = getBoolean("mobs.bat.takes-damage-from-water", batTakeDamageFromWater);
+        batAlwaysDropExp = getBoolean("mobs.bat.always-drop-exp", batAlwaysDropExp);
+    }
+
+    public boolean beeRidable = false;
+    public boolean beeRidableInWater = true;
+    public boolean beeControllable = true;
+    public double beeMaxY = 320D;
+    public double beeMaxHealth = 10.0D;
+    public double beeScale = 1.0D;
+    public int beeBreedingTicks = 6000;
+    public boolean beeTakeDamageFromWater = false;
+    public boolean beeCanInstantlyStartDrowning = true;
+    public boolean beeCanWorkAtNight = false;
+    public boolean beeCanWorkInRain = false;
+    public boolean beeAlwaysDropExp = false;
+    public boolean beeDiesAfterSting = true;
+    private void beeSettings() {
+        beeRidable = getBoolean("mobs.bee.ridable", beeRidable);
+        beeRidableInWater = getBoolean("mobs.bee.ridable-in-water", beeRidableInWater);
+        beeControllable = getBoolean("mobs.bee.controllable", beeControllable);
+        beeMaxY = getDouble("mobs.bee.ridable-max-y", beeMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.bee.attributes.max-health", beeMaxHealth);
+            set("mobs.bee.attributes.max-health", null);
+            set("mobs.bee.attributes.max_health", oldValue);
+        }
+        beeMaxHealth = getDouble("mobs.bee.attributes.max_health", beeMaxHealth);
+        beeScale = Mth.clamp(getDouble("mobs.bee.attributes.scale", beeScale), 0.0625D, 16.0D);
+        beeBreedingTicks = getInt("mobs.bee.breeding-delay-ticks", beeBreedingTicks);
+        if (PurpurConfig.version < 40) {
+            set("mobs.bee.takes-damage-from-water", false);
+        }
+        beeTakeDamageFromWater = getBoolean("mobs.bee.takes-damage-from-water", beeTakeDamageFromWater);
+        beeCanWorkAtNight = getBoolean("mobs.bee.can-work-at-night", beeCanWorkAtNight);
+        beeCanWorkInRain = getBoolean("mobs.bee.can-work-in-rain", beeCanWorkInRain);
+        beeCanInstantlyStartDrowning = getBoolean("mobs.bee.can-instantly-start-drowning", beeCanInstantlyStartDrowning);
+        beeAlwaysDropExp = getBoolean("mobs.bee.always-drop-exp", beeAlwaysDropExp);
+        beeDiesAfterSting = getBoolean("mobs.bee.dies-after-sting", beeDiesAfterSting);
+    }
+
+    public boolean blazeRidable = false;
+    public boolean blazeRidableInWater = true;
+    public boolean blazeControllable = true;
+    public double blazeMaxY = 320D;
+    public double blazeMaxHealth = 20.0D;
+    public double blazeScale = 1.0D;
+    public boolean blazeTakeDamageFromWater = true;
+    public boolean blazeAlwaysDropExp = false;
+    private void blazeSettings() {
+        blazeRidable = getBoolean("mobs.blaze.ridable", blazeRidable);
+        blazeRidableInWater = getBoolean("mobs.blaze.ridable-in-water", blazeRidableInWater);
+        blazeControllable = getBoolean("mobs.blaze.controllable", blazeControllable);
+        blazeMaxY = getDouble("mobs.blaze.ridable-max-y", blazeMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.blaze.attributes.max-health", blazeMaxHealth);
+            set("mobs.blaze.attributes.max-health", null);
+            set("mobs.blaze.attributes.max_health", oldValue);
+        }
+        blazeMaxHealth = getDouble("mobs.blaze.attributes.max_health", blazeMaxHealth);
+        blazeScale = Mth.clamp(getDouble("mobs.blaze.attributes.scale", blazeScale), 0.0625D, 16.0D);
+        blazeTakeDamageFromWater = getBoolean("mobs.blaze.takes-damage-from-water", blazeTakeDamageFromWater);
+        blazeAlwaysDropExp = getBoolean("mobs.blaze.always-drop-exp", blazeAlwaysDropExp);
+    }
+
+    public boolean boggedRidable = false;
+    public boolean boggedRidableInWater = true;
+    public boolean boggedControllable = true;
+    public double boggedMaxHealth = 16.0D;
+    public double boggedScale = 1.0D;
+    private void boggedSettings() {
+        boggedRidable = getBoolean("mobs.bogged.ridable", boggedRidable);
+        boggedRidableInWater = getBoolean("mobs.bogged.ridable-in-water", boggedRidableInWater);
+        boggedControllable = getBoolean("mobs.bogged.controllable", boggedControllable);
+        boggedMaxHealth = getDouble("mobs.bogged.attributes.max_health", boggedMaxHealth);
+        boggedScale = Mth.clamp(getDouble("mobs.bogged.attributes.scale", boggedScale), 0.0625D, 16.0D);
+    }
+
+    public boolean camelRidableInWater = false;
+    public double camelMaxHealthMin = 32.0D;
+    public double camelMaxHealthMax = 32.0D;
+    public double camelJumpStrengthMin = 0.42D;
+    public double camelJumpStrengthMax = 0.42D;
+    public double camelMovementSpeedMin = 0.09D;
+    public double camelMovementSpeedMax = 0.09D;
+    public int camelBreedingTicks = 6000;
+    private void camelSettings() {
+        camelRidableInWater = getBoolean("mobs.camel.ridable-in-water", camelRidableInWater);
+        camelMaxHealthMin = getDouble("mobs.camel.attributes.max_health.min", camelMaxHealthMin);
+        camelMaxHealthMax = getDouble("mobs.camel.attributes.max_health.max", camelMaxHealthMax);
+        camelJumpStrengthMin = getDouble("mobs.camel.attributes.jump_strength.min", camelJumpStrengthMin);
+        camelJumpStrengthMax = getDouble("mobs.camel.attributes.jump_strength.max", camelJumpStrengthMax);
+        camelMovementSpeedMin = getDouble("mobs.camel.attributes.movement_speed.min", camelMovementSpeedMin);
+        camelMovementSpeedMax = getDouble("mobs.camel.attributes.movement_speed.max", camelMovementSpeedMax);
+        camelBreedingTicks = getInt("mobs.camel.breeding-delay-ticks", camelBreedingTicks);
+    }
+
+    public boolean catRidable = false;
+    public boolean catRidableInWater = true;
+    public boolean catControllable = true;
+    public double catMaxHealth = 10.0D;
+    public double catScale = 1.0D;
+    public int catSpawnDelay = 1200;
+    public int catSpawnSwampHutScanRange = 16;
+    public int catSpawnVillageScanRange = 48;
+    public int catBreedingTicks = 6000;
+    public DyeColor catDefaultCollarColor = DyeColor.RED;
+    public boolean catTakeDamageFromWater = false;
+    public boolean catAlwaysDropExp = false;
+    private void catSettings() {
+        catRidable = getBoolean("mobs.cat.ridable", catRidable);
+        catRidableInWater = getBoolean("mobs.cat.ridable-in-water", catRidableInWater);
+        catControllable = getBoolean("mobs.cat.controllable", catControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cat.attributes.max-health", catMaxHealth);
+            set("mobs.cat.attributes.max-health", null);
+            set("mobs.cat.attributes.max_health", oldValue);
+        }
+        catMaxHealth = getDouble("mobs.cat.attributes.max_health", catMaxHealth);
+        catScale = Mth.clamp(getDouble("mobs.cat.attributes.scale", catScale), 0.0625D, 16.0D);
+        catSpawnDelay = getInt("mobs.cat.spawn-delay", catSpawnDelay);
+        catSpawnSwampHutScanRange = getInt("mobs.cat.scan-range-for-other-cats.swamp-hut", catSpawnSwampHutScanRange);
+        catSpawnVillageScanRange = getInt("mobs.cat.scan-range-for-other-cats.village", catSpawnVillageScanRange);
+        catBreedingTicks = getInt("mobs.cat.breeding-delay-ticks", catBreedingTicks);
+        try {
+            catDefaultCollarColor = DyeColor.valueOf(getString("mobs.cat.default-collar-color", catDefaultCollarColor.name()));
+        } catch (IllegalArgumentException ignore) {
+            catDefaultCollarColor = DyeColor.RED;
+        }
+        catTakeDamageFromWater = getBoolean("mobs.cat.takes-damage-from-water", catTakeDamageFromWater);
+        catAlwaysDropExp = getBoolean("mobs.cat.always-drop-exp", catAlwaysDropExp);
+    }
+
+    public boolean caveSpiderRidable = false;
+    public boolean caveSpiderRidableInWater = true;
+    public boolean caveSpiderControllable = true;
+    public double caveSpiderMaxHealth = 12.0D;
+    public double caveSpiderScale = 1.0D;
+    public boolean caveSpiderTakeDamageFromWater = false;
+    public boolean caveSpiderAlwaysDropExp = false;
+    private void caveSpiderSettings() {
+        caveSpiderRidable = getBoolean("mobs.cave_spider.ridable", caveSpiderRidable);
+        caveSpiderRidableInWater = getBoolean("mobs.cave_spider.ridable-in-water", caveSpiderRidableInWater);
+        caveSpiderControllable = getBoolean("mobs.cave_spider.controllable", caveSpiderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cave_spider.attributes.max-health", caveSpiderMaxHealth);
+            set("mobs.cave_spider.attributes.max-health", null);
+            set("mobs.cave_spider.attributes.max_health", oldValue);
+        }
+        caveSpiderMaxHealth = getDouble("mobs.cave_spider.attributes.max_health", caveSpiderMaxHealth);
+        caveSpiderScale = Mth.clamp(getDouble("mobs.cave_spider.attributes.scale", caveSpiderScale), 0.0625D, 16.0D);
+        caveSpiderTakeDamageFromWater = getBoolean("mobs.cave_spider.takes-damage-from-water", caveSpiderTakeDamageFromWater);
+        caveSpiderAlwaysDropExp = getBoolean("mobs.cave_spider.always-drop-exp", caveSpiderAlwaysDropExp);
+    }
+
+    public boolean chickenRidable = false;
+    public boolean chickenRidableInWater = false;
+    public boolean chickenControllable = true;
+    public double chickenMaxHealth = 4.0D;
+    public double chickenScale = 1.0D;
+    public boolean chickenRetaliate = false;
+    public int chickenBreedingTicks = 6000;
+    public boolean chickenTakeDamageFromWater = false;
+    public boolean chickenAlwaysDropExp = false;
+    private void chickenSettings() {
+        chickenRidable = getBoolean("mobs.chicken.ridable", chickenRidable);
+        chickenRidableInWater = getBoolean("mobs.chicken.ridable-in-water", chickenRidableInWater);
+        chickenControllable = getBoolean("mobs.chicken.controllable", chickenControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.chicken.attributes.max-health", chickenMaxHealth);
+            set("mobs.chicken.attributes.max-health", null);
+            set("mobs.chicken.attributes.max_health", oldValue);
+        }
+        chickenMaxHealth = getDouble("mobs.chicken.attributes.max_health", chickenMaxHealth);
+        chickenScale = Mth.clamp(getDouble("mobs.chicken.attributes.scale", chickenScale), 0.0625D, 16.0D);
+        chickenRetaliate = getBoolean("mobs.chicken.retaliate", chickenRetaliate);
+        chickenBreedingTicks = getInt("mobs.chicken.breeding-delay-ticks", chickenBreedingTicks);
+        chickenTakeDamageFromWater = getBoolean("mobs.chicken.takes-damage-from-water", chickenTakeDamageFromWater);
+        chickenAlwaysDropExp = getBoolean("mobs.chicken.always-drop-exp", chickenAlwaysDropExp);
+    }
+
+    public boolean codRidable = false;
+    public boolean codControllable = true;
+    public double codMaxHealth = 3.0D;
+    public double codScale = 1.0D;
+    public boolean codTakeDamageFromWater = false;
+    public boolean codAlwaysDropExp = false;
+    private void codSettings() {
+        codRidable = getBoolean("mobs.cod.ridable", codRidable);
+        codControllable = getBoolean("mobs.cod.controllable", codControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cod.attributes.max-health", codMaxHealth);
+            set("mobs.cod.attributes.max-health", null);
+            set("mobs.cod.attributes.max_health", oldValue);
+        }
+        codMaxHealth = getDouble("mobs.cod.attributes.max_health", codMaxHealth);
+        codScale = Mth.clamp(getDouble("mobs.cod.attributes.scale", codScale), 0.0625D, 16.0D);
+        codTakeDamageFromWater = getBoolean("mobs.cod.takes-damage-from-water", codTakeDamageFromWater);
+        codAlwaysDropExp = getBoolean("mobs.cod.always-drop-exp", codAlwaysDropExp);
+    }
+
+    public boolean cowRidable = false;
+    public boolean cowRidableInWater = true;
+    public boolean cowControllable = true;
+    public double cowMaxHealth = 10.0D;
+    public double cowScale = 1.0D;
+    public int cowFeedMushrooms = 0;
+    public int cowBreedingTicks = 6000;
+    public boolean cowTakeDamageFromWater = false;
+    public double cowNaturallyAggressiveToPlayersChance = 0.0D;
+    public double cowNaturallyAggressiveToPlayersDamage = 2.0D;
+    public boolean cowAlwaysDropExp = false;
+    private void cowSettings() {
+        if (PurpurConfig.version < 22) {
+            double oldValue = getDouble("mobs.cow.naturally-aggressive-to-players-chance", cowNaturallyAggressiveToPlayersChance);
+            set("mobs.cow.naturally-aggressive-to-players-chance", null);
+            set("mobs.cow.naturally-aggressive-to-players.chance", oldValue);
+        }
+        cowRidable = getBoolean("mobs.cow.ridable", cowRidable);
+        cowRidableInWater = getBoolean("mobs.cow.ridable-in-water", cowRidableInWater);
+        cowControllable = getBoolean("mobs.cow.controllable", cowControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.cow.attributes.max-health", cowMaxHealth);
+            set("mobs.cow.attributes.max-health", null);
+            set("mobs.cow.attributes.max_health", oldValue);
+        }
+        cowMaxHealth = getDouble("mobs.cow.attributes.max_health", cowMaxHealth);
+        cowScale = Mth.clamp(getDouble("mobs.cow.attributes.scale", cowScale), 0.0625D, 16.0D);
+        cowFeedMushrooms = getInt("mobs.cow.feed-mushrooms-for-mooshroom", cowFeedMushrooms);
+        cowBreedingTicks = getInt("mobs.cow.breeding-delay-ticks", cowBreedingTicks);
+        cowTakeDamageFromWater = getBoolean("mobs.cow.takes-damage-from-water", cowTakeDamageFromWater);
+        cowNaturallyAggressiveToPlayersChance = getDouble("mobs.cow.naturally-aggressive-to-players.chance", cowNaturallyAggressiveToPlayersChance);
+        cowNaturallyAggressiveToPlayersDamage = getDouble("mobs.cow.naturally-aggressive-to-players.damage", cowNaturallyAggressiveToPlayersDamage);
+        cowAlwaysDropExp = getBoolean("mobs.cow.always-drop-exp", cowAlwaysDropExp);
+    }
+
+    public boolean creakingRidable = false;
+    public boolean creakingRidableInWater = true;
+    public boolean creakingControllable = true;
+    public double creakingMaxHealth = 1.0D;
+    public double creakingScale = 1.0D;
+    private void creakingSettings() {
+        creakingRidable = getBoolean("mobs.creaking.ridable", creakingRidable);
+        creakingRidableInWater = getBoolean("mobs.creaking.ridable-in-water", creakingRidableInWater);
+        creakingControllable = getBoolean("mobs.creaking.controllable", creakingControllable);
+        creakingMaxHealth = getDouble("mobs.creaking.attributes.max_health", creakingMaxHealth);
+        creakingScale = Mth.clamp(getDouble("mobs.creaking.attributes.scale", creakingScale), 0.0625D, 16.0D);
+    }
+
+    public boolean creeperRidable = false;
+    public boolean creeperRidableInWater = true;
+    public boolean creeperControllable = true;
+    public double creeperMaxHealth = 20.0D;
+    public double creeperScale = 1.0D;
+    public double creeperChargedChance = 0.0D;
+    public boolean creeperAllowGriefing = true;
+    public Boolean creeperMobGriefingOverride = null;
+    public boolean creeperTakeDamageFromWater = false;
+    public boolean creeperExplodeWhenKilled = false;
+    public boolean creeperHealthRadius = false;
+    public boolean creeperAlwaysDropExp = false;
+    public double creeperHeadVisibilityPercent = 0.5D;
+    public boolean creeperEncircleTarget = false;
+    private void creeperSettings() {
+        creeperRidable = getBoolean("mobs.creeper.ridable", creeperRidable);
+        creeperRidableInWater = getBoolean("mobs.creeper.ridable-in-water", creeperRidableInWater);
+        creeperControllable = getBoolean("mobs.creeper.controllable", creeperControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.creeper.attributes.max-health", creeperMaxHealth);
+            set("mobs.creeper.attributes.max-health", null);
+            set("mobs.creeper.attributes.max_health", oldValue);
+        }
+        creeperMaxHealth = getDouble("mobs.creeper.attributes.max_health", creeperMaxHealth);
+        creeperScale = Mth.clamp(getDouble("mobs.creeper.attributes.scale", creeperScale), 0.0625D, 16.0D);
+        creeperChargedChance = getDouble("mobs.creeper.naturally-charged-chance", creeperChargedChance);
+        creeperAllowGriefing = getBoolean("mobs.creeper.allow-griefing", creeperAllowGriefing);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.creeper.bypass-mob-griefing", false);
+            set("mobs.creeper.bypass-mob-griefing", null);
+            set("mobs.creeper.mob-griefing-override", oldVal ? true : "default");
+        }
+        creeperMobGriefingOverride = getBooleanOrDefault("mobs.creeper.mob-griefing-override", creeperMobGriefingOverride);
+        creeperTakeDamageFromWater = getBoolean("mobs.creeper.takes-damage-from-water", creeperTakeDamageFromWater);
+        creeperExplodeWhenKilled = getBoolean("mobs.creeper.explode-when-killed", creeperExplodeWhenKilled);
+        creeperHealthRadius = getBoolean("mobs.creeper.health-impacts-explosion", creeperHealthRadius);
+        creeperAlwaysDropExp = getBoolean("mobs.creeper.always-drop-exp", creeperAlwaysDropExp);
+        creeperHeadVisibilityPercent = getDouble("mobs.creeper.head-visibility-percent", creeperHeadVisibilityPercent);
+        creeperEncircleTarget = getBoolean("mobs.creeper.encircle-target", creeperEncircleTarget);
+    }
+
+    public boolean dolphinRidable = false;
+    public boolean dolphinControllable = true;
+    public int dolphinSpitCooldown = 20;
+    public float dolphinSpitSpeed = 1.0F;
+    public float dolphinSpitDamage = 2.0F;
+    public double dolphinMaxHealth = 10.0D;
+    public double dolphinScale = 1.0D;
+    public boolean dolphinDisableTreasureSearching = false;
+    public boolean dolphinTakeDamageFromWater = false;
+    public double dolphinNaturallyAggressiveToPlayersChance = 0.0D;
+    public boolean dolphinAlwaysDropExp = false;
+    private void dolphinSettings() {
+        dolphinRidable = getBoolean("mobs.dolphin.ridable", dolphinRidable);
+        dolphinControllable = getBoolean("mobs.dolphin.controllable", dolphinControllable);
+        dolphinSpitCooldown = getInt("mobs.dolphin.spit.cooldown", dolphinSpitCooldown);
+        dolphinSpitSpeed = (float) getDouble("mobs.dolphin.spit.speed", dolphinSpitSpeed);
+        dolphinSpitDamage = (float) getDouble("mobs.dolphin.spit.damage", dolphinSpitDamage);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.dolphin.attributes.max-health", dolphinMaxHealth);
+            set("mobs.dolphin.attributes.max-health", null);
+            set("mobs.dolphin.attributes.max_health", oldValue);
+        }
+        dolphinMaxHealth = getDouble("mobs.dolphin.attributes.max_health", dolphinMaxHealth);
+        dolphinScale = Mth.clamp(getDouble("mobs.dolphin.attributes.scale", dolphinScale), 0.0625D, 16.0D);
+        dolphinDisableTreasureSearching = getBoolean("mobs.dolphin.disable-treasure-searching", dolphinDisableTreasureSearching);
+        dolphinTakeDamageFromWater = getBoolean("mobs.dolphin.takes-damage-from-water", dolphinTakeDamageFromWater);
+        dolphinNaturallyAggressiveToPlayersChance = getDouble("mobs.dolphin.naturally-aggressive-to-players-chance", dolphinNaturallyAggressiveToPlayersChance);
+        dolphinAlwaysDropExp = getBoolean("mobs.dolphin.always-drop-exp", dolphinAlwaysDropExp);
+    }
+
+    public boolean donkeyRidableInWater = false;
+    public double donkeyMaxHealthMin = 15.0D;
+    public double donkeyMaxHealthMax = 30.0D;
+    public double donkeyJumpStrengthMin = 0.5D;
+    public double donkeyJumpStrengthMax = 0.5D;
+    public double donkeyMovementSpeedMin = 0.175D;
+    public double donkeyMovementSpeedMax = 0.175D;
+    public int donkeyBreedingTicks = 6000;
+    public boolean donkeyTakeDamageFromWater = false;
+    public boolean donkeyAlwaysDropExp = false;
+    private void donkeySettings() {
+        donkeyRidableInWater = getBoolean("mobs.donkey.ridable-in-water", donkeyRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.donkey.attributes.max-health.min", donkeyMaxHealthMin);
+            double oldMax = getDouble("mobs.donkey.attributes.max-health.max", donkeyMaxHealthMax);
+            set("mobs.donkey.attributes.max-health", null);
+            set("mobs.donkey.attributes.max_health.min", oldMin);
+            set("mobs.donkey.attributes.max_health.max", oldMax);
+        }
+        donkeyMaxHealthMin = getDouble("mobs.donkey.attributes.max_health.min", donkeyMaxHealthMin);
+        donkeyMaxHealthMax = getDouble("mobs.donkey.attributes.max_health.max", donkeyMaxHealthMax);
+        donkeyJumpStrengthMin = getDouble("mobs.donkey.attributes.jump_strength.min", donkeyJumpStrengthMin);
+        donkeyJumpStrengthMax = getDouble("mobs.donkey.attributes.jump_strength.max", donkeyJumpStrengthMax);
+        donkeyMovementSpeedMin = getDouble("mobs.donkey.attributes.movement_speed.min", donkeyMovementSpeedMin);
+        donkeyMovementSpeedMax = getDouble("mobs.donkey.attributes.movement_speed.max", donkeyMovementSpeedMax);
+        donkeyBreedingTicks = getInt("mobs.donkey.breeding-delay-ticks", donkeyBreedingTicks);
+        donkeyTakeDamageFromWater = getBoolean("mobs.donkey.takes-damage-from-water", donkeyTakeDamageFromWater);
+        donkeyAlwaysDropExp = getBoolean("mobs.donkey.always-drop-exp", donkeyAlwaysDropExp);
+    }
+
+    public boolean drownedRidable = false;
+    public boolean drownedRidableInWater = true;
+    public boolean drownedControllable = true;
+    public double drownedMaxHealth = 20.0D;
+    public double drownedScale = 1.0D;
+    public double drownedSpawnReinforcements = 0.1D;
+    public boolean drownedJockeyOnlyBaby = true;
+    public double drownedJockeyChance = 0.05D;
+    public boolean drownedJockeyTryExistingChickens = true;
+    public boolean drownedTakeDamageFromWater = false;
+    public boolean drownedBreakDoors = false;
+    public boolean drownedAlwaysDropExp = false;
+    private void drownedSettings() {
+        drownedRidable = getBoolean("mobs.drowned.ridable", drownedRidable);
+        drownedRidableInWater = getBoolean("mobs.drowned.ridable-in-water", drownedRidableInWater);
+        drownedControllable = getBoolean("mobs.drowned.controllable", drownedControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.drowned.attributes.max-health", drownedMaxHealth);
+            set("mobs.drowned.attributes.max-health", null);
+            set("mobs.drowned.attributes.max_health", oldValue);
+        }
+        drownedMaxHealth = getDouble("mobs.drowned.attributes.max_health", drownedMaxHealth);
+        drownedScale = Mth.clamp(getDouble("mobs.drowned.attributes.scale", drownedScale), 0.0625D, 16.0D);
+        drownedSpawnReinforcements = getDouble("mobs.drowned.attributes.spawn_reinforcements", drownedSpawnReinforcements);
+        drownedJockeyOnlyBaby = getBoolean("mobs.drowned.jockey.only-babies", drownedJockeyOnlyBaby);
+        drownedJockeyChance = getDouble("mobs.drowned.jockey.chance", drownedJockeyChance);
+        drownedJockeyTryExistingChickens = getBoolean("mobs.drowned.jockey.try-existing-chickens", drownedJockeyTryExistingChickens);
+        drownedTakeDamageFromWater = getBoolean("mobs.drowned.takes-damage-from-water", drownedTakeDamageFromWater);
+        drownedBreakDoors = getBoolean("mobs.drowned.can-break-doors", drownedBreakDoors);
+        drownedAlwaysDropExp = getBoolean("mobs.drowned.always-drop-exp", drownedAlwaysDropExp);
+    }
+
+    public boolean elderGuardianRidable = false;
+    public boolean elderGuardianControllable = true;
+    public double elderGuardianMaxHealth = 80.0D;
+    public double elderGuardianScale = 1.0D;
+    public boolean elderGuardianTakeDamageFromWater = false;
+    public boolean elderGuardianAlwaysDropExp = false;
+    private void elderGuardianSettings() {
+        elderGuardianRidable = getBoolean("mobs.elder_guardian.ridable", elderGuardianRidable);
+        elderGuardianControllable = getBoolean("mobs.elder_guardian.controllable", elderGuardianControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.elder_guardian.attributes.max-health", elderGuardianMaxHealth);
+            set("mobs.elder_guardian.attributes.max-health", null);
+            set("mobs.elder_guardian.attributes.max_health", oldValue);
+        }
+        elderGuardianMaxHealth = getDouble("mobs.elder_guardian.attributes.max_health", elderGuardianMaxHealth);
+        elderGuardianScale = Mth.clamp(getDouble("mobs.elder_guardian.attributes.scale", elderGuardianScale), 0.0625D, 16.0D);
+        elderGuardianTakeDamageFromWater = getBoolean("mobs.elder_guardian.takes-damage-from-water", elderGuardianTakeDamageFromWater);
+        elderGuardianAlwaysDropExp = getBoolean("mobs.elder_guardian.always-drop-exp", elderGuardianAlwaysDropExp);
+    }
+
+    public boolean enchantmentTableLapisPersists = false;
+    private void enchantmentTableSettings() {
+        enchantmentTableLapisPersists = getBoolean("blocks.enchantment-table.lapis-persists", enchantmentTableLapisPersists);
+    }
+
+    public boolean enderDragonRidable = false;
+    public boolean enderDragonRidableInWater = true;
+    public boolean enderDragonControllable = true;
+    public double enderDragonMaxY = 320D;
+    public double enderDragonMaxHealth = 200.0D;
+    public boolean enderDragonAlwaysDropsFullExp = false;
+    public Boolean enderDragonMobGriefingOverride = null;
+    public boolean enderDragonTakeDamageFromWater = false;
+    public boolean enderDragonCanRideVehicles = false;
+    private void enderDragonSettings() {
+        enderDragonRidable = getBoolean("mobs.ender_dragon.ridable", enderDragonRidable);
+        enderDragonRidableInWater = getBoolean("mobs.ender_dragon.ridable-in-water", enderDragonRidableInWater);
+        enderDragonControllable = getBoolean("mobs.ender_dragon.controllable", enderDragonControllable);
+        enderDragonMaxY = getDouble("mobs.ender_dragon.ridable-max-y", enderDragonMaxY);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.ender_dragon.max-health", enderDragonMaxHealth);
+            set("mobs.ender_dragon.max-health", null);
+            set("mobs.ender_dragon.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ender_dragon.attributes.max-health", enderDragonMaxHealth);
+            set("mobs.ender_dragon.attributes.max-health", null);
+            set("mobs.ender_dragon.attributes.max_health", oldValue);
+        }
+        enderDragonMaxHealth = getDouble("mobs.ender_dragon.attributes.max_health", enderDragonMaxHealth);
+        enderDragonAlwaysDropsFullExp = getBoolean("mobs.ender_dragon.always-drop-full-exp", enderDragonAlwaysDropsFullExp);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.ender_dragon.bypass-mob-griefing", false);
+            set("mobs.ender_dragon.bypass-mob-griefing", null);
+            set("mobs.ender_dragon.mob-griefing-override", oldVal ? true : "default");
+        }
+        enderDragonMobGriefingOverride = getBooleanOrDefault("mobs.ender_dragon.mob-griefing-override", enderDragonMobGriefingOverride);
+        enderDragonTakeDamageFromWater = getBoolean("mobs.ender_dragon.takes-damage-from-water", enderDragonTakeDamageFromWater);
+        enderDragonCanRideVehicles = getBoolean("mobs.ender_dragon.can-ride-vehicles", enderDragonCanRideVehicles);
+    }
+
+    public boolean endermanRidable = false;
+    public boolean endermanRidableInWater = true;
+    public boolean endermanControllable = true;
+    public double endermanMaxHealth = 40.0D;
+    public double endermanScale = 1.0D;
+    public boolean endermanAllowGriefing = true;
+    public boolean endermanDespawnEvenWithBlock = false;
+    public Boolean endermanMobGriefingOverride = null;
+    public boolean endermanTakeDamageFromWater = true;
+    public boolean endermanAggroEndermites = true;
+    public boolean endermanAggroEndermitesOnlyIfPlayerSpawned = false;
+    public boolean endermanDisableStareAggro = false;
+    public boolean endermanIgnoreProjectiles = false;
+    public boolean endermanAlwaysDropExp = false;
+    private void endermanSettings() {
+        endermanRidable = getBoolean("mobs.enderman.ridable", endermanRidable);
+        endermanRidableInWater = getBoolean("mobs.enderman.ridable-in-water", endermanRidableInWater);
+        endermanControllable = getBoolean("mobs.enderman.controllable", endermanControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.enderman.attributes.max-health", endermanMaxHealth);
+            set("mobs.enderman.attributes.max-health", null);
+            set("mobs.enderman.attributes.max_health", oldValue);
+        }
+        if (PurpurConfig.version < 15) {
+            // remove old option
+            set("mobs.enderman.aggressive-towards-spawned-endermites", null);
+        }
+        endermanMaxHealth = getDouble("mobs.enderman.attributes.max_health", endermanMaxHealth);
+        endermanScale = Mth.clamp(getDouble("mobs.enderman.attributes.scale", endermanScale), 0.0625D, 16.0D);
+        endermanAllowGriefing = getBoolean("mobs.enderman.allow-griefing", endermanAllowGriefing);
+        endermanDespawnEvenWithBlock = getBoolean("mobs.enderman.can-despawn-with-held-block", endermanDespawnEvenWithBlock);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.enderman.bypass-mob-griefing", false);
+            set("mobs.enderman.bypass-mob-griefing", null);
+            set("mobs.enderman.mob-griefing-override", oldVal ? true : "default");
+        }
+        endermanMobGriefingOverride = getBooleanOrDefault("mobs.enderman.mob-griefing-override", endermanMobGriefingOverride);
+        endermanTakeDamageFromWater = getBoolean("mobs.enderman.takes-damage-from-water", endermanTakeDamageFromWater);
+        endermanAggroEndermites = getBoolean("mobs.enderman.aggressive-towards-endermites", endermanAggroEndermites);
+        endermanAggroEndermitesOnlyIfPlayerSpawned = getBoolean("mobs.enderman.aggressive-towards-endermites-only-spawned-by-player-thrown-ender-pearls", endermanAggroEndermitesOnlyIfPlayerSpawned);
+        endermanDisableStareAggro = getBoolean("mobs.enderman.disable-player-stare-aggression", endermanDisableStareAggro);
+        endermanIgnoreProjectiles = getBoolean("mobs.enderman.ignore-projectiles", endermanIgnoreProjectiles);
+        endermanAlwaysDropExp = getBoolean("mobs.enderman.always-drop-exp", endermanAlwaysDropExp);
+    }
+
+    public boolean endermiteRidable = false;
+    public boolean endermiteRidableInWater = true;
+    public boolean endermiteControllable = true;
+    public double endermiteMaxHealth = 8.0D;
+    public double endermiteScale = 1.0D;
+    public boolean endermiteTakeDamageFromWater = false;
+    public boolean endermiteAlwaysDropExp = false;
+    private void endermiteSettings() {
+        endermiteRidable = getBoolean("mobs.endermite.ridable", endermiteRidable);
+        endermiteRidableInWater = getBoolean("mobs.endermite.ridable-in-water", endermiteRidableInWater);
+        endermiteControllable = getBoolean("mobs.endermite.controllable", endermiteControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.endermite.attributes.max-health", endermiteMaxHealth);
+            set("mobs.endermite.attributes.max-health", null);
+            set("mobs.endermite.attributes.max_health", oldValue);
+        }
+        endermiteMaxHealth = getDouble("mobs.endermite.attributes.max_health", endermiteMaxHealth);
+        endermiteScale = Mth.clamp(getDouble("mobs.endermite.attributes.scale", endermiteScale), 0.0625D, 16.0D);
+        endermiteTakeDamageFromWater = getBoolean("mobs.endermite.takes-damage-from-water", endermiteTakeDamageFromWater);
+        endermiteAlwaysDropExp = getBoolean("mobs.endermite.always-drop-exp", endermiteAlwaysDropExp);
+    }
+
+    public boolean evokerRidable = false;
+    public boolean evokerRidableInWater = true;
+    public boolean evokerControllable = true;
+    public double evokerMaxHealth = 24.0D;
+    public double evokerScale = 1.0D;
+    public Boolean evokerMobGriefingOverride = null;
+    public boolean evokerTakeDamageFromWater = false;
+    public boolean evokerAlwaysDropExp = false;
+    private void evokerSettings() {
+        evokerRidable = getBoolean("mobs.evoker.ridable", evokerRidable);
+        evokerRidableInWater = getBoolean("mobs.evoker.ridable-in-water", evokerRidableInWater);
+        evokerControllable = getBoolean("mobs.evoker.controllable", evokerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.evoker.attributes.max-health", evokerMaxHealth);
+            set("mobs.evoker.attributes.max-health", null);
+            set("mobs.evoker.attributes.max_health", oldValue);
+        }
+        evokerMaxHealth = getDouble("mobs.evoker.attributes.max_health", evokerMaxHealth);
+        evokerScale = Mth.clamp(getDouble("mobs.evoker.attributes.scale", evokerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.evoker.bypass-mob-griefing", false);
+            set("mobs.evoker.bypass-mob-griefing", null);
+            set("mobs.evoker.mob-griefing-override", oldVal ? true : "default");
+        }
+        evokerMobGriefingOverride = getBooleanOrDefault("mobs.evoker.mob-griefing-override", evokerMobGriefingOverride);
+        evokerTakeDamageFromWater = getBoolean("mobs.evoker.takes-damage-from-water", evokerTakeDamageFromWater);
+        evokerAlwaysDropExp = getBoolean("mobs.evoker.always-drop-exp", evokerAlwaysDropExp);
+    }
+
+    public boolean foxRidable = false;
+    public boolean foxRidableInWater = true;
+    public boolean foxControllable = true;
+    public double foxMaxHealth = 10.0D;
+    public double foxScale = 1.0D;
+    public boolean foxTypeChangesWithTulips = false;
+    public int foxBreedingTicks = 6000;
+    public Boolean foxMobGriefingOverride = null;
+    public boolean foxTakeDamageFromWater = false;
+    public boolean foxAlwaysDropExp = false;
+    private void foxSettings() {
+        foxRidable = getBoolean("mobs.fox.ridable", foxRidable);
+        foxRidableInWater = getBoolean("mobs.fox.ridable-in-water", foxRidableInWater);
+        foxControllable = getBoolean("mobs.fox.controllable", foxControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.fox.attributes.max-health", foxMaxHealth);
+            set("mobs.fox.attributes.max-health", null);
+            set("mobs.fox.attributes.max_health", oldValue);
+        }
+        foxMaxHealth = getDouble("mobs.fox.attributes.max_health", foxMaxHealth);
+        foxScale = Mth.clamp(getDouble("mobs.fox.attributes.scale", foxScale), 0.0625D, 16.0D);
+        foxTypeChangesWithTulips = getBoolean("mobs.fox.tulips-change-type", foxTypeChangesWithTulips);
+        foxBreedingTicks = getInt("mobs.fox.breeding-delay-ticks", foxBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.fox.bypass-mob-griefing", false);
+            set("mobs.fox.bypass-mob-griefing", null);
+            set("mobs.fox.mob-griefing-override", oldVal ? true : "default");
+        }
+        foxMobGriefingOverride = getBooleanOrDefault("mobs.fox.mob-griefing-override", foxMobGriefingOverride);
+        foxTakeDamageFromWater = getBoolean("mobs.fox.takes-damage-from-water", foxTakeDamageFromWater);
+        foxAlwaysDropExp = getBoolean("mobs.fox.always-drop-exp", foxAlwaysDropExp);
+    }
+
+    public boolean frogRidable = false;
+    public boolean frogRidableInWater = true;
+    public boolean frogControllable = true;
+    public float frogRidableJumpHeight = 0.65F;
+    public int frogBreedingTicks = 6000;
+    private void frogSettings() {
+        frogRidable = getBoolean("mobs.frog.ridable", frogRidable);
+        frogRidableInWater = getBoolean("mobs.frog.ridable-in-water", frogRidableInWater);
+        frogControllable = getBoolean("mobs.frog.controllable", frogControllable);
+        frogRidableJumpHeight = (float) getDouble("mobs.frog.ridable-jump-height", frogRidableJumpHeight);
+        frogBreedingTicks = getInt("mobs.frog.breeding-delay-ticks", frogBreedingTicks);
+    }
+
+    public boolean ghastRidable = false;
+    public boolean ghastRidableInWater = true;
+    public boolean ghastControllable = true;
+    public double ghastMaxY = 320D;
+    public double ghastMaxHealth = 10.0D;
+    public double ghastScale = 1.0D;
+    public boolean ghastTakeDamageFromWater = false;
+    public boolean ghastAlwaysDropExp = false;
+    private void ghastSettings() {
+        ghastRidable = getBoolean("mobs.ghast.ridable", ghastRidable);
+        ghastRidableInWater = getBoolean("mobs.ghast.ridable-in-water", ghastRidableInWater);
+        ghastControllable = getBoolean("mobs.ghast.controllable", ghastControllable);
+        ghastMaxY = getDouble("mobs.ghast.ridable-max-y", ghastMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ghast.attributes.max-health", ghastMaxHealth);
+            set("mobs.ghast.attributes.max-health", null);
+            set("mobs.ghast.attributes.max_health", oldValue);
+        }
+        ghastMaxHealth = getDouble("mobs.ghast.attributes.max_health", ghastMaxHealth);
+        ghastScale = Mth.clamp(getDouble("mobs.ghast.attributes.scale", ghastScale), 0.0625D, 16.0D);
+        ghastTakeDamageFromWater = getBoolean("mobs.ghast.takes-damage-from-water", ghastTakeDamageFromWater);
+        ghastAlwaysDropExp = getBoolean("mobs.ghast.always-drop-exp", ghastAlwaysDropExp);
+    }
+
+    public boolean giantRidable = false;
+    public boolean giantRidableInWater = true;
+    public boolean giantControllable = true;
+    public double giantMovementSpeed = 0.5D;
+    public double giantAttackDamage = 50.0D;
+    public double giantMaxHealth = 100.0D;
+    public double giantScale = 1.0D;
+    public float giantStepHeight = 2.0F;
+    public float giantJumpHeight = 1.0F;
+    public boolean giantHaveAI = false;
+    public boolean giantHaveHostileAI = false;
+    public boolean giantTakeDamageFromWater = false;
+    public boolean giantAlwaysDropExp = false;
+    private void giantSettings() {
+        giantRidable = getBoolean("mobs.giant.ridable", giantRidable);
+        giantRidableInWater = getBoolean("mobs.giant.ridable-in-water", giantRidableInWater);
+        giantControllable = getBoolean("mobs.giant.controllable", giantControllable);
+        giantMovementSpeed = getDouble("mobs.giant.movement-speed", giantMovementSpeed);
+        giantAttackDamage = getDouble("mobs.giant.attack-damage", giantAttackDamage);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.giant.max-health", giantMaxHealth);
+            set("mobs.giant.max-health", null);
+            set("mobs.giant.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.giant.attributes.max-health", giantMaxHealth);
+            set("mobs.giant.attributes.max-health", null);
+            set("mobs.giant.attributes.max_health", oldValue);
+        }
+        giantMaxHealth = getDouble("mobs.giant.attributes.max_health", giantMaxHealth);
+        giantScale = Mth.clamp(getDouble("mobs.giant.attributes.scale", giantScale), 0.0625D, 16.0D);
+        giantStepHeight = (float) getDouble("mobs.giant.step-height", giantStepHeight);
+        giantJumpHeight = (float) getDouble("mobs.giant.jump-height", giantJumpHeight);
+        giantHaveAI = getBoolean("mobs.giant.have-ai", giantHaveAI);
+        giantHaveHostileAI = getBoolean("mobs.giant.have-hostile-ai", giantHaveHostileAI);
+        giantTakeDamageFromWater = getBoolean("mobs.giant.takes-damage-from-water", giantTakeDamageFromWater);
+        giantAlwaysDropExp = getBoolean("mobs.giant.always-drop-exp", giantAlwaysDropExp);
+    }
+
+    public boolean glowSquidRidable = false;
+    public boolean glowSquidControllable = true;
+    public double glowSquidMaxHealth = 10.0D;
+    public double glowSquidScale = 1.0D;
+    public boolean glowSquidsCanFly = false;
+    public boolean glowSquidTakeDamageFromWater = false;
+    public boolean glowSquidAlwaysDropExp = false;
+    private void glowSquidSettings() {
+        glowSquidRidable = getBoolean("mobs.glow_squid.ridable", glowSquidRidable);
+        glowSquidControllable = getBoolean("mobs.glow_squid.controllable", glowSquidControllable);
+        glowSquidMaxHealth = getDouble("mobs.glow_squid.attributes.max_health", glowSquidMaxHealth);
+        glowSquidScale = Mth.clamp(getDouble("mobs.glow_squid.attributes.scale", glowSquidScale), 0.0625D, 16.0D);
+        glowSquidsCanFly = getBoolean("mobs.glow_squid.can-fly", glowSquidsCanFly);
+        glowSquidTakeDamageFromWater = getBoolean("mobs.glow_squid.takes-damage-from-water", glowSquidTakeDamageFromWater);
+        glowSquidAlwaysDropExp = getBoolean("mobs.glow_squid.always-drop-exp", glowSquidAlwaysDropExp);
+    }
+
+    public boolean goatRidable = false;
+    public boolean goatRidableInWater = true;
+    public boolean goatControllable = true;
+    public double goatMaxHealth = 10.0D;
+    public double goatScale = 1.0D;
+    public int goatBreedingTicks = 6000;
+    public boolean goatTakeDamageFromWater = false;
+    public boolean goatAlwaysDropExp = false;
+    private void goatSettings() {
+        goatRidable = getBoolean("mobs.goat.ridable", goatRidable);
+        goatRidableInWater = getBoolean("mobs.goat.ridable-in-water", goatRidableInWater);
+        goatControllable = getBoolean("mobs.goat.controllable", goatControllable);
+        goatMaxHealth = getDouble("mobs.goat.attributes.max_health", goatMaxHealth);
+        goatScale = Mth.clamp(getDouble("mobs.goat.attributes.scale", goatScale), 0.0625D, 16.0D);
+        goatBreedingTicks = getInt("mobs.goat.breeding-delay-ticks", goatBreedingTicks);
+        goatTakeDamageFromWater = getBoolean("mobs.goat.takes-damage-from-water", goatTakeDamageFromWater);
+        goatAlwaysDropExp = getBoolean("mobs.goat.always-drop-exp", goatAlwaysDropExp);
+    }
+
+    public boolean guardianRidable = false;
+    public boolean guardianControllable = true;
+    public double guardianMaxHealth = 30.0D;
+    public double guardianScale = 1.0D;
+    public boolean guardianTakeDamageFromWater = false;
+    public boolean guardianAlwaysDropExp = false;
+    private void guardianSettings() {
+        guardianRidable = getBoolean("mobs.guardian.ridable", guardianRidable);
+        guardianControllable = getBoolean("mobs.guardian.controllable", guardianControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.guardian.attributes.max-health", guardianMaxHealth);
+            set("mobs.guardian.attributes.max-health", null);
+            set("mobs.guardian.attributes.max_health", oldValue);
+        }
+        guardianMaxHealth = getDouble("mobs.guardian.attributes.max_health", guardianMaxHealth);
+        guardianScale = Mth.clamp(getDouble("mobs.guardian.attributes.scale", guardianScale), 0.0625D, 16.0D);
+        guardianTakeDamageFromWater = getBoolean("mobs.guardian.takes-damage-from-water", guardianTakeDamageFromWater);
+        guardianAlwaysDropExp = getBoolean("mobs.guardian.always-drop-exp", guardianAlwaysDropExp);
+    }
+
+    public boolean forceHalloweenSeason = false;
+    public float chanceHeadHalloweenOnEntity = 0.25F;
+    private void halloweenSetting() {
+        forceHalloweenSeason = getBoolean("gameplay-mechanics.halloween.force", forceHalloweenSeason);
+        chanceHeadHalloweenOnEntity = (float) getDouble("gameplay-mechanics.halloween.head-chance", chanceHeadHalloweenOnEntity);
+    }
+
+    public boolean happyGhastRidableInWater = false;
+    public double happyGhastMaxHealth = 20.0D;
+    public double happyGhastTemptRange = 16.0D;
+    public double happyGhastFlyingSpeed = 0.05D;
+    public double happyGhastMovementSpeed = 0.05D;
+    public double happyGhastFollowRange = 16.0D;
+    public double happyGhastCameraDistance = 8.0D;
+    public double happyGhastScale = 1.0D;
+    public boolean happyGhastTakeDamageFromWater = false;
+    public boolean happyGhastAlwaysDropExp = false;
+    private void happyGhastSettings() {
+        happyGhastRidableInWater = getBoolean("mobs.happy_ghast.ridable-in-water", happyGhastRidableInWater);
+        happyGhastMaxHealth = getDouble("mobs.happy_ghast.attributes.max_health", happyGhastMaxHealth);
+        happyGhastTemptRange = getDouble("mobs.happy_ghast.attributes.tempt_range", happyGhastTemptRange);
+        happyGhastFlyingSpeed = getDouble("mobs.happy_ghast.attributes.flying_speed", happyGhastFlyingSpeed);
+        happyGhastMovementSpeed = getDouble("mobs.happy_ghast.attributes.movement_speed", happyGhastMovementSpeed);
+        happyGhastFollowRange = getDouble("mobs.happy_ghast.attributes.follow_range", happyGhastFollowRange);
+        happyGhastCameraDistance = getDouble("mobs.happy_ghast.attributes.camera_distance", happyGhastCameraDistance);
+        happyGhastScale = Mth.clamp(getDouble("mobs.happy_ghast.attributes.scale", happyGhastScale), 0.0625D, 1.0D);
+        happyGhastTakeDamageFromWater = getBoolean("mobs.happy_ghast.takes-damage-from-water", happyGhastTakeDamageFromWater);
+        happyGhastAlwaysDropExp = getBoolean("mobs.happy_ghast.always-drop-exp", happyGhastAlwaysDropExp);
+    }
+
+    public boolean hoglinRidable = false;
+    public boolean hoglinRidableInWater = true;
+    public boolean hoglinControllable = true;
+    public double hoglinMaxHealth = 40.0D;
+    public double hoglinScale = 1.0D;
+    public int hoglinBreedingTicks = 6000;
+    public boolean hoglinTakeDamageFromWater = false;
+    public boolean hoglinAlwaysDropExp = false;
+    private void hoglinSettings() {
+        hoglinRidable = getBoolean("mobs.hoglin.ridable", hoglinRidable);
+        hoglinRidableInWater = getBoolean("mobs.hoglin.ridable-in-water", hoglinRidableInWater);
+        hoglinControllable = getBoolean("mobs.hoglin.controllable", hoglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.hoglin.attributes.max-health", hoglinMaxHealth);
+            set("mobs.hoglin.attributes.max-health", null);
+            set("mobs.hoglin.attributes.max_health", oldValue);
+        }
+        hoglinMaxHealth = getDouble("mobs.hoglin.attributes.max_health", hoglinMaxHealth);
+        hoglinScale = Mth.clamp(getDouble("mobs.hoglin.attributes.scale", hoglinScale), 0.0625D, 16.0D);
+        hoglinBreedingTicks = getInt("mobs.hoglin.breeding-delay-ticks", hoglinBreedingTicks);
+        hoglinTakeDamageFromWater = getBoolean("mobs.hoglin.takes-damage-from-water", hoglinTakeDamageFromWater);
+        hoglinAlwaysDropExp = getBoolean("mobs.hoglin.always-drop-exp", hoglinAlwaysDropExp);
+    }
+
+    public boolean horseRidableInWater = false;
+    public double horseMaxHealthMin = 15.0D;
+    public double horseMaxHealthMax = 30.0D;
+    public double horseJumpStrengthMin = 0.4D;
+    public double horseJumpStrengthMax = 1.0D;
+    public double horseMovementSpeedMin = 0.1125D;
+    public double horseMovementSpeedMax = 0.3375D;
+    public int horseBreedingTicks = 6000;
+    public boolean horseTakeDamageFromWater = false;
+    public boolean horseAlwaysDropExp = false;
+    private void horseSettings() {
+        horseRidableInWater = getBoolean("mobs.horse.ridable-in-water", horseRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.horse.attributes.max-health.min", horseMaxHealthMin);
+            double oldMax = getDouble("mobs.horse.attributes.max-health.max", horseMaxHealthMax);
+            set("mobs.horse.attributes.max-health", null);
+            set("mobs.horse.attributes.max_health.min", oldMin);
+            set("mobs.horse.attributes.max_health.max", oldMax);
+        }
+        horseMaxHealthMin = getDouble("mobs.horse.attributes.max_health.min", horseMaxHealthMin);
+        horseMaxHealthMax = getDouble("mobs.horse.attributes.max_health.max", horseMaxHealthMax);
+        horseJumpStrengthMin = getDouble("mobs.horse.attributes.jump_strength.min", horseJumpStrengthMin);
+        horseJumpStrengthMax = getDouble("mobs.horse.attributes.jump_strength.max", horseJumpStrengthMax);
+        horseMovementSpeedMin = getDouble("mobs.horse.attributes.movement_speed.min", horseMovementSpeedMin);
+        horseMovementSpeedMax = getDouble("mobs.horse.attributes.movement_speed.max", horseMovementSpeedMax);
+        horseBreedingTicks = getInt("mobs.horse.breeding-delay-ticks", horseBreedingTicks);
+        horseTakeDamageFromWater = getBoolean("mobs.horse.takes-damage-from-water", horseTakeDamageFromWater);
+        horseAlwaysDropExp = getBoolean("mobs.horse.always-drop-exp", horseAlwaysDropExp);
+    }
+
+    public boolean huskRidable = false;
+    public boolean huskRidableInWater = true;
+    public boolean huskControllable = true;
+    public double huskMaxHealth = 20.0D;
+    public double huskScale = 1.0D;
+    public double huskSpawnReinforcements = 0.1D;
+    public boolean huskJockeyOnlyBaby = true;
+    public double huskJockeyChance = 0.05D;
+    public boolean huskJockeyTryExistingChickens = true;
+    public boolean huskTakeDamageFromWater = false;
+    public boolean huskAlwaysDropExp = false;
+    private void huskSettings() {
+        huskRidable = getBoolean("mobs.husk.ridable", huskRidable);
+        huskRidableInWater = getBoolean("mobs.husk.ridable-in-water", huskRidableInWater);
+        huskControllable = getBoolean("mobs.husk.controllable", huskControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.husk.attributes.max-health", huskMaxHealth);
+            set("mobs.husk.attributes.max-health", null);
+            set("mobs.husk.attributes.max_health", oldValue);
+        }
+        huskMaxHealth = getDouble("mobs.husk.attributes.max_health", huskMaxHealth);
+        huskScale = Mth.clamp(getDouble("mobs.husk.attributes.scale", huskScale), 0.0625D, 16.0D);
+        huskSpawnReinforcements = getDouble("mobs.husk.attributes.spawn_reinforcements", huskSpawnReinforcements);
+        huskJockeyOnlyBaby = getBoolean("mobs.husk.jockey.only-babies", huskJockeyOnlyBaby);
+        huskJockeyChance = getDouble("mobs.husk.jockey.chance", huskJockeyChance);
+        huskJockeyTryExistingChickens = getBoolean("mobs.husk.jockey.try-existing-chickens", huskJockeyTryExistingChickens);
+        huskTakeDamageFromWater = getBoolean("mobs.husk.takes-damage-from-water", huskTakeDamageFromWater);
+        huskAlwaysDropExp = getBoolean("mobs.husk.always-drop-exp", huskAlwaysDropExp);
+    }
+
+    public boolean illusionerRidable = false;
+    public boolean illusionerRidableInWater = true;
+    public boolean illusionerControllable = true;
+    public double illusionerMovementSpeed = 0.5D;
+    public double illusionerFollowRange = 18.0D;
+    public double illusionerMaxHealth = 32.0D;
+    public double illusionerScale = 1.0D;
+    public boolean illusionerTakeDamageFromWater = false;
+    public boolean illusionerAlwaysDropExp = false;
+    private void illusionerSettings() {
+        illusionerRidable = getBoolean("mobs.illusioner.ridable", illusionerRidable);
+        illusionerRidableInWater = getBoolean("mobs.illusioner.ridable-in-water", illusionerRidableInWater);
+        illusionerControllable = getBoolean("mobs.illusioner.controllable", illusionerControllable);
+        illusionerMovementSpeed = getDouble("mobs.illusioner.movement-speed", illusionerMovementSpeed);
+        illusionerFollowRange = getDouble("mobs.illusioner.follow-range", illusionerFollowRange);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.illusioner.max-health", illusionerMaxHealth);
+            set("mobs.illusioner.max-health", null);
+            set("mobs.illusioner.attributes.max_health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.illusioner.attributes.max-health", illusionerMaxHealth);
+            set("mobs.illusioner.attributes.max-health", null);
+            set("mobs.illusioner.attributes.max_health", oldValue);
+        }
+        illusionerMaxHealth = getDouble("mobs.illusioner.attributes.max_health", illusionerMaxHealth);
+        illusionerScale = Mth.clamp(getDouble("mobs.illusioner.attributes.scale", illusionerScale), 0.0625D, 16.0D);
+        illusionerTakeDamageFromWater = getBoolean("mobs.illusioner.takes-damage-from-water", illusionerTakeDamageFromWater);
+        illusionerAlwaysDropExp = getBoolean("mobs.illusioner.always-drop-exp", illusionerAlwaysDropExp);
+    }
+
+    public boolean ironGolemRidable = false;
+    public boolean ironGolemRidableInWater = true;
+    public boolean ironGolemControllable = true;
+    public boolean ironGolemCanSwim = false;
+    public double ironGolemMaxHealth = 100.0D;
+    public double ironGolemScale = 1.0D;
+    public boolean ironGolemTakeDamageFromWater = false;
+    public boolean ironGolemPoppyCalm = false;
+    public boolean ironGolemHealCalm = false;
+    public boolean ironGolemAlwaysDropExp = false;
+    private void ironGolemSettings() {
+        ironGolemRidable = getBoolean("mobs.iron_golem.ridable", ironGolemRidable);
+        ironGolemRidableInWater = getBoolean("mobs.iron_golem.ridable-in-water", ironGolemRidableInWater);
+        ironGolemControllable = getBoolean("mobs.iron_golem.controllable", ironGolemControllable);
+        ironGolemCanSwim = getBoolean("mobs.iron_golem.can-swim", ironGolemCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.iron_golem.attributes.max-health", ironGolemMaxHealth);
+            set("mobs.iron_golem.attributes.max-health", null);
+            set("mobs.iron_golem.attributes.max_health", oldValue);
+        }
+        ironGolemMaxHealth = getDouble("mobs.iron_golem.attributes.max_health", ironGolemMaxHealth);
+        ironGolemScale = Mth.clamp(getDouble("mobs.iron_golem.attributes.scale", ironGolemScale), 0.0625D, 16.0D);
+        ironGolemTakeDamageFromWater = getBoolean("mobs.iron_golem.takes-damage-from-water", ironGolemTakeDamageFromWater);
+        ironGolemPoppyCalm = getBoolean("mobs.iron_golem.poppy-calms-anger", ironGolemPoppyCalm);
+        ironGolemHealCalm = getBoolean("mobs.iron_golem.healing-calms-anger", ironGolemHealCalm);
+        ironGolemAlwaysDropExp = getBoolean("mobs.iron_golem.always-drop-exp", ironGolemAlwaysDropExp);
+    }
+
+    public boolean llamaRidable = false;
+    public boolean llamaRidableInWater = false;
+    public boolean llamaControllable = true;
+    public double llamaMaxHealthMin = 15.0D;
+    public double llamaMaxHealthMax = 30.0D;
+    public double llamaJumpStrengthMin = 0.5D;
+    public double llamaJumpStrengthMax = 0.5D;
+    public double llamaMovementSpeedMin = 0.175D;
+    public double llamaMovementSpeedMax = 0.175D;
+    public int llamaBreedingTicks = 6000;
+    public boolean llamaTakeDamageFromWater = false;
+    public boolean llamaJoinCaravans = true;
+    public boolean llamaAlwaysDropExp = false;
+    private void llamaSettings() {
+        llamaRidable = getBoolean("mobs.llama.ridable", llamaRidable);
+        llamaRidableInWater = getBoolean("mobs.llama.ridable-in-water", llamaRidableInWater);
+        llamaControllable = getBoolean("mobs.llama.controllable", llamaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.llama.attributes.max-health.min", llamaMaxHealthMin);
+            double oldMax = getDouble("mobs.llama.attributes.max-health.max", llamaMaxHealthMax);
+            set("mobs.llama.attributes.max-health", null);
+            set("mobs.llama.attributes.max_health.min", oldMin);
+            set("mobs.llama.attributes.max_health.max", oldMax);
+        }
+        llamaMaxHealthMin = getDouble("mobs.llama.attributes.max_health.min", llamaMaxHealthMin);
+        llamaMaxHealthMax = getDouble("mobs.llama.attributes.max_health.max", llamaMaxHealthMax);
+        llamaJumpStrengthMin = getDouble("mobs.llama.attributes.jump_strength.min", llamaJumpStrengthMin);
+        llamaJumpStrengthMax = getDouble("mobs.llama.attributes.jump_strength.max", llamaJumpStrengthMax);
+        llamaMovementSpeedMin = getDouble("mobs.llama.attributes.movement_speed.min", llamaMovementSpeedMin);
+        llamaMovementSpeedMax = getDouble("mobs.llama.attributes.movement_speed.max", llamaMovementSpeedMax);
+        llamaBreedingTicks = getInt("mobs.llama.breeding-delay-ticks", llamaBreedingTicks);
+        llamaTakeDamageFromWater = getBoolean("mobs.llama.takes-damage-from-water", llamaTakeDamageFromWater);
+        llamaJoinCaravans = getBoolean("mobs.llama.join-caravans", llamaJoinCaravans);
+        llamaAlwaysDropExp = getBoolean("mobs.llama.always-drop-exp", llamaAlwaysDropExp);
+    }
+
+    public boolean magmaCubeRidable = false;
+    public boolean magmaCubeRidableInWater = true;
+    public boolean magmaCubeControllable = true;
+    public String magmaCubeMaxHealth = "size * size";
+    public String magmaCubeAttackDamage = "size";
+    public Map<Integer, Double> magmaCubeMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> magmaCubeAttackDamageCache = new HashMap<>();
+    public boolean magmaCubeTakeDamageFromWater = false;
+    public boolean magmaCubeAlwaysDropExp = false;
+    private void magmaCubeSettings() {
+        magmaCubeRidable = getBoolean("mobs.magma_cube.ridable", magmaCubeRidable);
+        magmaCubeRidableInWater = getBoolean("mobs.magma_cube.ridable-in-water", magmaCubeRidableInWater);
+        magmaCubeControllable = getBoolean("mobs.magma_cube.controllable", magmaCubeControllable);
+        if (PurpurConfig.version < 10) {
+            String oldValue = getString("mobs.magma_cube.attributes.max-health", magmaCubeMaxHealth);
+            set("mobs.magma_cube.attributes.max-health", null);
+            set("mobs.magma_cube.attributes.max_health", oldValue);
+        }
+        magmaCubeMaxHealth = getString("mobs.magma_cube.attributes.max_health", magmaCubeMaxHealth);
+        magmaCubeAttackDamage = getString("mobs.magma_cube.attributes.attack_damage", magmaCubeAttackDamage);
+        magmaCubeMaxHealthCache.clear();
+        magmaCubeAttackDamageCache.clear();
+        magmaCubeTakeDamageFromWater = getBoolean("mobs.magma_cube.takes-damage-from-water", magmaCubeTakeDamageFromWater);
+        magmaCubeAlwaysDropExp = getBoolean("mobs.magma_cube.always-drop-exp", magmaCubeAlwaysDropExp);
+    }
+
+    public boolean mooshroomRidable = false;
+    public boolean mooshroomRidableInWater = true;
+    public boolean mooshroomControllable = true;
+    public double mooshroomMaxHealth = 10.0D;
+    public double mooshroomScale = 1.0D;
+    public int mooshroomBreedingTicks = 6000;
+    public boolean mooshroomTakeDamageFromWater = false;
+    public boolean mooshroomAlwaysDropExp = false;
+    private void mooshroomSettings() {
+        mooshroomRidable = getBoolean("mobs.mooshroom.ridable", mooshroomRidable);
+        mooshroomRidableInWater = getBoolean("mobs.mooshroom.ridable-in-water", mooshroomRidableInWater);
+        mooshroomControllable = getBoolean("mobs.mooshroom.controllable", mooshroomControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.mooshroom.attributes.max-health", mooshroomMaxHealth);
+            set("mobs.mooshroom.attributes.max-health", null);
+            set("mobs.mooshroom.attributes.max_health", oldValue);
+        }
+        mooshroomMaxHealth = getDouble("mobs.mooshroom.attributes.max_health", mooshroomMaxHealth);
+        mooshroomScale = Mth.clamp(getDouble("mobs.mooshroom.attributes.scale", mooshroomScale), 0.0625D, 16.0D);
+        mooshroomBreedingTicks = getInt("mobs.mooshroom.breeding-delay-ticks", mooshroomBreedingTicks);
+        mooshroomTakeDamageFromWater = getBoolean("mobs.mooshroom.takes-damage-from-water", mooshroomTakeDamageFromWater);
+        mooshroomAlwaysDropExp = getBoolean("mobs.mooshroom.always-drop-exp", mooshroomAlwaysDropExp);
+    }
+
+    public boolean muleRidableInWater = false;
+    public double muleMaxHealthMin = 15.0D;
+    public double muleMaxHealthMax = 30.0D;
+    public double muleJumpStrengthMin = 0.5D;
+    public double muleJumpStrengthMax = 0.5D;
+    public double muleMovementSpeedMin = 0.175D;
+    public double muleMovementSpeedMax = 0.175D;
+    public int muleBreedingTicks = 6000;
+    public boolean muleTakeDamageFromWater = false;
+    public boolean muleAlwaysDropExp = false;
+    private void muleSettings() {
+        muleRidableInWater = getBoolean("mobs.mule.ridable-in-water", muleRidableInWater);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.mule.attributes.max-health.min", muleMaxHealthMin);
+            double oldMax = getDouble("mobs.mule.attributes.max-health.max", muleMaxHealthMax);
+            set("mobs.mule.attributes.max-health", null);
+            set("mobs.mule.attributes.max_health.min", oldMin);
+            set("mobs.mule.attributes.max_health.max", oldMax);
+        }
+        muleMaxHealthMin = getDouble("mobs.mule.attributes.max_health.min", muleMaxHealthMin);
+        muleMaxHealthMax = getDouble("mobs.mule.attributes.max_health.max", muleMaxHealthMax);
+        muleJumpStrengthMin = getDouble("mobs.mule.attributes.jump_strength.min", muleJumpStrengthMin);
+        muleJumpStrengthMax = getDouble("mobs.mule.attributes.jump_strength.max", muleJumpStrengthMax);
+        muleMovementSpeedMin = getDouble("mobs.mule.attributes.movement_speed.min", muleMovementSpeedMin);
+        muleMovementSpeedMax = getDouble("mobs.mule.attributes.movement_speed.max", muleMovementSpeedMax);
+        muleBreedingTicks = getInt("mobs.mule.breeding-delay-ticks", muleBreedingTicks);
+        muleTakeDamageFromWater = getBoolean("mobs.mule.takes-damage-from-water", muleTakeDamageFromWater);
+        muleAlwaysDropExp = getBoolean("mobs.mule.always-drop-exp", muleAlwaysDropExp);
+    }
+
+    public boolean ocelotRidable = false;
+    public boolean ocelotRidableInWater = true;
+    public boolean ocelotControllable = true;
+    public double ocelotMaxHealth = 10.0D;
+    public double ocelotScale = 1.0D;
+    public int ocelotBreedingTicks = 6000;
+    public boolean ocelotTakeDamageFromWater = false;
+    public boolean ocelotAlwaysDropExp = false;
+    public boolean ocelotSpawnUnderSeaLevel = false;
+    private void ocelotSettings() {
+        ocelotRidable = getBoolean("mobs.ocelot.ridable", ocelotRidable);
+        ocelotRidableInWater = getBoolean("mobs.ocelot.ridable-in-water", ocelotRidableInWater);
+        ocelotControllable = getBoolean("mobs.ocelot.controllable", ocelotControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ocelot.attributes.max-health", ocelotMaxHealth);
+            set("mobs.ocelot.attributes.max-health", null);
+            set("mobs.ocelot.attributes.max_health", oldValue);
+        }
+        ocelotMaxHealth = getDouble("mobs.ocelot.attributes.max_health", ocelotMaxHealth);
+        ocelotScale = Mth.clamp(getDouble("mobs.ocelot.attributes.scale", ocelotScale), 0.0625D, 16.0D);
+        ocelotBreedingTicks = getInt("mobs.ocelot.breeding-delay-ticks", ocelotBreedingTicks);
+        ocelotTakeDamageFromWater = getBoolean("mobs.ocelot.takes-damage-from-water", ocelotTakeDamageFromWater);
+        ocelotAlwaysDropExp = getBoolean("mobs.ocelot.always-drop-exp", ocelotAlwaysDropExp);
+        ocelotSpawnUnderSeaLevel = getBoolean("mobs.ocelot.spawn-below-sea-level", ocelotSpawnUnderSeaLevel);
+    }
+
+    public boolean pandaRidable = false;
+    public boolean pandaRidableInWater = true;
+    public boolean pandaControllable = true;
+    public double pandaMaxHealth = 20.0D;
+    public double pandaScale = 1.0D;
+    public int pandaBreedingTicks = 6000;
+    public boolean pandaTakeDamageFromWater = false;
+    public boolean pandaAlwaysDropExp = false;
+    private void pandaSettings() {
+        pandaRidable = getBoolean("mobs.panda.ridable", pandaRidable);
+        pandaRidableInWater = getBoolean("mobs.panda.ridable-in-water", pandaRidableInWater);
+        pandaControllable = getBoolean("mobs.panda.controllable", pandaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.panda.attributes.max-health", pandaMaxHealth);
+            set("mobs.panda.attributes.max-health", null);
+            set("mobs.panda.attributes.max_health", oldValue);
+        }
+        pandaMaxHealth = getDouble("mobs.panda.attributes.max_health", pandaMaxHealth);
+        pandaScale = Mth.clamp(getDouble("mobs.panda.attributes.scale", pandaScale), 0.0625D, 16.0D);
+        pandaBreedingTicks = getInt("mobs.panda.breeding-delay-ticks", pandaBreedingTicks);
+        pandaTakeDamageFromWater = getBoolean("mobs.panda.takes-damage-from-water", pandaTakeDamageFromWater);
+        pandaAlwaysDropExp = getBoolean("mobs.panda.always-drop-exp", pandaAlwaysDropExp);
+    }
+
+    public boolean parrotRidable = false;
+    public boolean parrotRidableInWater = true;
+    public boolean parrotControllable = true;
+    public double parrotMaxY = 320D;
+    public double parrotMaxHealth = 6.0D;
+    public double parrotScale = 1.0D;
+    public boolean parrotTakeDamageFromWater = false;
+    public boolean parrotBreedable = false;
+    public boolean parrotAlwaysDropExp = false;
+    private void parrotSettings() {
+        parrotRidable = getBoolean("mobs.parrot.ridable", parrotRidable);
+        parrotRidableInWater = getBoolean("mobs.parrot.ridable-in-water", parrotRidableInWater);
+        parrotControllable = getBoolean("mobs.parrot.controllable", parrotControllable);
+        parrotMaxY = getDouble("mobs.parrot.ridable-max-y", parrotMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.parrot.attributes.max-health", parrotMaxHealth);
+            set("mobs.parrot.attributes.max-health", null);
+            set("mobs.parrot.attributes.max_health", oldValue);
+        }
+        parrotMaxHealth = getDouble("mobs.parrot.attributes.max_health", parrotMaxHealth);
+        parrotScale = Mth.clamp(getDouble("mobs.parrot.attributes.scale", parrotScale), 0.0625D, 16.0D);
+        parrotTakeDamageFromWater = getBoolean("mobs.parrot.takes-damage-from-water", parrotTakeDamageFromWater);
+        parrotBreedable = getBoolean("mobs.parrot.can-breed", parrotBreedable);
+        parrotAlwaysDropExp = getBoolean("mobs.parrot.always-drop-exp", parrotAlwaysDropExp);
+    }
+
+    public boolean phantomRidable = false;
+    public boolean phantomRidableInWater = true;
+    public boolean phantomControllable = true;
+    public double phantomMaxY = 320D;
+    public float phantomFlameDamage = 1.0F;
+    public int phantomFlameFireTime = 8;
+    public boolean phantomAllowGriefing = false;
+    public String phantomMaxHealth = "20.0";
+    public String phantomAttackDamage = "6 + size";
+    public Map<Integer, Double> phantomMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> phantomAttackDamageCache = new HashMap<>();
+    public double phantomAttackedByCrystalRadius = 0.0D;
+    public float phantomAttackedByCrystalDamage = 1.0F;
+    public double phantomOrbitCrystalRadius = 0.0D;
+    public int phantomSpawnMinSkyDarkness = 5;
+    public boolean phantomSpawnOnlyAboveSeaLevel = true;
+    public boolean phantomSpawnOnlyWithVisibleSky = true;
+    public double phantomSpawnLocalDifficultyChance = 3.0D;
+    public int phantomSpawnMinPerAttempt = 1;
+    public int phantomSpawnMaxPerAttempt = -1;
+    public int phantomBurnInLight = 0;
+    public boolean phantomIgnorePlayersWithTorch = false;
+    public boolean phantomBurnInDaylight = true;
+    public boolean phantomFlamesOnSwoop = false;
+    public boolean phantomTakeDamageFromWater = false;
+    public boolean phantomAlwaysDropExp = false;
+    public int phantomMinSize = 0;
+    public int phantomMaxSize = 0;
+    private void phantomSettings() {
+        phantomRidable = getBoolean("mobs.phantom.ridable", phantomRidable);
+        phantomRidableInWater = getBoolean("mobs.phantom.ridable-in-water", phantomRidableInWater);
+        phantomControllable = getBoolean("mobs.phantom.controllable", phantomControllable);
+        phantomMaxY = getDouble("mobs.phantom.ridable-max-y", phantomMaxY);
+        phantomFlameDamage = (float) getDouble("mobs.phantom.flames.damage", phantomFlameDamage);
+        phantomFlameFireTime = getInt("mobs.phantom.flames.fire-time", phantomFlameFireTime);
+        phantomAllowGriefing = getBoolean("mobs.phantom.allow-griefing", phantomAllowGriefing);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.phantom.attributes.max-health", Double.parseDouble(phantomMaxHealth));
+            set("mobs.phantom.attributes.max-health", null);
+            set("mobs.phantom.attributes.max_health", String.valueOf(oldValue));
+        }
+        if (PurpurConfig.version < 25) {
+            double oldValue = getDouble("mobs.phantom.attributes.max_health", Double.parseDouble(phantomMaxHealth));
+            set("mobs.phantom.attributes.max_health", String.valueOf(oldValue));
+        }
+        phantomMaxHealth = getString("mobs.phantom.attributes.max_health", phantomMaxHealth);
+        phantomAttackDamage = getString("mobs.phantom.attributes.attack_damage", phantomAttackDamage);
+        phantomMaxHealthCache.clear();
+        phantomAttackDamageCache.clear();
+        phantomAttackedByCrystalRadius = getDouble("mobs.phantom.attacked-by-crystal-range", phantomAttackedByCrystalRadius);
+        phantomAttackedByCrystalDamage = (float) getDouble("mobs.phantom.attacked-by-crystal-damage", phantomAttackedByCrystalDamage);
+        phantomOrbitCrystalRadius = getDouble("mobs.phantom.orbit-crystal-radius", phantomOrbitCrystalRadius);
+        phantomSpawnMinSkyDarkness = getInt("mobs.phantom.spawn.min-sky-darkness", phantomSpawnMinSkyDarkness);
+        phantomSpawnOnlyAboveSeaLevel = getBoolean("mobs.phantom.spawn.only-above-sea-level", phantomSpawnOnlyAboveSeaLevel);
+        phantomSpawnOnlyWithVisibleSky = getBoolean("mobs.phantom.spawn.only-with-visible-sky", phantomSpawnOnlyWithVisibleSky);
+        phantomSpawnLocalDifficultyChance = getDouble("mobs.phantom.spawn.local-difficulty-chance", phantomSpawnLocalDifficultyChance);
+        phantomSpawnMinPerAttempt = getInt("mobs.phantom.spawn.per-attempt.min", phantomSpawnMinPerAttempt);
+        phantomSpawnMaxPerAttempt = getInt("mobs.phantom.spawn.per-attempt.max", phantomSpawnMaxPerAttempt);
+        phantomBurnInLight = getInt("mobs.phantom.burn-in-light", phantomBurnInLight);
+        phantomBurnInDaylight = getBoolean("mobs.phantom.burn-in-daylight", phantomBurnInDaylight);
+        phantomIgnorePlayersWithTorch = getBoolean("mobs.phantom.ignore-players-with-torch", phantomIgnorePlayersWithTorch);
+        phantomFlamesOnSwoop = getBoolean("mobs.phantom.flames-on-swoop", phantomFlamesOnSwoop);
+        phantomTakeDamageFromWater = getBoolean("mobs.phantom.takes-damage-from-water", phantomTakeDamageFromWater);
+        phantomAlwaysDropExp = getBoolean("mobs.phantom.always-drop-exp", phantomAlwaysDropExp);
+        phantomMinSize = Mth.clamp(getInt("mobs.phantom.size.min", phantomMinSize), 0, 64);
+        phantomMaxSize = Mth.clamp(getInt("mobs.phantom.size.max", phantomMaxSize), 0, 64);
+        if (phantomMinSize > phantomMaxSize) {
+            phantomMinSize = phantomMinSize ^ phantomMaxSize;
+            phantomMaxSize = phantomMinSize ^ phantomMaxSize;
+            phantomMinSize = phantomMinSize ^ phantomMaxSize;
+        }
+    }
+
+    public boolean pigRidable = false;
+    public boolean pigRidableInWater = false;
+    public boolean pigControllable = true;
+    public double pigMaxHealth = 10.0D;
+    public double pigScale = 1.0D;
+    public boolean pigGiveSaddleBack = false;
+    public int pigBreedingTicks = 6000;
+    public boolean pigTakeDamageFromWater = false;
+    public boolean pigAlwaysDropExp = false;
+    private void pigSettings() {
+        pigRidable = getBoolean("mobs.pig.ridable", pigRidable);
+        pigRidableInWater = getBoolean("mobs.pig.ridable-in-water", pigRidableInWater);
+        pigControllable = getBoolean("mobs.pig.controllable", pigControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pig.attributes.max-health", pigMaxHealth);
+            set("mobs.pig.attributes.max-health", null);
+            set("mobs.pig.attributes.max_health", oldValue);
+        }
+        pigMaxHealth = getDouble("mobs.pig.attributes.max_health", pigMaxHealth);
+        pigScale = Mth.clamp(getDouble("mobs.pig.attributes.scale", pigScale), 0.0625D, 16.0D);
+        pigGiveSaddleBack = getBoolean("mobs.pig.give-saddle-back", pigGiveSaddleBack);
+        pigBreedingTicks = getInt("mobs.pig.breeding-delay-ticks", pigBreedingTicks);
+        pigTakeDamageFromWater = getBoolean("mobs.pig.takes-damage-from-water", pigTakeDamageFromWater);
+        pigAlwaysDropExp = getBoolean("mobs.pig.always-drop-exp", pigAlwaysDropExp);
+    }
+
+    public boolean piglinRidable = false;
+    public boolean piglinRidableInWater = true;
+    public boolean piglinControllable = true;
+    public double piglinMaxHealth = 16.0D;
+    public double piglinScale = 1.0D;
+    public Boolean piglinMobGriefingOverride = null;
+    public boolean piglinTakeDamageFromWater = false;
+    public int piglinPortalSpawnModifier = 2000;
+    public boolean piglinAlwaysDropExp = false;
+    public double piglinHeadVisibilityPercent = 0.5D;
+    public boolean piglinIgnoresArmorWithGoldTrim = false;
+    private void piglinSettings() {
+        piglinRidable = getBoolean("mobs.piglin.ridable", piglinRidable);
+        piglinRidableInWater = getBoolean("mobs.piglin.ridable-in-water", piglinRidableInWater);
+        piglinControllable = getBoolean("mobs.piglin.controllable", piglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.piglin.attributes.max-health", piglinMaxHealth);
+            set("mobs.piglin.attributes.max-health", null);
+            set("mobs.piglin.attributes.max_health", oldValue);
+        }
+        piglinMaxHealth = getDouble("mobs.piglin.attributes.max_health", piglinMaxHealth);
+        piglinScale = Mth.clamp(getDouble("mobs.piglin.attributes.scale", piglinScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.piglin.bypass-mob-griefing", false);
+            set("mobs.piglin.bypass-mob-griefing", null);
+            set("mobs.piglin.mob-griefing-override", oldVal ? true : "default");
+        }
+        piglinMobGriefingOverride = getBooleanOrDefault("mobs.piglin.mob-griefing-override", piglinMobGriefingOverride);
+        piglinTakeDamageFromWater = getBoolean("mobs.piglin.takes-damage-from-water", piglinTakeDamageFromWater);
+        piglinPortalSpawnModifier = getInt("mobs.piglin.portal-spawn-modifier", piglinPortalSpawnModifier);
+        piglinAlwaysDropExp = getBoolean("mobs.piglin.always-drop-exp", piglinAlwaysDropExp);
+        piglinHeadVisibilityPercent = getDouble("mobs.piglin.head-visibility-percent", piglinHeadVisibilityPercent);
+        piglinIgnoresArmorWithGoldTrim = getBoolean("mobs.piglin.ignores-armor-with-gold-trim", piglinIgnoresArmorWithGoldTrim);
+    }
+
+    public boolean piglinBruteRidable = false;
+    public boolean piglinBruteRidableInWater = true;
+    public boolean piglinBruteControllable = true;
+    public double piglinBruteMaxHealth = 50.0D;
+    public double piglinBruteScale = 1.0D;
+    public boolean piglinBruteTakeDamageFromWater = false;
+    public boolean piglinBruteAlwaysDropExp = false;
+    private void piglinBruteSettings() {
+        piglinBruteRidable = getBoolean("mobs.piglin_brute.ridable", piglinBruteRidable);
+        piglinBruteRidableInWater = getBoolean("mobs.piglin_brute.ridable-in-water", piglinBruteRidableInWater);
+        piglinBruteControllable = getBoolean("mobs.piglin_brute.controllable", piglinBruteControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.piglin_brute.attributes.max-health", piglinBruteMaxHealth);
+            set("mobs.piglin_brute.attributes.max-health", null);
+            set("mobs.piglin_brute.attributes.max_health", oldValue);
+        }
+        piglinBruteMaxHealth = getDouble("mobs.piglin_brute.attributes.max_health", piglinBruteMaxHealth);
+        piglinBruteScale = Mth.clamp(getDouble("mobs.piglin_brute.attributes.scale", piglinBruteScale), 0.0625D, 16.0D);
+        piglinBruteTakeDamageFromWater = getBoolean("mobs.piglin_brute.takes-damage-from-water", piglinBruteTakeDamageFromWater);
+        piglinBruteAlwaysDropExp = getBoolean("mobs.piglin_brute.always-drop-exp", piglinBruteAlwaysDropExp);
+    }
+
+    public boolean pillagerRidable = false;
+    public boolean pillagerRidableInWater = true;
+    public boolean pillagerControllable = true;
+    public double pillagerMaxHealth = 24.0D;
+    public double pillagerScale = 1.0D;
+    public Boolean pillagerMobGriefingOverride = null;
+    public boolean pillagerTakeDamageFromWater = false;
+    public boolean pillagerAlwaysDropExp = false;
+    private void pillagerSettings() {
+        pillagerRidable = getBoolean("mobs.pillager.ridable", pillagerRidable);
+        pillagerRidableInWater = getBoolean("mobs.pillager.ridable-in-water", pillagerRidableInWater);
+        pillagerControllable = getBoolean("mobs.pillager.controllable", pillagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pillager.attributes.max-health", pillagerMaxHealth);
+            set("mobs.pillager.attributes.max-health", null);
+            set("mobs.pillager.attributes.max_health", oldValue);
+        }
+        pillagerMaxHealth = getDouble("mobs.pillager.attributes.max_health", pillagerMaxHealth);
+        pillagerScale = Mth.clamp(getDouble("mobs.pillager.attributes.scale", pillagerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.pillager.bypass-mob-griefing", false);
+            set("mobs.pillager.bypass-mob-griefing", null);
+            set("mobs.pillager.mob-griefing-override", oldVal ? true : "default");
+        }
+        pillagerMobGriefingOverride = getBooleanOrDefault("mobs.pillager.mob-griefing-override", pillagerMobGriefingOverride);
+        pillagerTakeDamageFromWater = getBoolean("mobs.pillager.takes-damage-from-water", pillagerTakeDamageFromWater);
+        pillagerAlwaysDropExp = getBoolean("mobs.pillager.always-drop-exp", pillagerAlwaysDropExp);
+    }
+
+    public boolean polarBearRidable = false;
+    public boolean polarBearRidableInWater = true;
+    public boolean polarBearControllable = true;
+    public double polarBearMaxHealth = 30.0D;
+    public double polarBearScale = 1.0D;
+    public String polarBearBreedableItemString = "";
+    public Item polarBearBreedableItem = null;
+    public int polarBearBreedingTicks = 6000;
+    public boolean polarBearTakeDamageFromWater = false;
+    public boolean polarBearAlwaysDropExp = false;
+    private void polarBearSettings() {
+        polarBearRidable = getBoolean("mobs.polar_bear.ridable", polarBearRidable);
+        polarBearRidableInWater = getBoolean("mobs.polar_bear.ridable-in-water", polarBearRidableInWater);
+        polarBearControllable = getBoolean("mobs.polar_bear.controllable", polarBearControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.polar_bear.attributes.max-health", polarBearMaxHealth);
+            set("mobs.polar_bear.attributes.max-health", null);
+            set("mobs.polar_bear.attributes.max_health", oldValue);
+        }
+        polarBearMaxHealth = getDouble("mobs.polar_bear.attributes.max_health", polarBearMaxHealth);
+        polarBearScale = Mth.clamp(getDouble("mobs.polar_bear.attributes.scale", polarBearScale), 0.0625D, 16.0D);
+        polarBearBreedableItemString = getString("mobs.polar_bear.breedable-item", polarBearBreedableItemString);
+        Item item = BuiltInRegistries.ITEM.getValue(ResourceLocation.parse(polarBearBreedableItemString));
+        if (item != Items.AIR) polarBearBreedableItem = item;
+        polarBearBreedingTicks = getInt("mobs.polar_bear.breeding-delay-ticks", polarBearBreedingTicks);
+        polarBearTakeDamageFromWater = getBoolean("mobs.polar_bear.takes-damage-from-water", polarBearTakeDamageFromWater);
+        polarBearAlwaysDropExp = getBoolean("mobs.polar_bear.always-drop-exp", polarBearAlwaysDropExp);
+    }
+
+    public boolean pufferfishRidable = false;
+    public boolean pufferfishControllable = true;
+    public double pufferfishMaxHealth = 3.0D;
+    public double pufferfishScale = 1.0D;
+    public boolean pufferfishTakeDamageFromWater = false;
+    public boolean pufferfishAlwaysDropExp = false;
+    private void pufferfishSettings() {
+        pufferfishRidable = getBoolean("mobs.pufferfish.ridable", pufferfishRidable);
+        pufferfishControllable = getBoolean("mobs.pufferfish.controllable", pufferfishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.pufferfish.attributes.max-health", pufferfishMaxHealth);
+            set("mobs.pufferfish.attributes.max-health", null);
+            set("mobs.pufferfish.attributes.max_health", oldValue);
+        }
+        pufferfishMaxHealth = getDouble("mobs.pufferfish.attributes.max_health", pufferfishMaxHealth);
+        pufferfishScale = Mth.clamp(getDouble("mobs.pufferfish.attributes.scale", pufferfishScale), 0.0625D, 16.0D);
+        pufferfishTakeDamageFromWater = getBoolean("mobs.pufferfish.takes-damage-from-water", pufferfishTakeDamageFromWater);
+        pufferfishAlwaysDropExp = getBoolean("mobs.pufferfish.always-drop-exp", pufferfishAlwaysDropExp);
+    }
+
+    public boolean rabbitRidable = false;
+    public boolean rabbitRidableInWater = true;
+    public boolean rabbitControllable = true;
+    public double rabbitMaxHealth = 3.0D;
+    public double rabbitScale = 1.0D;
+    public double rabbitNaturalToast = 0.0D;
+    public double rabbitNaturalKiller = 0.0D;
+    public int rabbitBreedingTicks = 6000;
+    public Boolean rabbitMobGriefingOverride = null;
+    public boolean rabbitTakeDamageFromWater = false;
+    public boolean rabbitAlwaysDropExp = false;
+    private void rabbitSettings() {
+        rabbitRidable = getBoolean("mobs.rabbit.ridable", rabbitRidable);
+        rabbitRidableInWater = getBoolean("mobs.rabbit.ridable-in-water", rabbitRidableInWater);
+        rabbitControllable = getBoolean("mobs.rabbit.controllable", rabbitControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.rabbit.attributes.max-health", rabbitMaxHealth);
+            set("mobs.rabbit.attributes.max-health", null);
+            set("mobs.rabbit.attributes.max_health", oldValue);
+        }
+        rabbitMaxHealth = getDouble("mobs.rabbit.attributes.max_health", rabbitMaxHealth);
+        rabbitScale = Mth.clamp(getDouble("mobs.rabbit.attributes.scale", rabbitScale), 0.0625D, 16.0D);
+        rabbitNaturalToast = getDouble("mobs.rabbit.spawn-toast-chance", rabbitNaturalToast);
+        rabbitNaturalKiller = getDouble("mobs.rabbit.spawn-killer-rabbit-chance", rabbitNaturalKiller);
+        rabbitBreedingTicks = getInt("mobs.rabbit.breeding-delay-ticks", rabbitBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.rabbit.bypass-mob-griefing", false);
+            set("mobs.rabbit.bypass-mob-griefing", null);
+            set("mobs.rabbit.mob-griefing-override", oldVal ? true : "default");
+        }
+        rabbitMobGriefingOverride = getBooleanOrDefault("mobs.rabbit.mob-griefing-override", rabbitMobGriefingOverride);
+        rabbitTakeDamageFromWater = getBoolean("mobs.rabbit.takes-damage-from-water", rabbitTakeDamageFromWater);
+        rabbitAlwaysDropExp = getBoolean("mobs.rabbit.always-drop-exp", rabbitAlwaysDropExp);
+    }
+
+    public boolean ravagerRidable = false;
+    public boolean ravagerRidableInWater = false;
+    public boolean ravagerControllable = true;
+    public double ravagerMaxHealth = 100.0D;
+    public double ravagerScale = 1.0D;
+    public Boolean ravagerMobGriefingOverride = null;
+    public boolean ravagerTakeDamageFromWater = false;
+    public List<Block> ravagerGriefableBlocks = new ArrayList<>();
+    public boolean ravagerAlwaysDropExp = false;
+    public boolean ravagerAvoidRabbits = false;
+    private void ravagerSettings() {
+        ravagerRidable = getBoolean("mobs.ravager.ridable", ravagerRidable);
+        ravagerRidableInWater = getBoolean("mobs.ravager.ridable-in-water", ravagerRidableInWater);
+        ravagerControllable = getBoolean("mobs.ravager.controllable", ravagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.ravager.attributes.max-health", ravagerMaxHealth);
+            set("mobs.ravager.attributes.max-health", null);
+            set("mobs.ravager.attributes.max_health", oldValue);
+        }
+        ravagerMaxHealth = getDouble("mobs.ravager.attributes.max_health", ravagerMaxHealth);
+        ravagerScale = Mth.clamp(getDouble("mobs.ravager.attributes.scale", ravagerScale), 0.0625D, 16.0D);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.ravager.bypass-mob-griefing", false);
+            set("mobs.ravager.bypass-mob-griefing", null);
+            set("mobs.ravager.mob-griefing-override", oldVal ? true : "default");
+        }
+        ravagerMobGriefingOverride = getBooleanOrDefault("mobs.ravager.mob-griefing-override", ravagerMobGriefingOverride);
+        ravagerTakeDamageFromWater = getBoolean("mobs.ravager.takes-damage-from-water", ravagerTakeDamageFromWater);
+        List<String> defaultRavagerGriefableBlocks = List.of(
+            "minecraft:oak_leaves",
+            "minecraft:spruce_leaves",
+            "minecraft:birch_leaves",
+            "minecraft:jungle_leaves",
+            "minecraft:acacia_leaves",
+            "minecraft:cherry_leaves",
+            "minecraft:dark_oak_leaves",
+            "minecraft:pale_oak_leaves",
+            "minecraft:mangrove_leaves",
+            "minecraft:azalea_leaves",
+            "minecraft:flowering_azalea_leaves",
+            "minecraft:wheat",
+            "minecraft:carrots",
+            "minecraft:potatoes",
+            "minecraft:torchflower_crop",
+            "minecraft:pitcher_crop",
+            "minecraft:beetroots"
+        );
+        if (PurpurConfig.version < 41) {
+            Set<String> set = new HashSet<>();
+            getList("mobs.ravager.griefable-blocks", defaultRavagerGriefableBlocks)
+                .forEach(key -> set.add(key.toString()));
+            set.add("minecraft:cherry_leaves");
+            set.add("minecraft:pale_oak_leaves");
+            set.add("minecraft:mangrove_leaves");
+            set.add("minecraft:azalea_leaves");
+            set.add("minecraft:flowering_azalea_leaves");
+            set.add("minecraft:torchflower_crop");
+            set.add("minecraft:pitcher_crop");
+            set("mobs.ravager.griefable-blocks", new ArrayList<>(set));
+        }
+        getList("mobs.ravager.griefable-blocks", defaultRavagerGriefableBlocks).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                ravagerGriefableBlocks.add(block);
+            }
+        });
+        ravagerAlwaysDropExp = getBoolean("mobs.ravager.always-drop-exp", ravagerAlwaysDropExp);
+        ravagerAvoidRabbits = getBoolean("mobs.ravager.avoid-rabbits", ravagerAvoidRabbits);
+    }
+
+    public boolean salmonRidable = false;
+    public boolean salmonControllable = true;
+    public double salmonMaxHealth = 3.0D;
+    public double salmonScale = 1.0D;
+    public boolean salmonTakeDamageFromWater = false;
+    public boolean salmonAlwaysDropExp = false;
+    private void salmonSettings() {
+        salmonRidable = getBoolean("mobs.salmon.ridable", salmonRidable);
+        salmonControllable = getBoolean("mobs.salmon.controllable", salmonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.salmon.attributes.max-health", salmonMaxHealth);
+            set("mobs.salmon.attributes.max-health", null);
+            set("mobs.salmon.attributes.max_health", oldValue);
+        }
+        salmonMaxHealth = getDouble("mobs.salmon.attributes.max_health", salmonMaxHealth);
+        salmonScale = Mth.clamp(getDouble("mobs.salmon.attributes.scale", salmonScale), 0.0625D, 16.0D);
+        salmonTakeDamageFromWater = getBoolean("mobs.salmon.takes-damage-from-water", salmonTakeDamageFromWater);
+        salmonAlwaysDropExp = getBoolean("mobs.salmon.always-drop-exp", salmonAlwaysDropExp);
+    }
+
+    public boolean sheepRidable = false;
+    public boolean sheepRidableInWater = true;
+    public boolean sheepControllable = true;
+    public double sheepMaxHealth = 8.0D;
+    public double sheepScale = 1.0D;
+    public int sheepBreedingTicks = 6000;
+    public Boolean sheepMobGriefingOverride = null;
+    public boolean sheepTakeDamageFromWater = false;
+    public boolean sheepAlwaysDropExp = false;
+    private void sheepSettings() {
+        sheepRidable = getBoolean("mobs.sheep.ridable", sheepRidable);
+        sheepRidableInWater = getBoolean("mobs.sheep.ridable-in-water", sheepRidableInWater);
+        sheepControllable = getBoolean("mobs.sheep.controllable", sheepControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.sheep.attributes.max-health", sheepMaxHealth);
+            set("mobs.sheep.attributes.max-health", null);
+            set("mobs.sheep.attributes.max_health", oldValue);
+        }
+        sheepMaxHealth = getDouble("mobs.sheep.attributes.max_health", sheepMaxHealth);
+        sheepScale = Mth.clamp(getDouble("mobs.sheep.attributes.scale", sheepScale), 0.0625D, 16.0D);
+        sheepBreedingTicks = getInt("mobs.sheep.breeding-delay-ticks", sheepBreedingTicks);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.sheep.bypass-mob-griefing", false);
+            set("mobs.sheep.bypass-mob-griefing", null);
+            set("mobs.sheep.mob-griefing-override", oldVal ? true : "default");
+        }
+        sheepMobGriefingOverride = getBooleanOrDefault("mobs.sheep.mob-griefing-override", sheepMobGriefingOverride);
+        sheepTakeDamageFromWater = getBoolean("mobs.sheep.takes-damage-from-water", sheepTakeDamageFromWater);
+        sheepAlwaysDropExp = getBoolean("mobs.sheep.always-drop-exp", sheepAlwaysDropExp);
+    }
+
+    public boolean shulkerRidable = false;
+    public boolean shulkerRidableInWater = true;
+    public boolean shulkerControllable = true;
+    public double shulkerMaxHealth = 30.0D;
+    public double shulkerScale = 1.0D;
+    public boolean shulkerTakeDamageFromWater = false;
+    public float shulkerSpawnFromBulletBaseChance = 1.0F;
+    public boolean shulkerSpawnFromBulletRequireOpenLid = true;
+    public double shulkerSpawnFromBulletNearbyRange = 8.0D;
+    public String shulkerSpawnFromBulletNearbyEquation = "(nearby - 1) / 5.0";
+    public boolean shulkerSpawnFromBulletRandomColor = false;
+    public boolean shulkerChangeColorWithDye = false;
+    public boolean shulkerAlwaysDropExp = false;
+    private void shulkerSettings() {
+        shulkerRidable = getBoolean("mobs.shulker.ridable", shulkerRidable);
+        shulkerRidableInWater = getBoolean("mobs.shulker.ridable-in-water", shulkerRidableInWater);
+        shulkerControllable = getBoolean("mobs.shulker.controllable", shulkerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.shulker.attributes.max-health", shulkerMaxHealth);
+            set("mobs.shulker.attributes.max-health", null);
+            set("mobs.shulker.attributes.max_health", oldValue);
+        }
+        shulkerMaxHealth = getDouble("mobs.shulker.attributes.max_health", shulkerMaxHealth);
+        shulkerScale = Mth.clamp(getDouble("mobs.shulker.attributes.scale", shulkerScale), 0.0625D, Shulker.MAX_SCALE);
+        shulkerTakeDamageFromWater = getBoolean("mobs.shulker.takes-damage-from-water", shulkerTakeDamageFromWater);
+        shulkerSpawnFromBulletBaseChance = (float) getDouble("mobs.shulker.spawn-from-bullet.base-chance", shulkerSpawnFromBulletBaseChance);
+        shulkerSpawnFromBulletRequireOpenLid = getBoolean("mobs.shulker.spawn-from-bullet.require-open-lid", shulkerSpawnFromBulletRequireOpenLid);
+        shulkerSpawnFromBulletNearbyRange = getDouble("mobs.shulker.spawn-from-bullet.nearby-range", shulkerSpawnFromBulletNearbyRange);
+        shulkerSpawnFromBulletNearbyEquation = getString("mobs.shulker.spawn-from-bullet.nearby-equation", shulkerSpawnFromBulletNearbyEquation);
+        shulkerSpawnFromBulletRandomColor = getBoolean("mobs.shulker.spawn-from-bullet.random-color", shulkerSpawnFromBulletRandomColor);
+        shulkerChangeColorWithDye = getBoolean("mobs.shulker.change-color-with-dye", shulkerChangeColorWithDye);
+        shulkerAlwaysDropExp = getBoolean("mobs.shulker.always-drop-exp", shulkerAlwaysDropExp);
+    }
+
+    public boolean silverfishRidable = false;
+    public boolean silverfishRidableInWater = true;
+    public boolean silverfishControllable = true;
+    public double silverfishMaxHealth = 8.0D;
+    public double silverfishScale = 1.0D;
+    public double silverfishMovementSpeed = 0.25D;
+    public double silverfishAttackDamage = 1.0D;
+    public Boolean silverfishMobGriefingOverride = null;
+    public boolean silverfishTakeDamageFromWater = false;
+    public boolean silverfishAlwaysDropExp = false;
+    private void silverfishSettings() {
+        silverfishRidable = getBoolean("mobs.silverfish.ridable", silverfishRidable);
+        silverfishRidableInWater = getBoolean("mobs.silverfish.ridable-in-water", silverfishRidableInWater);
+        silverfishControllable = getBoolean("mobs.silverfish.controllable", silverfishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.silverfish.attributes.max-health", silverfishMaxHealth);
+            set("mobs.silverfish.attributes.max-health", null);
+            set("mobs.silverfish.attributes.max_health", oldValue);
+        }
+        silverfishMaxHealth = getDouble("mobs.silverfish.attributes.max_health", silverfishMaxHealth);
+        silverfishScale = Mth.clamp(getDouble("mobs.silverfish.attributes.scale", silverfishScale), 0.0625D, 16.0D);
+        silverfishMovementSpeed = getDouble("mobs.silverfish.attributes.movement_speed", silverfishMovementSpeed);
+        silverfishAttackDamage = getDouble("mobs.silverfish.attributes.attack_damage", silverfishAttackDamage);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.silverfish.bypass-mob-griefing", false);
+            set("mobs.silverfish.bypass-mob-griefing", null);
+            set("mobs.silverfish.mob-griefing-override", oldVal ? true : "default");
+        }
+        silverfishMobGriefingOverride = getBooleanOrDefault("mobs.silverfish.mob-griefing-override", silverfishMobGriefingOverride);
+        silverfishTakeDamageFromWater = getBoolean("mobs.silverfish.takes-damage-from-water", silverfishTakeDamageFromWater);
+        silverfishAlwaysDropExp = getBoolean("mobs.silverfish.always-drop-exp", silverfishAlwaysDropExp);
+    }
+
+    public boolean skeletonRidable = false;
+    public boolean skeletonRidableInWater = true;
+    public boolean skeletonControllable = true;
+    public double skeletonMaxHealth = 20.0D;
+    public double skeletonScale = 1.0D;
+    public boolean skeletonTakeDamageFromWater = false;
+    public boolean skeletonAlwaysDropExp = false;
+    public double skeletonHeadVisibilityPercent = 0.5D;
+    public int skeletonFeedWitherRoses = 0;
+    public String skeletonBowAccuracy = "14 - difficulty * 4";
+    public Map<Integer, Float> skeletonBowAccuracyMap = new HashMap<>();
+    private void skeletonSettings() {
+        skeletonRidable = getBoolean("mobs.skeleton.ridable", skeletonRidable);
+        skeletonRidableInWater = getBoolean("mobs.skeleton.ridable-in-water", skeletonRidableInWater);
+        skeletonControllable = getBoolean("mobs.skeleton.controllable", skeletonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.skeleton.attributes.max-health", skeletonMaxHealth);
+            set("mobs.skeleton.attributes.max-health", null);
+            set("mobs.skeleton.attributes.max_health", oldValue);
+        }
+        skeletonMaxHealth = getDouble("mobs.skeleton.attributes.max_health", skeletonMaxHealth);
+        skeletonScale = Mth.clamp(getDouble("mobs.skeleton.attributes.scale", skeletonScale), 0.0625D, 16.0D);
+        skeletonTakeDamageFromWater = getBoolean("mobs.skeleton.takes-damage-from-water", skeletonTakeDamageFromWater);
+        skeletonAlwaysDropExp = getBoolean("mobs.skeleton.always-drop-exp", skeletonAlwaysDropExp);
+        skeletonHeadVisibilityPercent = getDouble("mobs.skeleton.head-visibility-percent", skeletonHeadVisibilityPercent);
+        skeletonFeedWitherRoses = getInt("mobs.skeleton.feed-wither-roses", skeletonFeedWitherRoses);
+        final String defaultSkeletonBowAccuracy = skeletonBowAccuracy;
+        skeletonBowAccuracy = getString("mobs.skeleton.bow-accuracy", skeletonBowAccuracy);
+        for (int i = 1; i < 4; i++) {
+            final float divergence;
+            try {
+                divergence = ((Number) Entity.scriptEngine.eval("let difficulty = " + i + "; " + skeletonBowAccuracy)).floatValue();
+            } catch (javax.script.ScriptException e) {
+                e.printStackTrace();
+                break;
+            }
+            skeletonBowAccuracyMap.put(i, divergence);
+        }
+    }
+
+    public boolean skeletonHorseRidable = false;
+    public boolean skeletonHorseRidableInWater = true;
+    public boolean skeletonHorseCanSwim = false;
+    public double skeletonHorseMaxHealthMin = 15.0D;
+    public double skeletonHorseMaxHealthMax = 15.0D;
+    public double skeletonHorseJumpStrengthMin = 0.4D;
+    public double skeletonHorseJumpStrengthMax = 1.0D;
+    public double skeletonHorseMovementSpeedMin = 0.2D;
+    public double skeletonHorseMovementSpeedMax = 0.2D;
+    public boolean skeletonHorseTakeDamageFromWater = false;
+    public boolean skeletonHorseAlwaysDropExp = false;
+    private void skeletonHorseSettings() {
+        skeletonHorseRidable = getBoolean("mobs.skeleton_horse.ridable", skeletonHorseRidable);
+        skeletonHorseRidableInWater = getBoolean("mobs.skeleton_horse.ridable-in-water", skeletonHorseRidableInWater);
+        skeletonHorseCanSwim = getBoolean("mobs.skeleton_horse.can-swim", skeletonHorseCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.skeleton_horse.attributes.max-health", skeletonHorseMaxHealthMin);
+            set("mobs.skeleton_horse.attributes.max-health", null);
+            set("mobs.skeleton_horse.attributes.max_health.min", oldValue);
+            set("mobs.skeleton_horse.attributes.max_health.max", oldValue);
+        }
+        skeletonHorseMaxHealthMin = getDouble("mobs.skeleton_horse.attributes.max_health.min", skeletonHorseMaxHealthMin);
+        skeletonHorseMaxHealthMax = getDouble("mobs.skeleton_horse.attributes.max_health.max", skeletonHorseMaxHealthMax);
+        skeletonHorseJumpStrengthMin = getDouble("mobs.skeleton_horse.attributes.jump_strength.min", skeletonHorseJumpStrengthMin);
+        skeletonHorseJumpStrengthMax = getDouble("mobs.skeleton_horse.attributes.jump_strength.max", skeletonHorseJumpStrengthMax);
+        skeletonHorseMovementSpeedMin = getDouble("mobs.skeleton_horse.attributes.movement_speed.min", skeletonHorseMovementSpeedMin);
+        skeletonHorseMovementSpeedMax = getDouble("mobs.skeleton_horse.attributes.movement_speed.max", skeletonHorseMovementSpeedMax);
+        skeletonHorseTakeDamageFromWater = getBoolean("mobs.skeleton_horse.takes-damage-from-water", skeletonHorseTakeDamageFromWater);
+        skeletonHorseAlwaysDropExp = getBoolean("mobs.skeleton_horse.always-drop-exp", skeletonHorseAlwaysDropExp);
+    }
+
+    public boolean slimeRidable = false;
+    public boolean slimeRidableInWater = true;
+    public boolean slimeControllable = true;
+    public String slimeMaxHealth = "size * size";
+    public String slimeAttackDamage = "size";
+    public Map<Integer, Double> slimeMaxHealthCache = new HashMap<>();
+    public Map<Integer, Double> slimeAttackDamageCache = new HashMap<>();
+    public boolean slimeTakeDamageFromWater = false;
+    public boolean slimeAlwaysDropExp = false;
+    private void slimeSettings() {
+        slimeRidable = getBoolean("mobs.slime.ridable", slimeRidable);
+        slimeRidableInWater = getBoolean("mobs.slime.ridable-in-water", slimeRidableInWater);
+        slimeControllable = getBoolean("mobs.slime.controllable", slimeControllable);
+        if (PurpurConfig.version < 10) {
+            String oldValue = getString("mobs.slime.attributes.max-health", slimeMaxHealth);
+            set("mobs.slime.attributes.max-health", null);
+            set("mobs.slime.attributes.max_health", oldValue);
+        }
+        slimeMaxHealth = getString("mobs.slime.attributes.max_health", slimeMaxHealth);
+        slimeAttackDamage = getString("mobs.slime.attributes.attack_damage", slimeAttackDamage);
+        slimeMaxHealthCache.clear();
+        slimeAttackDamageCache.clear();
+        slimeTakeDamageFromWater = getBoolean("mobs.slime.takes-damage-from-water", slimeTakeDamageFromWater);
+        slimeAlwaysDropExp = getBoolean("mobs.slime.always-drop-exp", slimeAlwaysDropExp);
+    }
+
+    public boolean snowGolemRidable = false;
+    public boolean snowGolemRidableInWater = true;
+    public boolean snowGolemControllable = true;
+    public boolean snowGolemLeaveTrailWhenRidden = false;
+    public double snowGolemMaxHealth = 4.0D;
+    public double snowGolemScale = 1.0D;
+    public boolean snowGolemPutPumpkinBack = false;
+    public int snowGolemSnowBallMin = 20;
+    public int snowGolemSnowBallMax = 20;
+    public float snowGolemSnowBallModifier = 10.0F;
+    public double snowGolemAttackDistance = 1.25D;
+    public Boolean snowGolemMobGriefingOverride = null;
+    public boolean snowGolemTakeDamageFromWater = true;
+    public boolean snowGolemAlwaysDropExp = false;
+    private void snowGolemSettings() {
+        snowGolemRidable = getBoolean("mobs.snow_golem.ridable", snowGolemRidable);
+        snowGolemRidableInWater = getBoolean("mobs.snow_golem.ridable-in-water", snowGolemRidableInWater);
+        snowGolemControllable = getBoolean("mobs.snow_golem.controllable", snowGolemControllable);
+        snowGolemLeaveTrailWhenRidden = getBoolean("mobs.snow_golem.leave-trail-when-ridden", snowGolemLeaveTrailWhenRidden);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.snow_golem.attributes.max-health", snowGolemMaxHealth);
+            set("mobs.snow_golem.attributes.max-health", null);
+            set("mobs.snow_golem.attributes.max_health", oldValue);
+        }
+        snowGolemMaxHealth = getDouble("mobs.snow_golem.attributes.max_health", snowGolemMaxHealth);
+        snowGolemScale = Mth.clamp(getDouble("mobs.snow_golem.attributes.scale", snowGolemScale), 0.0625D, 16.0D);
+        snowGolemPutPumpkinBack = getBoolean("mobs.snow_golem.pumpkin-can-be-added-back", snowGolemPutPumpkinBack);
+        snowGolemSnowBallMin = getInt("mobs.snow_golem.min-shoot-interval-ticks", snowGolemSnowBallMin);
+        snowGolemSnowBallMax = getInt("mobs.snow_golem.max-shoot-interval-ticks", snowGolemSnowBallMax);
+        snowGolemSnowBallModifier = (float) getDouble("mobs.snow_golem.snow-ball-modifier", snowGolemSnowBallModifier);
+        snowGolemAttackDistance = getDouble("mobs.snow_golem.attack-distance", snowGolemAttackDistance);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.snow_golem.bypass-mob-griefing", false);
+            set("mobs.snow_golem.bypass-mob-griefing", null);
+            set("mobs.snow_golem.mob-griefing-override", oldVal ? true : "default");
+        }
+        snowGolemMobGriefingOverride = getBooleanOrDefault("mobs.snow_golem.mob-griefing-override", snowGolemMobGriefingOverride);
+        snowGolemTakeDamageFromWater = getBoolean("mobs.snow_golem.takes-damage-from-water", snowGolemTakeDamageFromWater);
+        snowGolemAlwaysDropExp = getBoolean("mobs.snow_golem.always-drop-exp", snowGolemAlwaysDropExp);
+    }
+
+    public boolean snifferRidable = false;
+    public boolean snifferRidableInWater = true;
+    public boolean snifferControllable = true;
+    public double snifferMaxHealth = 14.0D;
+    public double snifferScale = 1.0D;
+    public int snifferBreedingTicks = 6000;
+    private void snifferSettings() {
+        snifferRidable = getBoolean("mobs.sniffer.ridable", snifferRidable);
+        snifferRidableInWater = getBoolean("mobs.sniffer.ridable-in-water", snifferRidableInWater);
+        snifferControllable = getBoolean("mobs.sniffer.controllable", snifferControllable);
+        snifferMaxHealth = getDouble("mobs.sniffer.attributes.max_health", snifferMaxHealth);
+        snifferScale = Mth.clamp(getDouble("mobs.sniffer.attributes.scale", snifferScale), 0.0625D, 16.0D);
+        snifferBreedingTicks = getInt("mobs.sniffer.breeding-delay-ticks", snifferBreedingTicks);
+    }
+
+    public boolean squidRidable = false;
+    public boolean squidControllable = true;
+    public double squidMaxHealth = 10.0D;
+    public double squidScale = 1.0D;
+    public boolean squidImmuneToEAR = true;
+    public double squidOffsetWaterCheck = 0.0D;
+    public boolean squidsCanFly = false;
+    public boolean squidTakeDamageFromWater = false;
+    public boolean squidAlwaysDropExp = false;
+    private void squidSettings() {
+        squidRidable = getBoolean("mobs.squid.ridable", squidRidable);
+        squidControllable = getBoolean("mobs.squid.controllable", squidControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.squid.attributes.max-health", squidMaxHealth);
+            set("mobs.squid.attributes.max-health", null);
+            set("mobs.squid.attributes.max_health", oldValue);
+        }
+        squidMaxHealth = getDouble("mobs.squid.attributes.max_health", squidMaxHealth);
+        squidScale = Mth.clamp(getDouble("mobs.squid.attributes.scale", squidScale), 0.0625D, 16.0D);
+        squidImmuneToEAR = getBoolean("mobs.squid.immune-to-EAR", squidImmuneToEAR);
+        squidOffsetWaterCheck = getDouble("mobs.squid.water-offset-check", squidOffsetWaterCheck);
+        squidsCanFly = getBoolean("mobs.squid.can-fly", squidsCanFly);
+        squidTakeDamageFromWater = getBoolean("mobs.squid.takes-damage-from-water", squidTakeDamageFromWater);
+        squidAlwaysDropExp = getBoolean("mobs.squid.always-drop-exp", squidAlwaysDropExp);
+    }
+
+    public boolean spiderRidable = false;
+    public boolean spiderRidableInWater = false;
+    public boolean spiderControllable = true;
+    public double spiderMaxHealth = 16.0D;
+    public double spiderScale = 1.0D;
+    public boolean spiderTakeDamageFromWater = false;
+    public boolean spiderAlwaysDropExp = false;
+    private void spiderSettings() {
+        spiderRidable = getBoolean("mobs.spider.ridable", spiderRidable);
+        spiderRidableInWater = getBoolean("mobs.spider.ridable-in-water", spiderRidableInWater);
+        spiderControllable = getBoolean("mobs.spider.controllable", spiderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.spider.attributes.max-health", spiderMaxHealth);
+            set("mobs.spider.attributes.max-health", null);
+            set("mobs.spider.attributes.max_health", oldValue);
+        }
+        spiderMaxHealth = getDouble("mobs.spider.attributes.max_health", spiderMaxHealth);
+        spiderScale = Mth.clamp(getDouble("mobs.spider.attributes.scale", spiderScale), 0.0625D, 16.0D);
+        spiderTakeDamageFromWater = getBoolean("mobs.spider.takes-damage-from-water", spiderTakeDamageFromWater);
+        spiderAlwaysDropExp = getBoolean("mobs.spider.always-drop-exp", spiderAlwaysDropExp);
+    }
+
+    public boolean strayRidable = false;
+    public boolean strayRidableInWater = true;
+    public boolean strayControllable = true;
+    public double strayMaxHealth = 20.0D;
+    public double strayScale = 1.0D;
+    public boolean strayTakeDamageFromWater = false;
+    public boolean strayAlwaysDropExp = false;
+    private void straySettings() {
+        strayRidable = getBoolean("mobs.stray.ridable", strayRidable);
+        strayRidableInWater = getBoolean("mobs.stray.ridable-in-water", strayRidableInWater);
+        strayControllable = getBoolean("mobs.stray.controllable", strayControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.stray.attributes.max-health", strayMaxHealth);
+            set("mobs.stray.attributes.max-health", null);
+            set("mobs.stray.attributes.max_health", oldValue);
+        }
+        strayMaxHealth = getDouble("mobs.stray.attributes.max_health", strayMaxHealth);
+        strayScale = Mth.clamp(getDouble("mobs.stray.attributes.scale", strayScale), 0.0625D, 16.0D);
+        strayTakeDamageFromWater = getBoolean("mobs.stray.takes-damage-from-water", strayTakeDamageFromWater);
+        strayAlwaysDropExp = getBoolean("mobs.stray.always-drop-exp", strayAlwaysDropExp);
+    }
+
+    public boolean striderRidable = false;
+    public boolean striderRidableInWater = false;
+    public boolean striderControllable = true;
+    public double striderMaxHealth = 20.0D;
+    public double striderScale = 1.0D;
+    public int striderBreedingTicks = 6000;
+    public boolean striderGiveSaddleBack = false;
+    public boolean striderTakeDamageFromWater = true;
+    public boolean striderAlwaysDropExp = false;
+    private void striderSettings() {
+        striderRidable = getBoolean("mobs.strider.ridable", striderRidable);
+        striderRidableInWater = getBoolean("mobs.strider.ridable-in-water", striderRidableInWater);
+        striderControllable = getBoolean("mobs.strider.controllable", striderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.strider.attributes.max-health", striderMaxHealth);
+            set("mobs.strider.attributes.max-health", null);
+            set("mobs.strider.attributes.max_health", oldValue);
+        }
+        striderMaxHealth = getDouble("mobs.strider.attributes.max_health", striderMaxHealth);
+        striderScale = Mth.clamp(getDouble("mobs.strider.attributes.scale", striderScale), 0.0625D, 16.0D);
+        striderBreedingTicks = getInt("mobs.strider.breeding-delay-ticks", striderBreedingTicks);
+        striderGiveSaddleBack = getBoolean("mobs.strider.give-saddle-back", striderGiveSaddleBack);
+        striderTakeDamageFromWater = getBoolean("mobs.strider.takes-damage-from-water", striderTakeDamageFromWater);
+        striderAlwaysDropExp = getBoolean("mobs.strider.always-drop-exp", striderAlwaysDropExp);
+    }
+
+    public boolean tadpoleRidable = false;
+    public boolean tadpoleRidableInWater = true;
+    public boolean tadpoleControllable = true;
+    private void tadpoleSettings() {
+        tadpoleRidable = getBoolean("mobs.tadpole.ridable", tadpoleRidable);
+        tadpoleRidableInWater = getBoolean("mobs.tadpole.ridable-in-water", tadpoleRidableInWater);
+        tadpoleControllable = getBoolean("mobs.tadpole.controllable", tadpoleControllable);
+    }
+
+    public boolean traderLlamaRidable = false;
+    public boolean traderLlamaRidableInWater = false;
+    public boolean traderLlamaControllable = true;
+    public double traderLlamaMaxHealthMin = 15.0D;
+    public double traderLlamaMaxHealthMax = 30.0D;
+    public double traderLlamaJumpStrengthMin = 0.5D;
+    public double traderLlamaJumpStrengthMax = 0.5D;
+    public double traderLlamaMovementSpeedMin = 0.175D;
+    public double traderLlamaMovementSpeedMax = 0.175D;
+    public int traderLlamaBreedingTicks = 6000;
+    public boolean traderLlamaTakeDamageFromWater = false;
+    public boolean traderLlamaAlwaysDropExp = false;
+    private void traderLlamaSettings() {
+        traderLlamaRidable = getBoolean("mobs.trader_llama.ridable", traderLlamaRidable);
+        traderLlamaRidableInWater = getBoolean("mobs.trader_llama.ridable-in-water", traderLlamaRidableInWater);
+        traderLlamaControllable = getBoolean("mobs.trader_llama.controllable", traderLlamaControllable);
+        if (PurpurConfig.version < 10) {
+            double oldMin = getDouble("mobs.trader_llama.attributes.max-health.min", traderLlamaMaxHealthMin);
+            double oldMax = getDouble("mobs.trader_llama.attributes.max-health.max", traderLlamaMaxHealthMax);
+            set("mobs.trader_llama.attributes.max-health", null);
+            set("mobs.trader_llama.attributes.max_health.min", oldMin);
+            set("mobs.trader_llama.attributes.max_health.max", oldMax);
+        }
+        traderLlamaMaxHealthMin = getDouble("mobs.trader_llama.attributes.max_health.min", traderLlamaMaxHealthMin);
+        traderLlamaMaxHealthMax = getDouble("mobs.trader_llama.attributes.max_health.max", traderLlamaMaxHealthMax);
+        traderLlamaJumpStrengthMin = getDouble("mobs.trader_llama.attributes.jump_strength.min", traderLlamaJumpStrengthMin);
+        traderLlamaJumpStrengthMax = getDouble("mobs.trader_llama.attributes.jump_strength.max", traderLlamaJumpStrengthMax);
+        traderLlamaMovementSpeedMin = getDouble("mobs.trader_llama.attributes.movement_speed.min", traderLlamaMovementSpeedMin);
+        traderLlamaMovementSpeedMax = getDouble("mobs.trader_llama.attributes.movement_speed.max", traderLlamaMovementSpeedMax);
+        traderLlamaBreedingTicks = getInt("mobs.trader_llama.breeding-delay-ticks", traderLlamaBreedingTicks);
+        traderLlamaTakeDamageFromWater = getBoolean("mobs.trader_llama.takes-damage-from-water", traderLlamaTakeDamageFromWater);
+        traderLlamaAlwaysDropExp = getBoolean("mobs.trader_llama.always-drop-exp", traderLlamaAlwaysDropExp);
+    }
+
+    public boolean tropicalFishRidable = false;
+    public boolean tropicalFishControllable = true;
+    public double tropicalFishMaxHealth = 3.0D;
+    public double tropicalFishScale = 1.0D;
+    public boolean tropicalFishTakeDamageFromWater = false;
+    public boolean tropicalFishAlwaysDropExp = false;
+    private void tropicalFishSettings() {
+        tropicalFishRidable = getBoolean("mobs.tropical_fish.ridable", tropicalFishRidable);
+        tropicalFishControllable = getBoolean("mobs.tropical_fish.controllable", tropicalFishControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.tropical_fish.attributes.max-health", tropicalFishMaxHealth);
+            set("mobs.tropical_fish.attributes.max-health", null);
+            set("mobs.tropical_fish.attributes.max_health", oldValue);
+        }
+        tropicalFishMaxHealth = getDouble("mobs.tropical_fish.attributes.max_health", tropicalFishMaxHealth);
+        tropicalFishScale = Mth.clamp(getDouble("mobs.tropical_fish.attributes.scale", tropicalFishScale), 0.0625D, 16.0D);
+        tropicalFishTakeDamageFromWater = getBoolean("mobs.tropical_fish.takes-damage-from-water", tropicalFishTakeDamageFromWater);
+        tropicalFishAlwaysDropExp = getBoolean("mobs.tropical_fish.always-drop-exp", tropicalFishAlwaysDropExp);
+    }
+
+    public boolean turtleRidable = false;
+    public boolean turtleRidableInWater = true;
+    public boolean turtleControllable = true;
+    public double turtleMaxHealth = 30.0D;
+    public double turtleScale = 1.0D;
+    public int turtleBreedingTicks = 6000;
+    public boolean turtleTakeDamageFromWater = false;
+    public boolean turtleAlwaysDropExp = false;
+    private void turtleSettings() {
+        turtleRidable = getBoolean("mobs.turtle.ridable", turtleRidable);
+        turtleRidableInWater = getBoolean("mobs.turtle.ridable-in-water", turtleRidableInWater);
+        turtleControllable = getBoolean("mobs.turtle.controllable", turtleControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.turtle.attributes.max-health", turtleMaxHealth);
+            set("mobs.turtle.attributes.max-health", null);
+            set("mobs.turtle.attributes.max_health", oldValue);
+        }
+        turtleMaxHealth = getDouble("mobs.turtle.attributes.max_health", turtleMaxHealth);
+        turtleScale = Mth.clamp(getDouble("mobs.turtle.attributes.scale", turtleScale), 0.0625D, 16.0D);
+        turtleBreedingTicks = getInt("mobs.turtle.breeding-delay-ticks", turtleBreedingTicks);
+        turtleTakeDamageFromWater = getBoolean("mobs.turtle.takes-damage-from-water", turtleTakeDamageFromWater);
+        turtleAlwaysDropExp = getBoolean("mobs.turtle.always-drop-exp", turtleAlwaysDropExp);
+    }
+
+    public boolean vexRidable = false;
+    public boolean vexRidableInWater = true;
+    public boolean vexControllable = true;
+    public double vexMaxY = 320D;
+    public double vexMaxHealth = 14.0D;
+    public double vexScale = 1.0D;
+    public boolean vexTakeDamageFromWater = false;
+    public boolean vexAlwaysDropExp = false;
+    private void vexSettings() {
+        vexRidable = getBoolean("mobs.vex.ridable", vexRidable);
+        vexRidableInWater = getBoolean("mobs.vex.ridable-in-water", vexRidableInWater);
+        vexControllable = getBoolean("mobs.vex.controllable", vexControllable);
+        vexMaxY = getDouble("mobs.vex.ridable-max-y", vexMaxY);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.vex.attributes.max-health", vexMaxHealth);
+            set("mobs.vex.attributes.max-health", null);
+            set("mobs.vex.attributes.max_health", oldValue);
+        }
+        vexMaxHealth = getDouble("mobs.vex.attributes.max_health", vexMaxHealth);
+        vexScale = Mth.clamp(getDouble("mobs.vex.attributes.scale", vexScale), 0.0625D, 16.0D);
+        vexTakeDamageFromWater = getBoolean("mobs.vex.takes-damage-from-water", vexTakeDamageFromWater);
+        vexAlwaysDropExp = getBoolean("mobs.vex.always-drop-exp", vexAlwaysDropExp);
+    }
+
+    public boolean villagerRidable = false;
+    public boolean villagerRidableInWater = true;
+    public boolean villagerControllable = true;
+    public double villagerMaxHealth = 20.0D;
+    public double villagerScale = 1.0D;
+    public boolean villagerFollowEmeraldBlock = false;
+    public double villagerTemptRange = 10.0D;
+    public boolean villagerCanBeLeashed = false;
+    public boolean villagerCanBreed = true;
+    public int villagerBreedingTicks = 6000;
+    public boolean villagerClericsFarmWarts = false;
+    public boolean villagerClericFarmersThrowWarts = true;
+    public Boolean villagerMobGriefingOverride = null;
+    public boolean villagerTakeDamageFromWater = false;
+    public boolean villagerAllowTrading = true;
+    public boolean villagerAlwaysDropExp = false;
+    public int villagerMinimumDemand = 0;
+    public boolean villagerLobotomizeEnabled = false;
+    public int villagerLobotomizeCheckInterval = 100;
+    public boolean villagerLobotomizeWaitUntilTradeLocked = false;
+    public boolean villagerDisplayTradeItem = true;
+    public int villagerSpawnIronGolemRadius = 0;
+    public int villagerSpawnIronGolemLimit = 0;
+    public int villagerAcquirePoiSearchRadius = 48;
+    public int villagerNearestBedSensorSearchRadius = 48;
+    private void villagerSettings() {
+        villagerRidable = getBoolean("mobs.villager.ridable", villagerRidable);
+        villagerRidableInWater = getBoolean("mobs.villager.ridable-in-water", villagerRidableInWater);
+        villagerControllable = getBoolean("mobs.villager.controllable", villagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.villager.attributes.max-health", villagerMaxHealth);
+            set("mobs.villager.attributes.max-health", null);
+            set("mobs.villager.attributes.max_health", oldValue);
+        }
+        villagerMaxHealth = getDouble("mobs.villager.attributes.max_health", villagerMaxHealth);
+        villagerScale = Mth.clamp(getDouble("mobs.villager.attributes.scale", villagerScale), 0.0625D, 16.0D);
+        villagerFollowEmeraldBlock = getBoolean("mobs.villager.follow-emerald-blocks", villagerFollowEmeraldBlock);
+        villagerTemptRange = getDouble("mobs.villager.attributes.tempt_range", villagerTemptRange);
+        villagerCanBeLeashed = getBoolean("mobs.villager.can-be-leashed", villagerCanBeLeashed);
+        villagerCanBreed = getBoolean("mobs.villager.can-breed", villagerCanBreed);
+        villagerBreedingTicks = getInt("mobs.villager.breeding-delay-ticks", villagerBreedingTicks);
+        villagerClericsFarmWarts = getBoolean("mobs.villager.clerics-farm-warts", villagerClericsFarmWarts);
+        villagerClericFarmersThrowWarts = getBoolean("mobs.villager.cleric-wart-farmers-throw-warts-at-villagers", villagerClericFarmersThrowWarts);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.villager.bypass-mob-griefing", false);
+            set("mobs.villager.bypass-mob-griefing", null);
+            set("mobs.villager.mob-griefing-override", oldVal ? true : "default");
+        }
+        villagerMobGriefingOverride = getBooleanOrDefault("mobs.villager.mob-griefing-override", villagerMobGriefingOverride);
+        villagerTakeDamageFromWater = getBoolean("mobs.villager.takes-damage-from-water", villagerTakeDamageFromWater);
+        villagerAllowTrading = getBoolean("mobs.villager.allow-trading", villagerAllowTrading);
+        villagerAlwaysDropExp = getBoolean("mobs.villager.always-drop-exp", villagerAlwaysDropExp);
+        villagerMinimumDemand = getInt("mobs.villager.minimum-demand", villagerMinimumDemand);
+        if (PurpurConfig.version < 9) {
+            boolean oldValue = getBoolean("mobs.villager.lobotomize-1x1", villagerLobotomizeEnabled);
+            set("mobs.villager.lobotomize.enabled", oldValue);
+            set("mobs.villager.lobotomize-1x1", null);
+        }
+        if (PurpurConfig.version < 27) {
+            int oldValue = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
+            set("mobs.villager.lobotomize.check-interval", oldValue == 60 ? 100 : oldValue);
+        }
+        villagerLobotomizeEnabled = getBoolean("mobs.villager.lobotomize.enabled", villagerLobotomizeEnabled);
+        villagerLobotomizeCheckInterval = getInt("mobs.villager.lobotomize.check-interval", villagerLobotomizeCheckInterval);
+        villagerLobotomizeWaitUntilTradeLocked = getBoolean("mobs.villager.lobotomize.wait-until-trade-locked", villagerLobotomizeWaitUntilTradeLocked);
+        villagerDisplayTradeItem = getBoolean("mobs.villager.display-trade-item", villagerDisplayTradeItem);
+        villagerSpawnIronGolemRadius = getInt("mobs.villager.spawn-iron-golem.radius", villagerSpawnIronGolemRadius);
+        villagerSpawnIronGolemLimit = getInt("mobs.villager.spawn-iron-golem.limit", villagerSpawnIronGolemLimit);
+        villagerAcquirePoiSearchRadius = getInt("mobs.villager.search-radius.acquire-poi", villagerAcquirePoiSearchRadius);
+        villagerNearestBedSensorSearchRadius = getInt("mobs.villager.search-radius.nearest-bed-sensor", villagerNearestBedSensorSearchRadius);
+    }
+
+    public boolean vindicatorRidable = false;
+    public boolean vindicatorRidableInWater = true;
+    public boolean vindicatorControllable = true;
+    public double vindicatorMaxHealth = 24.0D;
+    public double vindicatorScale = 1.0D;
+    public double vindicatorJohnnySpawnChance = 0D;
+    public boolean vindicatorTakeDamageFromWater = false;
+    public boolean vindicatorAlwaysDropExp = false;
+    private void vindicatorSettings() {
+        vindicatorRidable = getBoolean("mobs.vindicator.ridable", vindicatorRidable);
+        vindicatorRidableInWater = getBoolean("mobs.vindicator.ridable-in-water", vindicatorRidableInWater);
+        vindicatorControllable = getBoolean("mobs.vindicator.controllable", vindicatorControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.vindicator.attributes.max-health", vindicatorMaxHealth);
+            set("mobs.vindicator.attributes.max-health", null);
+            set("mobs.vindicator.attributes.max_health", oldValue);
+        }
+        vindicatorMaxHealth = getDouble("mobs.vindicator.attributes.max_health", vindicatorMaxHealth);
+        vindicatorScale = Mth.clamp(getDouble("mobs.vindicator.attributes.scale", vindicatorScale), 0.0625D, 16.0D);
+        vindicatorJohnnySpawnChance = getDouble("mobs.vindicator.johnny.spawn-chance", vindicatorJohnnySpawnChance);
+        vindicatorTakeDamageFromWater = getBoolean("mobs.vindicator.takes-damage-from-water", vindicatorTakeDamageFromWater);
+        vindicatorAlwaysDropExp = getBoolean("mobs.vindicator.always-drop-exp", vindicatorAlwaysDropExp);
+    }
+
+    public boolean wanderingTraderRidable = false;
+    public boolean wanderingTraderRidableInWater = true;
+    public boolean wanderingTraderControllable = true;
+    public double wanderingTraderMaxHealth = 20.0D;
+    public double wanderingTraderScale = 1.0D;
+    public boolean wanderingTraderFollowEmeraldBlock = false;
+    public double wanderingTraderTemptRange = 10.0D;
+    public boolean wanderingTraderCanBeLeashed = false;
+    public boolean wanderingTraderTakeDamageFromWater = false;
+    public boolean wanderingTraderAllowTrading = true;
+    public boolean wanderingTraderAlwaysDropExp = false;
+    private void wanderingTraderSettings() {
+        wanderingTraderRidable = getBoolean("mobs.wandering_trader.ridable", wanderingTraderRidable);
+        wanderingTraderRidableInWater = getBoolean("mobs.wandering_trader.ridable-in-water", wanderingTraderRidableInWater);
+        wanderingTraderControllable = getBoolean("mobs.wandering_trader.controllable", wanderingTraderControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wandering_trader.attributes.max-health", wanderingTraderMaxHealth);
+            set("mobs.wandering_trader.attributes.max-health", null);
+            set("mobs.wandering_trader.attributes.max_health", oldValue);
+        }
+        wanderingTraderMaxHealth = getDouble("mobs.wandering_trader.attributes.max_health", wanderingTraderMaxHealth);
+        wanderingTraderScale = Mth.clamp(getDouble("mobs.wandering_trader.attributes.scale", wanderingTraderScale), 0.0625D, 16.0D);
+        wanderingTraderFollowEmeraldBlock = getBoolean("mobs.wandering_trader.follow-emerald-blocks", wanderingTraderFollowEmeraldBlock);
+        wanderingTraderTemptRange = getDouble("mobs.wandering_trader.attributes.tempt_range", wanderingTraderTemptRange);
+        wanderingTraderCanBeLeashed = getBoolean("mobs.wandering_trader.can-be-leashed", wanderingTraderCanBeLeashed);
+        wanderingTraderTakeDamageFromWater = getBoolean("mobs.wandering_trader.takes-damage-from-water", wanderingTraderTakeDamageFromWater);
+        wanderingTraderAllowTrading = getBoolean("mobs.wandering_trader.allow-trading", wanderingTraderAllowTrading);
+        wanderingTraderAlwaysDropExp = getBoolean("mobs.wandering_trader.always-drop-exp", wanderingTraderAlwaysDropExp);
+    }
+
+    public boolean wardenRidable = false;
+    public boolean wardenRidableInWater = true;
+    public boolean wardenControllable = true;
+    private void wardenSettings() {
+        wardenRidable = getBoolean("mobs.warden.ridable", wardenRidable);
+        wardenRidableInWater = getBoolean("mobs.warden.ridable-in-water", wardenRidableInWater);
+        wardenControllable = getBoolean("mobs.warden.controllable", wardenControllable);
+    }
+
+    public boolean witchRidable = false;
+    public boolean witchRidableInWater = true;
+    public boolean witchControllable = true;
+    public double witchMaxHealth = 26.0D;
+    public double witchScale = 1.0D;
+    public boolean witchTakeDamageFromWater = false;
+    public boolean witchAlwaysDropExp = false;
+    private void witchSettings() {
+        witchRidable = getBoolean("mobs.witch.ridable", witchRidable);
+        witchRidableInWater = getBoolean("mobs.witch.ridable-in-water", witchRidableInWater);
+        witchControllable = getBoolean("mobs.witch.controllable", witchControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.witch.attributes.max-health", witchMaxHealth);
+            set("mobs.witch.attributes.max-health", null);
+            set("mobs.witch.attributes.max_health", oldValue);
+        }
+        witchMaxHealth = getDouble("mobs.witch.attributes.max_health", witchMaxHealth);
+        witchScale = Mth.clamp(getDouble("mobs.witch.attributes.scale", witchScale), 0.0625D, 16.0D);
+        witchTakeDamageFromWater = getBoolean("mobs.witch.takes-damage-from-water", witchTakeDamageFromWater);
+        witchAlwaysDropExp = getBoolean("mobs.witch.always-drop-exp", witchAlwaysDropExp);
+    }
+
+    public boolean witherRidable = false;
+    public boolean witherRidableInWater = true;
+    public boolean witherControllable = true;
+    public double witherMaxY = 320D;
+    public double witherMaxHealth = 300.0D;
+    public double witherScale = 1.0D;
+    public float witherHealthRegenAmount = 1.0f;
+    public int witherHealthRegenDelay = 20;
+    public Boolean witherMobGriefingOverride = null;
+    public boolean witherTakeDamageFromWater = false;
+    public boolean witherCanRideVehicles = false;
+    public float witherExplosionRadius = 1.0F;
+    public boolean witherPlaySpawnSound = true;
+    public boolean witherAlwaysDropExp = false;
+    private void witherSettings() {
+        witherRidable = getBoolean("mobs.wither.ridable", witherRidable);
+        witherRidableInWater = getBoolean("mobs.wither.ridable-in-water", witherRidableInWater);
+        witherControllable = getBoolean("mobs.wither.controllable", witherControllable);
+        witherMaxY = getDouble("mobs.wither.ridable-max-y", witherMaxY);
+        if (PurpurConfig.version < 8) {
+            double oldValue = getDouble("mobs.wither.max-health", witherMaxHealth);
+            set("mobs.wither.max_health", null);
+            set("mobs.wither.attributes.max-health", oldValue);
+        } else if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wither.attributes.max-health", witherMaxHealth);
+            set("mobs.wither.attributes.max-health", null);
+            set("mobs.wither.attributes.max_health", oldValue);
+        }
+        witherMaxHealth = getDouble("mobs.wither.attributes.max_health", witherMaxHealth);
+        witherScale = Mth.clamp(getDouble("mobs.wither.attributes.scale", witherScale), 0.0625D, 16.0D);
+        witherHealthRegenAmount = (float) getDouble("mobs.wither.health-regen-amount", witherHealthRegenAmount);
+        witherHealthRegenDelay = getInt("mobs.wither.health-regen-delay", witherHealthRegenDelay);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.wither.bypass-mob-griefing", false);
+            set("mobs.wither.bypass-mob-griefing", null);
+            set("mobs.wither.mob-griefing-override", oldVal ? true : "default");
+        }
+        witherMobGriefingOverride = getBooleanOrDefault("mobs.wither.mob-griefing-override", witherMobGriefingOverride);
+        witherTakeDamageFromWater = getBoolean("mobs.wither.takes-damage-from-water", witherTakeDamageFromWater);
+        witherCanRideVehicles = getBoolean("mobs.wither.can-ride-vehicles", witherCanRideVehicles);
+        witherExplosionRadius = (float) getDouble("mobs.wither.explosion-radius", witherExplosionRadius);
+        witherPlaySpawnSound = getBoolean("mobs.wither.play-spawn-sound", witherPlaySpawnSound);
+        witherAlwaysDropExp = getBoolean("mobs.wither.always-drop-exp", witherAlwaysDropExp);
+    }
+
+    public boolean witherSkeletonRidable = false;
+    public boolean witherSkeletonRidableInWater = true;
+    public boolean witherSkeletonControllable = true;
+    public double witherSkeletonMaxHealth = 20.0D;
+    public double witherSkeletonScale = 1.0D;
+    public boolean witherSkeletonTakeDamageFromWater = false;
+    public boolean witherSkeletonAlwaysDropExp = false;
+    private void witherSkeletonSettings() {
+        witherSkeletonRidable = getBoolean("mobs.wither_skeleton.ridable", witherSkeletonRidable);
+        witherSkeletonRidableInWater = getBoolean("mobs.wither_skeleton.ridable-in-water", witherSkeletonRidableInWater);
+        witherSkeletonControllable = getBoolean("mobs.wither_skeleton.controllable", witherSkeletonControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wither_skeleton.attributes.max-health", witherSkeletonMaxHealth);
+            set("mobs.wither_skeleton.attributes.max-health", null);
+            set("mobs.wither_skeleton.attributes.max_health", oldValue);
+        }
+        witherSkeletonMaxHealth = getDouble("mobs.wither_skeleton.attributes.max_health", witherSkeletonMaxHealth);
+        witherSkeletonScale = Mth.clamp(getDouble("mobs.wither_skeleton.attributes.scale", witherSkeletonScale), 0.0625D, 16.0D);
+        witherSkeletonTakeDamageFromWater = getBoolean("mobs.wither_skeleton.takes-damage-from-water", witherSkeletonTakeDamageFromWater);
+        witherSkeletonAlwaysDropExp = getBoolean("mobs.wither_skeleton.always-drop-exp", witherSkeletonAlwaysDropExp);
+    }
+
+    public boolean wolfRidable = false;
+    public boolean wolfRidableInWater = true;
+    public boolean wolfControllable = true;
+    public double wolfMaxHealth = 8.0D;
+    public double wolfScale = 1.0D;
+    public DyeColor wolfDefaultCollarColor = DyeColor.RED;
+    public boolean wolfMilkCuresRabies = true;
+    public double wolfNaturalRabid = 0.0D;
+    public int wolfBreedingTicks = 6000;
+    public boolean wolfTakeDamageFromWater = false;
+    public boolean wolfAlwaysDropExp = false;
+    private void wolfSettings() {
+        wolfRidable = getBoolean("mobs.wolf.ridable", wolfRidable);
+        wolfRidableInWater = getBoolean("mobs.wolf.ridable-in-water", wolfRidableInWater);
+        wolfControllable = getBoolean("mobs.wolf.controllable", wolfControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.wolf.attributes.max-health", wolfMaxHealth);
+            set("mobs.wolf.attributes.max-health", null);
+            set("mobs.wolf.attributes.max_health", oldValue);
+        }
+        wolfMaxHealth = getDouble("mobs.wolf.attributes.max_health", wolfMaxHealth);
+        wolfScale = Mth.clamp(getDouble("mobs.wolf.attributes.scale", wolfScale), 0.0625D, 16.0D);
+        try {
+            wolfDefaultCollarColor = DyeColor.valueOf(getString("mobs.wolf.default-collar-color", wolfDefaultCollarColor.name()));
+        } catch (IllegalArgumentException ignore) {
+            wolfDefaultCollarColor = DyeColor.RED;
+        }
+        wolfMilkCuresRabies = getBoolean("mobs.wolf.milk-cures-rabid-wolves", wolfMilkCuresRabies);
+        wolfNaturalRabid = getDouble("mobs.wolf.spawn-rabid-chance", wolfNaturalRabid);
+        wolfBreedingTicks = getInt("mobs.wolf.breeding-delay-ticks", wolfBreedingTicks);
+        wolfTakeDamageFromWater = getBoolean("mobs.wolf.takes-damage-from-water", wolfTakeDamageFromWater);
+        wolfAlwaysDropExp = getBoolean("mobs.wolf.always-drop-exp", wolfAlwaysDropExp);
+    }
+
+    public boolean zoglinRidable = false;
+    public boolean zoglinRidableInWater = true;
+    public boolean zoglinControllable = true;
+    public double zoglinMaxHealth = 40.0D;
+    public double zoglinScale = 1.0D;
+    public boolean zoglinTakeDamageFromWater = false;
+    public boolean zoglinAlwaysDropExp = false;
+    private void zoglinSettings() {
+        zoglinRidable = getBoolean("mobs.zoglin.ridable", zoglinRidable);
+        zoglinRidableInWater = getBoolean("mobs.zoglin.ridable-in-water", zoglinRidableInWater);
+        zoglinControllable = getBoolean("mobs.zoglin.controllable", zoglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zoglin.attributes.max-health", zoglinMaxHealth);
+            set("mobs.zoglin.attributes.max-health", null);
+            set("mobs.zoglin.attributes.max_health", oldValue);
+        }
+        zoglinMaxHealth = getDouble("mobs.zoglin.attributes.max_health", zoglinMaxHealth);
+        zoglinScale = Mth.clamp(getDouble("mobs.zoglin.attributes.scale", zoglinScale), 0.0625D, 16.0D);
+        zoglinTakeDamageFromWater = getBoolean("mobs.zoglin.takes-damage-from-water", zoglinTakeDamageFromWater);
+        zoglinAlwaysDropExp = getBoolean("mobs.zoglin.always-drop-exp", zoglinAlwaysDropExp);
+    }
+
+    public boolean zombieRidable = false;
+    public boolean zombieRidableInWater = true;
+    public boolean zombieControllable = true;
+    public double zombieMaxHealth = 20.0D;
+    public double zombieScale = 1.0D;
+    public double zombieSpawnReinforcements = 0.1D;
+    public boolean zombieJockeyOnlyBaby = true;
+    public double zombieJockeyChance = 0.05D;
+    public boolean zombieJockeyTryExistingChickens = true;
+    public boolean zombieAggressiveTowardsVillagerWhenLagging = true;
+    public Boolean zombieMobGriefingOverride = null;
+    public boolean zombieTakeDamageFromWater = false;
+    public boolean zombieAlwaysDropExp = false;
+    public double zombieHeadVisibilityPercent = 0.5D;
+    private void zombieSettings() {
+        zombieRidable = getBoolean("mobs.zombie.ridable", zombieRidable);
+        zombieRidableInWater = getBoolean("mobs.zombie.ridable-in-water", zombieRidableInWater);
+        zombieControllable = getBoolean("mobs.zombie.controllable", zombieControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie.attributes.max-health", zombieMaxHealth);
+            set("mobs.zombie.attributes.max-health", null);
+            set("mobs.zombie.attributes.max_health", oldValue);
+        }
+        zombieMaxHealth = getDouble("mobs.zombie.attributes.max_health", zombieMaxHealth);
+        zombieScale = Mth.clamp(getDouble("mobs.zombie.attributes.scale", zombieScale), 0.0625D, 16.0D);
+        zombieSpawnReinforcements = getDouble("mobs.zombie.attributes.spawn_reinforcements", zombieSpawnReinforcements);
+        zombieJockeyOnlyBaby = getBoolean("mobs.zombie.jockey.only-babies", zombieJockeyOnlyBaby);
+        zombieJockeyChance = getDouble("mobs.zombie.jockey.chance", zombieJockeyChance);
+        zombieJockeyTryExistingChickens = getBoolean("mobs.zombie.jockey.try-existing-chickens", zombieJockeyTryExistingChickens);
+        zombieAggressiveTowardsVillagerWhenLagging = getBoolean("mobs.zombie.aggressive-towards-villager-when-lagging", zombieAggressiveTowardsVillagerWhenLagging);
+        if (PurpurConfig.version < 43) {
+            boolean oldVal = getBoolean("mobs.zombie.bypass-mob-griefing", false);
+            set("mobs.zombie.bypass-mob-griefing", null);
+            set("mobs.zombie.mob-griefing-override", oldVal ? true : "default");
+        }
+        zombieMobGriefingOverride = getBooleanOrDefault("mobs.zombie.mob-griefing-override", zombieMobGriefingOverride);
+        zombieTakeDamageFromWater = getBoolean("mobs.zombie.takes-damage-from-water", zombieTakeDamageFromWater);
+        zombieAlwaysDropExp = getBoolean("mobs.zombie.always-drop-exp", zombieAlwaysDropExp);
+        zombieHeadVisibilityPercent = getDouble("mobs.zombie.head-visibility-percent", zombieHeadVisibilityPercent);
+    }
+
+    public boolean zombieHorseRidable = false;
+    public boolean zombieHorseRidableInWater = false;
+    public boolean zombieHorseCanSwim = false;
+    public double zombieHorseMaxHealthMin = 15.0D;
+    public double zombieHorseMaxHealthMax = 15.0D;
+    public double zombieHorseJumpStrengthMin = 0.4D;
+    public double zombieHorseJumpStrengthMax = 1.0D;
+    public double zombieHorseMovementSpeedMin = 0.2D;
+    public double zombieHorseMovementSpeedMax = 0.2D;
+    public double zombieHorseSpawnChance = 0.0D;
+    public boolean zombieHorseTakeDamageFromWater = false;
+    public boolean zombieHorseAlwaysDropExp = false;
+    private void zombieHorseSettings() {
+        zombieHorseRidable = getBoolean("mobs.zombie_horse.ridable", zombieHorseRidable);
+        zombieHorseRidableInWater = getBoolean("mobs.zombie_horse.ridable-in-water", zombieHorseRidableInWater);
+        zombieHorseCanSwim = getBoolean("mobs.zombie_horse.can-swim", zombieHorseCanSwim);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie_horse.attributes.max-health", zombieHorseMaxHealthMin);
+            set("mobs.zombie_horse.attributes.max-health", null);
+            set("mobs.zombie_horse.attributes.max_health.min", oldValue);
+            set("mobs.zombie_horse.attributes.max_health.max", oldValue);
+        }
+        zombieHorseMaxHealthMin = getDouble("mobs.zombie_horse.attributes.max_health.min", zombieHorseMaxHealthMin);
+        zombieHorseMaxHealthMax = getDouble("mobs.zombie_horse.attributes.max_health.max", zombieHorseMaxHealthMax);
+        zombieHorseJumpStrengthMin = getDouble("mobs.zombie_horse.attributes.jump_strength.min", zombieHorseJumpStrengthMin);
+        zombieHorseJumpStrengthMax = getDouble("mobs.zombie_horse.attributes.jump_strength.max", zombieHorseJumpStrengthMax);
+        zombieHorseMovementSpeedMin = getDouble("mobs.zombie_horse.attributes.movement_speed.min", zombieHorseMovementSpeedMin);
+        zombieHorseMovementSpeedMax = getDouble("mobs.zombie_horse.attributes.movement_speed.max", zombieHorseMovementSpeedMax);
+        zombieHorseSpawnChance = getDouble("mobs.zombie_horse.spawn-chance", zombieHorseSpawnChance);
+        zombieHorseTakeDamageFromWater = getBoolean("mobs.zombie_horse.takes-damage-from-water", zombieHorseTakeDamageFromWater);
+        zombieHorseAlwaysDropExp = getBoolean("mobs.zombie_horse.always-drop-exp", zombieHorseAlwaysDropExp);
+    }
+
+    public boolean zombieVillagerRidable = false;
+    public boolean zombieVillagerRidableInWater = true;
+    public boolean zombieVillagerControllable = true;
+    public double zombieVillagerMaxHealth = 20.0D;
+    public double zombieVillagerScale = 1.0D;
+    public double zombieVillagerSpawnReinforcements = 0.1D;
+    public boolean zombieVillagerJockeyOnlyBaby = true;
+    public double zombieVillagerJockeyChance = 0.05D;
+    public boolean zombieVillagerJockeyTryExistingChickens = true;
+    public boolean zombieVillagerTakeDamageFromWater = false;
+    public int zombieVillagerCuringTimeMin = 3600;
+    public int zombieVillagerCuringTimeMax = 6000;
+    public boolean zombieVillagerCureEnabled = true;
+    public boolean zombieVillagerAlwaysDropExp = false;
+    private void zombieVillagerSettings() {
+        zombieVillagerRidable = getBoolean("mobs.zombie_villager.ridable", zombieVillagerRidable);
+        zombieVillagerRidableInWater = getBoolean("mobs.zombie_villager.ridable-in-water", zombieVillagerRidableInWater);
+        zombieVillagerControllable = getBoolean("mobs.zombie_villager.controllable", zombieVillagerControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombie_villager.attributes.max-health", zombieVillagerMaxHealth);
+            set("mobs.zombie_villager.attributes.max-health", null);
+            set("mobs.zombie_villager.attributes.max_health", oldValue);
+        }
+        zombieVillagerMaxHealth = getDouble("mobs.zombie_villager.attributes.max_health", zombieVillagerMaxHealth);
+        zombieVillagerScale = Mth.clamp(getDouble("mobs.zombie_villager.attributes.scale", zombieVillagerScale), 0.0625D, 16.0D);
+        zombieVillagerSpawnReinforcements = getDouble("mobs.zombie_villager.attributes.spawn_reinforcements", zombieVillagerSpawnReinforcements);
+        zombieVillagerJockeyOnlyBaby = getBoolean("mobs.zombie_villager.jockey.only-babies", zombieVillagerJockeyOnlyBaby);
+        zombieVillagerJockeyChance = getDouble("mobs.zombie_villager.jockey.chance", zombieVillagerJockeyChance);
+        zombieVillagerJockeyTryExistingChickens = getBoolean("mobs.zombie_villager.jockey.try-existing-chickens", zombieVillagerJockeyTryExistingChickens);
+        zombieVillagerTakeDamageFromWater = getBoolean("mobs.zombie_villager.takes-damage-from-water", zombieVillagerTakeDamageFromWater);
+        zombieVillagerCuringTimeMin = getInt("mobs.zombie_villager.curing_time.min", zombieVillagerCuringTimeMin);
+        zombieVillagerCuringTimeMax = getInt("mobs.zombie_villager.curing_time.max", zombieVillagerCuringTimeMax);
+        zombieVillagerCureEnabled = getBoolean("mobs.zombie_villager.cure.enabled", zombieVillagerCureEnabled);
+        zombieVillagerAlwaysDropExp = getBoolean("mobs.zombie_villager.always-drop-exp", zombieVillagerAlwaysDropExp);
+    }
+
+    public boolean zombifiedPiglinRidable = false;
+    public boolean zombifiedPiglinRidableInWater = true;
+    public boolean zombifiedPiglinControllable = true;
+    public double zombifiedPiglinMaxHealth = 20.0D;
+    public double zombifiedPiglinScale = 1.0D;
+    public double zombifiedPiglinSpawnReinforcements = 0.0D;
+    public boolean zombifiedPiglinJockeyOnlyBaby = true;
+    public double zombifiedPiglinJockeyChance = 0.05D;
+    public boolean zombifiedPiglinJockeyTryExistingChickens = true;
+    public boolean zombifiedPiglinCountAsPlayerKillWhenAngry = false;
+    public boolean zombifiedPiglinTakeDamageFromWater = false;
+    public boolean zombifiedPiglinAlwaysDropExp = false;
+    private void zombifiedPiglinSettings() {
+        zombifiedPiglinRidable = getBoolean("mobs.zombified_piglin.ridable", zombifiedPiglinRidable);
+        zombifiedPiglinRidableInWater = getBoolean("mobs.zombified_piglin.ridable-in-water", zombifiedPiglinRidableInWater);
+        zombifiedPiglinControllable = getBoolean("mobs.zombified_piglin.controllable", zombifiedPiglinControllable);
+        if (PurpurConfig.version < 10) {
+            double oldValue = getDouble("mobs.zombified_piglin.attributes.max-health", zombifiedPiglinMaxHealth);
+            set("mobs.zombified_piglin.attributes.max-health", null);
+            set("mobs.zombified_piglin.attributes.max_health", oldValue);
+        }
+        zombifiedPiglinMaxHealth = getDouble("mobs.zombified_piglin.attributes.max_health", zombifiedPiglinMaxHealth);
+        zombifiedPiglinScale = Mth.clamp(getDouble("mobs.zombified_piglin.attributes.scale", zombifiedPiglinScale), 0.0625D, 16.0D);
+        zombifiedPiglinSpawnReinforcements = getDouble("mobs.zombified_piglin.attributes.spawn_reinforcements", zombifiedPiglinSpawnReinforcements);
+        zombifiedPiglinJockeyOnlyBaby = getBoolean("mobs.zombified_piglin.jockey.only-babies", zombifiedPiglinJockeyOnlyBaby);
+        zombifiedPiglinJockeyChance = getDouble("mobs.zombified_piglin.jockey.chance", zombifiedPiglinJockeyChance);
+        zombifiedPiglinJockeyTryExistingChickens = getBoolean("mobs.zombified_piglin.jockey.try-existing-chickens", zombifiedPiglinJockeyTryExistingChickens);
+        if (PurpurConfig.version < 42) {
+            set("mobs.zombified_piglin.count-as-player-kill-when-angry", false);
+        }
+        zombifiedPiglinCountAsPlayerKillWhenAngry = getBoolean("mobs.zombified_piglin.count-as-player-kill-when-angry", zombifiedPiglinCountAsPlayerKillWhenAngry);
+        zombifiedPiglinTakeDamageFromWater = getBoolean("mobs.zombified_piglin.takes-damage-from-water", zombifiedPiglinTakeDamageFromWater);
+        zombifiedPiglinAlwaysDropExp = getBoolean("mobs.zombified_piglin.always-drop-exp", zombifiedPiglinAlwaysDropExp);
+    }
+
+    public float hungerStarvationDamage = 1.0F;
+    private void hungerSettings() {
+        hungerStarvationDamage = (float) getDouble("hunger.starvation-damage", hungerStarvationDamage);
+    }
+
+    public int conduitDistance = 16;
+    public double conduitDamageDistance = 8;
+    public float conduitDamageAmount = 4;
+    public Block[] conduitBlocks;
+    private void conduitSettings() {
+        conduitDistance = getInt("blocks.conduit.effect-distance", conduitDistance);
+        conduitDamageDistance = getDouble("blocks.conduit.mob-damage.distance", conduitDamageDistance);
+        conduitDamageAmount = (float) getDouble("blocks.conduit.mob-damage.damage-amount", conduitDamageAmount);
+        List<Block> conduitBlockList = new ArrayList<>();
+        getList("blocks.conduit.valid-ring-blocks", new ArrayList<String>(){{
+            add("minecraft:prismarine");
+            add("minecraft:prismarine_bricks");
+            add("minecraft:sea_lantern");
+            add("minecraft:dark_prismarine");
+        }}).forEach(key -> {
+            Block block = BuiltInRegistries.BLOCK.getValue(ResourceLocation.parse(key.toString()));
+            if (!block.defaultBlockState().isAir()) {
+                conduitBlockList.add(block);
+            }
+        });
+        conduitBlocks = conduitBlockList.toArray(Block[]::new);
+    }
+
+    public float cauldronRainChance = 0.05F;
+    public float cauldronPowderSnowChance = 0.1F;
+    public float cauldronDripstoneWaterFillChance = 0.17578125F;
+    public float cauldronDripstoneLavaFillChance = 0.05859375F;
+    private void cauldronSettings() {
+        cauldronRainChance = (float) getDouble("blocks.cauldron.fill-chances.rain", cauldronRainChance);
+        cauldronPowderSnowChance = (float) getDouble("blocks.cauldron.fill-chances.powder-snow", cauldronPowderSnowChance);
+        cauldronDripstoneWaterFillChance = (float) getDouble("blocks.cauldron.fill-chances.dripstone-water", cauldronDripstoneWaterFillChance);
+        cauldronDripstoneLavaFillChance = (float) getDouble("blocks.cauldron.fill-chances.dripstone-lava", cauldronDripstoneLavaFillChance);
+    }
+
+    public float shearsCanDefuseTntChance = 0.00F;
+    public boolean shearsCanDefuseTnt = false;
+    private void shearsCanDefuseTntSettings() {
+        shearsCanDefuseTntChance = (float) getDouble("gameplay-mechanics.item.shears.defuse-tnt-chance", 0.00D);
+        shearsCanDefuseTnt = shearsCanDefuseTntChance > 0.00F;
+    }
+}
diff --git a/org/purpurmc/purpur/command/CompassCommand.java b/org/purpurmc/purpur/command/CompassCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..79b8490832d2a0cc7846ddcb091cb6bcac74ea45
--- /dev/null
+++ b/org/purpurmc/purpur/command/CompassCommand.java
@@ -0,0 +1,27 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.task.CompassTask;
+
+public class CompassCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("compass")
+                .requires(listener -> listener.hasPermission(2, "bukkit.command.compass"))
+                .executes(context -> {
+                    ServerPlayer player = context.getSource().getPlayerOrException();
+                    CompassTask task = CompassTask.instance();
+                    if (player.compassBar()) {
+                        task.removePlayer(player.getBukkitEntity());
+                        player.compassBar(false);
+                    } else {
+                        task.addPlayer(player.getBukkitEntity());
+                        player.compassBar(true);
+                    }
+                    return 1;
+                })
+        );
+    }
+}
diff --git a/org/purpurmc/purpur/command/CreditsCommand.java b/org/purpurmc/purpur/command/CreditsCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..40d2fab4a9728ac90c36e30c130f3116b7025d11
--- /dev/null
+++ b/org/purpurmc/purpur/command/CreditsCommand.java
@@ -0,0 +1,35 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class CreditsCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("credits")
+                .requires((listener) -> listener.hasPermission(2, "bukkit.command.credits"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(2, "bukkit.command.credits.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            ClientboundGameEventPacket packet = new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 1F);
+            player.connection.send(packet);
+            String output = String.format(PurpurConfig.creditsCommandOutput, player.getGameProfile().getName());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/DemoCommand.java b/org/purpurmc/purpur/command/DemoCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..235f3cd89f675b70a6152a00534608c0902f19fd
--- /dev/null
+++ b/org/purpurmc/purpur/command/DemoCommand.java
@@ -0,0 +1,35 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.network.protocol.game.ClientboundGameEventPacket;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class DemoCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("demo")
+                .requires((listener) -> listener.hasPermission(2, "bukkit.command.demo"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(2, "bukkit.command.demo.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            ClientboundGameEventPacket packet = new ClientboundGameEventPacket(ClientboundGameEventPacket.DEMO_EVENT, 0);
+            player.connection.send(packet);
+            String output = String.format(PurpurConfig.demoCommandOutput, player.getGameProfile().getName());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/PingCommand.java b/org/purpurmc/purpur/command/PingCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..74a602c331e9581d7425a09e4094f1d646099676
--- /dev/null
+++ b/org/purpurmc/purpur/command/PingCommand.java
@@ -0,0 +1,32 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class PingCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("ping")
+                .requires((listener) -> listener.hasPermission(2, "bukkit.command.ping"))
+                .executes((context) -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(2, "bukkit.command.ping.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            String output = String.format(PurpurConfig.pingCommandOutput, player.getGameProfile().getName(), player.connection.latency());
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/PurpurCommand.java b/org/purpurmc/purpur/command/PurpurCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..7163c8247c5f564c723409e4dc645ebee0a7d4d1
--- /dev/null
+++ b/org/purpurmc/purpur/command/PurpurCommand.java
@@ -0,0 +1,66 @@
+package org.purpurmc.purpur.command;
+
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.level.ServerLevel;
+import org.purpurmc.purpur.PurpurConfig;
+import org.bukkit.ChatColor;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+public class PurpurCommand extends Command {
+    public PurpurCommand(String name) {
+        super(name);
+        this.description = "Purpur related commands";
+        this.usageMessage = "/purpur [reload | version]";
+        this.setPermission("bukkit.command.purpur");
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+                    .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+                    .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+
+        if (args.length != 1) {
+            sender.sendMessage(ChatColor.RED + "Usage: " + usageMessage);
+            return false;
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "Please note that this command is not supported and may cause issues.");
+            Command.broadcastCommandMessage(sender, ChatColor.RED + "If you encounter any issues please use the /stop command to restart your server.");
+
+            MinecraftServer console = MinecraftServer.getServer();
+            PurpurConfig.init((File) console.options.valueOf("purpur-settings"));
+            for (ServerLevel level : console.getAllLevels()) {
+                level.purpurConfig.init();
+                level.resetBreedingCooldowns(); // Purpur - Add adjustable breeding cooldown to config
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, ChatColor.GREEN + "Purpur config reload complete.");
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command verCmd = org.bukkit.Bukkit.getServer().getCommandMap().getCommand("version");
+            if (verCmd != null) {
+                return verCmd.execute(sender, commandLabel, new String[0]);
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/org/purpurmc/purpur/command/RamBarCommand.java b/org/purpurmc/purpur/command/RamBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..2852c07adb080c34905f5d1b19efed8ea47eecc6
--- /dev/null
+++ b/org/purpurmc/purpur/command/RamBarCommand.java
@@ -0,0 +1,44 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.RamBarTask;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class RamBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("rambar")
+                .requires(listener -> listener.hasPermission(2, "bukkit.command.rambar"))
+                .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(2, "bukkit.command.rambar.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            boolean result = RamBarTask.instance().togglePlayer(player.getBukkitEntity());
+            player.ramBar(result);
+
+            Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.rambarCommandOutput,
+                    Placeholder.component("onoff", Component.translatable(result ? "options.on" : "options.off")
+                            .color(result ? NamedTextColor.GREEN : NamedTextColor.RED)),
+                    Placeholder.parsed("target", player.getGameProfile().getName()));
+
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/RamCommand.java b/org/purpurmc/purpur/command/RamCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..992f8dfc628c7485e335191e1308cdfd4eedfbe8
--- /dev/null
+++ b/org/purpurmc/purpur/command/RamCommand.java
@@ -0,0 +1,30 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.RamBarTask;
+
+public class RamCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("ram")
+                .requires(listener -> listener.hasPermission(2, "bukkit.command.ram"))
+                .executes(context -> {
+                    CommandSourceStack sender = context.getSource();
+                    RamBarTask ramBar = RamBarTask.instance();
+                    sender.sendSuccess(() -> PaperAdventure.asVanilla(MiniMessage.miniMessage().deserialize(PurpurConfig.ramCommandOutput,
+                            Placeholder.component("allocated", ramBar.format(ramBar.getAllocated())),
+                            Placeholder.component("used", ramBar.format(ramBar.getUsed())),
+                            Placeholder.component("xmx", ramBar.format(ramBar.getXmx())),
+                            Placeholder.component("xms", ramBar.format(ramBar.getXms())),
+                            Placeholder.unparsed("percent", ((int) (ramBar.getPercent() * 100)) + "%")
+                    )), false);
+                    return 1;
+                })
+        );
+    }
+}
diff --git a/org/purpurmc/purpur/command/TPSBarCommand.java b/org/purpurmc/purpur/command/TPSBarCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..d8f9b044107ff7c29a83eb5378aa9f5465ba1995
--- /dev/null
+++ b/org/purpurmc/purpur/command/TPSBarCommand.java
@@ -0,0 +1,44 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.commands.arguments.EntityArgument;
+import net.minecraft.server.level.ServerPlayer;
+import org.purpurmc.purpur.PurpurConfig;
+import org.purpurmc.purpur.task.TPSBarTask;
+
+import java.util.Collection;
+import java.util.Collections;
+
+public class TPSBarCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("tpsbar")
+                .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar"))
+                .executes(context -> execute(context.getSource(), Collections.singleton(context.getSource().getPlayerOrException())))
+                .then(Commands.argument("targets", EntityArgument.players())
+                        .requires(listener -> listener.hasPermission(2, "bukkit.command.tpsbar.other"))
+                        .executes((context) -> execute(context.getSource(), EntityArgument.getPlayers(context, "targets")))
+                )
+        );
+    }
+
+    private static int execute(CommandSourceStack sender, Collection<ServerPlayer> targets) {
+        for (ServerPlayer player : targets) {
+            boolean result = TPSBarTask.instance().togglePlayer(player.getBukkitEntity());
+            player.tpsBar(result);
+
+            Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.tpsbarCommandOutput,
+                    Placeholder.component("onoff", Component.translatable(result ? "options.on" : "options.off")
+                            .color(result ? NamedTextColor.GREEN : NamedTextColor.RED)),
+                            Placeholder.parsed("target", player.getGameProfile().getName()));
+
+            sender.sendSuccess(output, false);
+        }
+        return targets.size();
+    }
+}
diff --git a/org/purpurmc/purpur/command/UptimeCommand.java b/org/purpurmc/purpur/command/UptimeCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..4bb475099bcf8f05d5f1474e7fbf29c57c2c40cd
--- /dev/null
+++ b/org/purpurmc/purpur/command/UptimeCommand.java
@@ -0,0 +1,55 @@
+package org.purpurmc.purpur.command;
+
+import com.mojang.brigadier.CommandDispatcher;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import net.minecraft.commands.CommandSourceStack;
+import net.minecraft.commands.Commands;
+import net.minecraft.server.MinecraftServer;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.util.concurrent.TimeUnit;
+import java.util.function.Function;
+
+public class UptimeCommand {
+    public static void register(CommandDispatcher<CommandSourceStack> dispatcher) {
+        dispatcher.register(Commands.literal("uptime")
+                .requires((listener) -> listener.hasPermission(2, "bukkit.command.uptime"))
+                .executes((context) -> execute(context.getSource()))
+        );
+    }
+
+    private static int execute(CommandSourceStack sender) {
+        Data data = new Data();
+
+        data.format = PurpurConfig.uptimeFormat;
+        data.hide = true;
+        data.millis = System.currentTimeMillis() - MinecraftServer.startTimeMillis;
+
+        process(data, "<days>", PurpurConfig.uptimeDay, PurpurConfig.uptimeDays, TimeUnit.DAYS, TimeUnit.MILLISECONDS::toDays);
+        process(data, "<hours>", PurpurConfig.uptimeHour, PurpurConfig.uptimeHours, TimeUnit.HOURS, TimeUnit.MILLISECONDS::toHours);
+        process(data, "<minutes>", PurpurConfig.uptimeMinute, PurpurConfig.uptimeMinutes, TimeUnit.MINUTES, TimeUnit.MILLISECONDS::toMinutes);
+        data.hide = false; // never hide seconds
+        process(data, "<seconds>", PurpurConfig.uptimeSecond, PurpurConfig.uptimeSeconds, TimeUnit.SECONDS, TimeUnit.MILLISECONDS::toSeconds);
+
+        Component output = MiniMessage.miniMessage().deserialize(PurpurConfig.uptimeCommandOutput, Placeholder.unparsed("uptime", data.format));
+        sender.sendSuccess(output, false);
+        return 1;
+    }
+
+    private static void process(Data data, String replace, String singular, String plural, TimeUnit unit, Function<Long, Long> func) {
+        if (data.format.contains(replace)) {
+            long val = func.apply(data.millis);
+            if (data.hide) data.hide = val == 0;
+            if (!data.hide) data.millis -= unit.toMillis(val);
+            data.format = data.format.replace(replace, data.hide ? "" : String.format(val == 1 ? singular : plural, val));
+        }
+    }
+
+    private static class Data {
+        String format;
+        boolean hide;
+        long millis;
+    }
+}
diff --git a/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java b/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..940bcc6f79b59cb3cce578912eb789efd394f456
--- /dev/null
+++ b/org/purpurmc/purpur/controller/FlyingMoveControllerWASD.java
@@ -0,0 +1,74 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+
+public class FlyingMoveControllerWASD extends MoveControllerWASD {
+    protected final float groundSpeedModifier;
+    protected final float flyingSpeedModifier;
+    protected int tooHighCooldown = 0;
+    protected boolean setNoGravityFlag;
+
+    public FlyingMoveControllerWASD(Mob entity) {
+        this(entity, 1.0F);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier) {
+        this(entity, groundSpeedModifier, 1.0F, true);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier, float flyingSpeedModifier) {
+        this(entity, groundSpeedModifier, flyingSpeedModifier, true);
+    }
+
+    public FlyingMoveControllerWASD(Mob entity, float groundSpeedModifier, float flyingSpeedModifier, boolean setNoGravityFlag) {
+        super(entity);
+        this.groundSpeedModifier = groundSpeedModifier;
+        this.flyingSpeedModifier = flyingSpeedModifier;
+        this.setNoGravityFlag = setNoGravityFlag;
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : 0.0F;
+        float vertical = forward == 0.0F ? 0.0F : -(rider.xRotO / 45.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F);
+
+        if (lastClientInput.jump() && spacebarEvent(entity)) {
+            entity.onSpacebar();
+        }
+
+        if (entity.getY() >= entity.getMaxY() || --tooHighCooldown > 0) {
+            if (tooHighCooldown <= 0) {
+                tooHighCooldown = 20;
+            }
+            entity.setDeltaMovement(entity.getDeltaMovement().add(0.0D, -0.05D, 0.0D));
+            vertical = 0.0F;
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED));
+        float speed = (float) getSpeedModifier();
+
+        if (entity.onGround) {
+            speed *= groundSpeedModifier; // TODO = fix this!
+        } else {
+            speed *= flyingSpeedModifier;
+        }
+
+        if (setNoGravityFlag) {
+            entity.setNoGravity(forward > 0);
+        }
+
+        entity.setSpeed(speed);
+        entity.setVerticalMot(vertical);
+        entity.setStrafeMot(strafe);
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+}
diff --git a/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java b/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..e0bbaec05afa0ae67ed486b14ea1fbadbbe90d9b
--- /dev/null
+++ b/org/purpurmc/purpur/controller/FlyingWithSpacebarMoveControllerWASD.java
@@ -0,0 +1,66 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.phys.Vec3;
+
+public class FlyingWithSpacebarMoveControllerWASD extends FlyingMoveControllerWASD {
+    public FlyingWithSpacebarMoveControllerWASD(Mob entity) {
+        super(entity);
+    }
+
+    public FlyingWithSpacebarMoveControllerWASD(Mob entity, float groundSpeedModifier) {
+        super(entity, groundSpeedModifier);
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.5F;
+        float vertical = 0;
+
+        if (forward < 0.0F) {
+            forward *= 0.5F;
+            strafe *= 0.5F;
+        }
+
+        float speed = (float) entity.getAttributeValue(Attributes.MOVEMENT_SPEED);
+
+        if (entity.onGround) {
+            speed *= groundSpeedModifier;
+        }
+
+        if (lastClientInput.jump() && spacebarEvent(entity) && !entity.onSpacebar()) {
+            entity.setNoGravity(true);
+            vertical = 1.0F;
+        } else {
+            entity.setNoGravity(false);
+        }
+
+        if (entity.getY() >= entity.getMaxY() || --tooHighCooldown > 0) {
+            if (tooHighCooldown <= 0) {
+                tooHighCooldown = 20;
+            }
+            entity.setDeltaMovement(entity.getDeltaMovement().add(0.0D, -0.2D, 0.0D));
+            vertical = 0.0F;
+        }
+
+        setSpeedModifier(speed);
+        entity.setSpeed((float) getSpeedModifier());
+        entity.setVerticalMot(vertical);
+        entity.setStrafeMot(strafe);
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+
+        Vec3 mot = entity.getDeltaMovement();
+        if (mot.y > 0.2D) {
+            entity.setDeltaMovement(mot.x, 0.2D, mot.z);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/controller/LookControllerWASD.java b/org/purpurmc/purpur/controller/LookControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd219518150ca90f89ad238904fd4095efe032d8
--- /dev/null
+++ b/org/purpurmc/purpur/controller/LookControllerWASD.java
@@ -0,0 +1,79 @@
+package org.purpurmc.purpur.controller;
+
+
+import net.minecraft.network.protocol.game.ClientboundMoveEntityPacket;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.control.LookControl;
+import net.minecraft.world.entity.player.Player;
+
+public class LookControllerWASD extends LookControl {
+    protected final Mob entity;
+    private float yOffset = 0;
+    private float xOffset = 0;
+
+    public LookControllerWASD(Mob entity) {
+        super(entity);
+        this.entity = entity;
+    }
+
+    // tick
+    @Override
+    public void tick() {
+        if (entity.getRider() != null && entity.isControllable()) {
+            purpurTick(entity.getRider());
+        } else {
+            vanillaTick();
+        }
+    }
+
+    protected void purpurTick(Player rider) {
+        setYawPitch(rider.getYRot(), rider.getXRot());
+    }
+
+    public void vanillaTick() {
+        super.tick();
+    }
+
+    public void setYawPitch(float yRot, float xRot) {
+        entity.setXRot(normalizePitch(xRot + xOffset));
+        entity.setYRot(normalizeYaw(yRot + yOffset));
+        entity.setYHeadRot(entity.getYRot());
+        entity.xRotO = entity.getXRot();
+        entity.yRotO = entity.getYRot();
+
+        ClientboundMoveEntityPacket.PosRot entityPacket = new ClientboundMoveEntityPacket.PosRot(
+            entity.getId(),
+            (short) 0, (short) 0, (short) 0,
+            (byte) Mth.floor(entity.getYRot() * 256.0F / 360.0F),
+            (byte) Mth.floor(entity.getXRot() * 256.0F / 360.0F),
+            entity.onGround
+        );
+        ((ServerLevel) entity.level()).getChunkSource().broadcast(entity, entityPacket);
+    }
+
+    public void setOffsets(float yaw, float pitch) {
+        yOffset = yaw;
+        xOffset = pitch;
+    }
+
+    public float normalizeYaw(float yaw) {
+        yaw %= 360.0f;
+        if (yaw >= 180.0f) {
+            yaw -= 360.0f;
+        } else if (yaw < -180.0f) {
+            yaw += 360.0f;
+        }
+        return yaw;
+    }
+
+    public float normalizePitch(float pitch) {
+        if (pitch > 90.0f) {
+            pitch = 90.0f;
+        } else if (pitch < -90.0f) {
+            pitch = -90.0f;
+        }
+        return pitch;
+    }
+}
diff --git a/org/purpurmc/purpur/controller/MoveControllerWASD.java b/org/purpurmc/purpur/controller/MoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..34f3c43fa16e950326ac5e3d93faee0466ffedc6
--- /dev/null
+++ b/org/purpurmc/purpur/controller/MoveControllerWASD.java
@@ -0,0 +1,92 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.ai.control.MoveControl;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+import org.purpurmc.purpur.event.entity.RidableSpacebarEvent;
+
+public class MoveControllerWASD extends MoveControl {
+    protected final Mob entity;
+    private final double speedModifier;
+
+    public MoveControllerWASD(Mob entity) {
+        this(entity, 1.0D);
+    }
+
+    public MoveControllerWASD(Mob entity, double speedModifier) {
+        super(entity);
+        this.entity = entity;
+        this.speedModifier = speedModifier;
+    }
+
+    @Override
+    public boolean hasWanted() {
+        return entity.getRider() != null ? strafeForwards != 0 || strafeRight != 0 : super.hasWanted();
+    }
+
+    @Override
+    public void tick() {
+        if (entity.getRider() != null && entity.isControllable()) {
+            purpurTick(entity.getRider());
+        } else {
+            vanillaTick();
+        }
+    }
+
+    public void vanillaTick() {
+        super.tick();
+    }
+
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F) * 0.5F;
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.25F;
+
+        if (forward <= 0.0F) {
+            forward *= 0.5F;
+        }
+
+        float yawOffset = 0;
+        if (strafe != 0) {
+            if (forward == 0) {
+                yawOffset += strafe > 0 ? -90 : 90;
+                forward = Math.abs(strafe * 2);
+            } else {
+                yawOffset += strafe > 0 ? -30 : 30;
+                strafe /= 2;
+                if (forward < 0) {
+                    yawOffset += strafe > 0 ? -110 : 110;
+                    forward *= -1;
+                }
+            }
+        } else if (forward < 0) {
+            yawOffset -= 180;
+            forward *= -1;
+        }
+
+        ((LookControllerWASD) entity.getLookControl()).setOffsets(yawOffset, 0);
+
+        if (lastClientInput.jump() && spacebarEvent(entity) && !entity.onSpacebar() && entity.onGround) {
+            entity.jumpFromGround();
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED) * speedModifier);
+
+        entity.setSpeed((float) getSpeedModifier());
+        entity.setForwardMot(forward);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+
+    public static boolean spacebarEvent(Mob entity) {
+        if (RidableSpacebarEvent.getHandlerList().getRegisteredListeners().length > 0) {
+            return new RidableSpacebarEvent(entity.getBukkitEntity()).callEvent();
+        } else {
+            return true;
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java b/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java
new file mode 100644
index 0000000000000000000000000000000000000000..922e48799c43ca322a8f550c98a26e1e2959439c
--- /dev/null
+++ b/org/purpurmc/purpur/controller/WaterMoveControllerWASD.java
@@ -0,0 +1,53 @@
+package org.purpurmc.purpur.controller;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.attributes.Attributes;
+import net.minecraft.world.entity.player.Input;
+import net.minecraft.world.entity.player.Player;
+
+public class WaterMoveControllerWASD extends MoveControllerWASD {
+    private final double speedModifier;
+
+    public WaterMoveControllerWASD(Mob entity) {
+        this(entity, 1.0D);
+    }
+
+    public WaterMoveControllerWASD(Mob entity, double speedModifier) {
+        super(entity);
+        this.speedModifier = speedModifier;
+    }
+
+    @Override
+    public void purpurTick(Player rider) {
+        Input lastClientInput = ((ServerPlayer) rider).getLastClientInput();
+        float forward = (lastClientInput.forward() == lastClientInput.backward() ? 0.0F : lastClientInput.forward() ? 1.0F : -1.0F);
+        float strafe = (lastClientInput.left() == lastClientInput.right() ? 0.0F : lastClientInput.left() ? 1.0F : -1.0F) * 0.5F; // strafe slower by default
+        float vertical = -(rider.xRotO / 90);
+
+        if (forward == 0.0F) {
+            // strafe slower if not moving forward
+            strafe *= 0.5F;
+            // do not move vertically if not moving forward
+            vertical = 0.0F;
+        } else if (forward < 0.0F) {
+            // water animals can't swim backwards
+            forward = 0.0F;
+            vertical = 0.0F;
+        }
+
+        if (rider.jumping && spacebarEvent(entity)) {
+            entity.onSpacebar();
+        }
+
+        setSpeedModifier(entity.getAttributeValue(Attributes.MOVEMENT_SPEED) * speedModifier);
+        entity.setSpeed((float) getSpeedModifier() * 0.1F);
+
+        entity.setForwardMot(forward * (float) speedModifier);
+        entity.setStrafeMot(strafe * (float) speedModifier);
+        entity.setVerticalMot(vertical * (float) speedModifier);
+
+        setForward(entity.getForwardMot());
+        setStrafe(entity.getStrafeMot());
+    }
+}
diff --git a/org/purpurmc/purpur/entity/PurpurStoredBee.java b/org/purpurmc/purpur/entity/PurpurStoredBee.java
new file mode 100644
index 0000000000000000000000000000000000000000..683a98b424f170b4f819422550f3f7865abd39cf
--- /dev/null
+++ b/org/purpurmc/purpur/entity/PurpurStoredBee.java
@@ -0,0 +1,116 @@
+package org.purpurmc.purpur.entity;
+
+import com.mojang.logging.LogUtils;
+import io.papermc.paper.adventure.PaperAdventure;
+import net.kyori.adventure.text.Component;
+import net.minecraft.core.RegistryAccess;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.util.ProblemReporter;
+import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.storage.TagValueInput;
+import net.minecraft.world.level.storage.ValueInput;
+import org.bukkit.block.EntityBlockStorage;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.craftbukkit.util.CraftChatMessage;
+import org.bukkit.entity.Bee;
+import org.bukkit.entity.EntityType;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.slf4j.Logger;
+import java.util.Locale;
+
+public class PurpurStoredBee implements StoredEntity<Bee> {
+    static final Logger LOGGER = LogUtils.getLogger();
+
+    private static final CraftPersistentDataTypeRegistry DATA_TYPE_REGISTRY = new CraftPersistentDataTypeRegistry();
+
+    private final EntityBlockStorage<Bee> blockStorage;
+    private final BeehiveBlockEntity.BeeData handle;
+    private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(PurpurStoredBee.DATA_TYPE_REGISTRY);
+
+    private Component customName;
+
+    public PurpurStoredBee(BeehiveBlockEntity.BeeData data, EntityBlockStorage<Bee> blockStorage, final BeehiveBlockEntity blockEntity) {
+        this.handle = data;
+        this.blockStorage = blockStorage;
+
+        CompoundTag customData = handle.occupant.entityData().copyTag();
+
+        try (ProblemReporter.ScopedCollector scopedCollector = new ProblemReporter.ScopedCollector(blockEntity.problemPath(), LOGGER)) {
+            ValueInput valueInput = TagValueInput.create(scopedCollector, RegistryAccess.EMPTY, customData);
+
+            net.minecraft.network.chat.Component customNameMinecraft = BlockEntity.parseCustomNameSafe(valueInput, "CustomName");
+            this.customName = customNameMinecraft == null ? null : PaperAdventure.asAdventure(customNameMinecraft);
+
+            if (customData.get("BukkitValues") instanceof CompoundTag compoundTag) {
+                this.persistentDataContainer.putAll(compoundTag);
+            }
+        }
+    }
+
+    public BeehiveBlockEntity.BeeData getHandle() {
+        return handle;
+    }
+
+    @Override
+    public @Nullable Component customName() {
+        return customName;
+    }
+
+    @Override
+    public void customName(@Nullable Component customName) {
+        this.customName = customName;
+    }
+
+    @Override
+    public @Nullable String getCustomName() {
+        return PaperAdventure.asPlain(customName, Locale.US);
+    }
+
+    @Override
+    public void setCustomName(@Nullable String name) {
+        customName(name != null ? Component.text(name) : null);
+    }
+
+    @Override
+    public @NotNull PersistentDataContainer getPersistentDataContainer() {
+        return persistentDataContainer;
+    }
+
+    @Override
+    public boolean hasBeenReleased() {
+        return !blockStorage.getEntities().contains(this);
+    }
+
+    @Override
+    public @Nullable Bee release() {
+        return blockStorage.releaseEntity(this);
+    }
+
+    @Override
+    public @Nullable EntityBlockStorage<Bee> getBlockStorage() {
+        if(hasBeenReleased()) {
+            return null;
+        }
+
+        return blockStorage;
+    }
+
+    @Override
+    public @NotNull EntityType getType() {
+        return EntityType.BEE;
+    }
+
+    @Override
+    public void update() {
+        handle.occupant.entityData().copyTag().put("BukkitValues", this.persistentDataContainer.toTagCompound());
+        if(customName == null) {
+            handle.occupant.entityData().copyTag().remove("CustomName");
+        } else {
+            handle.occupant.entityData().copyTag().putString("CustomName", CraftChatMessage.toJSON(PaperAdventure.asVanilla(customName)));
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/HasRider.java b/org/purpurmc/purpur/entity/ai/HasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..8babdaddd8b33278aea0369dbbeeb445abe45016
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/HasRider.java
@@ -0,0 +1,20 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.Mob;
+import net.minecraft.world.entity.ai.goal.Goal;
+
+import java.util.EnumSet;
+
+public class HasRider extends Goal {
+    public final Mob entity;
+
+    public HasRider(Mob entity) {
+        this.entity = entity;
+        setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK, Flag.TARGET, Flag.UNKNOWN_BEHAVIOR));
+    }
+
+    @Override
+    public boolean canUse() {
+        return entity.getRider() != null && entity.isControllable();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/HorseHasRider.java b/org/purpurmc/purpur/entity/ai/HorseHasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..432f4f3d82af2f19820890b68d33189a9f2c69f9
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/HorseHasRider.java
@@ -0,0 +1,17 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.animal.horse.AbstractHorse;
+
+public class HorseHasRider extends HasRider {
+    public final AbstractHorse horse;
+
+    public HorseHasRider(AbstractHorse entity) {
+        super(entity);
+        this.horse = entity;
+    }
+
+    @Override
+    public boolean canUse() {
+        return super.canUse() && horse.isSaddled();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/LlamaHasRider.java b/org/purpurmc/purpur/entity/ai/LlamaHasRider.java
new file mode 100644
index 0000000000000000000000000000000000000000..18a95e043cbffa65eeaaf65ff7695e5dc939820c
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/LlamaHasRider.java
@@ -0,0 +1,17 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.world.entity.animal.horse.Llama;
+
+public class LlamaHasRider extends HasRider {
+    public final Llama llama;
+
+    public LlamaHasRider(Llama entity) {
+        super(entity);
+        this.llama = entity;
+    }
+
+    @Override
+    public boolean canUse() {
+        return super.canUse() && llama.isSaddled() && llama.isControllable();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/ai/ReceiveFlower.java b/org/purpurmc/purpur/entity/ai/ReceiveFlower.java
new file mode 100644
index 0000000000000000000000000000000000000000..9660716f4162a4441c6e1b0baddef8f5086566c5
--- /dev/null
+++ b/org/purpurmc/purpur/entity/ai/ReceiveFlower.java
@@ -0,0 +1,91 @@
+package org.purpurmc.purpur.entity.ai;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.InteractionHand;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.ai.goal.Goal;
+import net.minecraft.world.entity.animal.IronGolem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.block.Blocks;
+
+import java.util.EnumSet;
+import java.util.UUID;
+
+public class ReceiveFlower extends Goal {
+    private final IronGolem irongolem;
+    private ServerPlayer target;
+    private int cooldown;
+
+    public ReceiveFlower(IronGolem entity) {
+        this.irongolem = entity;
+        setFlags(EnumSet.of(Flag.MOVE, Flag.LOOK));
+    }
+
+    @Override
+    public boolean canUse() {
+        if (this.irongolem.getOfferFlowerTick() > 0) {
+            return false;
+        }
+        if (!this.irongolem.isAngry()) {
+            return false;
+        }
+        UUID uuid = this.irongolem.getPersistentAngerTarget();
+        if (uuid == null) {
+            return false;
+        }
+        Entity target = ((ServerLevel) this.irongolem.level()).getEntity(uuid);
+        if (!(target instanceof ServerPlayer player)) {
+            return false;
+        }
+        InteractionHand hand = getPoppyHand(player);
+        if (hand == null) {
+            return false;
+        }
+        removeFlower(player, hand);
+        this.target = player;
+        return true;
+    }
+
+    @Override
+    public boolean canContinueToUse() {
+        return this.cooldown > 0;
+    }
+
+    @Override
+    public void start() {
+        this.cooldown = 100;
+        this.irongolem.stopBeingAngry();
+        this.irongolem.offerFlower(true);
+    }
+
+    @Override
+    public void stop() {
+        this.irongolem.offerFlower(false);
+        this.target = null;
+    }
+
+    @Override
+    public void tick() {
+        this.irongolem.getLookControl().setLookAt(this.target, 30.0F, 30.0F);
+        --this.cooldown;
+    }
+
+    private InteractionHand getPoppyHand(ServerPlayer player) {
+        if (isPoppy(player.getMainHandItem())) {
+            return InteractionHand.MAIN_HAND;
+        }
+        if (isPoppy(player.getOffhandItem())) {
+            return InteractionHand.OFF_HAND;
+        }
+        return null;
+    }
+
+    private void removeFlower(ServerPlayer player, InteractionHand hand) {
+        player.setItemInHand(hand, ItemStack.EMPTY);
+    }
+
+    private boolean isPoppy(ItemStack item) {
+        return item.getItem() == Blocks.POPPY.asItem();
+    }
+}
diff --git a/org/purpurmc/purpur/entity/projectile/DolphinSpit.java b/org/purpurmc/purpur/entity/projectile/DolphinSpit.java
new file mode 100644
index 0000000000000000000000000000000000000000..e489b16983b8eea75726baf6323b41af0929bdec
--- /dev/null
+++ b/org/purpurmc/purpur/entity/projectile/DolphinSpit.java
@@ -0,0 +1,105 @@
+package org.purpurmc.purpur.entity.projectile;
+
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.animal.Dolphin;
+import net.minecraft.world.entity.projectile.LlamaSpit;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+import org.bukkit.event.entity.EntityRemoveEvent;
+
+public class DolphinSpit extends LlamaSpit {
+    public LivingEntity dolphin;
+    public int ticksLived;
+
+    public DolphinSpit(EntityType<? extends LlamaSpit> type, Level world) {
+        super(type, world);
+    }
+
+    public DolphinSpit(Level world, Dolphin dolphin) {
+        this(EntityType.LLAMA_SPIT, world);
+        this.setOwner(dolphin.getRider() != null ? dolphin.getRider() : dolphin);
+        this.dolphin = dolphin;
+        this.setPos(
+                dolphin.getX() - (double) (dolphin.getBbWidth() + 1.0F) * 0.5 * (double) Mth.sin(dolphin.yBodyRot * (float) (Math.PI / 180.0)),
+                dolphin.getEyeY() - 0.1F,
+                dolphin.getZ() + (double) (dolphin.getBbWidth() + 1.0F) * 0.5 * (double) Mth.cos(dolphin.yBodyRot * (float) (Math.PI / 180.0)));
+    }
+
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+
+    public void tick() {
+        projectileTick();
+
+        Vec3 mot = this.getDeltaMovement();
+        HitResult hitResult = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity);
+
+        this.preHitTargetOrDeflectSelf(hitResult);
+
+        double x = this.getX() + mot.x;
+        double y = this.getY() + mot.y;
+        double z = this.getZ() + mot.z;
+
+        this.updateRotation();
+
+        Vec3 motDouble = mot.scale(2.0);
+        for (int i = 0; i < 5; i++) {
+            ((ServerLevel) level()).sendParticlesSource(null, ParticleTypes.BUBBLE,
+                    true, false,
+                    getX() + random.nextFloat() / 2 - 0.25F,
+                    getY() + random.nextFloat() / 2 - 0.25F,
+                    getZ() + random.nextFloat() / 2 - 0.25F,
+                    0, motDouble.x(), motDouble.y(), motDouble.z(), 0.1D);
+        }
+
+        if (++ticksLived > 20) {
+            this.discard(EntityRemoveEvent.Cause.DISCARD);
+        } else {
+            this.setDeltaMovement(mot.scale(0.99D));
+            if (!this.isNoGravity()) {
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.06D, 0.0D));
+            }
+
+            this.setPos(x, y, z);
+        }
+    }
+
+    @Override
+    public void shoot(double x, double y, double z, float speed, float inaccuracy) {
+        setDeltaMovement(new Vec3(x, y, z).normalize().add(
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy)
+                .scale(speed));
+    }
+
+    @Override
+    protected void onHitEntity(EntityHitResult entityHitResult) {
+        Entity shooter = this.getOwner();
+        if (shooter instanceof LivingEntity) {
+            entityHitResult.getEntity().hurt(entityHitResult.getEntity().damageSources().mobProjectile(this, (LivingEntity) shooter), level().purpurConfig.dolphinSpitDamage);
+        }
+    }
+
+    @Override
+    protected void onHitBlock(BlockHitResult blockHitResult) {
+        if (this.hitCancelled) {
+            return;
+        }
+        BlockState state = this.level().getBlockState(blockHitResult.getBlockPos());
+        state.onProjectileHit(this.level(), state, blockHitResult, this);
+        this.discard(EntityRemoveEvent.Cause.DISCARD);
+    }
+}
diff --git a/org/purpurmc/purpur/entity/projectile/PhantomFlames.java b/org/purpurmc/purpur/entity/projectile/PhantomFlames.java
new file mode 100644
index 0000000000000000000000000000000000000000..b3fe215e163373641a11c0ab2f5fd5e666434055
--- /dev/null
+++ b/org/purpurmc/purpur/entity/projectile/PhantomFlames.java
@@ -0,0 +1,127 @@
+package org.purpurmc.purpur.entity.projectile;
+
+import net.minecraft.core.particles.ParticleTypes;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.util.Mth;
+import net.minecraft.world.entity.Entity;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.entity.decoration.ArmorStand;
+import net.minecraft.world.entity.monster.Phantom;
+import net.minecraft.world.entity.projectile.LlamaSpit;
+import net.minecraft.world.entity.projectile.ProjectileUtil;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.state.BlockBehaviour;
+import net.minecraft.world.level.block.state.BlockState;
+import net.minecraft.world.phys.BlockHitResult;
+import net.minecraft.world.phys.EntityHitResult;
+import net.minecraft.world.phys.HitResult;
+import net.minecraft.world.phys.Vec3;
+
+public class PhantomFlames extends LlamaSpit {
+    public Phantom phantom;
+    public int ticksLived;
+    public boolean canGrief = false;
+
+    public PhantomFlames(EntityType<? extends LlamaSpit> type, Level world) {
+        super(type, world);
+    }
+
+    public PhantomFlames(Level world, Phantom phantom) {
+        this(EntityType.LLAMA_SPIT, world);
+        setOwner(phantom.getRider() != null ? phantom.getRider() : phantom);
+        this.phantom = phantom;
+        this.setPos(
+                phantom.getX() - (double) (phantom.getBbWidth() + 1.0F) * 0.5D * (double) Mth.sin(phantom.yBodyRot * (float) (Math.PI / 180.0)),
+                phantom.getEyeY() - 0.10000000149011612D,
+                phantom.getZ() + (double) (phantom.getBbWidth() + 1.0F) * 0.5D * (double) Mth.cos(phantom.yBodyRot * (float) (Math.PI / 180.0)));
+    }
+
+    @Override
+    public boolean canSaveToDisk() {
+        return false;
+    }
+
+    public void tick() {
+        projectileTick();
+
+        Vec3 mot = this.getDeltaMovement();
+        HitResult hitResult = ProjectileUtil.getHitResultOnMoveVector(this, this::canHitEntity);
+
+        this.preHitTargetOrDeflectSelf(hitResult);
+
+        double x = this.getX() + mot.x;
+        double y = this.getY() + mot.y;
+        double z = this.getZ() + mot.z;
+
+        this.updateRotation();
+
+        Vec3 motDouble = mot.scale(2.0);
+        for (int i = 0; i < 5; i++) {
+            ((ServerLevel) level()).sendParticlesSource(null, ParticleTypes.FLAME,
+                    true, false,
+                    getX() + random.nextFloat() / 2 - 0.25F,
+                    getY() + random.nextFloat() / 2 - 0.25F,
+                    getZ() + random.nextFloat() / 2 - 0.25F,
+                    0, motDouble.x(), motDouble.y(), motDouble.z(), 0.1D);
+        }
+
+        if (++ticksLived > 20) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else if (this.level().getBlockStates(this.getBoundingBox()).noneMatch(BlockBehaviour.BlockStateBase::isAir)) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else if (this.isInWater()) {
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        } else {
+            this.setDeltaMovement(mot.scale(0.99D));
+            if (!this.isNoGravity()) {
+                this.setDeltaMovement(this.getDeltaMovement().add(0.0D, -0.06D, 0.0D));
+            }
+
+            this.setPos(x, y, z);
+        }
+    }
+
+    @Override
+    public void shoot(double x, double y, double z, float speed, float inaccuracy) {
+        setDeltaMovement(new Vec3(x, y, z).normalize().add(
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy,
+                random.nextGaussian() * (double) 0.0075F * (double) inaccuracy)
+                .scale(speed));
+    }
+
+    @Override
+    protected void onHitEntity(EntityHitResult entityHitResult) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel worldserver) {
+            Entity shooter = this.getOwner();
+            if (shooter instanceof LivingEntity) {
+                Entity target = entityHitResult.getEntity();
+                if (canGrief || (target instanceof LivingEntity && !(target instanceof ArmorStand))) {
+                    boolean hurt = target.hurtServer(worldserver, target.damageSources().mobProjectile(this, (LivingEntity) shooter), worldserver.purpurConfig.phantomFlameDamage);
+                    if (hurt && worldserver.purpurConfig.phantomFlameFireTime > 0) {
+                        target.igniteForSeconds(worldserver.purpurConfig.phantomFlameFireTime);
+                    }
+                }
+            }
+        }
+    }
+
+    @Override
+    protected void onHitBlock(BlockHitResult blockHitResult) {
+        Level world = this.level();
+
+        if (world instanceof ServerLevel worldserver) {
+            if (this.hitCancelled) {
+                return;
+            }
+            if (this.canGrief) {
+                BlockState state = worldserver.getBlockState(blockHitResult.getBlockPos());
+                state.onProjectileHit(worldserver, state, blockHitResult, this);
+            }
+            this.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/gui/GUIColor.java b/org/purpurmc/purpur/gui/GUIColor.java
new file mode 100644
index 0000000000000000000000000000000000000000..550222758bf0e7deff26a6e813a860b7be365e87
--- /dev/null
+++ b/org/purpurmc/purpur/gui/GUIColor.java
@@ -0,0 +1,58 @@
+package org.purpurmc.purpur.gui;
+
+import net.md_5.bungee.api.ChatColor;
+
+import java.awt.Color;
+import java.util.HashMap;
+import java.util.Map;
+
+public enum GUIColor {
+    BLACK(ChatColor.BLACK, new Color(0x000000)),
+    DARK_BLUE(ChatColor.DARK_BLUE, new Color(0x0000AA)),
+    DARK_GREEN(ChatColor.DARK_GREEN, new Color(0x00AA00)),
+    DARK_AQUA(ChatColor.DARK_AQUA, new Color(0x009999)),
+    DARK_RED(ChatColor.DARK_RED, new Color(0xAA0000)),
+    DARK_PURPLE(ChatColor.DARK_PURPLE, new Color(0xAA00AA)),
+    GOLD(ChatColor.GOLD, new Color(0xBB8800)),
+    GRAY(ChatColor.GRAY, new Color(0x888888)),
+    DARK_GRAY(ChatColor.DARK_GRAY, new Color(0x444444)),
+    BLUE(ChatColor.BLUE, new Color(0x5555FF)),
+    GREEN(ChatColor.GREEN, new Color(0x55FF55)),
+    AQUA(ChatColor.AQUA, new Color(0x55DDDD)),
+    RED(ChatColor.RED, new Color(0xFF5555)),
+    LIGHT_PURPLE(ChatColor.LIGHT_PURPLE, new Color(0xFF55FF)),
+    YELLOW(ChatColor.YELLOW, new Color(0xFFBB00)),
+    WHITE(ChatColor.WHITE, new Color(0xBBBBBB));
+
+    private final ChatColor chat;
+    private final Color color;
+
+    private static final Map<ChatColor, GUIColor> BY_CHAT = new HashMap<>();
+
+    GUIColor(ChatColor chat, Color color) {
+        this.chat = chat;
+        this.color = color;
+    }
+
+    public Color getColor() {
+        return color;
+    }
+
+    public ChatColor getChatColor() {
+        return chat;
+    }
+
+    public String getCode() {
+        return chat.toString();
+    }
+
+    public static GUIColor getColor(ChatColor chat) {
+        return BY_CHAT.get(chat);
+    }
+
+    static {
+        for (GUIColor color : values()) {
+            BY_CHAT.put(color.chat, color);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/gui/JColorTextPane.java b/org/purpurmc/purpur/gui/JColorTextPane.java
new file mode 100644
index 0000000000000000000000000000000000000000..d75fb5e77eff27d86135ed7d605dbc250b660f7d
--- /dev/null
+++ b/org/purpurmc/purpur/gui/JColorTextPane.java
@@ -0,0 +1,83 @@
+package org.purpurmc.purpur.gui;
+
+import com.google.common.collect.Sets;
+import javax.swing.UIManager;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+
+import javax.swing.JTextPane;
+import javax.swing.Timer;
+import javax.swing.text.AttributeSet;
+import javax.swing.text.BadLocationException;
+import javax.swing.text.SimpleAttributeSet;
+import javax.swing.text.StyleConstants;
+import javax.swing.text.StyleContext;
+import java.util.Set;
+
+public class JColorTextPane extends JTextPane {
+    private static final GUIColor DEFAULT_COLOR;
+    static {
+        DEFAULT_COLOR = UIManager.getSystemLookAndFeelClassName().equals("com.sun.java.swing.plaf.gtk.GTKLookAndFeel")
+            ? GUIColor.WHITE : GUIColor.BLACK;
+    }
+
+
+    public void append(String msg) {
+        // TODO: update to use adventure instead
+        BaseComponent[] components = TextComponent.fromLegacyText(DEFAULT_COLOR.getCode() + msg, DEFAULT_COLOR.getChatColor());
+        for (BaseComponent component : components) {
+            String text = component.toPlainText();
+            if (text == null || text.isEmpty()) {
+                continue;
+            }
+
+            GUIColor guiColor = GUIColor.getColor(component.getColor());
+
+            StyleContext context = StyleContext.getDefaultStyleContext();
+            AttributeSet attr = context.addAttribute(SimpleAttributeSet.EMPTY, StyleConstants.Foreground, guiColor.getColor());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Bold, component.isBold() || guiColor != DEFAULT_COLOR);
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Italic, component.isItalic());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Underline, component.isUnderlined());
+            attr = context.addAttribute(attr, StyleConstants.CharacterConstants.StrikeThrough, component.isStrikethrough());
+            //attr = context.addAttribute(attr, StyleConstants.CharacterConstants.Blink, component.isObfuscated()); // no such thing as Blink, sadly
+
+            try {
+                int pos = getDocument().getLength();
+                getDocument().insertString(pos, text, attr);
+
+                if (component.isObfuscated()) {
+                    // dirty hack to blink some text
+                    Blink blink = new Blink(pos, text.length(), attr, context.addAttribute(attr, StyleConstants.Foreground, getBackground()));
+                    BLINKS.add(blink);
+                }
+            } catch (BadLocationException ignore) {
+            }
+        }
+    }
+
+    private static final Set<Blink> BLINKS = Sets.newHashSet();
+    private static boolean SYNC_BLINK;
+
+    static {
+        new Timer(500, e -> {
+            SYNC_BLINK = !SYNC_BLINK;
+            BLINKS.forEach(Blink::blink);
+        }).start();
+    }
+
+    public class Blink {
+        private final int start, length;
+        private final AttributeSet attr1, attr2;
+
+        private Blink(int start, int length, AttributeSet attr1, AttributeSet attr2) {
+            this.start = start;
+            this.length = length;
+            this.attr1 = attr1;
+            this.attr2 = attr2;
+        }
+
+        private void blink() {
+            getStyledDocument().setCharacterAttributes(start, length, SYNC_BLINK ? attr1 : attr2, true);
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/item/GlowBerryItem.java b/org/purpurmc/purpur/item/GlowBerryItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..b257f35caa13b660854cf17f41fd8fba1d56c458
--- /dev/null
+++ b/org/purpurmc/purpur/item/GlowBerryItem.java
@@ -0,0 +1,26 @@
+package org.purpurmc.purpur.item;
+
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.effect.MobEffectInstance;
+import net.minecraft.world.effect.MobEffects;
+import net.minecraft.world.entity.LivingEntity;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import org.bukkit.event.entity.EntityPotionEffectEvent;
+
+public class GlowBerryItem extends BlockItem {
+    public GlowBerryItem(Block block, Properties settings) {
+        super(block, settings);
+    }
+
+    @Override
+    public ItemStack finishUsingItem(ItemStack stack, Level world, LivingEntity user) {
+        ItemStack result = super.finishUsingItem(stack, world, user);
+        if (world.purpurConfig.glowBerriesEatGlowDuration > 0 && user instanceof ServerPlayer player) {
+            player.addEffect(new MobEffectInstance(MobEffects.GLOWING, world.purpurConfig.glowBerriesEatGlowDuration), EntityPotionEffectEvent.Cause.FOOD);
+        }
+        return result;
+    }
+}
diff --git a/org/purpurmc/purpur/item/SpawnerItem.java b/org/purpurmc/purpur/item/SpawnerItem.java
new file mode 100644
index 0000000000000000000000000000000000000000..cfa02aa027a049af982a05a69ce7f682580e6153
--- /dev/null
+++ b/org/purpurmc/purpur/item/SpawnerItem.java
@@ -0,0 +1,43 @@
+package org.purpurmc.purpur.item;
+
+import java.util.Optional;
+import net.minecraft.core.BlockPos;
+import net.minecraft.core.component.DataComponents;
+import net.minecraft.nbt.CompoundTag;
+import net.minecraft.world.entity.EntityType;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.item.BlockItem;
+import net.minecraft.world.item.ItemStack;
+import net.minecraft.world.item.component.CustomData;
+import net.minecraft.world.level.Level;
+import net.minecraft.world.level.block.Block;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import net.minecraft.world.level.block.entity.SpawnerBlockEntity;
+import net.minecraft.world.level.block.state.BlockState;
+
+public class SpawnerItem extends BlockItem {
+
+    public SpawnerItem(Block block, Properties settings) {
+        super(block, settings);
+    }
+
+    @Override
+    protected boolean updateCustomBlockEntityTag(BlockPos pos, Level level, Player player, ItemStack stack, BlockState state) {
+        boolean handled = super.updateCustomBlockEntityTag(pos, level, player, stack, state);
+        if (level.purpurConfig.silkTouchEnabled && player.getBukkitEntity().hasPermission("purpur.place.spawners")) {
+            BlockEntity blockEntity = level.getBlockEntity(pos);
+            if (blockEntity instanceof SpawnerBlockEntity spawner) {
+                CompoundTag customData = stack.getOrDefault(DataComponents.CUSTOM_DATA, CustomData.EMPTY).copyTag();
+                Optional<String> mobTypeStringOptional = customData.getString("Purpur.mob_type");
+                if (mobTypeStringOptional.isPresent()) {
+                    EntityType.byString(mobTypeStringOptional.get()).ifPresent(type -> spawner.getSpawner().setEntityId(type, level, level.random, pos));
+                } else if (customData.contains("Purpur.SpawnData")) {
+                    customData.getCompound("Purpur.SpawnData")
+                        .flatMap(spawnerData -> spawnerData.read("SpawnData", net.minecraft.world.level.SpawnData.CODEC))
+                        .ifPresent(spawnData -> spawner.getSpawner().nextSpawnData = spawnData);
+                }
+            }
+        }
+        return handled;
+    }
+}
diff --git a/org/purpurmc/purpur/network/ClientboundBeehivePayload.java b/org/purpurmc/purpur/network/ClientboundBeehivePayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..793a3ea45fe04e84725926f17615c26e008b0ce4
--- /dev/null
+++ b/org/purpurmc/purpur/network/ClientboundBeehivePayload.java
@@ -0,0 +1,27 @@
+package org.purpurmc.purpur.network;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+
+public record ClientboundBeehivePayload(BlockPos pos, int numOfBees) implements CustomPacketPayload {
+    public static final StreamCodec<FriendlyByteBuf, ClientboundBeehivePayload> STREAM_CODEC = CustomPacketPayload.codec(ClientboundBeehivePayload::write, ClientboundBeehivePayload::new);
+    public static final Type<ClientboundBeehivePayload> TYPE = new Type<>(ResourceLocation.fromNamespaceAndPath("purpur", "beehive_s2c"));
+
+    public ClientboundBeehivePayload(FriendlyByteBuf friendlyByteBuf) {
+        this(friendlyByteBuf.readBlockPos(),  friendlyByteBuf.readInt());
+    }
+
+    private void write(FriendlyByteBuf friendlyByteBuf) {
+        friendlyByteBuf.writeBlockPos(this.pos);
+        friendlyByteBuf.writeInt(this.numOfBees);
+    }
+
+    @Override
+    public @NotNull Type<? extends CustomPacketPayload> type() {
+        return TYPE;
+    }
+}
diff --git a/org/purpurmc/purpur/network/ServerboundBeehivePayload.java b/org/purpurmc/purpur/network/ServerboundBeehivePayload.java
new file mode 100644
index 0000000000000000000000000000000000000000..fa72769e06061609e1e658a0250e99c8cb026c0e
--- /dev/null
+++ b/org/purpurmc/purpur/network/ServerboundBeehivePayload.java
@@ -0,0 +1,26 @@
+package org.purpurmc.purpur.network;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.network.codec.StreamCodec;
+import net.minecraft.network.protocol.common.custom.CustomPacketPayload;
+import net.minecraft.resources.ResourceLocation;
+import org.jetbrains.annotations.NotNull;
+
+public record ServerboundBeehivePayload(BlockPos pos) implements CustomPacketPayload {
+    public static final StreamCodec<FriendlyByteBuf, ServerboundBeehivePayload> STREAM_CODEC = CustomPacketPayload.codec(ServerboundBeehivePayload::write, ServerboundBeehivePayload::new);
+    public static final Type<ServerboundBeehivePayload> TYPE = new Type<>(ResourceLocation.fromNamespaceAndPath("purpur", "beehive_c2s"));
+
+    public ServerboundBeehivePayload(FriendlyByteBuf friendlyByteBuf) {
+        this(friendlyByteBuf.readBlockPos());
+    }
+
+    private void write(FriendlyByteBuf friendlyByteBuf) {
+        friendlyByteBuf.writeBlockPos(this.pos);
+    }
+
+    @Override
+    public @NotNull Type<? extends CustomPacketPayload> type() {
+        return TYPE;
+    }
+}
diff --git a/org/purpurmc/purpur/task/BeehiveTask.java b/org/purpurmc/purpur/task/BeehiveTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..664f9d5e1ce5e2787bf699bd11758b9e3aa8ed3a
--- /dev/null
+++ b/org/purpurmc/purpur/task/BeehiveTask.java
@@ -0,0 +1,67 @@
+package org.purpurmc.purpur.task;
+
+import io.netty.buffer.Unpooled;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerPlayer;
+import net.minecraft.world.level.block.entity.BeehiveBlockEntity;
+import net.minecraft.world.level.block.entity.BlockEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.entity.Player;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.messaging.PluginMessageListener;
+import org.jetbrains.annotations.NotNull;
+import org.purpurmc.purpur.network.ClientboundBeehivePayload;
+import org.purpurmc.purpur.network.ServerboundBeehivePayload;
+import org.purpurmc.purpur.util.MinecraftInternalPlugin;
+
+public class BeehiveTask implements PluginMessageListener {
+
+    private static BeehiveTask instance;
+
+    public static BeehiveTask instance() {
+        if (instance == null) {
+            instance = new BeehiveTask();
+        }
+        return instance;
+    }
+
+    private final PluginBase plugin = new MinecraftInternalPlugin();
+
+    private BeehiveTask() {
+    }
+
+    public void register() {
+        Bukkit.getMessenger().registerOutgoingPluginChannel(this.plugin, ClientboundBeehivePayload.TYPE.id().toString());
+        Bukkit.getMessenger().registerIncomingPluginChannel(this.plugin, ServerboundBeehivePayload.TYPE.id().toString(), this);
+    }
+
+    public void unregister() {
+        Bukkit.getMessenger().unregisterOutgoingPluginChannel(this.plugin, ClientboundBeehivePayload.TYPE.id().toString());
+        Bukkit.getMessenger().unregisterIncomingPluginChannel(this.plugin, ServerboundBeehivePayload.TYPE.id().toString());
+    }
+
+    @Override
+    public void onPluginMessageReceived(@NotNull String channel, @NotNull Player player, byte[] bytes) {
+        FriendlyByteBuf byteBuf = new FriendlyByteBuf(Unpooled.copiedBuffer(bytes));
+        ServerboundBeehivePayload payload = ServerboundBeehivePayload.STREAM_CODEC.decode(byteBuf);
+
+        ServerPlayer serverPlayer = ((CraftPlayer) player).getHandle();
+
+        // targeted block info max range specified in client at net.minecraft.client.gui.hud.DebugHud#render
+        if (!payload.pos().getCenter().closerThan(serverPlayer.position(), 20)) return; // Targeted Block info max range is 20
+        if (serverPlayer.level().getChunkIfLoaded(payload.pos()) == null) return;
+
+        BlockEntity blockEntity = serverPlayer.level().getBlockEntity(payload.pos());
+        if (!(blockEntity instanceof BeehiveBlockEntity beehive)) {
+            return;
+        }
+
+        ClientboundBeehivePayload customPacketPayload = new ClientboundBeehivePayload(payload.pos(), beehive.getOccupantCount());
+        FriendlyByteBuf friendlyByteBuf = new FriendlyByteBuf(Unpooled.buffer());
+        ClientboundBeehivePayload.STREAM_CODEC.encode(friendlyByteBuf, customPacketPayload);
+        byte[] byteArray = new byte[friendlyByteBuf.readableBytes()];
+        friendlyByteBuf.readBytes(byteArray);
+        player.sendPluginMessage(this.plugin, customPacketPayload.type().id().toString(), byteArray);
+    }
+}
diff --git a/org/purpurmc/purpur/task/BossBarTask.java b/org/purpurmc/purpur/task/BossBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..3c3d4cd52db93b97a40321030a70ebc282c9636b
--- /dev/null
+++ b/org/purpurmc/purpur/task/BossBarTask.java
@@ -0,0 +1,121 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.minecraft.server.level.ServerPlayer;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.bukkit.scheduler.BukkitRunnable;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.Map;
+import java.util.UUID;
+import org.purpurmc.purpur.util.MinecraftInternalPlugin;
+
+public abstract class BossBarTask extends BukkitRunnable {
+    private final Map<UUID, BossBar> bossbars = new HashMap<>();
+    private boolean started;
+
+    abstract BossBar createBossBar();
+
+    abstract void updateBossBar(BossBar bossbar, Player player);
+
+    @Override
+    public void run() {
+        Iterator<Map.Entry<UUID, BossBar>> iter = bossbars.entrySet().iterator();
+        while (iter.hasNext()) {
+            Map.Entry<UUID, BossBar> entry = iter.next();
+            Player player = Bukkit.getPlayer(entry.getKey());
+            if (player == null) {
+                iter.remove();
+                continue;
+            }
+            updateBossBar(entry.getValue(), player);
+        }
+    }
+
+    @Override
+    public void cancel() {
+        super.cancel();
+        new HashSet<>(this.bossbars.keySet()).forEach(uuid -> {
+            Player player = Bukkit.getPlayer(uuid);
+            if (player != null) {
+                removePlayer(player);
+            }
+        });
+        this.bossbars.clear();
+    }
+
+    public boolean removePlayer(Player player) {
+        BossBar bossbar = this.bossbars.remove(player.getUniqueId());
+        if (bossbar != null) {
+            player.hideBossBar(bossbar);
+            return true;
+        }
+        return false;
+    }
+
+    public void addPlayer(Player player) {
+        removePlayer(player);
+        BossBar bossbar = createBossBar();
+        this.bossbars.put(player.getUniqueId(), bossbar);
+        this.updateBossBar(bossbar, player);
+        player.showBossBar(bossbar);
+    }
+
+    public boolean hasPlayer(UUID uuid) {
+        return this.bossbars.containsKey(uuid);
+    }
+
+    public boolean togglePlayer(Player player) {
+        if (removePlayer(player)) {
+            return false;
+        }
+        addPlayer(player);
+        return true;
+    }
+
+    public void start() {
+        stop();
+        this.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 1, 1);
+        started = true;
+    }
+
+    public void stop() {
+        if (started) {
+            cancel();
+        }
+    }
+
+    public static void startAll() {
+        RamBarTask.instance().start();
+        TPSBarTask.instance().start();
+        CompassTask.instance().start();
+    }
+
+    public static void stopAll() {
+        RamBarTask.instance().stop();
+        TPSBarTask.instance().stop();
+        CompassTask.instance().stop();
+    }
+
+    public static void addToAll(ServerPlayer player) {
+        Player bukkit = player.getBukkitEntity();
+        if (player.ramBar()) {
+            RamBarTask.instance().addPlayer(bukkit);
+        }
+        if (player.tpsBar()) {
+            TPSBarTask.instance().addPlayer(bukkit);
+        }
+        if (player.compassBar()) {
+            CompassTask.instance().addPlayer(bukkit);
+        }
+    }
+
+    public static void removeFromAll(Player player) {
+        RamBarTask.instance().removePlayer(player);
+        TPSBarTask.instance().removePlayer(player);
+        CompassTask.instance().removePlayer(player);
+    }
+}
diff --git a/org/purpurmc/purpur/task/CompassTask.java b/org/purpurmc/purpur/task/CompassTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..bece7eefc8ba8822b433835526251d2fb916c025
--- /dev/null
+++ b/org/purpurmc/purpur/task/CompassTask.java
@@ -0,0 +1,68 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.item.Items;
+import org.bukkit.entity.Player;
+import org.purpurmc.purpur.PurpurConfig;
+
+public class CompassTask extends BossBarTask {
+    private static CompassTask instance;
+
+    private int tick = 0;
+
+    public static CompassTask instance() {
+        if (instance == null) {
+            instance = new CompassTask();
+        }
+        return instance;
+    }
+
+    @Override
+    public void run() {
+        if (++tick < PurpurConfig.commandCompassBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        MinecraftServer.getServer().getAllLevels().forEach((level) -> {
+            if (level.purpurConfig.compassItemShowsBossBar) {
+                level.players().forEach(player -> {
+                    if (!player.compassBar()) {
+                        if (player.getMainHandItem().getItem() != Items.COMPASS && player.getOffhandItem().getItem() != Items.COMPASS) {
+                            removePlayer(player.getBukkitEntity());
+                        } else if (!hasPlayer(player.getUUID())) {
+                            addPlayer(player.getBukkitEntity());
+                        }
+                    }
+                });
+            }
+        });
+
+        super.run();
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), PurpurConfig.commandCompassBarProgressPercent, PurpurConfig.commandCompassBarProgressColor, PurpurConfig.commandCompassBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        float yaw = player.getLocation().getYaw();
+        int length = PurpurConfig.commandCompassBarTitle.length();
+        int pos = (int) ((normalize(yaw) * (length / 720F)) + (length / 2F));
+        bossbar.name(Component.text(PurpurConfig.commandCompassBarTitle.substring(pos - 25, pos + 25)));
+    }
+
+    private float normalize(float yaw) {
+        while (yaw < -180.0F) {
+            yaw += 360.0F;
+        }
+        while (yaw > 180.0F) {
+            yaw -= 360.0F;
+        }
+        return yaw;
+    }
+}
diff --git a/org/purpurmc/purpur/task/RamBarTask.java b/org/purpurmc/purpur/task/RamBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e98c0ae73e2c40002a72b5d0d246ffa0c3ab38f
--- /dev/null
+++ b/org/purpurmc/purpur/task/RamBarTask.java
@@ -0,0 +1,117 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.bukkit.entity.Player;
+import org.purpurmc.purpur.PurpurConfig;
+
+import java.lang.management.ManagementFactory;
+import java.lang.management.MemoryUsage;
+
+public class RamBarTask extends BossBarTask {
+    private static RamBarTask instance;
+    private long allocated = 0L;
+    private long used = 0L;
+    private long xmx = 0L;
+    private long xms = 0L;
+    private float percent = 0F;
+    private int tick = 0;
+
+    public static RamBarTask instance() {
+        if (instance == null) {
+            instance = new RamBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(), PurpurConfig.commandRamBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress());
+        bossbar.color(getBossBarColor());
+        bossbar.name(MiniMessage.miniMessage().deserialize(PurpurConfig.commandRamBarTitle,
+                Placeholder.component("allocated", format(this.allocated)),
+                Placeholder.component("used", format(this.used)),
+                Placeholder.component("xmx", format(this.xmx)),
+                Placeholder.component("xms", format(this.xms)),
+                Placeholder.unparsed("percent", ((int) (this.percent * 100)) + "%")
+        ));
+    }
+
+    @Override
+    public void run() {
+        if (++this.tick < PurpurConfig.commandRamBarTickInterval) {
+            return;
+        }
+        this.tick = 0;
+
+        MemoryUsage heap = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();
+
+        this.allocated = heap.getCommitted();
+        this.used = heap.getUsed();
+        this.xmx = heap.getMax();
+        this.xms = heap.getInit();
+        this.percent = Math.max(Math.min((float) this.used / this.xmx, 1.0F), 0.0F);
+
+        super.run();
+    }
+
+    private float getBossBarProgress() {
+        return this.percent;
+    }
+
+    private BossBar.Color getBossBarColor() {
+        if (this.percent < 0.5F) {
+            return PurpurConfig.commandRamBarProgressColorGood;
+        } else if (this.percent < 0.75F) {
+            return PurpurConfig.commandRamBarProgressColorMedium;
+        } else {
+            return PurpurConfig.commandRamBarProgressColorLow;
+        }
+    }
+
+    public Component format(long v) {
+        String color;
+        if (this.percent < 0.60F) {
+            color = PurpurConfig.commandRamBarTextColorGood;
+        } else if (this.percent < 0.85F) {
+            color = PurpurConfig.commandRamBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandRamBarTextColorLow;
+        }
+        String value;
+        if (v < 1024) {
+            value = v + "B";
+        } else {
+            int z = (63 - Long.numberOfLeadingZeros(v)) / 10;
+            value = String.format("%.1f%s", (double) v / (1L << (z * 10)), "BKMGTPE".charAt(z));
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.unparsed("text", value));
+    }
+
+    public long getAllocated() {
+        return this.allocated;
+    }
+
+    public long getUsed() {
+        return this.used;
+    }
+
+    public long getXmx() {
+        return this.xmx;
+    }
+
+    public long getXms() {
+        return this.xms;
+    }
+
+    public float getPercent() {
+        return this.percent;
+    }
+}
diff --git a/org/purpurmc/purpur/task/TPSBarTask.java b/org/purpurmc/purpur/task/TPSBarTask.java
new file mode 100644
index 0000000000000000000000000000000000000000..8769993e7ca59da309087051a3cd38fc562c15d1
--- /dev/null
+++ b/org/purpurmc/purpur/task/TPSBarTask.java
@@ -0,0 +1,142 @@
+package org.purpurmc.purpur.task;
+
+import net.kyori.adventure.bossbar.BossBar;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.minimessage.MiniMessage;
+import net.kyori.adventure.text.minimessage.tag.resolver.Placeholder;
+import org.purpurmc.purpur.PurpurConfig;
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+
+public class TPSBarTask extends BossBarTask {
+    private static TPSBarTask instance;
+    private double tps = 20.0D;
+    private double mspt = 0.0D;
+    private int tick = 0;
+
+    public static TPSBarTask instance() {
+        if (instance == null) {
+            instance = new TPSBarTask();
+        }
+        return instance;
+    }
+
+    @Override
+    BossBar createBossBar() {
+        return BossBar.bossBar(Component.text(""), 0.0F, instance().getBossBarColor(), PurpurConfig.commandTPSBarProgressOverlay);
+    }
+
+    @Override
+    void updateBossBar(BossBar bossbar, Player player) {
+        bossbar.progress(getBossBarProgress());
+        bossbar.color(getBossBarColor());
+        bossbar.name(MiniMessage.miniMessage().deserialize(PurpurConfig.commandTPSBarTitle,
+                Placeholder.component("tps", getTPSColor()),
+                Placeholder.component("mspt", getMSPTColor()),
+                Placeholder.component("ping", getPingColor(player.getPing()))
+        ));
+    }
+
+    @Override
+    public void run() {
+        if (++tick < PurpurConfig.commandTPSBarTickInterval) {
+            return;
+        }
+        tick = 0;
+
+        this.tps = Math.max(Math.min(Bukkit.getTPS()[0], 20.0D), 0.0D);
+        this.mspt = Bukkit.getAverageTickTime();
+
+        super.run();
+    }
+
+    private float getBossBarProgress() {
+        if (PurpurConfig.commandTPSBarProgressFillMode == FillMode.MSPT) {
+            return Math.max(Math.min((float) mspt / 50.0F, 1.0F), 0.0F);
+        } else {
+            return Math.max(Math.min((float) tps / 20.0F, 1.0F), 0.0F);
+        }
+    }
+
+    private BossBar.Color getBossBarColor() {
+        if (isGood(PurpurConfig.commandTPSBarProgressFillMode)) {
+            return PurpurConfig.commandTPSBarProgressColorGood;
+        } else if (isMedium(PurpurConfig.commandTPSBarProgressFillMode)) {
+            return PurpurConfig.commandTPSBarProgressColorMedium;
+        } else {
+            return PurpurConfig.commandTPSBarProgressColorLow;
+        }
+    }
+
+    private boolean isGood(FillMode mode) {
+        return isGood(mode, 0);
+    }
+
+    private boolean isGood(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt < 40;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 19;
+        } else if (mode == FillMode.PING) {
+            return ping < 100;
+        } else {
+            return false;
+        }
+    }
+
+    private boolean isMedium(FillMode mode) {
+        return isMedium(mode, 0);
+    }
+
+    private boolean isMedium(FillMode mode, int ping) {
+        if (mode == FillMode.MSPT) {
+            return mspt < 50;
+        } else if (mode == FillMode.TPS) {
+            return tps >= 15;
+        } else if (mode == FillMode.PING) {
+            return ping < 200;
+        } else {
+            return false;
+        }
+    }
+
+    private Component getTPSColor() {
+        String color;
+        if (isGood(FillMode.TPS)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.TPS)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", tps)));
+    }
+
+    private Component getMSPTColor() {
+        String color;
+        if (isGood(FillMode.MSPT)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.MSPT)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%.2f", mspt)));
+    }
+
+    private Component getPingColor(int ping) {
+        String color;
+        if (isGood(FillMode.PING, ping)) {
+            color = PurpurConfig.commandTPSBarTextColorGood;
+        } else if (isMedium(FillMode.PING, ping)) {
+            color = PurpurConfig.commandTPSBarTextColorMedium;
+        } else {
+            color = PurpurConfig.commandTPSBarTextColorLow;
+        }
+        return MiniMessage.miniMessage().deserialize(color, Placeholder.parsed("text", String.format("%s", ping)));
+    }
+
+    public enum FillMode {
+        TPS, MSPT, PING
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Actionable.java b/org/purpurmc/purpur/tool/Actionable.java
new file mode 100644
index 0000000000000000000000000000000000000000..e18c37f06730da9d3055d5215e813b1477c1e70e
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Actionable.java
@@ -0,0 +1,24 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public abstract class Actionable {
+    private final Block into;
+    private final Map<Item, Double> drops;
+
+    public Actionable(Block into, Map<Item, Double> drops) {
+        this.into = into;
+        this.drops = drops;
+    }
+
+    public Block into() {
+        return into;
+    }
+
+    public Map<Item, Double> drops() {
+        return drops;
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Flattenable.java b/org/purpurmc/purpur/tool/Flattenable.java
new file mode 100644
index 0000000000000000000000000000000000000000..345d4ee4ff0b78bd1050959711a4f5d16a5e8aee
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Flattenable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Flattenable extends Actionable {
+    public Flattenable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Strippable.java b/org/purpurmc/purpur/tool/Strippable.java
new file mode 100644
index 0000000000000000000000000000000000000000..bf5402214f41af9c09bd6c5c4f45d330516d742e
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Strippable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Strippable extends Actionable {
+    public Strippable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Tillable.java b/org/purpurmc/purpur/tool/Tillable.java
new file mode 100644
index 0000000000000000000000000000000000000000..715f6dd44480347eebced43c11bc364e05727498
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Tillable.java
@@ -0,0 +1,50 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.HoeItem;
+import net.minecraft.world.item.Item;
+import net.minecraft.world.item.context.UseOnContext;
+import net.minecraft.world.level.block.Block;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class Tillable extends Actionable {
+    private final Condition condition;
+
+    public Tillable(Condition condition, Block into, Map<Item, Double> drops) {
+        super(into, drops);
+        this.condition = condition;
+    }
+
+    public Condition condition() {
+        return condition;
+    }
+
+    public enum Condition {
+        AIR_ABOVE(HoeItem::onlyIfAirAbove),
+        ALWAYS((useOnContext) -> true);
+
+        private final Predicate<UseOnContext> predicate;
+
+        Condition(Predicate<UseOnContext> predicate) {
+            this.predicate = predicate;
+        }
+
+        public Predicate<UseOnContext> predicate() {
+            return predicate;
+        }
+
+        private static final Map<String, Condition> BY_NAME = new HashMap<>();
+
+        static {
+            for (Condition condition : values()) {
+                BY_NAME.put(condition.name(), condition);
+            }
+        }
+
+        public static Condition get(String name) {
+            return BY_NAME.get(name.toUpperCase(java.util.Locale.ROOT));
+        }
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Waxable.java b/org/purpurmc/purpur/tool/Waxable.java
new file mode 100644
index 0000000000000000000000000000000000000000..64adb13b29b6757dcf227a55588da70ecabe083f
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Waxable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Waxable extends Actionable {
+    public Waxable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/tool/Weatherable.java b/org/purpurmc/purpur/tool/Weatherable.java
new file mode 100644
index 0000000000000000000000000000000000000000..b7586f494528f30eb0da82420d3bcf5b83a1a902
--- /dev/null
+++ b/org/purpurmc/purpur/tool/Weatherable.java
@@ -0,0 +1,12 @@
+package org.purpurmc.purpur.tool;
+
+import net.minecraft.world.item.Item;
+import net.minecraft.world.level.block.Block;
+
+import java.util.Map;
+
+public class Weatherable extends Actionable {
+    public Weatherable(Block into, Map<Item, Double> drops) {
+        super(into, drops);
+    }
+}
diff --git a/org/purpurmc/purpur/util/MinecraftInternalPlugin.java b/org/purpurmc/purpur/util/MinecraftInternalPlugin.java
new file mode 100644
index 0000000000000000000000000000000000000000..77a18f3048b18d38c5bd0129065efff27fa774fa
--- /dev/null
+++ b/org/purpurmc/purpur/util/MinecraftInternalPlugin.java
@@ -0,0 +1,149 @@
+package org.purpurmc.purpur.util;
+
+import io.papermc.paper.plugin.lifecycle.event.LifecycleEventManager;
+import org.bukkit.Server;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.configuration.file.FileConfiguration;
+import org.bukkit.generator.BiomeProvider;
+import org.bukkit.generator.ChunkGenerator;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginBase;
+import org.bukkit.plugin.PluginDescriptionFile;
+import org.bukkit.plugin.PluginLoader;
+import org.bukkit.plugin.PluginLogger;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import java.io.File;
+import java.io.InputStream;
+import java.util.List;
+
+public class MinecraftInternalPlugin extends PluginBase {
+    private boolean enabled = true;
+
+    private final String pluginName;
+    private PluginDescriptionFile pdf;
+
+    public MinecraftInternalPlugin() {
+        this.pluginName = "Minecraft";
+        pdf = new PluginDescriptionFile(pluginName, "1.0", "nms");
+    }
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    @Override
+    public File getDataFolder() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginDescriptionFile getDescription() {
+        return pdf;
+    }
+
+    @Override
+    public io.papermc.paper.plugin.configuration.PluginMeta getPluginMeta() {
+        return pdf;
+    }
+
+    @Override
+    public FileConfiguration getConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public InputStream getResource(String filename) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveDefaultConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void saveResource(String resourcePath, boolean replace) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void reloadConfig() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLogger getLogger() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public PluginLoader getPluginLoader() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public Server getServer() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    @Override
+    public void onDisable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onLoad() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void onEnable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean isNaggable() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public void setNaggable(boolean canNag) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public ChunkGenerator getDefaultWorldGenerator(String worldName, String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @Nullable BiomeProvider getDefaultBiomeProvider(@NotNull String worldName, @Nullable String id) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public boolean onCommand(CommandSender sender, Command command, String label, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public List<String> onTabComplete(CommandSender sender, Command command, String alias, String[] args) {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+
+    @Override
+    public @NotNull LifecycleEventManager<Plugin> getLifecycleManager() {
+        throw new UnsupportedOperationException("Not supported.");
+    }
+}
