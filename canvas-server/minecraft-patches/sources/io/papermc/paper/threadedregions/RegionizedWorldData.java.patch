--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -66,7 +_,7 @@
 
 public final class RegionizedWorldData {
 
-    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final Logger LOGGER = org.slf4j.LoggerFactory.getLogger("RegionizedWorldData"); // Canvas - rewrite scheduler
 
     private static final Entity[] EMPTY_ENTITY_ARRAY = new Entity[0];
 
@@ -82,7 +_,9 @@
             // entities
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
+                player.setRegionData(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
+                into.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 into.allEntities.add(entity);
@@ -120,7 +_,13 @@
             }
             for (final TickingBlockEntity tileEntityWrapped : from.blockEntityTickers) {
                 into.blockEntityTickers.add(tileEntityWrapped);
-                final BlockEntity tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas start - block entity sleeping
+                final BlockEntity tileEntity;
+                if (tileEntityWrapped instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    tileEntity = sleepingTicker.getTileEntityForRegionOperation(); // ensure we still update the entity ticks
+                } else tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas end - block entity sleeping
                 if (tileEntity != null) {
                     tileEntity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
                 }
@@ -181,6 +_,11 @@
                 // the chunk holder must _exist_, and so the region section exists.
                 final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
                 into.localPlayers.add(player);
+                player.setRegionData(into); // Canvas - rewrite scheduler
+                // Canvas start - region threading - restore waypoints
+                from.waypointManager.removePlayer(player);
+                into.waypointManager.addPlayer(player);
+                // Canvas end - region threading - restore waypoints
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -252,7 +_,18 @@
                   //       marked as removed. So if there is no section, it's probably removed!
             }
             for (final TickingBlockEntity tileEntity : from.blockEntityTickers) {
-                final BlockPos pos = tileEntity.getPos();
+                // Canvas start - block entity sleeping
+                final BlockPos pos;
+                if (tileEntity instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    pos = sleepingTicker.getPosForRegionOperation(); // ensure non-null, since the sleeping ticker has getPos() return null, which will crash the server on split
+                } else {
+                    pos = tileEntity.getPos();
+                }
+                if (pos == null) {
+                    throw new IllegalStateException("Pos cannot be null, class: " + tileEntity.getClass().getName());
+                }
+                // Canvas end - block entity sleeping
                 final int chunkX = pos.getX() >> 4;
                 final int chunkZ = pos.getZ() >> 4;
 
@@ -334,7 +_,7 @@
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
 
     // misc. fields
     private boolean isHandlingTick;
@@ -348,7 +_,7 @@
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    private final List<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -364,8 +_,8 @@
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
+    private final List<TickingBlockEntity> blockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     private boolean tickingBlockEntities;
 
     // time
@@ -394,6 +_,7 @@
     public boolean skipPullModeEventFire = false;
     public boolean skipPushModeEventFire = false;
     public boolean skipHopperEvents = false;
+    public boolean skipHopperSearchItemEvents = false; // Canvas - optimize hoppers
     // Paper end - Optimize Hoppers
     public long lastMidTickExecute;
     public long lastMidTickExecuteFailure;
@@ -402,8 +_,8 @@
     public final NeighborUpdater neighborUpdater;
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
     public List<ItemEntity> captureDrops;
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -418,11 +_,16 @@
     public boolean shouldSignal = true;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(64, 0.25f);
     public final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    public final List<LevelChunk> temporaryChunkTickList = new java.util.ArrayList<>();
+    public final List<LevelChunk> temporaryChunkTickList = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     public final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceLinkedOpenHashSet<>();
 
     // not transient
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
+    // Canvas start - optimize fluid spread
+    // this is transient
+    public it.unimi.dsi.fastutil.longs.LongSet slopeDistanceCacheVisited = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(512);
+    public net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque slopeDistanceCacheQueue = new net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque();
+    // Canvas end - optimize fluid spread
 
     // Mob spawning
     public final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
@@ -447,7 +_,15 @@
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final net.minecraft.world.level.levelgen.BitRandomSource simpleUnsafeLocalRandom = io.canvasmc.canvas.Config.ENABLE_FASTER_RANDOM ? new io.canvasmc.canvas.util.FasterRandomSource(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()) : new ca.spottedleaf.moonrise.common.util.SimpleThreadUnsafeRandom(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()); // Canvas - faster unsafe random
+    public final io.canvasmc.canvas.RegionizedTpsBar tpsbar; // Canvas - tpsbar
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+    public final ApiHandle apiHandle = new ApiHandle(this); // Canvas - expand region api
+    public final net.minecraft.server.waypoints.ServerWaypointManager waypointManager = new net.minecraft.server.waypoints.ServerWaypointManager(); // Canvas - region threading - restore waypoints
+    public final io.canvasmc.canvas.chunk.RandomTickSystem randomTickSystem = new io.canvasmc.canvas.chunk.RandomTickSystem(); // Leaf - optimize random tick
+    public final io.canvasmc.canvas.chunk.NatureSpawnChunkMap natureSpawnChunkMap = new io.canvasmc.canvas.chunk.NatureSpawnChunkMap(); // Canvas - optimize spawn chunk collection
+
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +_,8 @@
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
+        this.tpsbar = new io.canvasmc.canvas.RegionizedTpsBar(this); // Canvas - tpsbar
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -482,7 +_,8 @@
         this.hasEntityMoveEvent = io.papermc.paper.event.entity.EntityMoveEvent.getHandlerList().getRegisteredListeners().length > 0; // Paper - Add EntityMoveEvent
         this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
         // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
-        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.TIME_BETWEEN_TICKS;
+        this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.getTimeBetweenTicks(); // Canvas - rewrite scheduler
+        this.skipHopperSearchItemEvents = org.bukkit.event.inventory.HopperInventorySearchEvent.getHandlerList().getRegisteredListeners().length == 0; // Canvas - optimize hoppers
     }
 
     public NearbyPlayers getNearbyPlayers() {
@@ -500,17 +_,50 @@
         );
     }
 
+    // Canvas start - rewrite tick scheduler
+    // copied from it.unimi.dsi.fastutil.objects.ObjectLists.shuffle method, modified to use Minecraft RandomSources
+    public static <K> it.unimi.dsi.fastutil.objects.ObjectList<K> shuffle(final it.unimi.dsi.fastutil.objects.ObjectList<K> l, final net.minecraft.util.RandomSource random) {
+        for (int i = l.size(); i-- != 0;) {
+            final int p = random.nextInt(i + 1);
+            final K t = l.get(i);
+            l.set(i, l.get(p));
+            l.set(p, t);
+        }
+        return l;
+    }
+
+    // Canvas end - rewrite tick scheduler
     // connections
     public void tickConnections() {
-        final List<Connection> connections = new ArrayList<>(this.connections);
-        Collections.shuffle(connections);
+        final it.unimi.dsi.fastutil.objects.ObjectArrayList<Connection> connections = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(this.connections); // Canvas - optimized collection
+        shuffle(connections, this.simpleUnsafeLocalRandom); // Canvas - optimized collection
         for (final Connection conn : connections) {
             if (!conn.isConnected()) {
-                conn.handleDisconnection();
-                // global tick thread will not remove connections not owned by it, so we need to
-                RegionizedServer.getInstance().removeConnection(conn);
-                this.connections.remove(conn);
-                cleanUpConnection(conn);
+                // Canvas start - rewrite scheduler
+                try {
+                    ServerPlayer player = conn.getPlayer();
+                    // ensure we don't run into ownership issues with the bounding box exceeding the region
+                    player.level().loadChunksForMoveAsync(player.getBoundingBox().inflate(2), ca.spottedleaf.concurrentutil.util.Priority.HIGH, (chunks) -> {
+                        RegionizedServer.getInstance().taskQueue.queueTickTaskQueue(
+                            player.level(),
+                            player.chunkPosition().x,
+                            player.chunkPosition().z,
+                            () -> {
+                                conn.handleDisconnection();
+                                this.connections.remove(conn);
+                                // global tick thread will not remove connections not owned by it, so we need to
+                                RegionizedServer.getInstance().removeConnection(conn);
+                                cleanUpConnection(conn);
+                                LOGGER.info("Completed removal of player '{}' successfully.", player.getName().getString());
+                            }
+                        );
+                    });
+                } catch (Exception e) {
+                    LOGGER.info("Unable to execute connection removal for conn[{}]", conn.getPlayer().getName().getString());
+                    LOGGER.info("Disconnect details: {}", conn.getDisconnectionDetails());
+                    throw new RuntimeException(e);
+                }
+                // Canvas end - rewrite scheduler
                 continue;
             }
             if (!this.connections.contains(conn)) {
@@ -612,6 +_,8 @@
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
+                player.setRegionData(this); // Canvas - rewrite scheduler
+                this.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -628,6 +_,8 @@
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
+                player.setRegionData(null); // Canvas - rewrite scheduler
+                this.waypointManager.removePlayer(player); // Canvas - region threading - restore waypoints
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -768,4 +_,72 @@
     public int getChunkCount() {
         return this.chunks.size();
     }
+    // Canvas start - expand region API
+
+    public static class ApiHandle implements io.canvasmc.canvas.threadedregions.WorldRegionData {
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.worldData.world.getWorld();
+        }
+
+        @Override
+        public org.bukkit.Chunk getCenterChunk() {
+            ChunkPos pos = this.worldData.regionData.region.getCenterChunk();
+            return pos == null ? null : getWorld().getChunkAt(pos.longKey);
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getOwnedChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.chunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getTickingChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.tickingChunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public int getChunkCount() {
+            return this.worldData.getChunkCount();
+        }
+
+        @Override
+        public List<org.bukkit.entity.Player> getLocalPlayers() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.entity.Player> players = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final ServerPlayer localPlayer : this.worldData.localPlayers) {
+                players.add(localPlayer.getBukkitEntity());
+            }
+            return players;
+        }
+
+        @Override
+        public int getPlayerCount() {
+            return this.worldData.getPlayerCount();
+        }
+
+        @Override
+        public int getEntityCount() {
+            return this.worldData.getEntityCount();
+        }
+
+        @Override
+        public io.canvasmc.canvas.threadedregions.ThreadedWorldRegion getRegionizerRegion() {
+            return this.worldData.regionData.region.apiHandle;
+        }
+
+        private final RegionizedWorldData worldData;
+
+        public ApiHandle(RegionizedWorldData worldData) {
+            this.worldData = worldData;
+        }
+    }
+    // Canvas end - expand region API
 }
