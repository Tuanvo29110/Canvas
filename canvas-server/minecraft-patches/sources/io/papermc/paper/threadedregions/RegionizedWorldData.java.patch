--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -82,7 +_,9 @@
             // entities
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
+                into.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 into.allEntities.add(entity);
@@ -159,6 +_,10 @@
             for (final ChunkHolder chunkHolder : from.chunkHoldersToBroadcast) {
                 into.chunkHoldersToBroadcast.add(chunkHolder);
             }
+            // Canvas start - optimize entity/block ticking chunk lookups
+            into.blockTickingChunkHolders.addAll(from.blockTickingChunkHolders);
+            into.entityTickingChunkHolders.addAll(from.entityTickingChunkHolders);
+            // Canvas end
         }
 
         @Override
@@ -171,8 +_,12 @@
                 final ChunkPos pos = player.chunkPosition();
                 // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
                 // the chunk holder must _exist_, and so the region section exists.
-                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
-                    .connections.add(conn);
+                // Canvas start - region threading - restore waypoints
+                from.waypointManager.removePlayer(player);
+                RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                into.connections.add(conn);
+                into.waypointManager.addPlayer(player);
+                // Canvas end
             }
             // entities
             for (final ServerPlayer player : from.localPlayers) {
@@ -181,6 +_,7 @@
                 // the chunk holder must _exist_, and so the region section exists.
                 final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -326,6 +_,22 @@
                     into.chunkHoldersToBroadcast.add(chunkHolder);
                 }
             }
+            // Canvas start - optimize entity/block ticking chunk lookups
+            // we can just use 'regionToData' to find the chunk, since
+            // the long in this case *is* the chunk key
+            for (final long chunkKey : from.blockTickingChunkHolders) {
+                RegionizedWorldData worldData = regionToData.get(chunkKey);
+                if (worldData != null) {
+                    worldData.blockTickingChunkHolders.add(chunkKey);
+                }
+            }
+            for (final long chunkKey : from.entityTickingChunkHolders) {
+                RegionizedWorldData worldData = regionToData.get(chunkKey);
+                if (worldData != null) {
+                    worldData.entityTickingChunkHolders.add(chunkKey);
+                }
+            }
+            // Canvas end
         }
     };
 
@@ -348,7 +_,8 @@
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    // this is copy on write to allow packet processing to iterate safely // Canvas - rewrite scheduler
+    private final java.util.concurrent.CopyOnWriteArrayList<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -447,7 +_,34 @@
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+    public final ApiHandle apiHandle = new ApiHandle(this); // Canvas - expand region api
+    public final net.minecraft.server.waypoints.ServerWaypointManager waypointManager = new net.minecraft.server.waypoints.ServerWaypointManager(); // Canvas - region threading - restore waypoints
+
+    // Canvas start - optimize entity/block ticking chunk lookups
+    // if there's lots of chunks loaded, we don't want to search through that map to find block
+    // ticking holders or entity ticking holders, so we cache the ones that are valid to limit the search.
+    // the DynamicChunkPosLongSet is the fastest option for 'contains' operations(via tests conducted in V2)
+    public final Set<Long> blockTickingChunkHolders = new io.canvasmc.canvas.chunk.DynamicChunkPosLongSet();
+    public final Set<Long> entityTickingChunkHolders = new io.canvasmc.canvas.chunk.DynamicChunkPosLongSet();
+
+    public void markBlockTicking(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonBlockTickingIfPossible(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markEntityTicking(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonEntityTickingIfPossible(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+    // Canvas end
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +_,7 @@
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -612,6 +_,7 @@
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(this); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -628,6 +_,7 @@
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
+                player.getBukkitEntity().updateRegion(null); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -768,4 +_,72 @@
     public int getChunkCount() {
         return this.chunks.size();
     }
+    // Canvas start - expand region API
+
+    public static class ApiHandle implements io.canvasmc.canvas.threadedregions.WorldRegionData {
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.worldData.world.getWorld();
+        }
+
+        @Override
+        public org.bukkit.Chunk getCenterChunk() {
+            ChunkPos pos = this.worldData.regionData.region.getCenterChunk();
+            return pos == null ? null : getWorld().getChunkAt(pos.longKey);
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getOwnedChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.chunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getTickingChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.tickingChunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public int getChunkCount() {
+            return this.worldData.getChunkCount();
+        }
+
+        @Override
+        public List<org.bukkit.entity.Player> getLocalPlayers() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.entity.Player> players = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final ServerPlayer localPlayer : this.worldData.localPlayers) {
+                players.add(localPlayer.getBukkitEntity());
+            }
+            return players;
+        }
+
+        @Override
+        public int getPlayerCount() {
+            return this.worldData.getPlayerCount();
+        }
+
+        @Override
+        public int getEntityCount() {
+            return this.worldData.getEntityCount();
+        }
+
+        @Override
+        public io.canvasmc.canvas.threadedregions.ThreadedWorldRegion getRegionizerRegion() {
+            return this.worldData.regionData.region.apiHandle;
+        }
+
+        private final RegionizedWorldData worldData;
+
+        public ApiHandle(RegionizedWorldData worldData) {
+            this.worldData = worldData;
+        }
+    }
+    // Canvas end
 }
