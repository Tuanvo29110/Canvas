--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -82,6 +_,7 @@
             // entities
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -181,6 +_,7 @@
                 // the chunk holder must _exist_, and so the region section exists.
                 final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -348,7 +_,8 @@
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    // this is copy on write to allow packet processing to iterate safely // Canvas - rewrite scheduler
+    private final java.util.concurrent.CopyOnWriteArrayList<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -447,7 +_,10 @@
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+    public final ApiHandle apiHandle = new ApiHandle(this); // Canvas - expand region api
+
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +_,7 @@
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -612,6 +_,7 @@
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(this); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -628,6 +_,7 @@
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
+                player.getBukkitEntity().updateRegion(null); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -768,4 +_,67 @@
     public int getChunkCount() {
         return this.chunks.size();
     }
+    // Canvas start - expand region API
+
+    public static class ApiHandle implements io.canvasmc.canvas.region.WorldRegion {
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.worldData.world.getWorld();
+        }
+
+        @Override
+        public org.bukkit.Chunk getCenterChunk() {
+            ChunkPos pos = this.worldData.regionData.region.getCenterChunk();
+            return pos == null ? null : getWorld().getChunkAt(pos.longKey);
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getOwnedChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.chunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getTickingChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.tickingChunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public int getChunkCount() {
+            return this.worldData.getChunkCount();
+        }
+
+        @Override
+        public List<org.bukkit.entity.Player> getLocalPlayers() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.entity.Player> players = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final ServerPlayer localPlayer : this.worldData.localPlayers) {
+                players.add(localPlayer.getBukkitEntity());
+            }
+            return players;
+        }
+
+        @Override
+        public int getPlayerCount() {
+            return this.worldData.getPlayerCount();
+        }
+
+        @Override
+        public int getEntityCount() {
+            return this.worldData.getEntityCount();
+        }
+
+        private final RegionizedWorldData worldData;
+
+        public ApiHandle(RegionizedWorldData worldData) {
+            this.worldData = worldData;
+        }
+    }
+    // Canvas end
 }
