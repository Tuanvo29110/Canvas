--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -82,7 +_,9 @@
             // entities
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
+                player.getBukkitEntity().setRegionData(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
+                into.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 into.allEntities.add(entity);
@@ -120,7 +_,13 @@
             }
             for (final TickingBlockEntity tileEntityWrapped : from.blockEntityTickers) {
                 into.blockEntityTickers.add(tileEntityWrapped);
-                final BlockEntity tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas start - block entity sleeping
+                final BlockEntity tileEntity;
+                if (tileEntityWrapped instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    tileEntity = sleepingTicker.getTileEntityForRegionOperation(); // ensure we still update the entity ticks
+                } else tileEntity = tileEntityWrapped.getTileEntity();
+                // Canvas end - block entity sleeping
                 if (tileEntity != null) {
                     tileEntity.updateTicks(fromTickOffset, fromRedstoneTimeOffset);
                 }
@@ -171,8 +_,12 @@
                 final ChunkPos pos = player.chunkPosition();
                 // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
                 // the chunk holder must _exist_, and so the region section exists.
-                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
-                    .connections.add(conn);
+                // Canvas start - region threading - restore waypoints
+                from.waypointManager.removePlayer(player);
+                RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                into.connections.add(conn);
+                into.waypointManager.addPlayer(player);
+                // Canvas end - region threading - restore waypoints
             }
             // entities
             for (final ServerPlayer player : from.localPlayers) {
@@ -181,6 +_,7 @@
                 // the chunk holder must _exist_, and so the region section exists.
                 final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
                 into.localPlayers.add(player);
+                player.getBukkitEntity().setRegionData(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -252,7 +_,18 @@
                   //       marked as removed. So if there is no section, it's probably removed!
             }
             for (final TickingBlockEntity tileEntity : from.blockEntityTickers) {
-                final BlockPos pos = tileEntity.getPos();
+                // Canvas start - block entity sleeping
+                final BlockPos pos;
+                if (tileEntity instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable
+                    && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) {
+                    pos = sleepingTicker.getPosForRegionOperation(); // ensure non-null, since the sleeping ticker has getPos() return null, which will crash the server on split
+                } else {
+                    pos = tileEntity.getPos();
+                }
+                if (pos == null) {
+                    throw new IllegalStateException("Pos cannot be null, class: " + tileEntity.getClass().getName());
+                }
+                // Canvas end - block entity sleeping
                 final int chunkX = pos.getX() >> 4;
                 final int chunkZ = pos.getZ() >> 4;
 
@@ -334,7 +_,7 @@
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
 
     // misc. fields
     private boolean isHandlingTick;
@@ -348,7 +_,8 @@
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    // this is copy on write to allow packet processing to iterate safely
+    private final java.util.concurrent.CopyOnWriteArrayList<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -364,8 +_,8 @@
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
+    private final List<TickingBlockEntity> blockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     private boolean tickingBlockEntities;
 
     // time
@@ -394,6 +_,7 @@
     public boolean skipPullModeEventFire = false;
     public boolean skipPushModeEventFire = false;
     public boolean skipHopperEvents = false;
+    public boolean skipHopperSearchItemEvents = false; // Canvas - optimize hoppers
     // Paper end - Optimize Hoppers
     public long lastMidTickExecute;
     public long lastMidTickExecuteFailure;
@@ -402,8 +_,8 @@
     public final NeighborUpdater neighborUpdater;
     public boolean captureBlockStates = false;
     public boolean captureTreeGeneration = false;
-    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new java.util.LinkedHashMap<>(); // Paper
-    public final Map<BlockPos, BlockEntity> capturedTileEntities = new java.util.LinkedHashMap<>(); // Paper
+    public final Map<BlockPos, CraftBlockState> capturedBlockStates = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
+    public final Map<BlockPos, BlockEntity> capturedTileEntities = new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>(); // Paper // Canvas - optimized collection
     public List<ItemEntity> captureDrops;
     // Paper start
     public int wakeupInactiveRemainingAnimals;
@@ -418,11 +_,16 @@
     public boolean shouldSignal = true;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(64, 0.25f);
     public final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    public final List<LevelChunk> temporaryChunkTickList = new java.util.ArrayList<>();
+    // Canvas - optimize chunk collect - remove 'temporaryChunkTickList'
     public final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceLinkedOpenHashSet<>();
 
     // not transient
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
+    // Canvas start - optimize fluid spread
+    // this is transient
+    public it.unimi.dsi.fastutil.longs.LongSet slopeDistanceCacheVisited = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(512);
+    public net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque slopeDistanceCacheQueue = new net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque();
+    // Canvas end - optimize fluid spread
 
     // Mob spawning
     public final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
@@ -447,7 +_,13 @@
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final net.minecraft.world.level.levelgen.BitRandomSource simpleUnsafeLocalRandom = new io.canvasmc.canvas.util.FasterRandomSource(net.minecraft.world.level.levelgen.RandomSupport.generateUniqueSeed()); // Canvas - faster unsafe random
+    public final io.canvasmc.canvas.RegionizedTpsBar tpsbar; // Canvas - tpsbar
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+    public final ApiHandle apiHandle = new ApiHandle(this); // Canvas - expand region api
+    public final net.minecraft.server.waypoints.ServerWaypointManager waypointManager = new net.minecraft.server.waypoints.ServerWaypointManager(); // Canvas - region threading - restore waypoints
+
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +_,8 @@
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
+        this.tpsbar = new io.canvasmc.canvas.RegionizedTpsBar(this); // Canvas - tpsbar
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -483,6 +_,7 @@
         this.skipHopperEvents = this.world.paperConfig().hopper.disableMoveEvent || org.bukkit.event.inventory.InventoryMoveItemEvent.getHandlerList().getRegisteredListeners().length == 0; // Paper - Perf: Optimize Hoppers
         // always subtract from server init so that the tick starts at zero, allowing us to cast to int without much worry
         this.lagCompensationTick = (System.nanoTime() - MinecraftServer.SERVER_INIT) / TickRegionScheduler.TIME_BETWEEN_TICKS;
+        this.skipHopperSearchItemEvents = org.bukkit.event.inventory.HopperInventorySearchEvent.getHandlerList().getRegisteredListeners().length == 0; // Canvas - optimize hoppers
     }
 
     public NearbyPlayers getNearbyPlayers() {
@@ -492,14 +_,33 @@
     private static void cleanUpConnection(final Connection conn) {
         // note: ALL connections HERE have a player
         final ServerPlayer player = conn.getPlayer();
+        // Canvas start - region threading
+        ChunkPos disconnectPos = player.connection.disconnectPos;
+        if (disconnectPos == null) {
+            // position wasn't set for some dumbass reason.
+            disconnectPos = player.chunkPosition();
+        }
+        // Canvas end - region threading
         // now that the connection is removed, we can allow this region to die
         player.level().moonrise$getChunkTaskScheduler().chunkHolderManager.removeTicketAtLevel(
-            ServerGamePacketListenerImpl.DISCONNECT_TICKET, player.connection.disconnectPos,
+            ServerGamePacketListenerImpl.DISCONNECT_TICKET, disconnectPos, // Canvas - region threading
             ChunkHolderManager.MAX_TICKET_LEVEL,
             player.connection.disconnectTicketId
         );
     }
 
+    // Canvas start - rewrite tick scheduler
+    public void addConnection(Connection connection, ServerPlayer serverPlayer) {
+        this.connections.add(connection);
+        this.waypointManager.addPlayer(serverPlayer); // Canvas - region threading - restore waypoints
+    }
+
+    public void removeConnection(Connection connection, ServerPlayer serverPlayer) {
+        this.connections.remove(connection);
+        this.waypointManager.removePlayer(serverPlayer); // Canvas - region threading - restore waypoints
+    }
+
+    // Canvas end - rewrite tick scheduler
     // connections
     public void tickConnections() {
         final List<Connection> connections = new ArrayList<>(this.connections);
@@ -509,7 +_,7 @@
                 conn.handleDisconnection();
                 // global tick thread will not remove connections not owned by it, so we need to
                 RegionizedServer.getInstance().removeConnection(conn);
-                this.connections.remove(conn);
+                this.removeConnection(conn, conn.getPlayer()); // Canvas - rewrite tick scheduler
                 cleanUpConnection(conn);
                 continue;
             }
@@ -612,6 +_,7 @@
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
+                player.getBukkitEntity().setRegionData(this); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -628,6 +_,7 @@
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
+                player.getBukkitEntity().setRegionData(null); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -768,4 +_,72 @@
     public int getChunkCount() {
         return this.chunks.size();
     }
+    // Canvas start - expand region API
+
+    public static class ApiHandle implements io.canvasmc.canvas.threadedregions.WorldRegionData {
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.worldData.world.getWorld();
+        }
+
+        @Override
+        public org.bukkit.Chunk getCenterChunk() {
+            ChunkPos pos = this.worldData.regionData.region.getCenterChunk();
+            return pos == null ? null : getWorld().getChunkAt(pos.longKey);
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getOwnedChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.chunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getTickingChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.tickingChunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public int getChunkCount() {
+            return this.worldData.getChunkCount();
+        }
+
+        @Override
+        public List<org.bukkit.entity.Player> getLocalPlayers() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.entity.Player> players = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final ServerPlayer localPlayer : this.worldData.localPlayers) {
+                players.add(localPlayer.getBukkitEntity());
+            }
+            return players;
+        }
+
+        @Override
+        public int getPlayerCount() {
+            return this.worldData.getPlayerCount();
+        }
+
+        @Override
+        public int getEntityCount() {
+            return this.worldData.getEntityCount();
+        }
+
+        @Override
+        public io.canvasmc.canvas.threadedregions.ThreadedWorldRegion getRegionizerRegion() {
+            return this.worldData.regionData.region.apiHandle;
+        }
+
+        private final RegionizedWorldData worldData;
+
+        public ApiHandle(RegionizedWorldData worldData) {
+            this.worldData = worldData;
+        }
+    }
+    // Canvas end - expand region API
 }
