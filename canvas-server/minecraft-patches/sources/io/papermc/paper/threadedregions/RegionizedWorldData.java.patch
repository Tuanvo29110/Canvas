--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -83,6 +_,7 @@
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
                 into.nearbyPlayers.addPlayer(player);
+                into.waypointManager.addPlayer(player); // Canvas - region threading - restore waypoints
             }
             for (final Entity entity : from.allEntities) {
                 into.allEntities.add(entity);
@@ -159,6 +_,10 @@
             for (final ChunkHolder chunkHolder : from.chunkHoldersToBroadcast) {
                 into.chunkHoldersToBroadcast.add(chunkHolder);
             }
+            // Canvas start - optimize entity/block ticking chunk lookups
+            into.blockTickingChunkHolders.addAll(from.blockTickingChunkHolders);
+            into.entityTickingChunkHolders.addAll(from.entityTickingChunkHolders);
+            // Canvas end
         }
 
         @Override
@@ -171,8 +_,12 @@
                 final ChunkPos pos = player.chunkPosition();
                 // Note: It is impossible for an entity in the world to _not_ be in an entity chunk, which means
                 // the chunk holder must _exist_, and so the region section exists.
-                regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift))
-                    .connections.add(conn);
+                // Canvas start - region threading - restore waypoints
+                from.waypointManager.removePlayer(player);
+                RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
+                into.connections.add(conn);
+                into.waypointManager.addPlayer(player);
+                // Canvas end
             }
             // entities
             for (final ServerPlayer player : from.localPlayers) {
@@ -326,6 +_,22 @@
                     into.chunkHoldersToBroadcast.add(chunkHolder);
                 }
             }
+            // Canvas start - optimize entity/block ticking chunk lookups
+            // we can just use 'regionToData' to find the chunk, since
+            // the long in this case *is* the chunk key
+            for (final long chunkKey : from.blockTickingChunkHolders) {
+                RegionizedWorldData worldData = regionToData.get(chunkKey);
+                if (worldData != null) {
+                    worldData.blockTickingChunkHolders.add(chunkKey);
+                }
+            }
+            for (final long chunkKey : from.entityTickingChunkHolders) {
+                RegionizedWorldData worldData = regionToData.get(chunkKey);
+                if (worldData != null) {
+                    worldData.entityTickingChunkHolders.add(chunkKey);
+                }
+            }
+            // Canvas end
         }
     };
 
@@ -334,7 +_,7 @@
     private RegionizedServer.WorldLevelData tickData;
 
     // connections
-    public final List<Connection> connections = new ArrayList<>();
+    public final List<Connection> connections = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
 
     // misc. fields
     private boolean isHandlingTick;
@@ -348,7 +_,8 @@
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    // this is copy on write to allow packet processing to iterate safely // Canvas - rewrite scheduler
+    private final java.util.concurrent.CopyOnWriteArrayList<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -364,8 +_,8 @@
     private final LevelTicks<Fluid> fluidLevelTicks;
 
     // tile entity ticking
-    private final List<TickingBlockEntity> pendingBlockEntityTickers = new ArrayList<>();
-    private final List<TickingBlockEntity> blockEntityTickers = new ArrayList<>();
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
+    private final List<TickingBlockEntity> blockEntityTickers = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(); // Canvas - optimized collection
     private boolean tickingBlockEntities;
 
     // time
@@ -418,11 +_,16 @@
     public boolean shouldSignal = true;
     public final Map<ServerExplosion.CacheKey, Float> explosionDensityCache = new HashMap<>(64, 0.25f);
     public final PathTypeCache pathTypesByPosCache = new PathTypeCache();
-    public final List<LevelChunk> temporaryChunkTickList = new java.util.ArrayList<>();
+    // Canvas - optimize chunk collect
     public final Set<ChunkHolder> chunkHoldersToBroadcast = new ReferenceLinkedOpenHashSet<>();
 
     // not transient
     public java.util.ArrayDeque<net.minecraft.world.level.block.RedstoneTorchBlock.Toggle> redstoneUpdateInfos;
+    // Canvas start - optimize fluid spread
+    // this is transient
+    public it.unimi.dsi.fastutil.longs.LongSet slopeDistanceCacheVisited = new it.unimi.dsi.fastutil.longs.LongOpenHashSet(512);
+    public net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque slopeDistanceCacheQueue = new net.minecraft.world.level.material.FlowingFluid.SlopeDistanceNodeDeque();
+    // Canvas end
 
     // Mob spawning
     public final ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<ServerPlayer> spawnChunkTracker = new ca.spottedleaf.moonrise.common.misc.PositionCountingAreaMap<>();
@@ -447,7 +_,34 @@
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+    public final ApiHandle apiHandle = new ApiHandle(this); // Canvas - expand region api
+    public final net.minecraft.server.waypoints.ServerWaypointManager waypointManager = new net.minecraft.server.waypoints.ServerWaypointManager(); // Canvas - region threading - restore waypoints
+
+    // Canvas start - optimize entity/block ticking chunk lookups
+    // if there's lots of chunks loaded, we don't want to search through that map to find block
+    // ticking holders or entity ticking holders, so we cache the ones that are valid to limit the search.
+    // the DynamicChunkPosLongSet is the fastest option for 'contains' operations(via tests conducted in V2)
+    public final Set<Long> blockTickingChunkHolders = new io.canvasmc.canvas.chunk.DynamicChunkPosLongSet();
+    public final Set<Long> entityTickingChunkHolders = new io.canvasmc.canvas.chunk.DynamicChunkPosLongSet();
+
+    public void markBlockTicking(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonBlockTickingIfPossible(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.blockTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markEntityTicking(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.add(newChunkHolder.getCachedLongPos());
+    }
+
+    public void markNonEntityTickingIfPossible(ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder) {
+        this.entityTickingChunkHolders.remove(newChunkHolder.getCachedLongPos());
+    }
+    // Canvas end
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +_,7 @@
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -500,6 +_,18 @@
         );
     }
 
+    // Canvas start - rewrite tick scheduler
+    public void addConnection(Connection connection, ServerPlayer serverPlayer) {
+        this.connections.add(connection);
+        this.waypointManager.addPlayer(serverPlayer); // Canvas - region threading - restore waypoints
+    }
+
+    public void removeConnection(Connection connection, ServerPlayer serverPlayer) {
+        this.connections.remove(connection);
+        this.waypointManager.removePlayer(serverPlayer); // Canvas - region threading - restore waypoints
+    }
+
+    // Canvas end
     // connections
     public void tickConnections() {
         final List<Connection> connections = new ArrayList<>(this.connections);
@@ -509,7 +_,7 @@
                 conn.handleDisconnection();
                 // global tick thread will not remove connections not owned by it, so we need to
                 RegionizedServer.getInstance().removeConnection(conn);
-                this.connections.remove(conn);
+                this.removeConnection(conn, conn.getPlayer()); // Canvas - rewrite tick scheduler
                 cleanUpConnection(conn);
                 continue;
             }
@@ -768,4 +_,72 @@
     public int getChunkCount() {
         return this.chunks.size();
     }
+    // Canvas start - expand region API
+
+    public static class ApiHandle implements io.canvasmc.canvas.threadedregions.WorldRegionData {
+        @Override
+        public org.bukkit.World getWorld() {
+            return this.worldData.world.getWorld();
+        }
+
+        @Override
+        public org.bukkit.Chunk getCenterChunk() {
+            ChunkPos pos = this.worldData.regionData.region.getCenterChunk();
+            return pos == null ? null : getWorld().getChunkAt(pos.longKey);
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getOwnedChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.chunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public List<org.bukkit.Chunk> getTickingChunks() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.Chunk> chunks = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final LevelChunk chunk : this.worldData.tickingChunks) {
+                chunks.add(getWorld().getChunkAt(chunk.coordinateKey));
+            }
+            return chunks;
+        }
+
+        @Override
+        public int getChunkCount() {
+            return this.worldData.getChunkCount();
+        }
+
+        @Override
+        public List<org.bukkit.entity.Player> getLocalPlayers() {
+            it.unimi.dsi.fastutil.objects.ObjectArrayList<org.bukkit.entity.Player> players = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+            for (final ServerPlayer localPlayer : this.worldData.localPlayers) {
+                players.add(localPlayer.getBukkitEntity());
+            }
+            return players;
+        }
+
+        @Override
+        public int getPlayerCount() {
+            return this.worldData.getPlayerCount();
+        }
+
+        @Override
+        public int getEntityCount() {
+            return this.worldData.getEntityCount();
+        }
+
+        @Override
+        public io.canvasmc.canvas.threadedregions.ThreadedWorldRegion getRegionizerRegion() {
+            return this.worldData.regionData.region.apiHandle;
+        }
+
+        private final RegionizedWorldData worldData;
+
+        public ApiHandle(RegionizedWorldData worldData) {
+            this.worldData = worldData;
+        }
+    }
+    // Canvas end
 }
