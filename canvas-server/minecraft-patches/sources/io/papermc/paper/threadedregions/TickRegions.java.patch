--- a/io/papermc/paper/threadedregions/TickRegions.java
+++ b/io/papermc/paper/threadedregions/TickRegions.java
@@ -45,6 +_,13 @@
         gridExponent = Math.min(31, gridExponent);
         regionShift = gridExponent;
 
+    // Canvas start - rewrite scheduler
+        scheduler = new TickRegionScheduler();
+    }
+
+    public static void start() {
+        final GlobalConfiguration.ThreadedRegions config = GlobalConfiguration.get().threadedRegions;
+    // Canvas end
         int tickThreads;
         if (config.threads <= 0) {
             tickThreads = Runtime.getRuntime().availableProcessors() / 2;
@@ -57,7 +_,7 @@
             tickThreads = config.threads;
         }
 
-        scheduler = new TickRegionScheduler(tickThreads);
+        scheduler.setThreads(tickThreads); // Canvas - rewrite scheduler
         LOGGER.info("Regionised ticking is enabled with " + tickThreads + " tick threads");
     }
 
@@ -171,7 +_,7 @@
         private final Reference2ReferenceOpenHashMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
 
         // tick data
-        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, SchedulerThreadPool.DEADLINE_NOT_SET);
+        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET); // Canvas - rewrite scheduler
 
         // queue data
         private final RegionizedTaskQueue.RegionTaskQueueData taskQueueData;
@@ -182,15 +_,64 @@
         // async-safe read-only region data
         private final RegionStats regionStats;
 
+        private final java.util.concurrent.atomic.AtomicBoolean hasPackets = new java.util.concurrent.atomic.AtomicBoolean(false); // Canvas - rewrite scheduler
         public volatile ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler; // Folia - profiler
 
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
-            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData);
+            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData, this); // Canvas - rewrite scheduler
             this.regionStats = new RegionStats();
         }
 
+        // Canvas start - rewrite scheduler
+        public void setHasTasks() {
+            TickRegions.getScheduler().setHasTasks(this.tickHandle);
+        }
+
+        public void setHasPackets() {
+            if (!this.hasPackets.get() && !this.hasPackets.compareAndExchange(false, true)) {
+                this.setHasTasks();
+            }
+        }
+
+        public boolean drainOnePacket() {
+            if (!this.hasPackets.get()) {
+                return false;
+            }
+
+            final RegionizedWorldData worldData = this.world.getCurrentWorldData();
+            boolean hasPacketsNew = false;
+
+            for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+                    continue;
+                }
+                if (player.getBukkitEntity().executeOnePacket()) {
+                    hasPacketsNew |= player.getBukkitEntity().hasPackets();
+                }
+            }
+
+            if (!hasPacketsNew) {
+                this.hasPackets.set(false);
+
+                // handle race condition: packet added during packet processing
+                for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                    if (player.getBukkitEntity().hasPackets()) {
+                        this.hasPackets.set(true);
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        public void drainPackets() {
+            while (this.drainOnePacket());
+        }
+
+        // Canvas end
         public RegionStats getRegionStats() {
             return this.regionStats;
         }
@@ -224,7 +_,7 @@
                 return ret;
             }
 
-            ret = regionizedData.createNewValue();
+            ret = regionizedData.createNewValue(this); // Canvas - rewrite scheduler
             this.regionizedData.put(regionizedData, ret);
 
             return ret;
@@ -242,6 +_,12 @@
             for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
                 final TickRegionData data = region.getData();
                 data.tickHandle.copyDeadlineAndTickCount(this.tickHandle);
+                // Canvas start - rewrite scheduler
+                // just be lazy about this one, it's not very important
+                if (this.hasPackets.getOpaque()) {
+                    data.hasPackets.setOpaque(true);
+                }
+                // Canvas end
             }
 
             // generic regionised data
@@ -309,6 +_,12 @@
             // there's not really a great solution to the tick problem, no matter what it'll be messed up
             // we will pick the greatest time delay so that tps will not exceed TICK_RATE
             data.tickHandle.updateSchedulingToMax(this.tickHandle);
+            // Canvas start - rewrite scheduler
+            // just be lazy about this one, it's not very important
+            if (this.hasPackets.getOpaque()) {
+                data.hasPackets.setOpaque(true);
+            }
+            // Canvas end
 
             // generic regionised data
             final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
@@ -350,11 +_,11 @@
         }
 
         private void updateSchedulingToMax(final ConcreteRegionTickHandle from) {
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(from.getScheduledStart());
                 return;
             }
@@ -365,7 +_,7 @@
         private void copyDeadlineAndTickCount(final ConcreteRegionTickHandle from) {
             this.currentTick = from.currentTick;
 
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
@@ -374,7 +_,7 @@
         }
 
         private void checkInitialSchedule() {
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
             }
         }
@@ -409,35 +_,37 @@
         }
 
         @Override
-        protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+        protected void runRegionTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia start - profiler
             profiler.startInBetweenTick(); try { // Folia - profiler
             final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
 
             boolean processedChunkTask = false;
 
-            boolean executeChunkTask = true;
-            boolean executeTickTask = true;
+            // Canvas start - rewrite scheduler
+            boolean executeChunkTask;
+            boolean executeTickTask;
+            boolean executePacketTask;
             do {
-                if (executeTickTask) {
-                    executeTickTask = queue.executeTickTask();
-                }
-                if (executeChunkTask) {
-                    processedChunkTask |= (executeChunkTask = queue.executeChunkTask());
-                }
-            } while ((executeChunkTask | executeTickTask) && canContinue.getAsBoolean());
+                executeTickTask = queue.executeTickTask();
+                executeChunkTask = queue.executeChunkTask();
+                executePacketTask = this.region.drainOnePacket();
+
+                processedChunkTask |= executeChunkTask;
+            } while ((executeChunkTask | executeTickTask | executePacketTask) && canContinue.getAsBoolean());
+            // Canvas end
 
             if (processedChunkTask) {
                 // if we processed any chunk tasks, try to process ticket level updates for full status changes
                 this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
             }
-            return true;
+            // Canvas - rewrite scheduler
             } finally { profiler.stopInBetweenTick(); } // Folia - profiler
         }
 
         @Override
         protected boolean hasIntermediateTasks() {
-            return this.region.taskQueueData.hasTasks();
+            return this.region.taskQueueData.hasTasks() || this.region.hasPackets.get(); // Canvas - rewrite scheduler
         }
     }
 
