--- a/io/papermc/paper/threadedregions/TickRegions.java
+++ b/io/papermc/paper/threadedregions/TickRegions.java
@@ -21,7 +_,7 @@
 
 public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> {
 
-    private static final Logger LOGGER = LogUtils.getLogger();
+    private static final Logger LOGGER = org.slf4j.LoggerFactory.getLogger("ThreadedRegions"); // Canvas - change LOGGER name
     private static int regionShift = 31;
 
     public static int getRegionChunkShift() {
@@ -45,6 +_,13 @@
         gridExponent = Math.min(31, gridExponent);
         regionShift = gridExponent;
 
+    // Canvas start - rewrite scheduler
+        scheduler = new TickRegionScheduler();
+    }
+
+    public static void start() {
+        final GlobalConfiguration.ThreadedRegions config = GlobalConfiguration.get().threadedRegions;
+    // Canvas end
         int tickThreads;
         if (config.threads <= 0) {
             tickThreads = Runtime.getRuntime().availableProcessors() / 2;
@@ -57,7 +_,7 @@
             tickThreads = config.threads;
         }
 
-        scheduler = new TickRegionScheduler(tickThreads);
+        scheduler.setThreads(tickThreads); // Canvas - rewrite scheduler
         LOGGER.info("Regionised ticking is enabled with " + tickThreads + " tick threads");
     }
 
@@ -76,16 +_,13 @@
         final TickRegionData data = region.getData();
         // post-region merge/split regioninfo update
         data.getRegionStats().updateFrom(data.getOrCreateRegionizedData(data.world.worldRegionData));
+        new io.canvasmc.canvas.event.region.RegionCreateEvent(region.apiHandle).callEvent(); // Canvas - expand region api
     }
 
     @Override
     public void onRegionDestroy(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
         // nothing for now
-        // Folia start - profiler
-        if (region.getData().profiler != null) {
-            region.getData().profiler.stopProfiler();
-        }
-        // Folia end - profiler
+        new io.canvasmc.canvas.event.region.RegionDestroyEvent(region.apiHandle).callEvent(); // Canvas - expand region api
     }
 
     @Override
@@ -93,6 +_,7 @@
         final TickRegionData data = region.getData();
 
         data.tickHandle.checkInitialSchedule();
+        new io.canvasmc.canvas.event.region.RegionActiveEvent(region.apiHandle).callEvent(); // Canvas - expand region api
         scheduler.scheduleRegion(data.tickHandle);
     }
 
@@ -101,6 +_,7 @@
         final TickRegionData data = region.getData();
 
         scheduler.descheduleRegion(data.tickHandle);
+        new io.canvasmc.canvas.event.region.RegionInactiveEvent(region.apiHandle).callEvent(); // Canvas - expand region api
         // old handle cannot be scheduled anymore, copy to a new handle
         data.tickHandle = data.tickHandle.copy();
     }
@@ -108,23 +_,13 @@
     @Override
     public void preMerge(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> into) {
-        // Folia start - profiler
-        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
-        if (profiler != null) {
-            profiler.profilerGroup.preMerge(from, into);
-        }
-        // Folia end - profiler
+
     }
 
     @Override
     public void preSplit(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> from,
                          final java.util.List<ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData>> into) {
-        // Folia start - profiler
-        final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = from.getData().profiler;
-        if (profiler != null) {
-            profiler.profilerGroup.preSplit(from, into);
-        }
-        // Folia end - profiler
+
     }
 
     public static final class TickRegionSectionData implements ThreadedRegionizer.ThreadedRegionSectionData {}
@@ -171,7 +_,7 @@
         private final Reference2ReferenceOpenHashMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
 
         // tick data
-        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, SchedulerThreadPool.DEADLINE_NOT_SET);
+        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET); // Canvas - rewrite scheduler
 
         // queue data
         private final RegionizedTaskQueue.RegionTaskQueueData taskQueueData;
@@ -182,15 +_,63 @@
         // async-safe read-only region data
         private final RegionStats regionStats;
 
-        public volatile ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler; // Folia - profiler
+        private final java.util.concurrent.atomic.AtomicBoolean hasPackets = new java.util.concurrent.atomic.AtomicBoolean(false); // Canvas - rewrite scheduler
 
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
-            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData);
+            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData, this); // Canvas - rewrite scheduler
             this.regionStats = new RegionStats();
         }
 
+        // Canvas start - rewrite scheduler
+        public void setHasTasks() {
+            TickRegions.getScheduler().setHasTasks(this.tickHandle);
+        }
+
+        public void setHasPackets() {
+            if (!this.hasPackets.get() && !this.hasPackets.compareAndExchange(false, true)) {
+                this.setHasTasks();
+            }
+        }
+
+        public boolean drainOnePacket() {
+            if (!this.hasPackets.get()) {
+                return false;
+            }
+
+            final RegionizedWorldData worldData = this.world.getCurrentWorldData();
+            boolean hasPacketsNew = false;
+
+            for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+                    continue;
+                }
+                if (player.getBukkitEntity().executeOnePacket()) {
+                    hasPacketsNew |= player.getBukkitEntity().hasPackets();
+                }
+            }
+
+            if (!hasPacketsNew) {
+                this.hasPackets.set(false);
+
+                // handle race condition: packet added during packet processing
+                for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                    if (player.getBukkitEntity().hasPackets()) {
+                        this.hasPackets.set(true);
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        public void drainPackets() {
+            while (this.drainOnePacket());
+        }
+
+        // Canvas end
         public RegionStats getRegionStats() {
             return this.regionStats;
         }
@@ -213,7 +_,7 @@
             return this.holderManagerRegionData;
         }
 
-        <T> T getRegionizedData(final RegionizedData<T> regionizedData) {
+        public <T> T getRegionizedData(final RegionizedData<T> regionizedData) { // Canvas - package-private -> public
             return (T)this.regionizedData.get(regionizedData);
         }
 
@@ -224,7 +_,7 @@
                 return ret;
             }
 
-            ret = regionizedData.createNewValue();
+            ret = regionizedData.createNewValue(this); // Canvas - rewrite scheduler
             this.regionizedData.put(regionizedData, ret);
 
             return ret;
@@ -242,6 +_,12 @@
             for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
                 final TickRegionData data = region.getData();
                 data.tickHandle.copyDeadlineAndTickCount(this.tickHandle);
+                // Canvas start - rewrite scheduler
+                // just be lazy about this one, it's not very important
+                if (this.hasPackets.getOpaque()) {
+                    data.hasPackets.setOpaque(true);
+                }
+                // Canvas end
             }
 
             // generic regionised data
@@ -309,6 +_,12 @@
             // there's not really a great solution to the tick problem, no matter what it'll be messed up
             // we will pick the greatest time delay so that tps will not exceed TICK_RATE
             data.tickHandle.updateSchedulingToMax(this.tickHandle);
+            // Canvas start - rewrite scheduler
+            // just be lazy about this one, it's not very important
+            if (this.hasPackets.getOpaque()) {
+                data.hasPackets.setOpaque(true);
+            }
+            // Canvas end
 
             // generic regionised data
             final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
@@ -350,11 +_,11 @@
         }
 
         private void updateSchedulingToMax(final ConcreteRegionTickHandle from) {
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(from.getScheduledStart());
                 return;
             }
@@ -365,7 +_,7 @@
         private void copyDeadlineAndTickCount(final ConcreteRegionTickHandle from) {
             this.currentTick = from.currentTick;
 
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
@@ -374,7 +_,7 @@
         }
 
         private void checkInitialSchedule() {
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
             }
         }
@@ -389,55 +_,40 @@
             return this.region.region.markNotTicking();
         }
 
-        // Folia start - profiler
-        @Override
-        protected void addTickTime(final TickRegionScheduler.TickTime time) {
-            super.addTickTime(time);
-
-            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler();
-            profiler.addTickTime(time);
-            profiler.checkStop();
-         }
-         // Folia end - profiler
-
         @Override
         protected void tickRegion(final int tickCount, final long startTime, final long scheduledEnd) {
-            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia - profiler
-            profiler.startTick(); try { // Folia - profiler
             MinecraftServer.getServer().tickServer(startTime, scheduledEnd, TimeUnit.MILLISECONDS.toMillis(10L), this.region);
-            } finally { profiler.stopTick(); } // Folia - profiler
         }
 
         @Override
-        protected boolean runRegionTasks(final BooleanSupplier canContinue) {
-            final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia start - profiler
-            profiler.startInBetweenTick(); try { // Folia - profiler
+        protected void runRegionTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
 
             boolean processedChunkTask = false;
 
-            boolean executeChunkTask = true;
-            boolean executeTickTask = true;
+            // Canvas start - rewrite scheduler
+            boolean executeChunkTask;
+            boolean executeTickTask;
+            boolean executePacketTask;
             do {
-                if (executeTickTask) {
-                    executeTickTask = queue.executeTickTask();
-                }
-                if (executeChunkTask) {
-                    processedChunkTask |= (executeChunkTask = queue.executeChunkTask());
-                }
-            } while ((executeChunkTask | executeTickTask) && canContinue.getAsBoolean());
+                executeTickTask = queue.executeTickTask();
+                executeChunkTask = queue.executeChunkTask();
+                executePacketTask = this.region.drainOnePacket();
+
+                processedChunkTask |= executeChunkTask;
+            } while ((executeChunkTask | executeTickTask | executePacketTask) && canContinue.getAsBoolean());
+            // Canvas end
 
             if (processedChunkTask) {
                 // if we processed any chunk tasks, try to process ticket level updates for full status changes
                 this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
             }
-            return true;
-            } finally { profiler.stopInBetweenTick(); } // Folia - profiler
+            // Canvas - rewrite scheduler
         }
 
         @Override
         protected boolean hasIntermediateTasks() {
-            return this.region.taskQueueData.hasTasks();
+            return this.region.taskQueueData.hasTasks() || this.region.hasPackets.get(); // Canvas - rewrite scheduler
         }
     }
 
