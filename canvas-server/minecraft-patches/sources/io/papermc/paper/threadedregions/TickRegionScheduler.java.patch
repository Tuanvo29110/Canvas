--- a/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -41,10 +_,10 @@
     }
     // Folia end - watchdog
 
-    private final SchedulerThreadPool scheduler;
+    private final io.canvasmc.canvas.tick.ScheduledTaskThreadPool scheduler; // Canvas - rewrite scheduler
 
-    public TickRegionScheduler(final int threads) {
-        this.scheduler = new SchedulerThreadPool(threads, new ThreadFactory() {
+    public TickRegionScheduler() { // Canvas - rewrite scheduler
+        this.scheduler = new io.canvasmc.canvas.tick.ScheduledTaskThreadPool(new ThreadFactory() { // Canvas - rewrite scheduler
             private final AtomicInteger idGenerator = new AtomicInteger();
 
             @Override
@@ -53,11 +_,17 @@
                 ret.setUncaughtExceptionHandler(TickRegionScheduler.this::uncaughtException);
                 return ret;
             }
-        });
+    // Canvas start - rewrite scheduler
+        }, TimeUnit.MILLISECONDS.toNanos(3L), TimeUnit.MILLISECONDS.toNanos(2L));
+    }
+
+    public void setThreads(final int threads) {
+        this.scheduler.setCoreThreads(threads);
+    // Canvas end
     }
 
     public int getTotalThreadCount() {
-        return this.scheduler.getThreads().length;
+        return this.scheduler.getAliveThreads().length; // Canvas - rewrite scheduler
     }
 
     private static void setTickingRegion(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
@@ -84,7 +_,7 @@
         }
     }
 
-    private static void setTickTask(final SchedulerThreadPool.SchedulableTick task) {
+    private static void setTickTask(final io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task) { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             throw new IllegalStateException("Must be tick thread runner");
@@ -127,7 +_,7 @@
      * Returns the current ticking task, or {@code null} if there is no ticking region.
      * If this thread is not a TickThread, then returns {@code null}.
      */
-    public static SchedulerThreadPool.SchedulableTick getCurrentTickingTask() {
+    public static io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick getCurrentTickingTask() { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             return null;
@@ -165,22 +_,21 @@
         region.markNonSchedulable();
     }
 
-    /**
-     * Updates the tick start to the farthest into the future of its current scheduled time and the
-     * provided time.
-     * @return {@code false} if the region was not scheduled or is currently ticking or the specified time is less-than its
-     *                       current start time, {@code true} if the next tick start was adjusted.
-     */
-    public boolean updateTickStartToMax(final RegionScheduleHandle region, final long newStart) {
-        return this.scheduler.updateTickStartToMax(region, newStart);
-    }
+    // Canvas - rewrite scheduler
 
     public boolean halt(final boolean sync, final long maxWaitNS) {
-        return this.scheduler.halt(sync, maxWaitNS);
+        // Canvas start - rewrite scheduler
+        this.scheduler.halt();
+        if (!sync) {
+            return this.scheduler.getAliveThreads().length == 0;
+        }
+
+        return this.scheduler.join(maxWaitNS == 0L ? 0L : Math.max(1L, TimeUnit.NANOSECONDS.toMillis(maxWaitNS)));
+        // Canvas end
     }
 
     void dumpAliveThreadTraces(final String reason) {
-        for (final Thread thread : this.scheduler.getThreads()) {
+        for (final Thread thread : this.scheduler.getAliveThreads()) { // Canvas - rewrite scheduler
             if (thread.isAlive()) {
                 TraceUtil.dumpTraceForThread(thread, reason);
             }
@@ -191,16 +_,14 @@
         this.scheduler.notifyTasks(region);
     }
 
-    public void init() {
-        this.scheduler.start();
-    }
+    // Canvas - rewrite scheduler
 
     private void uncaughtException(final Thread thread, final Throwable thr) {
         LOGGER.error("Uncaught exception in tick thread \"" + thread.getName() + "\"", thr);
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        this.scheduler.halt(); // Canvas - rewrite scheduler
 
         MinecraftServer.getServer().stopServer();
     }
@@ -210,7 +_,7 @@
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        this.scheduler.halt(); // Canvas - rewrite scheduler
 
         final ChunkPos center = handle.region == null ? null : handle.region.region.getCenterChunk();
         final ServerLevel world = handle.region == null ? null : handle.region.world;
@@ -226,7 +_,7 @@
 
         private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
         private RegionizedWorldData currentTickingWorldRegionizedData;
-        private SchedulerThreadPool.SchedulableTick currentTickingTask;
+        private io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick currentTickingTask; // Canvas - rewrite scheduler
         // Folia start - profiler
         private ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
         // Folia end - profiler
@@ -236,7 +_,7 @@
         }
     }
 
-    public static abstract class RegionScheduleHandle extends SchedulerThreadPool.SchedulableTick {
+    public static abstract class RegionScheduleHandle extends io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick { // Canvas - rewrite scheduler
 
         protected long currentTick;
         protected long lastTickStart;
@@ -258,7 +_,7 @@
 
         public RegionScheduleHandle(final TickRegions.TickRegionData region, final long firstStart) {
             this.currentTick = 0L;
-            this.lastTickStart = SchedulerThreadPool.DEADLINE_NOT_SET;
+            this.lastTickStart = io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
             this.tickTimes5s = new TickData(TimeUnit.SECONDS.toNanos(5L));
             this.tickTimes15s = new TickData(TimeUnit.SECONDS.toNanos(15L));
             this.tickTimes1m = new TickData(TimeUnit.MINUTES.toNanos(1L));
@@ -267,16 +_,16 @@
             this.region = region;
 
             this.setScheduledStart(firstStart);
-            this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
+            this.tickSchedule = new Schedule(firstStart == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS); // Canvas - rewrite scheduler
         }
 
         /**
-         * Subclasses should call this instead of {@link ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick#setScheduledStart(long)}
+         * Subclasses should call this instead of {@link #setScheduledStart(long)} // Canvas - rewrite scheduler
          * so that the tick schedule and scheduled start remain synchronised
          */
         protected final void updateScheduledStart(final long to) {
             this.setScheduledStart(to);
-            this.tickSchedule.setLastPeriod(to == SchedulerThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS);
+            this.tickSchedule.setLastPeriod(to == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS); // Canvas - rewrite scheduler
         }
 
         public final void markNonSchedulable() {
@@ -293,7 +_,7 @@
 
         protected abstract void tickRegion(final int tickCount, final long startTime, final long scheduledEnd);
 
-        protected abstract boolean runRegionTasks(final BooleanSupplier canContinue);
+        protected abstract void runRegionTasks(final BooleanSupplier canContinue); // Canvas - rewrite scheduler
 
         protected abstract boolean hasIntermediateTasks();
 
@@ -303,9 +_,9 @@
         }
 
         @Override
-        public final Boolean runTasks(final BooleanSupplier canContinue) {
+        public final boolean runTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             if (this.cancelled.get()) {
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
@@ -316,7 +_,7 @@
                     throw new IllegalStateException("Scheduled region should be acquirable");
                 }
                 // region was killed
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             TickRegionScheduler.setTickTask(this);
@@ -326,8 +_,8 @@
 
             synchronized (this) {
                 this.currentTickData = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart, // Canvas - rewrite scheduler
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     false
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -337,20 +_,20 @@
             final FoliaWatchdogThread.RunningTick runningTick = new FoliaWatchdogThread.RunningTick(tickStart, this, Thread.currentThread()); // Folia - watchdog
             WATCHDOG_THREAD.addTick(runningTick); // Folia - watchdog
             try {
-                ret = this.runRegionTasks(() -> {
+                this.runRegionTasks(() -> { // Canvas - rewrite scheduler
                     return !RegionScheduleHandle.this.cancelled.get() && canContinue.getAsBoolean();
                 });
             } catch (final Throwable thr) {
                 this.scheduler.regionFailed(this, true, thr);
                 // don't release region for another tick
-                return null;
+                return false; // Canvas - rewrite scheduler
             } finally {
                 WATCHDOG_THREAD.removeTick(runningTick); // Folia - watchdog
                 final long tickEnd = System.nanoTime();
                 final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
 
                 final TickTime time = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, // Canvas - rewrite scheduler
                     tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, false
                 );
 
@@ -361,7 +_,7 @@
                 }
             }
 
-            return !this.markNotTicking() || this.cancelled.get() ? null : Boolean.valueOf(ret);
+            return this.markNotTicking() && !this.cancelled.get(); // Canvas - rewrite scheduler
         }
 
         @Override
@@ -405,7 +_,7 @@
             synchronized (this) {
                 this.currentTickData = new TickTime(
                     lastTickStart, scheduledStart, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     true
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -582,7 +_,7 @@
          * Only valid when {@link #isTickExecution()} is {@code true}.
          */
         public boolean hasLastTick() {
-            return this.previousTickStart != SchedulerThreadPool.DEADLINE_NOT_SET;
+            return this.previousTickStart != io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
         }
 
         /*
