--- a/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -41,10 +_,10 @@
     }
     // Folia end - watchdog
 
-    private final SchedulerThreadPool scheduler;
+    public final io.canvasmc.canvas.tick.ScheduledTaskThreadPool scheduler; // Canvas - rewrite scheduler
 
-    public TickRegionScheduler(final int threads) {
-        this.scheduler = new SchedulerThreadPool(threads, new ThreadFactory() {
+    public TickRegionScheduler() { // Canvas - rewrite scheduler
+        this.scheduler = new io.canvasmc.canvas.tick.ScheduledTaskThreadPool(new ThreadFactory() { // Canvas - rewrite scheduler
             private final AtomicInteger idGenerator = new AtomicInteger();
 
             @Override
@@ -53,11 +_,33 @@
                 ret.setUncaughtExceptionHandler(TickRegionScheduler.this::uncaughtException);
                 return ret;
             }
-        });
+    // Canvas start - rewrite scheduler
+        }, TimeUnit.MILLISECONDS.toNanos(3L), TimeUnit.MILLISECONDS.toNanos(2L));
+    }
+
+    private static float currTickRate = RegionizedServer.DEFAULT_TICK_RATE;
+    private static long currTimeBetweenTicks = RegionizedServer.DEFAULT_TICK_TIME_NANOS;
+
+    public static void modifyTickRate(final float newRate) {
+        currTickRate = newRate;
+        currTimeBetweenTicks = RegionizedServer.tickTimeNanosFromRate(newRate);
+    }
+
+    public static float getTickRate() {
+        return currTickRate;
+    }
+
+    public static long getTimeBetweenTicks() {
+        return currTimeBetweenTicks;
+    }
+
+    public void setThreads(final int threads) {
+        this.scheduler.setCoreThreads(threads);
+    // Canvas end - rewrite scheduler
     }
 
     public int getTotalThreadCount() {
-        return this.scheduler.getThreads().length;
+        return this.scheduler.getAliveThreads().length; // Canvas - rewrite scheduler
     }
 
     private static void setTickingRegion(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
@@ -79,7 +_,7 @@
         }
     }
 
-    private static void setTickTask(final SchedulerThreadPool.SchedulableTick task) {
+    private static void setTickTask(final io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task) { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             throw new IllegalStateException("Must be tick thread runner");
@@ -104,6 +_,16 @@
         }
         return tickThreadRunner.currentTickingRegion;
     }
+    // Canvas start - add check for if the current running region is a tick runner
+
+    /**
+     * Returns if the current thread is a tick thread runner
+     */
+    public static boolean isTickRunner() {
+        final Thread currThread = Thread.currentThread();
+        return currThread instanceof TickThreadRunner;
+    }
+    // Canvas end
 
     /**
      * Returns the current ticking region's world regionised data, or {@code null} if there is no ticking region.
@@ -122,7 +_,7 @@
      * Returns the current ticking task, or {@code null} if there is no ticking region.
      * If this thread is not a TickThread, then returns {@code null}.
      */
-    public static SchedulerThreadPool.SchedulableTick getCurrentTickingTask() {
+    public static io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick getCurrentTickingTask() { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             return null;
@@ -149,22 +_,21 @@
         region.markNonSchedulable();
     }
 
-    /**
-     * Updates the tick start to the farthest into the future of its current scheduled time and the
-     * provided time.
-     * @return {@code false} if the region was not scheduled or is currently ticking or the specified time is less-than its
-     *                       current start time, {@code true} if the next tick start was adjusted.
-     */
-    public boolean updateTickStartToMax(final RegionScheduleHandle region, final long newStart) {
-        return this.scheduler.updateTickStartToMax(region, newStart);
-    }
+    // Canvas - rewrite scheduler
 
     public boolean halt(final boolean sync, final long maxWaitNS) {
-        return this.scheduler.halt(sync, maxWaitNS);
+        // Canvas start - rewrite scheduler
+        this.scheduler.halt();
+        if (!sync) {
+            return this.scheduler.getAliveThreads().length == 0;
+        }
+
+        return this.scheduler.join(maxWaitNS == 0L ? 0L : Math.max(1L, TimeUnit.NANOSECONDS.toMillis(maxWaitNS)));
+        // Canvas end - rewrite scheduler
     }
 
     void dumpAliveThreadTraces(final String reason) {
-        for (final Thread thread : this.scheduler.getThreads()) {
+        for (final Thread thread : this.scheduler.getAliveThreads()) { // Canvas - rewrite scheduler
             if (thread.isAlive()) {
                 TraceUtil.dumpTraceForThread(thread, reason);
             }
@@ -175,16 +_,24 @@
         this.scheduler.notifyTasks(region);
     }
 
-    public void init() {
-        this.scheduler.start();
-    }
+    // Canvas - rewrite scheduler
 
     private void uncaughtException(final Thread thread, final Throwable thr) {
         LOGGER.error("Uncaught exception in tick thread \"" + thread.getName() + "\"", thr);
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        // Canvas start - rewrite scheduler
+        net.minecraft.CrashReport crashReport = net.minecraft.CrashReport.forThrowable(thr, "Region Crash");
+        net.minecraft.server.MinecraftServer.getServer().fillSystemReport(crashReport.getSystemReport());
+        java.nio.file.Path path = net.minecraft.server.MinecraftServer.getServer().getServerDirectory().resolve("crash-reports").resolve("crash-" + net.minecraft.Util.getFilenameFormattedDateTime() + "-server.txt");
+        if (crashReport.saveToFile(path, net.minecraft.ReportType.CRASH)) {
+            LOGGER.error("This crash report has been saved to: {}", path.toAbsolutePath());
+        } else {
+            LOGGER.error("We were unable to save this crash report to disk.");
+        }
+        this.scheduler.halt();
+        // Canvas end - rewrite scheduler
 
         MinecraftServer.getServer().stopServer();
     }
@@ -194,7 +_,20 @@
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        // Canvas start - rewrite scheduler
+        net.minecraft.CrashReport crashReport = net.minecraft.CrashReport.forThrowable(thr, "Region Crash");
+        net.minecraft.server.MinecraftServer.getServer().fillSystemReport(crashReport.getSystemReport());
+        net.minecraft.CrashReportCategory crashReportCategory = crashReport.addCategory("Region Context");
+        crashReportCategory.setDetail("Executing Tasks", () -> String.valueOf(executingTasks));
+        crashReportCategory.setDetail("RegionScheduleHandle", handle.region == null ? "Not available" : handle.region.region);
+        java.nio.file.Path path = net.minecraft.server.MinecraftServer.getServer().getServerDirectory().resolve("crash-reports").resolve("crash-" + net.minecraft.Util.getFilenameFormattedDateTime() + "-server.txt");
+        if (crashReport.saveToFile(path, net.minecraft.ReportType.CRASH)) {
+            LOGGER.error("This crash report has been saved to: {}", path.toAbsolutePath());
+        } else {
+            LOGGER.error("We were unable to save this crash report to disk.");
+        }
+        this.scheduler.halt();
+        // Canvas end - rewrite scheduler
 
         final ChunkPos center = handle.region == null ? null : handle.region.region.getCenterChunk();
         final ServerLevel world = handle.region == null ? null : handle.region.world;
@@ -210,14 +_,14 @@
 
         private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
         private RegionizedWorldData currentTickingWorldRegionizedData;
-        private SchedulerThreadPool.SchedulableTick currentTickingTask;
+        private io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick currentTickingTask; // Canvas - rewrite scheduler
 
         public TickThreadRunner(final Runnable run, final String name) {
             super(run, name);
         }
     }
 
-    public static abstract class RegionScheduleHandle extends SchedulerThreadPool.SchedulableTick {
+    public static abstract class RegionScheduleHandle extends io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick { // Canvas - rewrite scheduler
 
         protected long currentTick;
         protected long lastTickStart;
@@ -236,10 +_,13 @@
         protected final Schedule tickSchedule;
 
         private TickRegionScheduler scheduler;
+        public long ticksToSprint = 0; // Canvas - rewrite scheduler
+        public boolean wasSprinting = false; // Canvas - rewrite scheduler
+        public long startSprintNanos = System.nanoTime(); // Canvas - rewrite scheduler
 
         public RegionScheduleHandle(final TickRegions.TickRegionData region, final long firstStart) {
             this.currentTick = 0L;
-            this.lastTickStart = SchedulerThreadPool.DEADLINE_NOT_SET;
+            this.lastTickStart = io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
             this.tickTimes5s = new TickData(TimeUnit.SECONDS.toNanos(5L));
             this.tickTimes15s = new TickData(TimeUnit.SECONDS.toNanos(15L));
             this.tickTimes1m = new TickData(TimeUnit.MINUTES.toNanos(1L));
@@ -248,16 +_,16 @@
             this.region = region;
 
             this.setScheduledStart(firstStart);
-            this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
+            this.tickSchedule = new Schedule(firstStart == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - getTimeBetweenTicks()); // Canvas - rewrite scheduler
         }
 
         /**
-         * Subclasses should call this instead of {@link ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick#setScheduledStart(long)}
+         * Subclasses should call this instead of {@link #setScheduledStart(long)} // Canvas - rewrite scheduler
          * so that the tick schedule and scheduled start remain synchronised
          */
         protected final void updateScheduledStart(final long to) {
             this.setScheduledStart(to);
-            this.tickSchedule.setLastPeriod(to == SchedulerThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS);
+            this.tickSchedule.setLastPeriod(to == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? to : to - getTimeBetweenTicks()); // Canvas - rewrite scheduler
         }
 
         public final void markNonSchedulable() {
@@ -274,7 +_,7 @@
 
         protected abstract void tickRegion(final int tickCount, final long startTime, final long scheduledEnd);
 
-        protected abstract boolean runRegionTasks(final BooleanSupplier canContinue);
+        protected abstract void runRegionTasks(final BooleanSupplier canContinue); // Canvas - rewrite scheduler
 
         protected abstract boolean hasIntermediateTasks();
 
@@ -284,9 +_,9 @@
         }
 
         @Override
-        public final Boolean runTasks(final BooleanSupplier canContinue) {
+        public final boolean runTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             if (this.cancelled.get()) {
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
@@ -297,7 +_,7 @@
                     throw new IllegalStateException("Scheduled region should be acquirable");
                 }
                 // region was killed
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             TickRegionScheduler.setTickTask(this);
@@ -307,8 +_,8 @@
 
             synchronized (this) {
                 this.currentTickData = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart, // Canvas - rewrite scheduler
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     false
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -318,20 +_,20 @@
             final FoliaWatchdogThread.RunningTick runningTick = new FoliaWatchdogThread.RunningTick(tickStart, this, Thread.currentThread()); // Folia - watchdog
             WATCHDOG_THREAD.addTick(runningTick); // Folia - watchdog
             try {
-                ret = this.runRegionTasks(() -> {
+                this.runRegionTasks(() -> { // Canvas - rewrite scheduler
                     return !RegionScheduleHandle.this.cancelled.get() && canContinue.getAsBoolean();
                 });
             } catch (final Throwable thr) {
                 this.scheduler.regionFailed(this, true, thr);
                 // don't release region for another tick
-                return null;
+                return false; // Canvas - rewrite scheduler
             } finally {
                 WATCHDOG_THREAD.removeTick(runningTick); // Folia - watchdog
                 final long tickEnd = System.nanoTime();
                 final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
 
                 final TickTime time = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, // Canvas - rewrite scheduler
                     tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, false
                 );
 
@@ -342,7 +_,7 @@
                 }
             }
 
-            return !this.markNotTicking() || this.cancelled.get() ? null : Boolean.valueOf(ret);
+            return this.markNotTicking() && !this.cancelled.get(); // Canvas - rewrite scheduler
         }
 
         @Override
@@ -355,9 +_,25 @@
 
             final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
             final long tickStart = System.nanoTime();
+            // Canvas start - rewrite scheduler
+            boolean isSprinting = ticksToSprint > 0;
+            if (isSprinting) {
+                ticksToSprint--;
+                if (!wasSprinting) {
+                    startSprintNanos = System.nanoTime();
+                    wasSprinting = true;
+                }
+            } else if (wasSprinting) {
+                String name = this instanceof io.papermc.paper.threadedregions.RegionizedServer.GlobalTickTickHandle ?
+                    "Global Tick" : this.region.region.toString();
+                LOGGER.info("Scheduling Handle for {} finished tick sprint in {}ms", name, (System.nanoTime() - startSprintNanos) / 1e+6);
+                wasSprinting = false;
+            }
+            long deadlineFuture = isSprinting ? 1 : getTimeBetweenTicks(); // if sprinting, future is 0ns
+            // Canvas end - rewrite scheduler
 
             // use max(), don't assume that tickStart >= scheduledStart
-            final int tickCount = Math.max(1, this.tickSchedule.getPeriodsAhead(TIME_BETWEEN_TICKS, tickStart));
+            final int tickCount = Math.max(1, this.tickSchedule.getPeriodsAhead(deadlineFuture, tickStart)); // Canvas - rewrite scheduler
 
             if (!this.tryMarkTicking()) {
                 if (!this.cancelled.get()) {
@@ -381,12 +_,12 @@
             this.lastTickStart = tickStart;
 
             final long scheduledStart = this.getScheduledStart();
-            final long scheduledEnd = scheduledStart + TIME_BETWEEN_TICKS;
+            final long scheduledEnd = scheduledStart + deadlineFuture; // Canvas - rewrite scheduler
 
             synchronized (this) {
                 this.currentTickData = new TickTime(
                     lastTickStart, scheduledStart, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     true
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -409,8 +_,10 @@
                 // in order to ensure all regions get their chance at scheduling, we have to ensure that regions
                 // that exceed the max tick time are not always prioritised over everything else. Thus, we use the greatest
                 // of the current time and "ideal" next tick start.
-                this.tickSchedule.advanceBy(tickCount, TIME_BETWEEN_TICKS);
-                this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(TIME_BETWEEN_TICKS)));
+                // Canvas start - rewrite scheduler
+                this.tickSchedule.advanceBy(tickCount, deadlineFuture);
+                this.setScheduledStart(TimeUtil.getGreatestTime(tickEnd, this.tickSchedule.getDeadline(deadlineFuture)));
+                // Canvas end - rewrite scheduler
 
                 final TickTime time = new TickTime(
                     lastTickStart, scheduledStart, tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, true
@@ -548,14 +_,14 @@
 
         /**
          * The difference in time from the start of the last tick to the start of the current tick. If there is no
-         * last tick, then this value is max(TIME_BETWEEN_TICKS, tickLength).
+         * last tick, then this value is max(getTimeBetweenTicks(), tickLength).
          * Only valid when {@link #isTickExecution()} is {@code true}.
          */
         public final long differenceFromLastTick() {
             if (this.hasLastTick()) {
                 return this.tickStart - this.previousTickStart;
             }
-            return Math.max(TIME_BETWEEN_TICKS, this.tickLength());
+            return Math.max(getTimeBetweenTicks(), this.tickLength()); // Canvas - rewrite scheduler
         }
 
         /**
@@ -563,7 +_,7 @@
          * Only valid when {@link #isTickExecution()} is {@code true}.
          */
         public boolean hasLastTick() {
-            return this.previousTickStart != SchedulerThreadPool.DEADLINE_NOT_SET;
+            return this.previousTickStart != io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
         }
 
         /*
