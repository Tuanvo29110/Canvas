--- a/io/papermc/paper/threadedregions/TickData.java
+++ b/io/papermc/paper/threadedregions/TickData.java
@@ -20,6 +_,12 @@
     }
 
     public void addDataFrom(final TickRegionScheduler.TickTime time) {
+        // Canvas start - rewrite scheduler
+        if (!time.isTickExecution()) {
+            // TODO fix later
+            return;
+        }
+        // Canvas end - rewrite scheduler
         final long start = time.tickStart();
 
         TickRegionScheduler.TickTime first;
@@ -174,7 +_,7 @@
             } else {
                 long totalTickTime = 0L;
                 long totalCpuTime = 0L;
-                for (int k = 0, len2 = collapsedData.size(); k < len2; ++k) {
+                for (int k = 0, len2 = toCollapse.size(); k < len2; ++k) { // Canvas - fix index bounds with rewritten scheduler
                     final TickRegionScheduler.TickTime time = toCollapse.get(k);
                     totalTickTime += time.tickLength();
                     totalCpuTime += time.supportCPUTime() ? time.tickCpuTime() : 0L;
@@ -205,7 +_,7 @@
                         // Otherwise use the interval length.
                         // This is how differenceFromLastTick() works on TickTime when there is no previous interval.
                         differenceBetweenTicks = Math.max(
-                            TickRegionScheduler.TIME_BETWEEN_TICKS, totalTickTime
+                            TickRegionScheduler.getTimeBetweenTicks(), totalTickTime // Canvas - rewrite scheduler
                         );
                     }
 
