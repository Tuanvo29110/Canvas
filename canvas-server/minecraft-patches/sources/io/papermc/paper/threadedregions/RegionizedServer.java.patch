--- a/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -56,6 +_,7 @@
 
     public void addWorld(final ServerLevel world) {
         this.worlds.add(world);
+        world.updateTickData(); // Canvas - update tick data on world add
     }
 
     public void init() {
@@ -65,7 +_,7 @@
         // now we can schedule
         this.tickHandle.setInitialStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
         TickRegions.getScheduler().scheduleRegion(this.tickHandle);
-        TickRegions.getScheduler().init();
+        TickRegions.start(); // Canvas - rewrite scheduler
     }
 
     public void invalidateStatus() {
@@ -93,6 +_,17 @@
         return;
     }
 
+    // Canvas start - rewrite scheduler
+    private boolean hasAnyGlobalChunkTasks() {
+        for (final ServerLevel world : this.worlds) {
+            if (world.taskQueueRegionData.hasGlobalChunkTasks()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Canvas end - rewrite scheduler
     /**
      * Returns the current tick of the region ticking.
      * @throws IllegalStateException If there is no current region.
@@ -131,7 +_,7 @@
         private final AtomicBoolean ticking = new AtomicBoolean();
 
         public GlobalTickTickHandle(final RegionizedServer server) {
-            super(null, SchedulerThreadPool.DEADLINE_NOT_SET);
+            super(null, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET); // Canvas - rewrite scheduler
             this.server = server;
         }
 
@@ -177,20 +_,28 @@
             return true;
         }
 
+        // Canvas start - rewrite scheduler
+        private boolean runGlobalTask() {
+            boolean ret = false;
+            for (final ServerLevel world : this.server.worlds) {
+                ret |= world.taskQueueRegionData.executeGlobalChunkTask();
+            }
+            return ret;
+        }
+
         @Override
-        protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+        protected void runRegionTasks(final BooleanSupplier canContinue) {
             do {
-                if (!this.runOneTask()) {
-                    return false;
+                if (!this.runOneTask() || !this.runGlobalTask()) {
+                    return;
                 }
             } while (canContinue.getAsBoolean());
-
-            return true;
+        // Canvas end - rewrite scheduler
         }
 
         @Override
         protected boolean hasIntermediateTasks() {
-            return !this.server.globalTickQueue.isEmpty();
+            return !this.server.globalTickQueue.isEmpty() || this.server.hasAnyGlobalChunkTasks(); // Canvas - rewrite scheduler
         }
     }
 
@@ -414,6 +_,42 @@
     // A global tick only updates things like weather / worldborder, basically anything in the world that is
     // NOT tied to a specific region, but rather shared amongst all of them.
     private void globalTick(final ServerLevel world, final int tickCount) {
+        // Canvas start - fix world loading/unloading
+        if (world.isUnloading) {
+            // we are unloading, return.
+            AtomicBoolean isSingularRegionAlive = new AtomicBoolean(false);
+            world.regioniser.computeForAllRegionsUnsynchronised((region) -> {
+                if (!region.getData().isClosed) {
+                    // region still active, possibly still saving or hasn't gotten to that yet
+                    isSingularRegionAlive.set(true);
+                }
+            });
+            if (!isSingularRegionAlive.get()) {
+                LOGGER.info("Finalizing unload of world '" + world.getWorld().getName() + "'");
+                // double check that *all* players are removed from this world, since they may
+                // be added in some weird spot during shutdown of the world that we didn't catch previously
+                for (final net.minecraft.server.level.ServerPlayer player : world.players()) {
+                    player.getBukkitEntity().kick(net.kyori.adventure.text.Component.text("World unloading"), org.bukkit.event.player.PlayerKickEvent.Cause.WORLD_UNLOAD);
+                }
+                // all regions saved and players are removed, we can now close this world
+                world.moonrise$getChunkTaskScheduler().halt(false, 0L);
+                world.chunkSource.getDataStorage().close();
+                world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(false, true, true, false, false);
+                io.papermc.paper.FeatureHooks.closeEntityManager(world, false); // SPIGOT-6722: close entityManager // Paper - chunk system
+                try {
+                    world.levelStorageAccess.close();
+                } catch (java.io.IOException e) {
+                    throw new RuntimeException("Unable to close level storage access for world unload", e);
+                }
+                this.worlds.remove(world);
+                MinecraftServer.getServer().removeLevel(world);
+                MinecraftServer.getServer().server.worlds.remove(world.getWorld().getName().toLowerCase(java.util.Locale.ROOT));
+                LOGGER.info("Completed unload of world '{}'", world.getWorld().getName());
+                world.unloadFuture.complete(true);
+            }
+            return;
+        }
+        // Canvas end - fix world loading/unloading
         // needs
         // worldborder tick
         // advancing the weather cycle
@@ -442,6 +_,18 @@
 
         // time ticking (TODO API synchronisation?)
         this.tickTime(world, tickCount);
+        // Canvas start - fix end credits
+        List<net.minecraft.server.level.ServerPlayer> players = world.getServer().getPlayerList().seeingEndCredits;
+        for (java.util.Iterator<net.minecraft.server.level.ServerPlayer> iterator = players.iterator(); iterator.hasNext(); ) {
+            final net.minecraft.server.level.ServerPlayer serverPlayer = iterator.next();
+            if (serverPlayer.hasDisconnected()) {
+                iterator.remove();
+                LOGGER.info("Player disconnected while viewing end credits, removing from fallback keepalive");
+                continue;
+            }
+            serverPlayer.connection.keepConnectionAlive();
+        }
+        // Canvas end
 
         world.updateTickData();
 
