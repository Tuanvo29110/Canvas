--- a/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/player/RegionizedPlayerChunkLoader.java
@@ -383,8 +_,12 @@
             final int centerZ = PlayerChunkLoaderData.this.lastChunkZ;
 
             return Integer.compare(
-                Math.abs(c1x - centerX) + Math.abs(c1z - centerZ),
-                Math.abs(c2x - centerX) + Math.abs(c2z - centerZ)
+                // Canvas start - use Euclidean distance squared
+                io.canvasmc.canvas.Config.INSTANCE.chunks.useEuclideanDistanceSquared ?
+                    (c1x - centerX) * (c1x - centerX) + (c1z - centerZ) * (c1z - centerZ) : Math.abs(c1x - centerX) + Math.abs(c1z - centerZ),
+                io.canvasmc.canvas.Config.INSTANCE.chunks.useEuclideanDistanceSquared ?
+                    (c2x - centerX) * (c2x - centerX) + (c2z - centerZ) * (c2z - centerZ) : Math.abs(c2x - centerX) + Math.abs(c2z - centerZ)
+                // Canvas end - use Euclidean distance squared
             );
         };
         private final LongHeapPriorityQueue sendQueue = new LongHeapPriorityQueue(CLOSEST_MANHATTAN_DIST);
@@ -440,7 +_,15 @@
             // Note: drop isAlive() check so that chunks properly unload client-side when the player dies
             ((ChunkSystemChunkHolder)((ChunkSystemServerLevel)this.world).moonrise$getChunkTaskScheduler().chunkHolderManager
                 .getChunkHolder(chunkX, chunkZ).vanillaChunkHolder).moonrise$removeReceivedChunk(this.player);
-            this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)));
+            // Leaf start - async chunk sending
+            if (io.canvasmc.canvas.Config.INSTANCE.chunks.asyncChunkSend) {
+                io.canvasmc.canvas.chunk.AsyncChunkSend.POOL.execute(
+                    () -> this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)))
+                );
+            } else {
+                this.player.connection.send(new ClientboundForgetLevelChunkPacket(new ChunkPos(chunkX, chunkZ)));
+            }
+            // Leaf end - async chunk sending
             // Paper start - PlayerChunkUnloadEvent
             if (io.papermc.paper.event.packet.PlayerChunkUnloadEvent.getHandlerList().getRegisteredListeners().length > 0) {
                 new io.papermc.paper.event.packet.PlayerChunkUnloadEvent(player.getBukkitEntity().getWorld().getChunkAt(new ChunkPos(chunkX, chunkZ).longKey), player.getBukkitEntity()).callEvent();
@@ -542,12 +_,12 @@
             );
         }
 
-        private Packet<?> updateClientChunkRadius(final int radius) {
+        public Packet<?> updateClientChunkRadius(final int radius) { // Canvas - private -> public
             this.lastSentChunkRadius = radius;
             return new ClientboundSetChunkCacheRadiusPacket(radius);
         }
 
-        private Packet<?> updateClientSimulationDistance(final int distance) {
+        public Packet<?> updateClientSimulationDistance(final int distance) { // Canvas - private -> public
             this.lastSentSimulationDistance = distance;
             return new ClientboundSetSimulationDistancePacket(distance);
         }
