--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/NewChunkHolder.java
@@ -67,6 +_,13 @@
     public final int chunkZ;
 
     public final ChunkTaskScheduler scheduler;
+    // Canvas start - optimize entity/block ticking chunk lookups
+    private final long cachedLongPos;
+
+    public long getCachedLongPos() {
+        return cachedLongPos;
+    }
+    // Canvas end
 
     // load/unload state
 
@@ -651,6 +_,7 @@
         this.world = world;
         this.chunkX = chunkX;
         this.chunkZ = chunkZ;
+        this.cachedLongPos = ((long)chunkZ << 32) | (chunkX & 0xFFFFFFFFL); // Canvas - optimize entity/block ticking chunk lookups
         this.scheduler = scheduler;
         this.vanillaChunkHolder = new ChunkHolder(
                 new ChunkPos(chunkX, chunkZ), ChunkHolderManager.MAX_TICKET_LEVEL, world,
@@ -1216,6 +_,18 @@
 
     private void updateCurrentState(final FullChunkStatus to) {
         this.currentFullChunkStatus = to;
+        // Canvas start - optimize entity/block ticking chunk lookups
+        if (to.isOrAfter(FullChunkStatus.BLOCK_TICKING)) {
+            this.world.getCurrentWorldData().markBlockTicking(this);
+        } else {
+            this.world.getCurrentWorldData().markNonBlockTickingIfPossible(this);
+        }
+        if (to.isOrAfter(FullChunkStatus.ENTITY_TICKING)) {
+            this.world.getCurrentWorldData().markEntityTicking(this);
+        } else {
+            this.world.getCurrentWorldData().markNonEntityTickingIfPossible(this);
+        }
+        // Canvas end
     }
 
     // only to be called on the main thread, no locks need to be held
