--- a/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
+++ b/ca/spottedleaf/moonrise/patches/chunk_system/scheduling/ChunkTaskScheduler.java
@@ -67,11 +_,7 @@
     private static final Logger LOGGER = LogUtils.getClassLogger();
 
     public static void init(final boolean useParallelGen) {
-        for (final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor executor : MoonriseCommon.RADIUS_AWARE_GROUP.getAllExecutors()) {
-            executor.setMaxParallelism(useParallelGen ? -1 : 1);
-        }
-
-        LOGGER.info("Chunk system is using population gen parallelism: " + useParallelGen);
+        // Canvas - rewrite moonrise executor - remove max parallelism
     }
 
     public static final TicketType CHUNK_LOAD = ChunkSystemTicketType.create("chunk_system:chunk_load", Long::compareTo);
@@ -116,12 +_,14 @@
 
     public final ServerLevel world;
     public final RadiusAwarePrioritisedExecutor radiusAwareScheduler;
-    public final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor parallelGenExecutor;
-    private final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor radiusAwareGenExecutor;
-    public final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor loadExecutor;
+    // Canvas start - rewrite moonrise executor
+    public final io.canvasmc.canvas.chunk.TheChunkSystem.ExecutorGroup.ThreadPoolExecutor parallelGenExecutor;
+    private final io.canvasmc.canvas.chunk.TheChunkSystem.ExecutorGroup.ThreadPoolExecutor radiusAwareGenExecutor;
+    public final io.canvasmc.canvas.chunk.TheChunkSystem.ExecutorGroup.ThreadPoolExecutor loadExecutor;
     public final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor ioExecutor;
-    public final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor compressionExecutor;
-    public final PrioritisedThreadPool.ExecutorGroup.ThreadPoolExecutor saveExecutor;
+    public final io.canvasmc.canvas.chunk.TheChunkSystem.ExecutorGroup.ThreadPoolExecutor compressionExecutor;
+    public final io.canvasmc.canvas.chunk.TheChunkSystem.ExecutorGroup.ThreadPoolExecutor saveExecutor;
+    // Canvas end
 
     // Folia - regionised ticking
 
@@ -199,9 +_,7 @@
                 // FULL is executed on main.
         );
 
-        for (final ChunkStatus status : parallelCapableStatus) {
-            ((ChunkSystemChunkStatus)status).moonrise$setParallelCapable(true);
-        }
+        // Canvas - rewrite moonrise executor - remove max parallelism
     }
 
     private static final int[] ACCESS_RADIUS_TABLE_LOAD = new int[ChunkStatus.getStatusList().size()];
@@ -292,14 +_,16 @@
         this.lockShift = Math.max(((ChunkSystemServerLevel)world).moonrise$getRegionChunkShift(), ThreadedTicketLevelPropagator.SECTION_SHIFT);
         this.schedulingLockArea = new ReentrantAreaLock(this.getChunkSystemLockShift());
 
-        this.parallelGenExecutor = MoonriseCommon.PARALLEL_GEN_GROUP.createExecutor(-1, MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
-        this.radiusAwareGenExecutor = MoonriseCommon.RADIUS_AWARE_GROUP.createExecutor(1, MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
-        this.loadExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(-1, MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        // Canvas start - rewrite moonrise executor
+        this.parallelGenExecutor = MoonriseCommon.PARALLEL_GEN_GROUP.createExecutor(MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        this.radiusAwareGenExecutor = MoonriseCommon.RADIUS_AWARE_GROUP.createExecutor(MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        this.loadExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
         this.radiusAwareScheduler = new RadiusAwarePrioritisedExecutor(this.radiusAwareGenExecutor, 16);
         this.ioExecutor = MoonriseCommon.SERVER_REGION_IO_GROUP.createExecutor(-1, MoonriseCommon.IO_QUEUE_HOLD_TIME, 0);
         // we need a separate executor here so that on shutdown we can continue to process I/O tasks
-        this.compressionExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(-1, MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
-        this.saveExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(-1, MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        this.compressionExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        this.saveExecutor = MoonriseCommon.LOAD_GROUP.createExecutor(MoonriseCommon.WORKER_QUEUE_HOLD_TIME, 0);
+        // Canvas end
         this.chunkHolderManager = new ChunkHolderManager(world, this);
     }
 
