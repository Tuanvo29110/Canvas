--- a/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
+++ b/net/minecraft/network/protocol/game/ClientboundLevelChunkPacketData.java
@@ -61,19 +_,65 @@
         this.blockEntitiesData = Lists.newArrayList();
         int totalTileEntities = 0; // Paper - Handle oversized block entities in chunks
 
-        for (Entry<BlockPos, BlockEntity> entry : levelChunk.getBlockEntities().entrySet()) {
-            // Paper start - Handle oversized block entities in chunks
-            if (++totalTileEntities > BLOCK_ENTITY_LIMIT) {
-                net.minecraft.network.protocol.Packet<ClientGamePacketListener> packet = entry.getValue().getUpdatePacket();
-                if (packet != null) {
-                    this.extraPackets.add(packet);
-                    continue;
-                }
-            }
-            // Paper end - Handle oversized block entities in chunks
-            this.blockEntitiesData.add(ClientboundLevelChunkPacketData.BlockEntityInfo.create(entry.getValue()));
-        }
-    }
+        for (final BlockEntity blockEntity : levelChunk.getAllBlockEntities()) { // Canvas - optimize block entity fetching
+            // Paper start - Handle oversized block entities in chunks
+            if (++totalTileEntities > BLOCK_ENTITY_LIMIT) {
+                net.minecraft.network.protocol.Packet<ClientGamePacketListener> packet = blockEntity.getUpdatePacket(); // Canvas - optimize block entity fetching
+                if (packet != null) {
+                    this.extraPackets.add(packet);
+                    continue;
+                }
+            }
+            // Paper end - Handle oversized block entities in chunks
+            this.blockEntitiesData.add(ClientboundLevelChunkPacketData.BlockEntityInfo.create(blockEntity)); // Canvas - optimize block entity fetching
+        }
+    }
+
+    // Leaf start - async chunk sending
+    public ClientboundLevelChunkPacketData(LevelChunk levelChunk, io.papermc.paper.antixray.ChunkPacketInfo<net.minecraft.world.level.block.state.BlockState> chunkPacketInfo, BlockEntity[] blockEntities, Map<Heightmap.Types, long[]> heightmaps) {
+        this.heightmaps = heightmaps;
+
+        if (Thread.currentThread() instanceof io.canvasmc.canvas.chunk.AsyncChunkSend.AsyncChunkSendThread) {
+            int size = calculateChunkSize(levelChunk);
+            ByteBuf buffer = Unpooled.buffer(size);
+            extractChunkData(new FriendlyByteBuf(buffer), levelChunk, chunkPacketInfo);
+            // make sure all sections is latest
+            while (size != buffer.writerIndex()) {
+                buffer.writerIndex(0);
+                size = calculateChunkSize(levelChunk);
+                extractChunkData(new FriendlyByteBuf(buffer), levelChunk, chunkPacketInfo);
+            }
+            byte[] array = it.unimi.dsi.fastutil.bytes.ByteArrays.setLength(buffer.array(), buffer.writerIndex());
+            if (chunkPacketInfo != null) {
+                chunkPacketInfo.setBuffer(array);
+            }
+            this.buffer = array;
+        } else {
+            this.buffer = new byte[calculateChunkSize(levelChunk)];
+            // Paper start - Anti-Xray - Add chunk packet info
+            if (chunkPacketInfo != null) {
+                chunkPacketInfo.setBuffer(this.buffer);
+            }
+            extractChunkData(new FriendlyByteBuf(this.getWriteBuffer()), levelChunk, chunkPacketInfo);
+        }
+
+        this.blockEntitiesData = Lists.newArrayList();
+        int totalTileEntities = 0; // Paper - Handle oversized block entities in chunks
+
+        for (BlockEntity blockEntity : blockEntities) {
+            // Paper start - Handle oversized block entities in chunks
+            if (++totalTileEntities > BLOCK_ENTITY_LIMIT) {
+                net.minecraft.network.protocol.Packet<ClientGamePacketListener> packet = blockEntity.getUpdatePacket();
+                if (packet != null) {
+                    this.extraPackets.add(packet);
+                    continue;
+                }
+            }
+            // Paper end - Handle oversized block entities in chunks
+            this.blockEntitiesData.add(ClientboundLevelChunkPacketData.BlockEntityInfo.create(blockEntity));
+        }
+    }
+    // Leaf end - async chunk sending
 
     public ClientboundLevelChunkPacketData(RegistryFriendlyByteBuf buffer, int x, int z) {
         this.heightmaps = HEIGHTMAPS_STREAM_CODEC.decode(buffer);
@@ -123,6 +_,7 @@
             // Paper end  - Anti-Xray - Add chunk packet info
         }
 
+        if (Thread.currentThread() instanceof io.canvasmc.canvas.chunk.AsyncChunkSend.AsyncChunkSendThread) return; // Leaf - async chunk sending
         if (buffer.writerIndex() != buffer.capacity()) {
             throw new IllegalStateException("Didn't fill chunk buffer: expected " + buffer.capacity() + " bytes, got " + buffer.writerIndex());
         }
