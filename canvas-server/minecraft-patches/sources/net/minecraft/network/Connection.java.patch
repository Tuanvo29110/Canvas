--- a/net/minecraft/network/Connection.java
+++ b/net/minecraft/network/Connection.java
@@ -378,6 +_,11 @@
         if (protocolInfo.flow() != this.getReceiving()) {
             throw new IllegalStateException("Invalid inbound protocol: " + protocolInfo.id());
         } else {
+            // Leaf start - Async switch connection state
+            if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) {
+                this.channel.config().setAutoRead(false);
+            }
+            // Leaf end - Async switch connection state
             this.packetListener = packetInfo;
             this.disconnectListener = null;
             UnconfiguredPipelineHandler.InboundConfigurationTask inboundConfigurationTask = UnconfiguredPipelineHandler.setupInboundProtocol(protocolInfo);
@@ -387,7 +_,14 @@
                 inboundConfigurationTask = inboundConfigurationTask.andThen(context -> context.pipeline().addAfter("decoder", "bundler", packetBundlePacker));
             }
 
-            syncAfterConfigurationChange(this.channel.writeAndFlush(inboundConfigurationTask));
+            // Leaf start - Async switch connection state
+            var cf = this.channel.writeAndFlush(inboundConfigurationTask);
+            if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()) {
+                cf.addListener((ChannelFutureListener) Connection::syncAfterConfigurationChange);
+                return;
+            }
+            syncAfterConfigurationChange(cf);
+            // Leaf end - Async switch connection state
         }
     }
 
@@ -408,6 +_,31 @@
             syncAfterConfigurationChange(this.channel.writeAndFlush(outboundConfigurationTask.andThen(context -> this.sendLoginDisconnect = flag)));
         }
     }
+
+    // Leaf start - Async switch connection state
+    public @Nullable ChannelFuture setupOutboundProtocolAsync(ProtocolInfo<?> protocolInfo) {
+        if (protocolInfo.flow() != this.getSending()) {
+            throw new IllegalStateException("Invalid outbound protocol: " + protocolInfo.id());
+        } else {
+            UnconfiguredPipelineHandler.OutboundConfigurationTask outboundConfigurationTask = UnconfiguredPipelineHandler.setupOutboundProtocol(protocolInfo);
+            BundlerInfo bundlerInfo = protocolInfo.bundlerInfo();
+            if (bundlerInfo != null) {
+                PacketBundleUnpacker packetBundleUnpacker = new PacketBundleUnpacker(bundlerInfo);
+                outboundConfigurationTask = outboundConfigurationTask.andThen(
+                    context -> context.pipeline().addAfter("encoder", "unbundler", packetBundleUnpacker)
+                );
+            }
+
+            boolean flag = protocolInfo.id() == ConnectionProtocol.LOGIN;
+            var cf = this.channel.writeAndFlush(outboundConfigurationTask.andThen(context -> this.sendLoginDisconnect = flag));
+            if (true) {
+                cf.addListener((ChannelFutureListener) Connection::syncAfterConfigurationChange);
+                return cf;
+            }
+            return null;
+        }
+    }
+    // Leaf end - Async switch connection state
 
     public void setListenerForServerboundHandshake(PacketListener packetListener) {
         if (this.packetListener != null) {
