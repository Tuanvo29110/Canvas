--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -2,7 +_,6 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Sets;
 import com.google.common.collect.ImmutableList.Builder;
 import com.mojang.logging.LogUtils;
 import com.mojang.serialization.Codec;
@@ -11,13 +_,10 @@
 import it.unimi.dsi.fastutil.floats.FloatSet;
 import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
-import it.unimi.dsi.fastutil.objects.Object2DoubleArrayMap;
-import it.unimi.dsi.fastutil.objects.Object2DoubleMap;
 import it.unimi.dsi.fastutil.objects.ObjectArrayList;
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Objects;
@@ -260,6 +_,7 @@
     public float yRotO;
     public float xRotO;
     private AABB bb = INITIAL_AABB;
+    private boolean boundingBoxChanged = false; // Gale - VMP - skip entity move if movement is zero
     public boolean onGround;
     public boolean horizontalCollision;
     public boolean verticalCollision;
@@ -283,9 +_,14 @@
     public int tickCount;
     private int remainingFireTicks;
     public boolean wasTouchingWater;
-    protected Object2DoubleMap<TagKey<Fluid>> fluidHeight = new Object2DoubleArrayMap<>(2);
+    public double[] fluidHeightArray = new double[2]; // Canvas - optimize fluid height - protected -> public
     protected boolean wasEyeInWater;
-    private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
+    // Canvas start - optimize fluidOnEyes
+    // private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
+    private int fluidOnEyesMask = 0;
+    private static final int EYE_IN_WATER = 1 << 0;
+    private static final int EYE_IN_LAVA  = 1 << 1;
+    // Canvas end
     public int invulnerableTime;
     protected boolean firstTick = true;
     protected final SynchedEntityData entityData;
@@ -316,7 +_,7 @@
     protected UUID uuid = Mth.createInsecureUUID(this.random);
     protected String stringUUID = this.uuid.toString();
     private boolean hasGlowingTag;
-    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
+    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(it.unimi.dsi.fastutil.objects.ObjectSets.synchronize(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>()), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl // Canvas - fix commands with region threading
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
     private long pistonDeltasGameTime = Long.MIN_VALUE; // Folia - region threading
     protected EntityDimensions dimensions;
@@ -866,7 +_,7 @@
         }
 
         //if (this instanceof ServerPlayer) this.handlePortal(); // CraftBukkit - Moved up to postTick // Folia - region threading - ONLY allow in postTick()
-        if (this.canSpawnSprintParticle()) {
+        if (!io.canvasmc.canvas.Config.INSTANCE.particles.disableSprintParticles && this.canSpawnSprintParticle()) { // Canvas - particles config
             this.spawnSprintParticle();
         }
 
@@ -901,7 +_,16 @@
 
         this.checkBelowWorld();
         if (!this.level().isClientSide) {
+            // Canvas start - hide flames on entities with fire resistance or invis
+            if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0 &&
+                    (!io.canvasmc.canvas.Config.INSTANCE.networking.hideFlamesOnEntitiesWithFireResistance || !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE)) &&
+                    (!io.canvasmc.canvas.Config.INSTANCE.networking.hideFlamesOnEntitiesWithInvisibility || !livingEntity.isInvisible())
+                );
+            } else {
+            // Canvas end - hide flames on entities with fire resistance or invis
             this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            } // Canvas - hide flames on entities with fire resistance or invis
         }
 
         this.firstTick = false;
@@ -1090,10 +_,43 @@
     public boolean onGround() {
         return this.onGround;
     }
+    
+    //Luminol start - Fix large pos moving
+    private volatile boolean preventMoving = false;
+    //Luminol end
 
     public void move(MoverType type, Vec3 movement) {
+        // Gale start - VMP - skip entity move if movement is zero
+        if (!this.boundingBoxChanged && movement.equals(Vec3.ZERO)) {
+            return;
+        }
+        // Gale end - VMP - skip entity move if movement is zero
         final Vec3 originalMovement = movement; // Paper - Expose pre-collision velocity
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread("Cannot move an entity off-main"); // Folia - region threading
+        //Luminol start - Fix high position moving
+        if (ca.spottedleaf.moonrise.common.util.TickThread.isTickThread()){ //Except the threads because it may be called by the chunk system worker thread
+            var finalPosition = movement.add(this.position);
+            if (this.preventMoving || Double.isNaN(finalPosition.x) || Double.isNaN(finalPosition.y) || Double.isNaN(finalPosition.z)){
+                return;
+            }
+
+            if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(((ServerLevel) this.level),finalPosition)){
+                this.preventMoving = true;
+                this.teleportAsync(
+                        (ServerLevel) this.level(),
+                        finalPosition,
+                        this.getYRot(), this.getXRot(),
+                        null, org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.UNKNOWN,
+                        Entity.TELEPORT_FLAG_LOAD_CHUNK | Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS,
+                        result -> {
+                            this.preventMoving = false;
+                        }
+                );
+                MinecraftServer.LOGGER.warn("Entity {} with entityId {} has tried moving to another region!",this.type.getCategory().getName(),this.getId());
+                return;
+            }
+        }
+        //Luminol end
         if (this.noPhysics) {
             this.setPos(this.getX() + movement.x, this.getY() + movement.y, this.getZ() + movement.z);
         } else {
@@ -1641,6 +_,11 @@
 
     private void checkInsideBlocks(Vec3 vec3, Vec3 vec31, InsideBlockEffectApplier.StepBasedCollector stepBasedCollector, LongSet set) {
         AABB aabb = this.makeBoundingBox(vec31).deflate(1.0E-5F);
+        // Canvas start - optimize checkInsideBlocks
+        // use element array for lambdas
+        final net.minecraft.world.level.chunk.ChunkAccess[] cachedChunk = new  net.minecraft.world.level.chunk.ChunkAccess[] { null };
+        final long[] lastChunkPos = { Long.MIN_VALUE };
+        // Canvas end - optimize checkInsideBlocks
         BlockGetter.forEachBlockIntersectedBetween(
             vec3,
             vec31,
@@ -1649,7 +_,22 @@
                 if (!this.isAlive()) {
                     return false;
                 } else {
-                    BlockState blockState = this.level().getBlockState(pos);
+                    // Canvas start - optimize checkInsideBlocks
+                    final int chunkX = pos.getX() >> 4;
+                    final int chunkZ = pos.getZ() >> 4;
+                    final long chunkLongPos = ((long) chunkZ << 32) | (chunkX & 0xFFFFFFFFL);
+                    if (lastChunkPos[0] != chunkLongPos) {
+                        // update cache, this is a different chunk than previous
+                        lastChunkPos[0] = chunkLongPos;
+                        cachedChunk[0] = this.level.getChunkIfLoaded(chunkX, chunkZ);
+                    }
+                    net.minecraft.world.level.chunk.ChunkAccess chunk = cachedChunk[0];
+                    if (chunk == null) {
+                        // return as if it were air
+                        return true;
+                    }
+                    BlockState blockState = chunk.getBlockState(pos);
+                    // Canvas end - optimize checkInsideBlocks
                     if (blockState.isAir()) {
                         this.debugBlockIntersection(pos, false, false);
                         return true;
@@ -1692,6 +_,7 @@
     }
 
     public boolean collidedWithFluid(FluidState fluid, BlockPos pos, Vec3 from, Vec3 to) {
+        if (fluid.isEmpty()) return false; // Canvas - optimize checkInsideBlocks
         AABB aabb = fluid.getAABB(this.level(), pos);
         return aabb != null && this.collidedWithShapeMovingFrom(from, to, List.of(aabb));
     }
@@ -1934,7 +_,7 @@
     }
 
     protected boolean updateInWaterStateAndDoFluidPushing() {
-        this.fluidHeight.clear();
+        this.fluidHeightArray = new double[2]; // Canvas - optimize fluid height
         this.updateInWaterStateAndDoWaterCurrentPushing();
         double d = this.level().dimensionType().ultraWarm() ? 0.007 : 0.0023333333333333335;
         boolean flag = this.updateFluidHeightAndDoFluidPushing(FluidTags.LAVA, d);
@@ -1957,8 +_,8 @@
     }
 
     private void updateFluidOnEyes() {
-        this.wasEyeInWater = this.isEyeInFluid(FluidTags.WATER);
-        this.fluidOnEyes.clear();
+        this.wasEyeInWater = this.isEyeInWater(); // Canvas - optimize fluidOnEyes
+        this.fluidOnEyesMask = 0; // Canvas - optimize fluidOnEyes
         double eyeY = this.getEyeY();
         if (!(
             this.getVehicle() instanceof AbstractBoat abstractBoat
@@ -1970,10 +_,29 @@
             FluidState fluidState = this.level().getFluidState(blockPos);
             double d = blockPos.getY() + fluidState.getHeight(this.level(), blockPos);
             if (d > eyeY) {
-                fluidState.getTags().forEach(this.fluidOnEyes::add);
+                // Canvas start - optimize fluidOnEyes - remove stream and use bitmask
+                TagKey<Fluid>[] tags = fluidState.getTagsArray();
+                for (TagKey<Fluid> tag : tags) {
+                    if (tag == FluidTags.WATER) {
+                        this.fluidOnEyesMask |= EYE_IN_WATER;
+                    } else if (tag == FluidTags.LAVA) {
+                        this.fluidOnEyesMask |= EYE_IN_LAVA;
+                    }
+                }
+                // Canvas end - optimize fluidOnEyes - remove stream and use bitmask
             }
         }
     }
+    // Canvas start - optimize fluidOnEyes
+
+    public boolean isEyeInWater() {
+        return (this.fluidOnEyesMask & EYE_IN_WATER) != 0;
+    }
+
+    public boolean isEyeInLava() {
+        return (this.fluidOnEyesMask & EYE_IN_LAVA) != 0;
+    }
+    // Canvas end - optimize fluidOnEyes
 
     protected void doWaterSplashEffect() {
         Entity entity = Objects.requireNonNullElse(this.getControllingPassenger(), this);
@@ -1990,6 +_,7 @@
 
         float f1 = Mth.floor(this.getY());
 
+        if (!io.canvasmc.canvas.Config.INSTANCE.particles.disableWaterSplashParticles) { // Canvas - particles config
         for (int i = 0; i < 1.0F + this.dimensions.width() * 20.0F; i++) {
             double d = (this.random.nextDouble() * 2.0 - 1.0) * this.dimensions.width();
             double d1 = (this.random.nextDouble() * 2.0 - 1.0) * this.dimensions.width();
@@ -2010,6 +_,7 @@
             double d1 = (this.random.nextDouble() * 2.0 - 1.0) * this.dimensions.width();
             this.level().addParticle(ParticleTypes.SPLASH, this.getX() + d, f1 + 1.0F, this.getZ() + d1, deltaMovement.x, deltaMovement.y, deltaMovement.z);
         }
+        } // Canvas - particles config
 
         this.gameEvent(GameEvent.SPLASH);
     }
@@ -2051,11 +_,32 @@
     }
 
     public boolean isEyeInFluid(TagKey<Fluid> fluidTag) {
-        return this.fluidOnEyes.contains(fluidTag);
-    }
+        // Canvas start - optimize fluidOnEyes
+        if (fluidTag == FluidTags.WATER) {
+            return (this.fluidOnEyesMask & EYE_IN_WATER) != 0;
+        } else if (fluidTag == FluidTags.LAVA) {
+            return (this.fluidOnEyesMask & EYE_IN_LAVA) != 0;
+        }
+        return false;
+        // Canvas end
+    }
+    // Canvas start - optimize fluid height
+
+    // Note: realistically would want to avoid using this, just use the index
+    //    - WATER: 0
+    //    - LAVA: 1
+    private int getFluidHeightIndex(TagKey<Fluid> fluidTag) {
+        if (fluidTag == FluidTags.WATER) {
+            return 0;
+        } else if (fluidTag == FluidTags.LAVA) {
+            return 1;
+        }
+        throw new UnsupportedOperationException("Unknown fluid tag");
+    }
+    // Canvas end - optimize fluid height
 
     public boolean isInLava() {
-        return !this.firstTick && this.fluidHeight.getDouble(FluidTags.LAVA) > 0.0;
+        return !this.firstTick && this.fluidHeightArray[1] > 0.0; // Canvas - optimize fluid height
     }
 
     public void moveRelative(float amount, Vec3 relative) {
@@ -2199,8 +_,8 @@
     }
 
     public void push(Entity entity) {
+        if (!entity.noPhysics && !this.noPhysics) { // Leaf - collision physics check before vehicle check
         if (!this.isPassengerOfSameVehicle(entity)) {
-            if (!entity.noPhysics && !this.noPhysics) {
                 if (this.level.paperConfig().collisions.onlyPlayersCollide && !(entity instanceof ServerPlayer || this instanceof ServerPlayer)) return; // Paper - Collision option for requiring a player participant
                 double d = entity.getX() - this.getX();
                 double d1 = entity.getZ() - this.getZ();
@@ -2520,6 +_,7 @@
             }
 
             this.addAdditionalSaveData(output, includeAll); // CraftBukkit - pass on includeAll
+            if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) output.store("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC, this.getBoundingBox()); // Canvas - MC-2025
             if (this.isVehicle()) {
                 ValueOutput.ValueOutputList valueOutputList = output.childrenList("Passengers");
 
@@ -2623,6 +_,7 @@
                 this.tags.clear();
                 input.read("Tags", TAG_LIST_CODEC).ifPresent(this.tags::addAll);
                 this.readAdditionalSaveData(input);
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) input.read("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC).ifPresent(this::setBoundingBox); // Canvas - MC-2025
                 if (this.repositionEntityAfterLoad()) {
                     this.reapplyPosition();
                 }
@@ -3690,6 +_,7 @@
     }
 
     protected static void sendBubbleColumnParticles(Level level, BlockPos pos) {
+        if (io.canvasmc.canvas.Config.INSTANCE.particles.disableBubbleColumnParticles) return; // Canvas - particles config
         if (level instanceof ServerLevel serverLevel) {
             for (int i = 0; i < 2; i++) {
                 serverLevel.sendParticles(
@@ -3852,7 +_,7 @@
             );
     }
 
-    public final boolean isInvulnerableToBase(DamageSource damageSource) {
+    public boolean isInvulnerableToBase(DamageSource damageSource) { // Canvas - mutable - TODO - wideners in weaver?
         return this.isRemoved()
             || this.invulnerable && !damageSource.is(DamageTypeTags.BYPASSES_INVULNERABILITY) && !damageSource.isCreativePlayer()
             || damageSource.is(DamageTypeTags.IS_FIRE) && this.fireImmune()
@@ -4232,6 +_,19 @@
         );
     }
 
+    // Canvas start - region threading
+    private boolean checkNearbyRegions(int destX, int destZ) {
+        int sizeBx = Math.min(6, (int) (this.bb.maxX - this.bb.minX) + ((ServerLevel) this.level).serverLevelData.distanceConfig.simulationDistanceOrDefault());
+        int sizeBz = Math.min(6, (int) (this.bb.maxZ - this.bb.minZ) + ((ServerLevel) this.level).serverLevelData.distanceConfig.simulationDistanceOrDefault());
+
+        return ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(this.level,
+            (destX >> 4) - sizeBx,
+            (destZ >> 4) - sizeBz,
+            (destX >> 4) + sizeBx,
+            (destZ >> 4) + sizeBz);
+    }
+
+    // Canvas end - region threading
     public final boolean teleportAsync(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity,
                                        org.bukkit.event.player.PlayerTeleportEvent.TeleportCause cause, long teleportFlags,
                                        java.util.function.Consumer<Entity> teleportComplete) {
@@ -4265,13 +_,52 @@
                 return false;
             }
         }
+        if (destination.isUnloading) return false; // Canvas - fix world loading/unloading
 
         // TODO any events that can modify go HERE
+        // Canvas start - fix events with region threading
+        // Note: TeleportCommand.java normally calls this event for that, but we
+        // don't need to there because it calls this method, and we handle it here
+        Vec3 currPos = this.position();
+        org.bukkit.Location newLocation;
+        org.bukkit.Location from = new org.bukkit.Location(this.level().getWorld(), currPos.x, currPos.y, currPos.z, this.getYRot(), this.getXRot());
+        org.bukkit.Location to = new org.bukkit.Location(destination.getWorld(), pos.x, pos.y, pos.z, yaw == null ? this.getYRot() : yaw, pitch == null ? this.getXRot() : pitch);
+        if (!(this instanceof ServerPlayer player)) {
+            org.bukkit.event.entity.EntityTeleportEvent entityTeleportEvent = new org.bukkit.event.entity.EntityTeleportEvent(
+                this.getBukkitEntity(), from, to
+            );
+            if (!entityTeleportEvent.callEvent() || entityTeleportEvent.getTo() == null) {
+                return false;
+            } else {
+                newLocation = entityTeleportEvent.getTo();
+                yaw = entityTeleportEvent.getTo().getYaw();
+                pitch = entityTeleportEvent.getTo().getPitch();
+            }
+        } else {
+            org.bukkit.event.player.PlayerTeleportEvent playerTeleportEvent = new org.bukkit.event.player.PlayerTeleportEvent(
+                player.getBukkitEntity(), from, to,
+                cause, Set.of()
+            );
+
+            if (!playerTeleportEvent.callEvent()) {
+                return false;
+            } else {
+                newLocation = playerTeleportEvent.getTo();
+                yaw = playerTeleportEvent.getTo().getYaw();
+                pitch = playerTeleportEvent.getTo().getPitch();
+            }
+        }
+
+        pos = new Vec3(
+            newLocation.getX(), newLocation.getY(), newLocation.getZ()
+        );
+        // Canvas end - fix events with region threading
 
         // check for same region
         if (destination == this.level()) {
-            Vec3 currPos = this.position();
+            // Vec3 currPos = this.position(); // Canvas - fix events with region threading - move up
             if (
+                this.checkNearbyRegions((int) pos.x, (int) pos.z) && // Canvas - region threading
                 destination.regioniser.getRegionAtUnsynchronised(
                     ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(currPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(currPos)
                 ) == destination.regioniser.getRegionAtUnsynchronised(
@@ -4346,7 +_,7 @@
     public boolean endPortalLogicAsync(BlockPos portalPos) {
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
-        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END ? Level.OVERWORLD : Level.END);
+        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END ? io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey() : Level.END); // Canvas - default respawn dimension config
         if (destination == null) {
             // wat
             return false;
@@ -4358,7 +_,7 @@
     public boolean netherPortalLogicAsync(BlockPos portalPos) {
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
-        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER);
+        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey() : Level.NETHER); // Canvas - default respawn dimension config
         if (destination == null) {
             // wat
             return false;
@@ -4579,6 +_,7 @@
                 }
             }
         }
+        if (to != null && to.isUnloading) return false; // Canvas - fix world loading/unloading
 
         return true;
     }
@@ -4928,7 +_,7 @@
 
     public boolean canTeleport(Level fromLevel, Level toLevel) {
         if (!this.isAlive() || !this.valid) return false; // Paper - Fix item duplication and teleport issues
-        if (fromLevel.dimension() == Level.END && toLevel.dimension() == Level.OVERWORLD) {
+        if (fromLevel.dimension() == Level.END && toLevel.dimension() == io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()) { // Canvas - default respawn dimension config
             for (Entity entity : this.getPassengers()) {
                 if (entity instanceof ServerPlayer serverPlayer && !serverPlayer.seenCredits) {
                     return false;
@@ -5156,6 +_,11 @@
     }
 
     public final void setBoundingBox(AABB bb) {
+        // Gale start - VMP - skip entity move if movement is zero
+        if (!this.bb.equals(bb)) {
+            this.boundingBoxChanged = true;
+        }
+        // Gale end - VMP - skip entity move if movement is zero
         // CraftBukkit start - block invalid bounding boxes
         double minX = bb.minX,
                 minY = bb.minY,
@@ -5462,9 +_,7 @@
 
     // Paper start - optimise collisions
     public boolean updateFluidHeightAndDoFluidPushing(final TagKey<Fluid> fluid, final double flowScale) {
-        if (this.touchingUnloadedChunk()) {
-            return false;
-        }
+        // Canvas - optimize fluid pushing
 
         final AABB boundingBox = this.getBoundingBox().deflate(1.0E-3);
 
@@ -5499,9 +_,17 @@
 
         final net.minecraft.world.level.chunk.ChunkSource chunkSource = world.getChunkSource();
 
+        int heightIndex = getFluidHeightIndex(fluid); // Canvas - optimize fluid height
         for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
             for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
-                final net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunkSource.getChunk(currChunkX, currChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, false).getSections();
+                // Canvas start - optimize fluid pushing
+                net.minecraft.world.level.chunk.LevelChunk chunk = (net.minecraft.world.level.chunk.LevelChunk) chunkSource.getChunk(currChunkX, currChunkZ, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, false);
+                // we remove the touching unloaded chunk check, so we need to check nullable because this is now nullable
+                if (chunk == null) {
+                    continue;
+                }
+                final net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunk.getSections();
+                // Canvas end - optimize fluid pushing
 
                 // bound y
                 for (int currChunkY = minChunkY; currChunkY <= maxChunkY; ++currChunkY) {
@@ -5510,7 +_,7 @@
                         continue;
                     }
                     final net.minecraft.world.level.chunk.LevelChunkSection section = sections[sectionIdx];
-                    if (section.hasOnlyAir()) {
+                    if (section.hasOnlyAir() || (fluid == FluidTags.WATER && section.waterCount == 0 && section.bubbleCount <= 0) || (fluid == FluidTags.LAVA && section.lavaCount == 0)) { // Canvas - optimize fluid pushing
                         // empty
                         continue;
                     }
@@ -5565,7 +_,7 @@
             }
         }
 
-        this.fluidHeight.put(fluid, maxHeightDiff);
+        this.fluidHeightArray[heightIndex] = maxHeightDiff; // Canvas - optimize fluid height
 
         if (pushVector.lengthSqr() == 0.0) {
             return inFluid;
@@ -5601,7 +_,7 @@
     }
 
     public double getFluidHeight(TagKey<Fluid> fluidTag) {
-        return this.fluidHeight.getDouble(fluidTag);
+        return this.fluidHeightArray[getFluidHeightIndex(fluidTag)]; // Canvas - optimize fluid height
     }
 
     public double getFluidJumpThreshold() {
