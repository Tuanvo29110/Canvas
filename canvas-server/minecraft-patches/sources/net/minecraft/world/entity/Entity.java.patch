--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -316,7 +_,7 @@
     protected UUID uuid = Mth.createInsecureUUID(this.random);
     protected String stringUUID = this.uuid.toString();
     private boolean hasGlowingTag;
-    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
+    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(it.unimi.dsi.fastutil.objects.ObjectSets.synchronize(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>()), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl // Canvas - fix commands with region threading
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
     private long pistonDeltasGameTime = Long.MIN_VALUE; // Folia - region threading
     protected EntityDimensions dimensions;
@@ -901,7 +_,13 @@
 
         this.checkBelowWorld();
         if (!this.level().isClientSide) {
+            // Canvas start - hide flames on entities with fire resistance
+            if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0 && (!io.canvasmc.canvas.Config.INSTANCE.entities.hideFlamesOnEntitiesWithFireResistance || !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE)));
+            } else {
+            // Canvas end - hide flames on entities with fire resistance
             this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            } // Canvas - hide flames on entities with fire resistance
         }
 
         this.firstTick = false;
@@ -2546,6 +_,7 @@
             }
 
             this.addAdditionalSaveData(output, includeAll); // CraftBukkit - pass on includeAll
+            if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) output.store("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC, this.getBoundingBox()); // Canvas - MC-2025
             if (this.isVehicle()) {
                 ValueOutput.ValueOutputList valueOutputList = output.childrenList("Passengers");
 
@@ -2649,6 +_,7 @@
                 this.tags.clear();
                 input.read("Tags", TAG_LIST_CODEC).ifPresent(this.tags::addAll);
                 this.readAdditionalSaveData(input);
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) input.read("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC).ifPresent(this::setBoundingBox); // Canvas - MC-2025
                 if (this.repositionEntityAfterLoad()) {
                     this.reapplyPosition();
                 }
@@ -4291,12 +_,50 @@
                 return false;
             }
         }
+        if (destination.isUnloading) return false; // Canvas - fix world loading/unloading
 
         // TODO any events that can modify go HERE
+        // Canvas start - fix events with region threading
+        // Note: TeleportCommand.java normally calls this event for that, but we
+        // don't need to there because it calls this method, and we handle it here
+        Vec3 currPos = this.position();
+        org.bukkit.Location newLocation;
+        org.bukkit.Location from = new org.bukkit.Location(this.level().getWorld(), currPos.x, currPos.y, currPos.z, this.getYRot(), this.getXRot());
+        org.bukkit.Location to = new org.bukkit.Location(destination.getWorld(), pos.x, pos.y, pos.z, yaw == null ? this.getYRot() : yaw, pitch == null ? this.getXRot() : pitch);
+        if (!(this instanceof ServerPlayer player)) {
+            org.bukkit.event.entity.EntityTeleportEvent entityTeleportEvent = new org.bukkit.event.entity.EntityTeleportEvent(
+                this.getBukkitEntity(), from, to
+            );
+            if (!entityTeleportEvent.callEvent() || entityTeleportEvent.getTo() == null) {
+                return false;
+            } else {
+                newLocation = entityTeleportEvent.getTo();
+                yaw = entityTeleportEvent.getTo().getYaw();
+                pitch = entityTeleportEvent.getTo().getPitch();
+            }
+        } else {
+            org.bukkit.event.player.PlayerTeleportEvent playerTeleportEvent = new org.bukkit.event.player.PlayerTeleportEvent(
+                player.getBukkitEntity(), from, to,
+                cause, Set.of()
+            );
+
+            if (!playerTeleportEvent.callEvent()) {
+                return false;
+            } else {
+                newLocation = playerTeleportEvent.getTo();
+                yaw = playerTeleportEvent.getTo().getYaw();
+                pitch = playerTeleportEvent.getTo().getPitch();
+            }
+        }
+
+        pos = new Vec3(
+            newLocation.getX(), newLocation.getY(), newLocation.getZ()
+        );
+        // Canvas end - fix events with region threading
 
         // check for same region
         if (destination == this.level()) {
-            Vec3 currPos = this.position();
+            // Vec3 currPos = this.position(); // Canvas - fix events with region threading - move up
             if (
                 destination.regioniser.getRegionAtUnsynchronised(
                     ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(currPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(currPos)
@@ -4605,6 +_,7 @@
                 }
             }
         }
+        if (to != null && to.isUnloading) return false; // Canvas - fix world loading/unloading
 
         return true;
     }
