--- a/net/minecraft/world/entity/Entity.java
+++ b/net/minecraft/world/entity/Entity.java
@@ -285,7 +_,12 @@
     public boolean wasTouchingWater;
     protected Object2DoubleMap<TagKey<Fluid>> fluidHeight = new Object2DoubleArrayMap<>(2);
     protected boolean wasEyeInWater;
-    private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
+    // Canvas start - optimize fluidOnEyes
+    // private final Set<TagKey<Fluid>> fluidOnEyes = new HashSet<>();
+    private int fluidOnEyesMask = 0;
+    private static final int EYE_IN_WATER = 1 << 0;
+    private static final int EYE_IN_LAVA  = 1 << 1;
+    // Canvas end
     public int invulnerableTime;
     protected boolean firstTick = true;
     protected final SynchedEntityData entityData;
@@ -316,7 +_,7 @@
     protected UUID uuid = Mth.createInsecureUUID(this.random);
     protected String stringUUID = this.uuid.toString();
     private boolean hasGlowingTag;
-    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>(), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl
+    private final Set<String> tags = new io.papermc.paper.util.SizeLimitedSet<>(it.unimi.dsi.fastutil.objects.ObjectSets.synchronize(new it.unimi.dsi.fastutil.objects.ObjectOpenHashSet<>()), MAX_ENTITY_TAG_COUNT); // Paper - fully limit tag size - replace set impl // Canvas - fix commands with region threading
     private final double[] pistonDeltas = new double[]{0.0, 0.0, 0.0};
     private long pistonDeltasGameTime = Long.MIN_VALUE; // Folia - region threading
     protected EntityDimensions dimensions;
@@ -866,7 +_,7 @@
         }
 
         //if (this instanceof ServerPlayer) this.handlePortal(); // CraftBukkit - Moved up to postTick // Folia - region threading - ONLY allow in postTick()
-        if (this.canSpawnSprintParticle()) {
+        if (false && this.canSpawnSprintParticle()) { // Canvas - why tf are we doing this? this is handled on the client
             this.spawnSprintParticle();
         }
 
@@ -901,7 +_,16 @@
 
         this.checkBelowWorld();
         if (!this.level().isClientSide) {
+            // Canvas start - hide flames on entities with fire resistance or invis
+            if (this instanceof net.minecraft.world.entity.LivingEntity livingEntity) {
+                this.setSharedFlagOnFire(this.remainingFireTicks > 0 &&
+                    (!io.canvasmc.canvas.Config.INSTANCE.networking.hideFlamesOnEntitiesWithFireResistance || !livingEntity.hasEffect(net.minecraft.world.effect.MobEffects.FIRE_RESISTANCE)) &&
+                    (!io.canvasmc.canvas.Config.INSTANCE.networking.hideFlamesOnEntitiesWithInvisibility || !livingEntity.isInvisible())
+                );
+            } else {
+            // Canvas end - hide flames on entities with fire resistance or invis
             this.setSharedFlagOnFire(this.remainingFireTicks > 0);
+            } // Canvas - hide flames on entities with fire resistance or invis
         }
 
         this.firstTick = false;
@@ -1641,6 +_,11 @@
 
     private void checkInsideBlocks(Vec3 vec3, Vec3 vec31, InsideBlockEffectApplier.StepBasedCollector stepBasedCollector, LongSet set) {
         AABB aabb = this.makeBoundingBox(vec31).deflate(1.0E-5F);
+        // Canvas start - optimize checkInsideBlocks
+        // use element array for lambdas
+        final net.minecraft.world.level.chunk.ChunkAccess[] cachedChunk = new  net.minecraft.world.level.chunk.ChunkAccess[] { null };
+        final long[] lastChunkPos = { Long.MIN_VALUE };
+        // Canvas end - optimize checkInsideBlocks
         BlockGetter.forEachBlockIntersectedBetween(
             vec3,
             vec31,
@@ -1649,7 +_,22 @@
                 if (!this.isAlive()) {
                     return false;
                 } else {
-                    BlockState blockState = this.level().getBlockState(pos);
+                    // Canvas start - optimize checkInsideBlocks
+                    final int chunkX = pos.getX() >> 4;
+                    final int chunkZ = pos.getZ() >> 4;
+                    final long chunkLongPos = ((long) chunkZ << 32) | (chunkX & 0xFFFFFFFFL);
+                    if (lastChunkPos[0] != chunkLongPos) {
+                        // update cache, this is a different chunk than previous
+                        lastChunkPos[0] = chunkLongPos;
+                        cachedChunk[0] = this.level.getChunkIfLoaded(chunkX, chunkZ);
+                    }
+                    net.minecraft.world.level.chunk.ChunkAccess chunk = cachedChunk[0];
+                    if (chunk == null) {
+                        // return as if it were air
+                        return true;
+                    }
+                    BlockState blockState = chunk.getBlockState(pos);
+                    // Canvas end - optimize checkInsideBlocks
                     if (blockState.isAir()) {
                         this.debugBlockIntersection(pos, false, false);
                         return true;
@@ -1692,6 +_,7 @@
     }
 
     public boolean collidedWithFluid(FluidState fluid, BlockPos pos, Vec3 from, Vec3 to) {
+        if (fluid.isEmpty()) return false; // Canvas - optimize checkInsideBlocks
         AABB aabb = fluid.getAABB(this.level(), pos);
         return aabb != null && this.collidedWithShapeMovingFrom(from, to, List.of(aabb));
     }
@@ -1957,8 +_,8 @@
     }
 
     private void updateFluidOnEyes() {
-        this.wasEyeInWater = this.isEyeInFluid(FluidTags.WATER);
-        this.fluidOnEyes.clear();
+        this.wasEyeInWater = this.isEyeInWater(); // Canvas - optimize fluidOnEyes
+        this.fluidOnEyesMask = 0; // Canvas - optimize fluidOnEyes
         double eyeY = this.getEyeY();
         if (!(
             this.getVehicle() instanceof AbstractBoat abstractBoat
@@ -1970,10 +_,29 @@
             FluidState fluidState = this.level().getFluidState(blockPos);
             double d = blockPos.getY() + fluidState.getHeight(this.level(), blockPos);
             if (d > eyeY) {
-                fluidState.getTags().forEach(this.fluidOnEyes::add);
+                // Canvas start - optimize fluidOnEyes - remove stream and use bitmask
+                TagKey<Fluid>[] tags = fluidState.getTagsArray();
+                for (TagKey<Fluid> tag : tags) {
+                    if (tag == FluidTags.WATER) {
+                        this.fluidOnEyesMask |= EYE_IN_WATER;
+                    } else if (tag == FluidTags.LAVA) {
+                        this.fluidOnEyesMask |= EYE_IN_LAVA;
+                    }
+                }
+                // Canvas end - optimize fluidOnEyes - remove stream and use bitmask
             }
         }
     }
+    // Canvas start - optimize fluidOnEyes
+
+    public boolean isEyeInWater() {
+        return (this.fluidOnEyesMask & EYE_IN_WATER) != 0;
+    }
+
+    public boolean isEyeInLava() {
+        return (this.fluidOnEyesMask & EYE_IN_LAVA) != 0;
+    }
+    // Canvas end - optimize fluidOnEyes
 
     protected void doWaterSplashEffect() {
         Entity entity = Objects.requireNonNullElse(this.getControllingPassenger(), this);
@@ -2051,7 +_,14 @@
     }
 
     public boolean isEyeInFluid(TagKey<Fluid> fluidTag) {
-        return this.fluidOnEyes.contains(fluidTag);
+        // Canvas start - optimize fluidOnEyes
+        if (fluidTag == FluidTags.WATER) {
+            return (this.fluidOnEyesMask & EYE_IN_WATER) != 0;
+        } else if (fluidTag == FluidTags.LAVA) {
+            return (this.fluidOnEyesMask & EYE_IN_LAVA) != 0;
+        }
+        return false;
+        // Canvas end
     }
 
     public boolean isInLava() {
@@ -2520,6 +_,7 @@
             }
 
             this.addAdditionalSaveData(output, includeAll); // CraftBukkit - pass on includeAll
+            if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) output.store("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC, this.getBoundingBox()); // Canvas - MC-2025
             if (this.isVehicle()) {
                 ValueOutput.ValueOutputList valueOutputList = output.childrenList("Passengers");
 
@@ -2623,6 +_,7 @@
                 this.tags.clear();
                 input.read("Tags", TAG_LIST_CODEC).ifPresent(this.tags::addAll);
                 this.readAdditionalSaveData(input);
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc2025) input.read("AABB", io.canvasmc.canvas.util.Codecs.AABB_CODEC).ifPresent(this::setBoundingBox); // Canvas - MC-2025
                 if (this.repositionEntityAfterLoad()) {
                     this.reapplyPosition();
                 }
@@ -3852,7 +_,7 @@
             );
     }
 
-    public final boolean isInvulnerableToBase(DamageSource damageSource) {
+    public boolean isInvulnerableToBase(DamageSource damageSource) { // Canvas - mutable - TODO - wideners in weaver?
         return this.isRemoved()
             || this.invulnerable && !damageSource.is(DamageTypeTags.BYPASSES_INVULNERABILITY) && !damageSource.isCreativePlayer()
             || damageSource.is(DamageTypeTags.IS_FIRE) && this.fireImmune()
@@ -4265,12 +_,50 @@
                 return false;
             }
         }
+        if (destination.isUnloading) return false; // Canvas - fix world loading/unloading
 
         // TODO any events that can modify go HERE
+        // Canvas start - fix events with region threading
+        // Note: TeleportCommand.java normally calls this event for that, but we
+        // don't need to there because it calls this method, and we handle it here
+        Vec3 currPos = this.position();
+        org.bukkit.Location newLocation;
+        org.bukkit.Location from = new org.bukkit.Location(this.level().getWorld(), currPos.x, currPos.y, currPos.z, this.getYRot(), this.getXRot());
+        org.bukkit.Location to = new org.bukkit.Location(destination.getWorld(), pos.x, pos.y, pos.z, yaw == null ? this.getYRot() : yaw, pitch == null ? this.getXRot() : pitch);
+        if (!(this instanceof ServerPlayer player)) {
+            org.bukkit.event.entity.EntityTeleportEvent entityTeleportEvent = new org.bukkit.event.entity.EntityTeleportEvent(
+                this.getBukkitEntity(), from, to
+            );
+            if (!entityTeleportEvent.callEvent() || entityTeleportEvent.getTo() == null) {
+                return false;
+            } else {
+                newLocation = entityTeleportEvent.getTo();
+                yaw = entityTeleportEvent.getTo().getYaw();
+                pitch = entityTeleportEvent.getTo().getPitch();
+            }
+        } else {
+            org.bukkit.event.player.PlayerTeleportEvent playerTeleportEvent = new org.bukkit.event.player.PlayerTeleportEvent(
+                player.getBukkitEntity(), from, to,
+                cause, Set.of()
+            );
+
+            if (!playerTeleportEvent.callEvent()) {
+                return false;
+            } else {
+                newLocation = playerTeleportEvent.getTo();
+                yaw = playerTeleportEvent.getTo().getYaw();
+                pitch = playerTeleportEvent.getTo().getPitch();
+            }
+        }
+
+        pos = new Vec3(
+            newLocation.getX(), newLocation.getY(), newLocation.getZ()
+        );
+        // Canvas end - fix events with region threading
 
         // check for same region
         if (destination == this.level()) {
-            Vec3 currPos = this.position();
+            // Vec3 currPos = this.position(); // Canvas - fix events with region threading - move up
             if (
                 destination.regioniser.getRegionAtUnsynchronised(
                     ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(currPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(currPos)
@@ -4346,7 +_,7 @@
     public boolean endPortalLogicAsync(BlockPos portalPos) {
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
-        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END ? Level.OVERWORLD : Level.END);
+        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.END ? io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey() : Level.END); // Canvas - default respawn dimension config
         if (destination == null) {
             // wat
             return false;
@@ -4358,7 +_,7 @@
     public boolean netherPortalLogicAsync(BlockPos portalPos) {
         ca.spottedleaf.moonrise.common.util.TickThread.ensureTickThread(this, "Cannot portal entity async");
 
-        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? Level.OVERWORLD : Level.NETHER);
+        ServerLevel destination = this.getServer().getLevel(this.level().getTypeKey() == net.minecraft.world.level.dimension.LevelStem.NETHER ? io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey() : Level.NETHER); // Canvas - default respawn dimension config
         if (destination == null) {
             // wat
             return false;
@@ -4579,6 +_,7 @@
                 }
             }
         }
+        if (to != null && to.isUnloading) return false; // Canvas - fix world loading/unloading
 
         return true;
     }
@@ -4928,7 +_,7 @@
 
     public boolean canTeleport(Level fromLevel, Level toLevel) {
         if (!this.isAlive() || !this.valid) return false; // Paper - Fix item duplication and teleport issues
-        if (fromLevel.dimension() == Level.END && toLevel.dimension() == Level.OVERWORLD) {
+        if (fromLevel.dimension() == Level.END && toLevel.dimension() == io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()) { // Canvas - default respawn dimension config
             for (Entity entity : this.getPassengers()) {
                 if (entity instanceof ServerPlayer serverPlayer && !serverPlayer.seenCredits) {
                     return false;
