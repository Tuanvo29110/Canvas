--- a/net/minecraft/world/entity/ai/memory/NearestVisibleLivingEntities.java
+++ b/net/minecraft/world/entity/ai/memory/NearestVisibleLivingEntities.java
@@ -32,11 +_,30 @@
     }
 
     public Optional<LivingEntity> findClosest(Predicate<LivingEntity> predicate) {
-        for (LivingEntity livingEntity : this.nearbyEntities) {
-            if (predicate.test(livingEntity) && this.lineOfSightTest.test(livingEntity)) {
-                return Optional.of(livingEntity);
+        // Leaf start - Optimize SetLookAndInteract and NearestVisibleLivingEntities
+        // Early return if no entities
+        if (this.nearbyEntities.isEmpty()) {
+            return Optional.empty();
+        }
+
+        // Avoid computing line of sight unless necessary
+        LivingEntity closest = null;
+        double closestDistSq = Double.MAX_VALUE;
+
+        for (int i = 0; i < this.nearbyEntities.size(); i++) {
+            LivingEntity entity = this.nearbyEntities.get(i);
+
+            // Check predicate first as it's likely cheaper than line of sight test
+            if (predicate.test(entity)) {
+                // Only do expensive line of sight check if other conditions pass
+                if (this.lineOfSightTest.test(entity)) {
+                    // For SetLookAndInteract we can optimize further since distanceSq check
+                    // is already in the predicate - see if there's a chance to return early
+                    return Optional.of(entity);
+                }
             }
         }
+        // Leaf end - Optimize SetLookAndInteract and NearestVisibleLivingEntities
 
         return Optional.empty();
     }
@@ -46,8 +_,20 @@
     }
 
     public Stream<LivingEntity> find(Predicate<LivingEntity> predicate) {
-        return this.nearbyEntities.stream().filter(target -> predicate.test(target) && this.lineOfSightTest.test(target));
-    }
+        return this.nearbyEntities.stream().filter(target -> predicate.test(target) && this.lineOfSightTest.test(target)); // Leaf - Optimize SetLookAndInteract and NearestVisibleLivingEntities - diff on change
+    }
+
+    // Leaf start - Optimize SetLookAndInteract and NearestVisibleLivingEntities
+    public List<LivingEntity> findWithList(Predicate<LivingEntity> predicate) {
+        it.unimi.dsi.fastutil.objects.ObjectList<LivingEntity> result = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
+        for (LivingEntity entity : this.nearbyEntities) {
+            if (predicate.test(entity) && this.lineOfSightTest.test(entity)) {
+                result.add(entity);
+            }
+        }
+        return result;
+    }
+    // Leaf end - Optimize SetLookAndInteract and NearestVisibleLivingEntities
 
     public boolean contains(LivingEntity entity) {
         return this.nearbyEntities.contains(entity) && this.lineOfSightTest.test(entity);
