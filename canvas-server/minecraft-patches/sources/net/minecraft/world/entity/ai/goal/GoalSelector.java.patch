--- a/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -20,10 +_,11 @@
         }
     };
     private final Map<Goal.Flag, WrappedGoal> lockedFlags = new EnumMap<>(Goal.Flag.class);
-    private final Set<WrappedGoal> availableGoals = new ObjectLinkedOpenHashSet<>();
+    private final io.canvasmc.canvas.util.map.BinaryGoalSet availableGoals = new io.canvasmc.canvas.util.map.BinaryGoalSet(); // Leaf - optimize goal selector
     private static final Goal.Flag[] GOAL_FLAG_VALUES = Goal.Flag.values(); // Paper - remove streams from GoalSelector
     private final ca.spottedleaf.moonrise.common.set.OptimizedSmallEnumSet<net.minecraft.world.entity.ai.goal.Goal.Flag> goalTypes = new ca.spottedleaf.moonrise.common.set.OptimizedSmallEnumSet<>(Goal.Flag.class); // Paper - remove streams from GoalSelector
     private int curRate; // Paper - EAR 2
+    private final int[] lockedPriorities = new int[GOAL_FLAG_VALUES.length]; // Leaf - optimize goal selector
 
     public void addGoal(int priority, Goal goal) {
         this.availableGoals.add(new WrappedGoal(priority, goal));
@@ -40,7 +_,12 @@
     }
 
     public boolean hasTasks() {
-        for (WrappedGoal task : this.availableGoals) {
+        // Leaf start - optimize goal selector
+        io.canvasmc.canvas.util.map.BinaryGoalSet availableGoals = this.availableGoals;
+        WrappedGoal[] elements = availableGoals.elements();
+        for (int i = 0, j = availableGoals.size(); i < j; i++) {
+            WrappedGoal task = elements[i];
+        // Leaf end - optimize goal selector
             if (task.isRunning()) {
                 return true;
             }
@@ -50,7 +_,12 @@
     // Paper end - EAR 2
 
     public void removeGoal(Goal goal) {
-        for (WrappedGoal wrappedGoal : this.availableGoals) {
+        // Leaf start - optimize goal selector
+        io.canvasmc.canvas.util.map.BinaryGoalSet availableGoals = this.availableGoals;
+        WrappedGoal[] elements = availableGoals.elements();
+        for (int i = 0, j = availableGoals.size(); i < j; i++) {
+            WrappedGoal wrappedGoal = elements[i];
+        // Leaf end - optimize goal selector
             if (wrappedGoal.getGoal() == goal && wrappedGoal.isRunning()) {
                 wrappedGoal.stop();
             }
@@ -80,37 +_,81 @@
     }
 
     public void tick() {
-        for (WrappedGoal wrappedGoal : this.availableGoals) {
-            if (wrappedGoal.isRunning() && (goalContainsAnyFlags(wrappedGoal, this.goalTypes) || !wrappedGoal.canContinueToUse())) { // Paper - Perf: optimize goal types by removing streams
-                wrappedGoal.stop();
-            }
-        }
-
-        this.lockedFlags.entrySet().removeIf(entry -> !entry.getValue().isRunning());
-
-        for (WrappedGoal wrappedGoalx : this.availableGoals) {
-            // Paper start
-            if (!wrappedGoalx.isRunning() && !goalContainsAnyFlags(wrappedGoalx, this.goalTypes) && goalCanBeReplacedForAllFlags(wrappedGoalx, this.lockedFlags) && wrappedGoalx.canUse()) {
-                long flagIterator = wrappedGoalx.getFlags().getBackingSet();
-                int wrappedGoalSize = wrappedGoalx.getFlags().size();
-                for (int i = 0; i < wrappedGoalSize; ++i) {
-                    final Goal.Flag flag = GOAL_FLAG_VALUES[Long.numberOfTrailingZeros(flagIterator)];
-                    flagIterator ^= ca.spottedleaf.concurrentutil.util.IntegerUtil.getTrailingBit(flagIterator);
-                    // Paper end
-                    WrappedGoal wrappedGoal1 = this.lockedFlags.getOrDefault(flag, NO_GOAL);
-                    wrappedGoal1.stop();
-                    this.lockedFlags.put(flag, wrappedGoalx);
+        // Canvas start - Leaf - optimize goal selector
+        final io.canvasmc.canvas.util.map.BinaryGoalSet availableGoals = this.availableGoals;
+        final WrappedGoal[] elements = availableGoals.elements();
+        final long disabled = this.goalTypes.getBackingSet();
+        final int elemSize = availableGoals.size();
+        final Map<Goal.Flag, WrappedGoal> lockedFlags = this.lockedFlags;
+        final int[] lockedPriorities = this.lockedPriorities;
+        long mask = 0L;
+
+        for (int i = 0; i < elemSize; i++) {
+            final WrappedGoal goal = elements[i];
+            if (goal.isRunning() && ((disabled & goal.goal.getFlags().getBackingSet()) != 0 || !goal.canContinueToUse())) {
+                goal.stop();
+            }
+        }
+        for (int i = 0; i < GOAL_FLAG_VALUES.length; i++) {
+            final Goal.Flag flag = GOAL_FLAG_VALUES[i];
+            final WrappedGoal locked = lockedFlags.get(flag);
+            if (locked == null) {
+                lockedPriorities[i] = Integer.MAX_VALUE;
+            } else if (!locked.isRunning()) {
+                lockedFlags.remove(flag);
+                lockedPriorities[i] = Integer.MAX_VALUE;
+            } else {
+                lockedPriorities[i] = locked.isInterruptable()
+                    ? locked.getPriority()
+                    : Integer.MIN_VALUE;
+                mask |= (1L << i);
+            }
+        }
+        for (int i = 0; i < elemSize; i++) {
+            final WrappedGoal goal = elements[i];
+            if (goal.isRunning()) {
+                continue;
+            }
+            final long f = goal.goal.getFlags().getBackingSet();
+            final int p = goal.getPriority();
+            if ((disabled & f) != 0L
+                || (f & mask) != 0L
+                && ((f & 1L) != 0L && p >= lockedPriorities[0]
+                || (f & 2L) != 0L && p >= lockedPriorities[1]
+                || (f & 4L) != 0L && p >= lockedPriorities[2]
+                || (f & 8L) != 0L && p >= lockedPriorities[3]
+                || (f & 16L) != 0L && p >= lockedPriorities[4])) {
+                continue;
+            } else if (!goal.canUse()) {
+                continue;
+            }
+            for (long iter = f; iter != 0L; iter &= iter - 1) {
+                final int j = Long.numberOfTrailingZeros(iter);
+                final Goal.Flag flag = GOAL_FLAG_VALUES[j];
+                final WrappedGoal locked = lockedFlags.get(flag);
+                if (locked != null) {
+                    locked.stop();
                 }
-
-                wrappedGoalx.start();
+                lockedFlags.put(flag, goal);
+                lockedPriorities[j] = goal.isInterruptable()
+                    ? goal.getPriority()
+                    : Integer.MIN_VALUE;
+                mask |= (1L << j);
             }
+            goal.start();
         }
 
         this.tickRunningGoals(true);
+        // Canvas end - Leaf - optimize goal selector
     }
 
     public void tickRunningGoals(boolean tickAllRunning) {
-        for (WrappedGoal wrappedGoal : this.availableGoals) {
+        // Leaf start - optimize goal selector
+        io.canvasmc.canvas.util.map.BinaryGoalSet availableGoals = this.availableGoals;
+        WrappedGoal[] elements = availableGoals.elements();
+        for (int i = 0, j = availableGoals.size(); i < j; i++) {
+            WrappedGoal wrappedGoal = elements[i];
+        // Leaf end - optimize goal selector
             if (wrappedGoal.isRunning() && (tickAllRunning || wrappedGoal.requiresUpdateEveryTick())) {
                 wrappedGoal.tick();
             }
