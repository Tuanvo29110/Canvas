--- a/net/minecraft/world/entity/ExperienceOrb.java
+++ b/net/minecraft/world/entity/ExperienceOrb.java
@@ -153,7 +_,7 @@
         } else {
             super.tick();
             boolean flag = !this.level().noCollision(this.getBoundingBox());
-            if (this.isEyeInFluid(FluidTags.WATER)) {
+            if (this.isEyeInWater()) { // Canvas - optimize fluidOnEyes
                 this.setUnderwaterMovement();
             } else if (!flag) {
                 this.applyGravity();
@@ -246,7 +_,7 @@
     private void scanForMerges() {
         if (this.level() instanceof ServerLevel) {
             for (ExperienceOrb experienceOrb : this.level()
-                .getEntities(EntityTypeTest.forClass(ExperienceOrb.class), this.getBoundingBox().inflate(0.5), this::canMerge)) {
+                .getEntities(EntityTypeTest.forClass(ExperienceOrb.class), this.getBoundingBox().inflate(io.canvasmc.canvas.Config.INSTANCE.fastOrbs ? 0.9 : 0.5), this::canMerge)) { // Canvas - fast orbs
                 this.merge(experienceOrb);
             }
         }
@@ -262,6 +_,24 @@
     }
     public static void awardWithDirection(ServerLevel level, Vec3 pos, Vec3 direction, int amount, @Nullable org.bukkit.entity.ExperienceOrb.SpawnReason reason, @Nullable Entity triggerId, @Nullable Entity sourceId) {
     // Paper end - add reason to orbs
+        // Canvas start - fast orbs
+        if (io.canvasmc.canvas.Config.INSTANCE.fastOrbs) {
+            if (amount <= 0) return; // skip if count is 0
+            int experienceValue = getExperienceValue(amount);
+            AABB aabb = AABB.ofSize(pos, 1.0, 1.0, 1.0);
+            List<ExperienceOrb> entities = level.getEntities(
+                EntityTypeTest.forClass(ExperienceOrb.class), aabb, experienceOrb1 -> canMerge(experienceOrb1, -1, -1) // we are running fast orbs so it just checks if it's alive, the 2 int vals don't matter
+            );
+            if (!entities.isEmpty()) {
+                ExperienceOrb experienceOrb = entities.getFirst();
+                experienceOrb.age = 0;
+                experienceOrb.setValue(experienceOrb.getValue() + experienceValue);
+            } else {
+                level.addFreshEntity(new ExperienceOrb(level, pos, direction, experienceValue, reason, triggerId, sourceId));
+            }
+            return;
+        }
+        // Canvas end - fast orbs
         while (amount > 0) {
             int experienceValue = getExperienceValue(amount);
             amount -= experienceValue;
@@ -289,10 +_,12 @@
     }
 
     private boolean canMerge(ExperienceOrb orb) {
+        if (io.canvasmc.canvas.Config.INSTANCE.fastOrbs) return orb.isAlive() && !this.is(orb); // Canvas - fast orbs
         return orb != this && canMerge(orb, this.getId(), this.getValue());
     }
 
     private static boolean canMerge(ExperienceOrb orb, int amount, int other) {
+        if (io.canvasmc.canvas.Config.INSTANCE.fastOrbs) return orb.isAlive(); // Canvas - fast orbs
         return !orb.isRemoved() && (orb.getId() - amount) % io.papermc.paper.configuration.GlobalConfiguration.get().misc.xpOrbGroupsPerArea.or(ORB_GROUPS_PER_AREA) == 0 && orb.getValue() == other; // Paper - Configure how many orbs will merge together
     }
 
@@ -302,6 +_,14 @@
             return;
         }
         // Paper end - call orb merge event
+        // Canvas start - fast orbs
+        if (io.canvasmc.canvas.Config.INSTANCE.fastOrbs) {
+            this.setValue(this.getValue() + orb.getValue());
+            this.age = Math.min(this.age, orb.age);
+            orb.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.MERGE); // CraftBukkit - add Bukkit remove cause
+            return;
+        }
+        // Canvas end - fast orbs
         this.count = this.count + orb.count;
         this.age = Math.min(this.age, orb.age);
         orb.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.MERGE); // CraftBukkit - add Bukkit remove cause
@@ -358,7 +_,7 @@
     public void playerTouch(Player entity) {
         if (entity instanceof ServerPlayer serverPlayer) {
             if (entity.takeXpDelay == 0 && new com.destroystokyo.paper.event.player.PlayerPickupExperienceEvent(serverPlayer.getBukkitEntity(), (org.bukkit.entity.ExperienceOrb) this.getBukkitEntity()).callEvent()) { // Paper - PlayerPickupExperienceEvent
-                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, 2, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2;
+                entity.takeXpDelay = org.bukkit.craftbukkit.event.CraftEventFactory.callPlayerXpCooldownEvent(entity, io.canvasmc.canvas.Config.INSTANCE.fastOrbs ? 0 : 2, org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason.PICKUP_ORB).getNewCooldown(); // CraftBukkit - entityhuman.takeXpDelay = 2; // Canvas - fast orbs
                 entity.take(this, 1);
                 int i = this.repairPlayerItems(serverPlayer, this.getValue());
                 if (i > 0) {
