--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -208,7 +_,7 @@
     private static final Dynamic<?> EMPTY_BRAIN = new Dynamic<>(JavaOps.INSTANCE, Map.of("memories", Map.of()));
     private final AttributeMap attributes;
     public CombatTracker combatTracker = new CombatTracker(this);
-    public final Map<Holder<MobEffect>, MobEffectInstance> activeEffects = Maps.newHashMap();
+    public final Map<Holder<MobEffect>, MobEffectInstance> activeEffects = new it.unimi.dsi.fastutil.objects.Reference2ReferenceOpenHashMap<>(); // Canvas - optimized collection
     private final Map<EquipmentSlot, ItemStack> lastEquipmentItems = Util.makeEnumMap(EquipmentSlot.class, slot -> ItemStack.EMPTY);
     public boolean swinging;
     private boolean discardFriction = false;
@@ -1022,14 +_,18 @@
     }
 
     private void updateSynchronizedMobEffectParticles() {
-        List<ParticleOptions> list = this.activeEffects
-            .values()
-            .stream()
-            .filter(MobEffectInstance::isVisible)
-            .map(MobEffectInstance::getParticleOptions)
-            .toList();
+        // Canvas start - remove streams
+        List<ParticleOptions> list = new java.util.ArrayList<>();
+        final Collection<MobEffectInstance> effectsValues = this.activeEffects.values(); // Canvas - optimized collection
+
+        for (MobEffectInstance effect : effectsValues) { // Canvas - optimized collection
+            if (effect.isVisible()) {
+                list.add(effect.getParticleOptions());
+            }
+        }
+        // Canvas end - remove streams
         this.entityData.set(DATA_EFFECT_PARTICLES, list);
-        this.entityData.set(DATA_EFFECT_AMBIENCE_ID, areAllEffectsAmbient(this.activeEffects.values()));
+        this.entityData.set(DATA_EFFECT_AMBIENCE_ID, areAllEffectsAmbient(effectsValues)); // Canvas - optimized collection
     }
 
     private void updateGlowingStatus() {
@@ -3569,7 +_,7 @@
             this.checkAutoSpinAttack(boundingBox, this.getBoundingBox());
         }
 
-        this.pushEntities();
+        if (io.canvasmc.canvas.Config.INSTANCE.entityCollisionMode.allEntitiesCanBePushed()) this.pushEntities(); // Canvas - entity collision mode config
         // Paper start - Add EntityMoveEvent
         if (((ServerLevel) this.level()).getCurrentWorldData().hasEntityMoveEvent && !(this instanceof Player)) { // Folia - region threading
             if (this.xo != this.getX() || this.yo != this.getY() || this.zo != this.getZ() || this.yRotO != this.getYRot() || this.xRotO != this.getXRot()) {
@@ -3646,6 +_,12 @@
     }
 
     protected void pushEntities() {
+        // Canvas start - only players push config
+        io.canvasmc.canvas.entity.EntityCollisionMode collisionMode = io.canvasmc.canvas.Config.INSTANCE.entityCollisionMode;
+        if (collisionMode.noCollisions()) {
+            return;
+        }
+        // Canvas end - only players push config
         // Paper start - don't run getEntities if we're not going to use its result
         if (!this.isPushable()) {
             return;
@@ -3661,7 +_,11 @@
             return;
         }
         // Paper end - don't run getEntities if we're not going to use its result
-        List<Entity> pushableEntities = this.level().getPushableEntities(this, this.getBoundingBox());
+        // Canvas start - only players push config
+        List<? extends Entity> pushableEntities = collisionMode.onlyPlayersPushable() ?
+            this.level().getIntersectingPlayers(this, this.getBoundingBox(), EntitySelector.pushableBy(this))
+            : this.level().getPushableEntities(this, this.getBoundingBox());
+        // Canvas end - only players push config
         if (!pushableEntities.isEmpty()) {
             if (this.level() instanceof ServerLevel serverLevel) {
                 // Paper - don't run getEntities if we're not going to use its result; moved up
