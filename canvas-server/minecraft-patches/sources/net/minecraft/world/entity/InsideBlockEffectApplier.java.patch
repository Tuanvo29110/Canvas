--- a/net/minecraft/world/entity/InsideBlockEffectApplier.java
+++ b/net/minecraft/world/entity/InsideBlockEffectApplier.java
@@ -30,20 +_,27 @@
     void runAfter(InsideBlockEffectType type, Consumer<Entity> effect);
 
     public static class StepBasedCollector implements InsideBlockEffectApplier {
+        // Canvas start - optimize step based collector
+        // heavily based off of https://github.com/Winds-Studio/Leaf/blob/ver/1.21.8/leaf-server/minecraft-patches/features/0273-optimize-checkInsideBlocks-calls.patch
+        // modifications included for micro optimizations and slight performance increases
         private static final InsideBlockEffectType[] APPLY_ORDER = InsideBlockEffectType.values();
-        private static final int NO_STEP = -1;
-        private final Map<InsideBlockEffectType, Consumer<Entity>> effectsInStep = new java.util.EnumMap<>(InsideBlockEffectType.class); // Paper - track position inside effect was triggered on
-        private final Map<InsideBlockEffectType, List<Consumer<Entity>>> beforeEffectsInStep = Util.makeEnumMap(
-            InsideBlockEffectType.class, insideBlockEffectType -> new ArrayList<>()
-        );
-        private final Map<InsideBlockEffectType, List<Consumer<Entity>>> afterEffectsInStep = Util.makeEnumMap(
-            InsideBlockEffectType.class, insideBlockEffectType -> new ArrayList<>()
-        );
-        private final List<Consumer<Entity>> finalEffects = new ArrayList<>();
+
+        private final Consumer<Entity>[] effectsInStep = new Consumer[APPLY_ORDER.length];
+        private final it.unimi.dsi.fastutil.objects.ObjectArrayList<Consumer<Entity>>[] beforeEffectsInStep = new it.unimi.dsi.fastutil.objects.ObjectArrayList[APPLY_ORDER.length];
+        private final it.unimi.dsi.fastutil.objects.ObjectArrayList<Consumer<Entity>>[] afterEffectsInStep = new it.unimi.dsi.fastutil.objects.ObjectArrayList[APPLY_ORDER.length];
+
+        private final it.unimi.dsi.fastutil.objects.ObjectArrayList<Consumer<Entity>> finalEffects = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>();
         private int lastStep = -1;
 
-        public void advanceStep(int step, net.minecraft.core.BlockPos pos) { // Paper - track position inside effect was triggered on
-            this.currentBlockPos = pos; // Paper - track position inside effect was triggered on
+        public StepBasedCollector() {
+            for (int i = 0; i < APPLY_ORDER.length; i++) {
+                beforeEffectsInStep[i] = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(2);
+                afterEffectsInStep[i] = new it.unimi.dsi.fastutil.objects.ObjectArrayList<>(2);
+            }
+        }
+
+        public void advanceStep(int step, net.minecraft.core.BlockPos pos) {
+            this.currentBlockPos = pos;
             if (this.lastStep != step) {
                 this.lastStep = step;
                 this.flushStep();
@@ -53,46 +_,83 @@
         public void applyAndClear(Entity entity) {
             this.flushStep();
 
-            for (Consumer<Entity> consumer : this.finalEffects) {
+            List<Consumer<Entity>> effects = this.finalEffects;
+            int size = effects.size();
+
+            if (size == 0) {
+                this.lastStep = -1;
+                return;
+            }
+
+            if (!entity.isAlive()) {
+                effects.clear();
+                this.lastStep = -1;
+                return;
+            }
+
+            int i = 0;
+            while (i < size - 3) {
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
+                effects.get(i++).accept(entity);
                 if (!entity.isAlive()) {
                     break;
                 }
-
-                consumer.accept(entity);
-            }
-
-            this.finalEffects.clear();
+            }
+
+            if (entity.isAlive()) {
+                for (; i < size; i++) {
+                    effects.get(i).accept(entity);
+                    if (!entity.isAlive()) {
+                        break;
+                    }
+                }
+            }
+
+            effects.clear();
             this.lastStep = -1;
         }
 
         private void flushStep() {
-            for (InsideBlockEffectType insideBlockEffectType : APPLY_ORDER) {
-                List<Consumer<Entity>> list = this.beforeEffectsInStep.get(insideBlockEffectType);
-                this.finalEffects.addAll(list);
-                list.clear();
-                if (this.effectsInStep.remove(insideBlockEffectType) instanceof final Consumer<Entity> recordedEffect) { // Paper - track position inside effect was triggered on - better than null check to avoid diff.
-                    this.finalEffects.add(recordedEffect); // Paper - track position inside effect was triggered on
-                }
-
-                List<Consumer<Entity>> list1 = this.afterEffectsInStep.get(insideBlockEffectType);
-                this.finalEffects.addAll(list1);
-                list1.clear();
+            final int len = APPLY_ORDER.length;
+            final Consumer<Entity>[] effectArr = this.effectsInStep;
+            final List<Consumer<Entity>> finalList = this.finalEffects;
+
+            for (int i = 0; i < len; i++) {
+                List<Consumer<Entity>> beforeList = this.beforeEffectsInStep[i];
+                if (!beforeList.isEmpty()) {
+                    finalList.addAll(beforeList);
+                    beforeList.clear();
+                }
+
+                Consumer<Entity> effect = effectArr[i];
+                if (effect != null) {
+                    finalList.add(effect);
+                    effectArr[i] = null;
+                }
+
+                List<Consumer<Entity>> afterList = this.afterEffectsInStep[i];
+                if (!afterList.isEmpty()) {
+                    finalList.addAll(afterList);
+                    afterList.clear();
+                }
             }
         }
 
         @Override
         public void apply(InsideBlockEffectType type) {
-            this.effectsInStep.put(type, recorded(type));  // Paper - track position inside effect was triggered on
+            effectsInStep[type.ordinal()] = recorded(type);
         }
 
         @Override
         public void runBefore(InsideBlockEffectType type, Consumer<Entity> effect) {
-            this.beforeEffectsInStep.get(type).add(effect);
+            beforeEffectsInStep[type.ordinal()].add(effect);
         }
 
         @Override
         public void runAfter(InsideBlockEffectType type, Consumer<Entity> effect) {
-            this.afterEffectsInStep.get(type).add(effect);
+            afterEffectsInStep[type.ordinal()].add(effect);
         }
 
         // Paper start - track position inside effect was triggered on
@@ -113,5 +_,6 @@
             }
         }
         // Paper end - track position inside effect was triggered on
+        // Canvas end - optimize step based collector
     }
 }
