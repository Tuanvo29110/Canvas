--- a/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -139,13 +_,14 @@
 
     public static void pushItemsTick(Level level, BlockPos pos, BlockState state, HopperBlockEntity blockEntity) {
         blockEntity.cooldownTime--;
-        blockEntity.tickedGameTime = level.getRedstoneGameTime(); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Canvas - optimize hoppers
+        blockEntity.tickedGameTime = worldData.getRedstoneGameTime(); // Folia - region threading // Canvas - optimize hoppers
         if (!blockEntity.isOnCooldown()) {
             blockEntity.setCooldown(0);
             // Spigot start
             boolean result = tryMoveItems(level, pos, state, blockEntity, () -> {
                 return suckInItems(level, blockEntity);
-            });
+            }, worldData); // Canvas - optimize hoppers
             if (!result && blockEntity.level.spigotConfig.hopperCheck > 1) {
                 blockEntity.setCooldown(blockEntity.level.spigotConfig.hopperCheck);
             }
@@ -190,7 +_,7 @@
     }
     // Paper end - Perf: Optimize Hoppers
 
-    private static boolean tryMoveItems(Level level, BlockPos pos, BlockState state, HopperBlockEntity blockEntity, BooleanSupplier validator) {
+    private static boolean tryMoveItems(Level level, BlockPos pos, BlockState state, HopperBlockEntity blockEntity, BooleanSupplier validator, io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Canvas - optimize hoppers
         if (level.isClientSide) {
             return false;
         } else {
@@ -198,7 +_,7 @@
                 boolean flag = false;
                 final int fullState = getFullState(blockEntity); // Paper - Perf: Optimize Hoppers
                 if (fullState != HOPPER_EMPTY) { // Paper - Perf: Optimize Hoppers
-                    flag = ejectItems(level, pos, blockEntity);
+                    flag = ejectItems(level, pos, blockEntity, worldData); // Canvas - optimize hoppers
                 }
 
                 if (fullState != HOPPER_IS_FULL || flag) { // Paper - Perf: Optimize Hoppers
@@ -226,148 +_,22 @@
         return true;
     }
 
-    // Paper start - Perf: Optimize Hoppers
-    // Folia - region threading - moved to RegionizedWorldData
-
-    private static boolean hopperPush(final Level level, final Container destination, final Direction direction, final HopperBlockEntity hopper) {
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
-        worldData.skipPushModeEventFire = worldData.skipHopperEvents; // Folia - region threading
-        boolean foundItem = false;
-        for (int i = 0; i < hopper.getContainerSize(); ++i) {
-            final ItemStack item = hopper.getItem(i);
-            if (!item.isEmpty()) {
-                foundItem = true;
-                ItemStack origItemStack = item;
-                ItemStack movedItem = origItemStack;
-
-                final int originalItemCount = origItemStack.getCount();
-                final int movedItemCount = Math.min(level.spigotConfig.hopperAmount, originalItemCount);
-                origItemStack.setCount(movedItemCount);
-
-                // We only need to fire the event once to give protection plugins a chance to cancel this event
-                // Because nothing uses getItem, every event call should end up the same result.
-                if (!worldData.skipPushModeEventFire) { // Folia - region threading
-                    movedItem = callPushMoveEvent(destination, movedItem, hopper);
-                    if (movedItem == null) { // cancelled
-                        origItemStack.setCount(originalItemCount);
-                        return false;
-                    }
-                }
-
-                final ItemStack remainingItem = addItem(hopper, destination, movedItem, direction);
-                final int remainingItemCount = remainingItem.getCount();
-                if (remainingItemCount != movedItemCount) {
-                    origItemStack = origItemStack.copy(true);
-                    origItemStack.setCount(originalItemCount);
-                    if (!origItemStack.isEmpty()) {
-                        origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
-                    }
-                    hopper.setItem(i, origItemStack);
-                    destination.setChanged();
-                    return true;
-                }
-                origItemStack.setCount(originalItemCount);
-            }
-        }
-        if (foundItem && level.paperConfig().hopper.cooldownWhenFull) { // Inventory was full - cooldown
-            hopper.setCooldown(level.spigotConfig.hopperTransfer);
-        }
-        return false;
-    }
-
-    private static boolean hopperPull(final Level level, final Hopper hopper, final Container container, ItemStack origItemStack, final int i) {
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = level.getCurrentWorldData(); // Folia - region threading
-        ItemStack movedItem = origItemStack;
-        final int originalItemCount = origItemStack.getCount();
-        final int movedItemCount = Math.min(level.spigotConfig.hopperAmount, originalItemCount);
-        container.setChanged(); // original logic always marks source inv as changed even if no move happens.
-        movedItem.setCount(movedItemCount);
-
-        if (!worldData.skipPullModeEventFire) { // Folia - region threading
-            movedItem = callPullMoveEvent(hopper, container, movedItem);
-            if (movedItem == null) { // cancelled
-                origItemStack.setCount(originalItemCount);
-                // Drastically improve performance by returning true.
-                // No plugin could have relied on the behavior of false as the other call
-                // site for IMIE did not exhibit the same behavior
-                return true;
-            }
-        }
-
-        final ItemStack remainingItem = addItem(container, hopper, movedItem, null);
-        final int remainingItemCount = remainingItem.getCount();
-        if (remainingItemCount != movedItemCount) {
-            origItemStack = origItemStack.copy(true);
-            origItemStack.setCount(originalItemCount);
-            if (!origItemStack.isEmpty()) {
-                origItemStack.setCount(originalItemCount - movedItemCount + remainingItemCount);
-            }
-
-            IGNORE_TILE_UPDATES.set(true); // Folia - region threading
-            container.setItem(i, origItemStack);
-            IGNORE_TILE_UPDATES.set(false); // Folia - region threading
-            container.setChanged();
-            return true;
-        }
-        origItemStack.setCount(originalItemCount);
-
-        if (level.paperConfig().hopper.cooldownWhenFull) {
-            applyCooldown(hopper);
-        }
-
-        return false;
-    }
-
-    @Nullable
-    private static ItemStack callPushMoveEvent(Container destination, ItemStack itemStack, HopperBlockEntity hopper) {
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
-        final org.bukkit.inventory.Inventory destinationInventory = getInventory(destination);
-        final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(
-            hopper.getOwner(false).getInventory(),
-            org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemStack),
-            destinationInventory,
-            true
-        );
-        final boolean result = event.callEvent();
-        if (!event.calledGetItem && !event.calledSetItem) {
-            worldData.skipPushModeEventFire = true; // Folia - region threading
-        }
-        if (!result) {
-            applyCooldown(hopper);
-            return null;
-        }
-
-        if (event.calledSetItem) {
-            return org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem());
-        } else {
-            return itemStack;
-        }
-    }
-
-    @Nullable
-    private static ItemStack callPullMoveEvent(final Hopper hopper, final Container container, final ItemStack itemstack) {
-        io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
-        final org.bukkit.inventory.Inventory sourceInventory = getInventory(container);
-        final org.bukkit.inventory.Inventory destination = getInventory(hopper);
-
-        // Mirror is safe as no plugins ever use this item
-        final io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent event = new io.papermc.paper.event.inventory.PaperInventoryMoveItemEvent(sourceInventory, org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(itemstack), destination, false);
-        final boolean result = event.callEvent();
-        if (!event.calledGetItem && !event.calledSetItem) {
-            worldData.skipPullModeEventFire = true; // Folia - region threading
-        }
-        if (!result) {
-            applyCooldown(hopper);
-            return null;
-        }
-
-        if (event.calledSetItem) {
-            return org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem());
-        } else {
-            return itemstack;
-        }
-    }
-
+    // Canvas start - optimize hoppers
+    /*
+        The optimizations included in this patch(primarily this file) return the following results
+        in an environment of a void world with 161,604 hoppers in 1 region. All tests with chests
+        place a chest  above every hopper, which also means it's touching the hopper above, if there is one
+
+        1.21.8 Folia, no chests: ~38.12ms
+        1.21.8 Folia, with chests: ~69.69ms
+
+        1.21.8 Canvas, no chests: ~28.19ms
+        1.21.8 Canvas, with chests: ~39.21ms
+
+        The test results shown above were done at the time of writing this patch. Over time, these
+        benchmarks may become inaccurate. If further performance enhancements are done for hoppers,
+        these benchmarks will be updated to match the new performance improvements
+     */
     private static org.bukkit.inventory.Inventory getInventory(final Container container) {
         final org.bukkit.inventory.Inventory sourceInventory;
         if (container instanceof net.minecraft.world.CompoundContainer compoundContainer) {
@@ -383,53 +_,9 @@
         return sourceInventory;
     }
 
-    private static void applyCooldown(final Hopper hopper) {
-        if (hopper instanceof HopperBlockEntity blockEntity && blockEntity.getLevel() != null) {
-            blockEntity.setCooldown(blockEntity.getLevel().spigotConfig.hopperTransfer);
-        }
-    }
-
-    private static boolean allMatch(Container container, Direction direction, java.util.function.BiPredicate<ItemStack, Integer> test) {
-        if (container instanceof WorldlyContainer) {
-            for (int slot : ((WorldlyContainer) container).getSlotsForFace(direction)) {
-                if (!test.test(container.getItem(slot), slot)) {
-                    return false;
-                }
-            }
-        } else {
-            int size = container.getContainerSize();
-            for (int slot = 0; slot < size; slot++) {
-                if (!test.test(container.getItem(slot), slot)) {
-                    return false;
-                }
-            }
-        }
-        return true;
-    }
-
-    private static boolean anyMatch(Container container, Direction direction, java.util.function.BiPredicate<ItemStack, Integer> test) {
-        if (container instanceof WorldlyContainer) {
-            for (int slot : ((WorldlyContainer) container).getSlotsForFace(direction)) {
-                if (test.test(container.getItem(slot), slot)) {
-                    return true;
-                }
-            }
-        } else {
-            int size = container.getContainerSize();
-            for (int slot = 0; slot < size; slot++) {
-                if (test.test(container.getItem(slot), slot)) {
-                    return true;
-                }
-            }
-        }
-        return true;
-    }
-    private static final java.util.function.BiPredicate<ItemStack, Integer> STACK_SIZE_TEST = (itemStack, i) -> itemStack.getCount() >= itemStack.getMaxStackSize();
-    private static final java.util.function.BiPredicate<ItemStack, Integer> IS_EMPTY_TEST = (itemStack, i) -> itemStack.isEmpty();
-    // Paper end - Perf: Optimize Hoppers
-
-    private static boolean ejectItems(Level level, BlockPos pos, HopperBlockEntity blockEntity) {
-        Container attachedContainer = getAttachedContainer(level, pos, blockEntity);
+    private static boolean ejectItems(Level level, BlockPos pos, HopperBlockEntity blockEntity, io.papermc.paper.threadedregions.RegionizedWorldData worldData) {
+        Container attachedContainer = getAttachedContainer(level, pos, blockEntity, worldData);
+    // Canvas end - optimize hoppers
         if (attachedContainer == null) {
             return false;
         } else {
@@ -437,60 +_,49 @@
             if (isFullContainer(attachedContainer, opposite)) {
                 return false;
             } else {
-                // Paper start - Perf: Optimize Hoppers
-                return hopperPush(level, attachedContainer, opposite, blockEntity);
-                //for (int i = 0; i < blockEntity.getContainerSize(); i++) {
-                //    ItemStack item = blockEntity.getItem(i);
-                //    if (!item.isEmpty()) {
-                //        int count = item.getCount();
-                //        // CraftBukkit start - Call event when pushing items into other inventories
-                //        ItemStack original = item.copy();
-                //        org.bukkit.craftbukkit.inventory.CraftItemStack oitemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(
-                //            blockEntity.removeItem(i, level.spigotConfig.hopperAmount)
-                //        ); // Spigot
-
-                //        org.bukkit.inventory.Inventory destinationInventory;
-                //        // Have to special case large chests as they work oddly
-                //        if (attachedContainer instanceof final net.minecraft.world.CompoundContainer compoundContainer) {
-                //            destinationInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest(compoundContainer);
-                //        } else if (attachedContainer.getOwner() != null) {
-                //            destinationInventory = attachedContainer.getOwner().getInventory();
-                //        } else {
-                //            destinationInventory = new org.bukkit.craftbukkit.inventory.CraftInventory(attachedContainer);
-                //        }
-
-                //        org.bukkit.event.inventory.InventoryMoveItemEvent event = new org.bukkit.event.inventory.InventoryMoveItemEvent(
-                //            blockEntity.getOwner().getInventory(),
-                //            oitemstack,
-                //            destinationInventory,
-                //            true
-                //        );
-                //        if (!event.callEvent()) {
-                //            blockEntity.setItem(i, original);
-                //            blockEntity.setCooldown(level.spigotConfig.hopperTransfer); // Delay hopper checks // Spigot
-                //            return false;
-                //        }
-                //        int origCount = event.getItem().getAmount(); // Spigot
-                //        ItemStack itemStack = HopperBlockEntity.addItem(blockEntity, attachedContainer, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem()), opposite);
-                //        // CraftBukkit end
-
-                //        if (itemStack.isEmpty()) {
-                //            attachedContainer.setChanged();
-                //            return true;
-                //        }
-
-                //        item.setCount(count);
-                //        // Spigot start
-                //        item.shrink(origCount - itemStack.getCount());
-                //        if (count <= level.spigotConfig.hopperAmount) {
-                //            // Spigot end
-                //            blockEntity.setItem(i, item);
-                //        }
-                //    }
-                //}
-
-                //return false;
-                // Paper end - Perf: Optimize Hoppers
+                for (int i = 0; i < blockEntity.getContainerSize(); i++) {
+                   ItemStack item = blockEntity.getItem(i);
+                   if (!item.isEmpty()) {
+                       int count = item.getCount();
+                       // CraftBukkit start - Call event when pushing items into other inventories
+                       ItemStack original = item.copy();
+                       org.bukkit.craftbukkit.inventory.CraftItemStack oitemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(
+                           blockEntity.removeItem(i, level.spigotConfig.hopperAmount)
+                       ); // Spigot
+
+                       org.bukkit.inventory.Inventory destinationInventory = getInventory(attachedContainer); // Canvas - optimize hoppers
+
+                       org.bukkit.event.inventory.InventoryMoveItemEvent event = new org.bukkit.event.inventory.InventoryMoveItemEvent(
+                           blockEntity.getOwner().getInventory(),
+                           oitemstack,
+                           destinationInventory,
+                           true
+                       );
+                       if (!event.callEvent()) {
+                           blockEntity.setItem(i, original);
+                           blockEntity.setCooldown(level.spigotConfig.hopperTransfer); // Delay hopper checks // Spigot
+                           return false;
+                       }
+                       int origCount = event.getItem().getAmount(); // Spigot
+                       ItemStack itemStack = HopperBlockEntity.addItem(blockEntity, attachedContainer, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem()), opposite);
+                       // CraftBukkit end
+
+                       if (itemStack.isEmpty()) {
+                           attachedContainer.setChanged();
+                           return true;
+                       }
+
+                       item.setCount(count);
+                       // Spigot start
+                       item.shrink(origCount - itemStack.getCount());
+                       if (count <= level.spigotConfig.hopperAmount) {
+                           // Spigot end
+                           blockEntity.setItem(i, item);
+                       }
+                   }
+                }
+
+                return false;
             }
         }
     }
@@ -543,7 +_,7 @@
         io.papermc.paper.threadedregions.RegionizedWorldData worldData = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData(); // Folia - region threading
         BlockPos blockPos = BlockPos.containing(hopper.getLevelX(), hopper.getLevelY() + 1.0, hopper.getLevelZ());
         BlockState blockState = level.getBlockState(blockPos);
-        Container sourceContainer = getSourceContainer(level, hopper, blockPos, blockState);
+        Container sourceContainer = getSourceContainer(level, hopper, blockPos, blockState, worldData); // Canvas - optimize hoppers
         if (sourceContainer != null) {
             Direction direction = Direction.DOWN;
             worldData.skipPullModeEventFire = worldData.skipHopperEvents; // Paper - Perf: Optimize Hoppers // Folia - region threading
@@ -572,58 +_,47 @@
     private static boolean tryTakeInItemFromSlot(Hopper hopper, Container container, int slot, Direction direction, Level level) { // Spigot
         ItemStack item = container.getItem(slot);
         if (!item.isEmpty() && canTakeItemFromContainer(hopper, container, item, slot, direction)) {
-            // Paper start - Perf: Optimize Hoppers
-            return hopperPull(level, hopper, container, item, slot);
-            //int count = item.getCount();
-            //// CraftBukkit start - Call event on collection of items from inventories into the hopper
-            //ItemStack original = item.copy();
-            //org.bukkit.craftbukkit.inventory.CraftItemStack oitemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(
-            //    container.removeItem(slot, level.spigotConfig.hopperAmount) // Spigot
-            //);
-
-            //org.bukkit.inventory.Inventory sourceInventory;
-            //// Have to special case large chests as they work oddly
-            //if (container instanceof final net.minecraft.world.CompoundContainer compoundContainer) {
-            //    sourceInventory = new org.bukkit.craftbukkit.inventory.CraftInventoryDoubleChest(compoundContainer);
-            //} else if (container.getOwner() != null) {
-            //    sourceInventory = container.getOwner().getInventory();
-            //} else {
-            //    sourceInventory = new org.bukkit.craftbukkit.inventory.CraftInventory(container);
-            //}
-
-            //org.bukkit.event.inventory.InventoryMoveItemEvent event = new org.bukkit.event.inventory.InventoryMoveItemEvent(
-            //    sourceInventory,
-            //    oitemstack,
-            //    hopper.getOwner().getInventory(),
-            //    false
-            //);
-
-            //if (!event.callEvent()) {
-            //    container.setItem(slot, original);
-
-            //    if (hopper instanceof final HopperBlockEntity hopperBlockEntity) {
-            //        hopperBlockEntity.setCooldown(level.spigotConfig.hopperTransfer); // Spigot
-            //    }
-
-            //    return false;
-            //}
-            //int origCount = event.getItem().getAmount(); // Spigot
-            //ItemStack itemStack = HopperBlockEntity.addItem(container, hopper, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem()), null);
-            //// CraftBukkit end
-
-            //if (itemStack.isEmpty()) {
-            //    container.setChanged();
-            //    return true;
-            //}
-
-            //item.setCount(count);
-            //// Spigot start
-            //item.shrink(origCount - itemStack.getCount());
-            //if (count <= level.spigotConfig.hopperAmount) {
-            //    // Spigot end
-            //    container.setItem(slot, item);
-            //}
-            // Paper end - Perf: Optimize Hoppers
+            int count = item.getCount();
+            // CraftBukkit start - Call event on collection of items from inventories into the hopper
+            ItemStack original = item.copy();
+            org.bukkit.craftbukkit.inventory.CraftItemStack oitemstack = org.bukkit.craftbukkit.inventory.CraftItemStack.asCraftMirror(
+               container.removeItem(slot, level.spigotConfig.hopperAmount) // Spigot
+            );
+
+            org.bukkit.inventory.Inventory sourceInventory = getInventory(container); // Canvas - optimize hoppers
+
+            org.bukkit.event.inventory.InventoryMoveItemEvent event = new org.bukkit.event.inventory.InventoryMoveItemEvent(
+               sourceInventory,
+               oitemstack,
+               hopper.getOwner().getInventory(),
+               false
+            );
+
+            if (!event.callEvent()) {
+               container.setItem(slot, original);
+
+               if (hopper instanceof final HopperBlockEntity hopperBlockEntity) {
+                   hopperBlockEntity.setCooldown(level.spigotConfig.hopperTransfer); // Spigot
+               }
+
+               return false;
+            }
+            int origCount = event.getItem().getAmount(); // Spigot
+            ItemStack itemStack = HopperBlockEntity.addItem(container, hopper, org.bukkit.craftbukkit.inventory.CraftItemStack.asNMSCopy(event.getItem()), null);
+            // CraftBukkit end
+
+            if (itemStack.isEmpty()) {
+               container.setChanged();
+               return true;
+            }
+
+            item.setCount(count);
+            // Spigot start
+            item.shrink(origCount - itemStack.getCount());
+            if (count <= level.spigotConfig.hopperAmount) {
+               // Spigot end
+               container.setItem(slot, item);
+            }
         }
 
         return false;
@@ -695,9 +_,7 @@
                     stack = stack.split(destination.getMaxStackSize());
                 }
                 // Spigot end
-                IGNORE_TILE_UPDATES.set(Boolean.TRUE); // Paper - Perf: Optimize Hoppers // Folia - region threading
                 destination.setItem(slot, stack);
-                IGNORE_TILE_UPDATES.set(Boolean.FALSE); // Paper - Perf: Optimize Hoppers // Folia - region threading
                 stack = leftover; // Paper - Make hoppers respect inventory max stack size
                 flag = true;
             } else if (canMergeItems(item, stack)) {
@@ -732,7 +_,9 @@
         org.bukkit.craftbukkit.block.CraftBlock hopper,
         org.bukkit.craftbukkit.block.CraftBlock searchLocation,
         org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType containerType
+        , io.papermc.paper.threadedregions.RegionizedWorldData worldData // Canvas - optimize hoppers
     ) {
+        if (worldData != null && worldData.skipHopperSearchItemEvents) return container; // Canvas - optimize hoppers
         org.bukkit.event.inventory.HopperInventorySearchEvent event = new org.bukkit.event.inventory.HopperInventorySearchEvent(
             (container != null) ? new org.bukkit.craftbukkit.inventory.CraftInventory(container) : null,
             containerType,
@@ -745,7 +_,7 @@
     // CraftBukkit end
 
     @Nullable
-    private static Container getAttachedContainer(Level level, BlockPos pos, HopperBlockEntity blockEntity) {
+    private static Container getAttachedContainer(Level level, BlockPos pos, HopperBlockEntity blockEntity, io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Canvas - optimize hoppers
         // CraftBukkit start
         BlockPos searchPosition = pos.relative(blockEntity.facing);
         Container inventory = getContainerAt(level, searchPosition);
@@ -757,12 +_,13 @@
             hopper,
             searchBlock,
             org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType.DESTINATION
+            , worldData // Canvas - optimize hoppers
         );
         // CraftBukkit end
     }
 
     @Nullable
-    private static Container getSourceContainer(Level level, Hopper hopper, BlockPos pos, BlockState state) {
+    private static Container getSourceContainer(Level level, Hopper hopper, BlockPos pos, BlockState state, io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Canvas - optimize hoppers
         // CraftBukkit start
         final Container inventory = HopperBlockEntity.getContainerAt(level, pos, state, hopper.getLevelX(), hopper.getLevelY() + 1.0D, hopper.getLevelZ());
 
@@ -774,6 +_,7 @@
             hopperBlock,
             containerBlock,
             org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType.SOURCE
+            , worldData // Canvas - optimize hoppers
         );
         // CraftBukkit end
     }
@@ -796,7 +_,7 @@
     @Nullable
     private static Container getContainerAt(Level level, BlockPos pos, BlockState state, double x, double y, double z, final boolean optimizeEntities) {
         // Paper end - Perf: Optimize Hoppers
-        Container blockContainer = getBlockContainer(level, pos, state);
+        Container blockContainer = state.hasBlockEntity() ? getBlockContainer(level, pos, state) : null; // Canvas - optimize hoppers - if there is no block entity, don't bother with this - helps when the hopper is pulling from a non-block-entity-block(air, dirt, etc)
         if (blockContainer == null && (!optimizeEntities || !level.paperConfig().hopper.ignoreOccludingBlocks || !state.getBukkitMaterial().isOccluding())) { // Paper - Perf: Optimize Hoppers
             blockContainer = getEntityContainer(level, x, y, z);
         }
@@ -806,13 +_,20 @@
 
     @Nullable
     private static Container getBlockContainer(Level level, BlockPos pos, BlockState state) {
-        if (!level.spigotConfig.hopperCanLoadChunks && !level.hasChunkAt(pos)) return null; // Spigot
+        // Canvas start - optimize hoppers
+        // the calling method already checks if it has a block entity, so
+        // we can assume that this does have a block entity for us to check
+        final int chunkX = pos.getX() >> 4;
+        final int chunkZ = pos.getZ() >> 4;
+        net.minecraft.world.level.chunk.LevelChunk chunk = level.spigotConfig.hopperCanLoadChunks ? level.getChunk(chunkX, chunkZ) : (net.minecraft.world.level.chunk.LevelChunk) level.getChunkIfLoadedImmediately(chunkX, chunkZ);
+        if (chunk == null) return null;
+        // Canvas end - optimize hoppers
         Block block = state.getBlock();
         if (block instanceof WorldlyContainerHolder) {
             return ((WorldlyContainerHolder)block).getContainer(state, level, pos);
-        } else if (state.hasBlockEntity() && level.getBlockEntity(pos) instanceof Container container) {
+        } else if (chunk.getBlockEntity(pos) instanceof Container container) { // Canvas - optimize hoppers
             if (container instanceof ChestBlockEntity && block instanceof ChestBlock) {
-                container = ChestBlock.getContainer((ChestBlock)block, state, level, pos, true);
+                container = ChestBlock.getContainerForHoppers((ChestBlock)block, state, level, pos, true, container); // Canvas - optimize hoppers
             }
 
             return container;
@@ -879,7 +_,7 @@
         if (entity instanceof ItemEntity itemEntity
             && !itemEntity.getItem().isEmpty()
             && entity.getBoundingBox().move(-pos.getX(), -pos.getY(), -pos.getZ()).intersects(blockEntity.getSuckAabb())) {
-            tryMoveItems(level, pos, state, blockEntity, () -> addItem(blockEntity, itemEntity));
+            tryMoveItems(level, pos, state, blockEntity, () -> addItem(blockEntity, itemEntity), null); // Canvas - optimize hoppers
         }
     }
 
