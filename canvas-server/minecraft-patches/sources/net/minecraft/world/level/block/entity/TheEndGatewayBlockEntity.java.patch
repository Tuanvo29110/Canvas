--- a/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
+++ b/net/minecraft/world/level/block/entity/TheEndGatewayBlockEntity.java
@@ -10,6 +_,7 @@
 import net.minecraft.nbt.CompoundTag;
 import net.minecraft.network.protocol.game.ClientboundBlockEntityDataPacket;
 import net.minecraft.server.level.ServerLevel;
+import net.minecraft.server.level.TicketType;
 import net.minecraft.util.Mth;
 import net.minecraft.util.RandomSource;
 import net.minecraft.world.level.BlockGetter;
@@ -157,7 +_,7 @@
         BlockPos blockPos = findValidSpawnInChunk(chunk);
         if (blockPos == null) {
             BlockPos blockPos1 = BlockPos.containing(vec3.x + 0.5, 75.0, vec3.z + 0.5);
-            LOGGER.debug("Failed to find a suitable block to teleport to, spawning an island on {}", blockPos1);
+            LOGGER.info("Failed to find a suitable block to teleport to, spawning an island on {}", blockPos1); // Canvas - debug -> info
             level.registryAccess()
                 .lookup(Registries.CONFIGURED_FEATURE)
                 .flatMap(registry -> registry.get(EndFeatures.END_ISLAND))
@@ -166,7 +_,7 @@
                 );
             blockPos = blockPos1;
         } else {
-            LOGGER.debug("Found suitable block to teleport to: {}", blockPos);
+            LOGGER.info("Found suitable block to teleport to: {}", blockPos); // Canvas - debug -> info
         }
 
         return findTallestBlock(level, blockPos, 16, true);
@@ -185,12 +_,27 @@
             LOGGER.debug("Skipping forward past empty chunk at {}", vec31);
         }
 
-        LOGGER.debug("Found chunk at {}", vec31);
+        LOGGER.info("Found chunk at {}", vec31); // Canvas - debug -> info
         return vec31;
     }
 
     private static boolean isChunkEmpty(ServerLevel level, Vec3 pos) {
-        return getChunk(level, pos).getHighestFilledSectionIndex() == -1;
+        // Canavs start - Threaded Regions
+        int chunkX = Mth.floor(pos.x / 16.0);
+        int chunkZ = Mth.floor(pos.z / 16.0);
+        LOGGER.info("Placing ticket for gateway to check if chunk is empty");
+        level.chunkSource.updateRegionTicket(chunkX, chunkZ, true, TicketType.END_GATEWAY);
+        try {
+            return getChunk(level, pos).getHighestFilledSectionIndex() == -1;
+        } catch (Throwable thrown) {
+            LOGGER.error("Couldn't load chunk to check if empty for gateway, removing ticket");
+            level.chunkSource.updateRegionTicket(chunkX, chunkZ, false, TicketType.END_GATEWAY);
+            throw thrown;
+        } finally {
+            LOGGER.info("Loaded chunk successfully to check if chunk was empty for gateway, removing ticket");
+            level.chunkSource.updateRegionTicket(chunkX, chunkZ, false, TicketType.END_GATEWAY);
+        }
+        // Canvas end
     }
 
     private static BlockPos findTallestBlock(BlockGetter level, BlockPos pos, int radius, boolean allowBedrock) {
@@ -246,7 +_,7 @@
     }
 
     private static void spawnGatewayPortal(ServerLevel level, BlockPos pos, EndGatewayConfiguration config) {
-        Feature.END_GATEWAY.place(config, level, level.getChunkSource().getGenerator(), RandomSource.create(), pos);
+        Feature.END_GATEWAY.place(config, level, level.getChunkSource().getGenerator(), level.random, pos); // Canvas - reduce RandomSource instances
     }
 
     @Override
