--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -336,43 +_,133 @@
 
     protected abstract void beforeDestroyingBlock(LevelAccessor level, BlockPos pos, BlockState state);
 
-    protected int getSlopeDistance(LevelReader level, BlockPos pos, int depth, Direction direction, BlockState state, FlowingFluid.SpreadContext spreadContext) {
-        int i = 1000;
-
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
-            if (direction1 != direction) {
-                BlockPos blockPos = pos.relative(direction1);
-                BlockState blockState = spreadContext.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
-                if (blockState == null) continue; // Paper - Prevent chunk loading from fluid flowing
-                FluidState fluidState = blockState.getFluidState();
-                if (this.canPassThrough(level, this.getFlowing(), pos, state, direction1, blockPos, blockState, fluidState)) {
-                    if (spreadContext.isHole(blockPos)) {
-                        return depth;
-                    }
-
-                    if (depth < this.getSlopeFindDistance(level)) {
-                        int slopeDistance = this.getSlopeDistance(level, blockPos, depth + 1, direction1.getOpposite(), blockState, spreadContext);
-                        if (slopeDistance < i) {
-                            i = slopeDistance;
-                        }
-                    }
-                }
-            }
-        }
-
-        return i;
+    // Leaf start - optimize fluid spread
+    protected int getSlopeDistance(LevelReader level, BlockPos startPos, int initialDepth, Direction excludedDirection, BlockState startState, FlowingFluid.SpreadContext spreadContext) {
+        it.unimi.dsi.fastutil.longs.LongSet visited = ((ServerLevel) level).getCurrentWorldData().slopeDistanceCacheVisited;
+        SlopeDistanceNodeDeque queue = ((ServerLevel) level).getCurrentWorldData().slopeDistanceCacheQueue;
+        visited.clear();
+        queue.clear();
+
+        for (Direction dir : Direction.Plane.HORIZONTAL) {
+            if (dir == excludedDirection) continue;
+
+            BlockPos neighborPos = startPos.relative(dir); // immutable
+            BlockState neighborState = spreadContext.getBlockStateIfLoaded(neighborPos);
+            if (neighborState == null) continue;
+
+            // Check if the fluid can actually pass through to this first neighbor before adding
+            FluidState neighborFluidState = neighborState.getFluidState();
+            if (!this.canPassThrough(level, this.getFlowing(), startPos, startState, dir, neighborPos, neighborState, neighborFluidState)) {
+                continue;
+            }
+            long visitKey = encodeSlopeNode(neighborPos, dir.getOpposite());
+            if (visited.add(visitKey)) {
+                queue.add(new FlowingFluid.SlopeDistanceNode(neighborPos, initialDepth, dir.getOpposite(), neighborState));
+            }
+        }
+
+        int slopeFindDistance = this.getSlopeFindDistance(level);
+        int minDistance = 1000;
+
+        // Process the queue
+        while (!queue.isEmpty()) {
+            FlowingFluid.SlopeDistanceNode current = queue.poll();
+            if (spreadContext.isHole(current.pos)) {
+                return current.depth;
+            }
+
+            if (current.depth >= slopeFindDistance) continue;
+
+            for (Direction dir : Direction.Plane.HORIZONTAL) {
+                if (dir == current.excludedDir) continue;
+
+                BlockPos nextPos = current.pos.relative(dir); // immutable
+                BlockState nextState = spreadContext.getBlockStateIfLoaded(nextPos);
+                if (nextState == null) continue;
+
+                FluidState nextFluidState = nextState.getFluidState();
+                if (!this.canPassThrough(level, this.getFlowing(), current.pos, current.state, dir, nextPos, nextState, nextFluidState)) {
+                    continue;
+                }
+
+                long visitKey = encodeSlopeNode(nextPos, dir.getOpposite());
+                if (visited.add(visitKey)) {
+                    queue.add(new FlowingFluid.SlopeDistanceNode(nextPos, current.depth + 1, dir.getOpposite(), nextState));
+                }
+            }
+        }
+
+        return minDistance;
+    }
+
+    private static long encodeSlopeNode(BlockPos pos, Direction excludedDir) {
+        return ((long) pos.getX() & 0xFFFFFFFFL) << 32 | ((long) pos.getZ() & 0xFFFFFFFFL) << 4 | (excludedDir.ordinal() & 0x0F);
+    }
+
+    public static class SlopeDistanceNodeDeque {
+        private SlopeDistanceNode[] array;
+        private int length;
+        private int start;
+        private int end;
+
+        public SlopeDistanceNodeDeque() {
+            array = new SlopeDistanceNode[256];
+            length = array.length;
+        }
+
+            /*
+        private int size() {
+            int apparent = end - start;
+            return apparent >= 0 ? apparent : length + apparent;
+        }
+        */
+
+        private void clear() {
+            start = 0;
+            end = 0;
+        }
+
+        private boolean isEmpty() {
+            return end == start || (end <= start && length == start - end);
+        }
+
+        private SlopeDistanceNode poll() {
+            final SlopeDistanceNode t = array[start];
+            if (++start == length) start = 0;
+            return t;
+        }
+
+        private void add(final SlopeDistanceNode node) {
+            array[end++] = node;
+            if (end == length) end = 0;
+            if (end == start) resize(length, 2 * length);
+        }
+
+        private void resize(final int size, final int newLength) {
+            final SlopeDistanceNode[] newArray = new SlopeDistanceNode[newLength];
+            if (size != 0) {
+                System.arraycopy(array, start, newArray, 0, length - start);
+                System.arraycopy(array, 0, newArray, length - start, end);
+            }
+            start = 0;
+            end = size;
+            array = newArray;
+            length = newLength;
+        }
+    }
+
+    private record SlopeDistanceNode(BlockPos pos, int depth, Direction excludedDir, BlockState state) {
+    // Leaf end - optimize fluid spread
     }
 
     public boolean isWaterHole(BlockGetter level, BlockPos pos, BlockState state, BlockPos belowPos, BlockState belowState) {
-        return canPassThroughWall(Direction.DOWN, level, pos, state, belowPos, belowState)
-            && (belowState.getFluidState().getType().isSame(this) || canHoldFluid(level, belowPos, belowState, this.getFlowing()));
+        return (belowState.getFluidState().getType().isSame(this) || canHoldFluid(level, belowPos, belowState, this.getFlowing())) && canPassThroughWall(Direction.DOWN, level, pos, state, belowPos, belowState); // Canvas - cheaper checks first
     }
 
     public boolean canPassThrough(
         BlockGetter level, Fluid fluid, BlockPos pos, BlockState state, Direction direction, BlockPos spreadPos, BlockState spreadState, FluidState fluidState
     ) {
-        return this.canMaybePassThrough(level, pos, state, direction, spreadPos, spreadState, fluidState)
-            && canHoldSpecificFluid(level, spreadPos, spreadState, fluid);
+        return canHoldSpecificFluid(level, spreadPos, spreadState, fluid) && this.canMaybePassThrough(level, pos, state, direction, spreadPos, spreadState, fluidState); // Canvas - cheaper checks first
     }
 
     public boolean canMaybePassThrough(
