--- a/net/minecraft/world/level/material/FlowingFluid.java
+++ b/net/minecraft/world/level/material/FlowingFluid.java
@@ -6,6 +_,8 @@
 import it.unimi.dsi.fastutil.shorts.Short2BooleanOpenHashMap;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectMap;
 import it.unimi.dsi.fastutil.shorts.Short2ObjectOpenHashMap;
+import java.util.ArrayDeque;
+import java.util.Deque;
 import java.util.Map;
 import java.util.Map.Entry;
 import net.minecraft.core.BlockPos;
@@ -342,32 +_,44 @@
 
     protected abstract void beforeDestroyingBlock(LevelAccessor level, BlockPos pos, BlockState state);
 
+    // Canvas start
+    private record Node(BlockPos pos, int depth, Direction direction) {}
     protected int getSlopeDistance(LevelReader level, BlockPos pos, int depth, Direction direction, BlockState state, FlowingFluid.SpreadContext spreadContext) {
-        int i = 1000;
-
-        for (Direction direction1 : Direction.Plane.HORIZONTAL) {
-            if (direction1 != direction) {
-                BlockPos blockPos = pos.relative(direction1);
-                BlockState blockState = spreadContext.getBlockStateIfLoaded(blockPos); // Paper - Prevent chunk loading from fluid flowing
-                if (blockState == null) continue; // Paper - Prevent chunk loading from fluid flowing
-                FluidState fluidState = blockState.getFluidState();
-                if (this.canPassThrough(level, this.getFlowing(), pos, state, direction1, blockPos, blockState, fluidState)) {
-                    if (spreadContext.isHole(blockPos)) {
-                        return depth;
+        int slopeFindDistance = this.getSlopeFindDistance(level);
+        int minDistance = slopeFindDistance;
+
+        Deque<Node> stack = new ArrayDeque<>();
+        stack.push(new Node(pos, depth, direction));
+
+        while (!stack.isEmpty()) {
+            Node current = stack.pop();
+            BlockPos currentPos = current.pos;
+            int currentDepth = current.depth;
+            Direction fromDirection = current.direction;
+
+            for (Direction dir : Direction.Plane.HORIZONTAL) {
+                if (dir == fromDirection) continue;
+
+                BlockPos neighborPos = currentPos.relative(dir);
+                BlockState neighborState = spreadContext.getBlockStateIfLoaded(neighborPos);
+                if (neighborState == null) continue; // prevent chunk loading
+
+                FluidState fluidState = neighborState.getFluidState();
+                if (this.canPassThrough(level, this.getFlowing(), currentPos, state, dir, neighborPos, neighborState, fluidState)) {
+                    if (spreadContext.isHole(neighborPos)) {
+                        return currentDepth;
                     }
 
-                    if (depth < this.getSlopeFindDistance(level)) {
-                        int slopeDistance = this.getSlopeDistance(level, blockPos, depth + 1, direction1.getOpposite(), blockState, spreadContext);
-                        if (slopeDistance < i) {
-                            i = slopeDistance;
-                        }
+                    if (currentDepth + 1 < slopeFindDistance && currentDepth + 1 < minDistance) {
+                        stack.push(new Node(neighborPos, currentDepth + 1, dir.getOpposite()));
                     }
                 }
             }
         }
 
-        return i;
+        return minDistance;
     }
+    // Canvas end
 
     boolean isWaterHole(BlockGetter level, BlockPos pos, BlockState state, BlockPos belowPos, BlockState belowState) {
         return canPassThroughWall(Direction.DOWN, level, pos, state, belowPos, belowState)
