--- a/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
+++ b/net/minecraft/world/level/chunk/storage/SerializableChunkData.java
@@ -471,14 +_,16 @@
             throw new IllegalArgumentException("Chunk can't be serialized: " + chunk);
         } else {
             ChunkPos pos = chunk.getPos();
-            List<SerializableChunkData.SectionData> list = new ArrayList<>(); final List<SerializableChunkData.SectionData> sectionsList = list; // Paper - starlight - OBFHELPER
-            LevelChunkSection[] sections = chunk.getSections();
-            LevelLightEngine lightEngine = level.getChunkSource().getLightEngine();
 
             // Paper start - starlight
             final int minLightSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinLightSection(level);
             final int maxLightSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxLightSection(level);
             final int minBlockSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(level);
+            // Canvas start - optimize chunk unload
+            // Pre-allocate with correct capacity to avoid resizing
+            final int expectedSectionCount = maxLightSection - minLightSection + 1;
+            List<SerializableChunkData.SectionData> list = new ArrayList<>(expectedSectionCount);
+            // Canvas end - optimize chunk unload
 
             final LevelChunkSection[] chunkSections = chunk.getSections();
             final ca.spottedleaf.moonrise.patches.starlight.light.SWMRNibbleArray[] blockNibbles = ((ca.spottedleaf.moonrise.patches.starlight.chunk.StarlightChunk)chunk).starlight$getBlockNibbles();
@@ -496,10 +_,20 @@
                     continue;
                 }
 
+                // Canvas start - optimize chunk unload
+                DataLayer blockDataLayer = null;
+                if (blockNibble != null && blockNibble.data != null) {
+                    blockDataLayer = new DataLayer(blockNibble.data);
+                }
+
+                DataLayer skyDataLayer = null;
+                if (skyNibble != null && skyNibble.data != null) {
+                    skyDataLayer = new DataLayer(skyNibble.data);
+                }
+
+                // Canvas end - optimize chunk unload
                 final SerializableChunkData.SectionData sectionData = new SerializableChunkData.SectionData(
-                    lightSection, chunkSection,
-                    blockNibble == null ? null : (blockNibble.data == null ? null : new DataLayer(blockNibble.data)),
-                    skyNibble == null ? null : (skyNibble.data == null ? null : new DataLayer(skyNibble.data))
+                    lightSection, chunkSection, blockDataLayer, skyDataLayer // Canvas - optimize chunk unload
                 );
 
                 if (blockNibble != null) {
@@ -510,12 +_,17 @@
                     ((ca.spottedleaf.moonrise.patches.starlight.storage.StarlightSectionData)(Object)sectionData).starlight$setSkyLightState(skyNibble.state);
                 }
 
-                sectionsList.add(sectionData);
+                list.add(sectionData); // Canvas - optimize chunk unload
             }
             // Paper end - starlight
 
-            List<CompoundTag> list1 = new ArrayList<>(chunk.getBlockEntitiesPos().size());
+            // Canvas start - optimize chunk unload
+            // pre-allocate block entities list with exact size needed
+            final int blockEntityCount = chunk.getBlockEntitiesPos().size();
+            List<CompoundTag> list1 = blockEntityCount > 0 ? new ArrayList<>(blockEntityCount) : java.util.Collections.emptyList();
 
+            if (blockEntityCount > 0)
+            // Canvas end - optimize chunk unload
             for (BlockPos blockPos : chunk.getBlockEntitiesPos()) {
                 CompoundTag blockEntityNbtForSaving = chunk.getBlockEntityNbtForSaving(blockPos, level.registryAccess());
                 if (blockEntityNbtForSaving != null) {
@@ -523,15 +_,27 @@
                 }
             }
 
-            List<CompoundTag> list2 = new ArrayList<>();
+            // Canvas start - optimize chunk unload
+            // for entities, use an initial estimated capacity if it's a ProtoChunk
+            List<CompoundTag> list2;
             long[] longs = null;
             if (chunk.getPersistedStatus().getChunkType() == ChunkType.PROTOCHUNK) {
                 ProtoChunk protoChunk = (ProtoChunk)chunk;
-                list2.addAll(protoChunk.getEntities());
+                // Canvas start - optimize chunk unload
+                int entitySize = protoChunk.getEntities().size();
+                if (entitySize > 0) {
+                    list2 = new ArrayList<>(Math.max(16, entitySize));
+                    list2.addAll(protoChunk.getEntities());
+                } else {
+                    list2 = java.util.Collections.emptyList();
+                }
+            // Canvas end - optimize chunk unload
                 CarvingMask carvingMask = protoChunk.getCarvingMask();
                 if (carvingMask != null) {
                     longs = carvingMask.toArray();
                 }
+            } else {
+                list2 = java.util.Collections.emptyList(); // Canvas - optimize chunk unload
             }
 
             Map<Heightmap.Types, long[]> map = new EnumMap<>(Heightmap.Types.class);
@@ -539,14 +_,26 @@
             for (Entry<Heightmap.Types, Heightmap> entry : chunk.getHeightmaps()) {
                 if (chunk.getPersistedStatus().heightmapsAfter().contains(entry.getKey())) {
                     long[] rawData = entry.getValue().getRawData();
-                    map.put(entry.getKey(), (long[])rawData.clone());
+                    map.put(entry.getKey(), Arrays.copyOf(rawData, rawData.length)); // Canvas - optimize chunk unload
                 }
             }
 
             ChunkAccess.PackedTicks ticksForSerialization = chunk.getTicksForSerialization(level.getRedstoneGameTime()); // Folia - region threading
-            ShortList[] lists = Arrays.stream(chunk.getPostProcessing())
-                .map(list3 -> list3 != null ? new ShortArrayList(list3) : null)
-                .toArray(ShortList[]::new);
+            // Canvas start - optimize chunk unload - remove stream
+            ShortList[] postProcessing = chunk.getPostProcessing();
+            ShortList[] lists = new ShortList[postProcessing.length];
+            for (int i = 0; i < postProcessing.length; i++) {
+                ShortList source = postProcessing[i];
+                // Only create a new list if there's actual data to copy
+                if (source != null) {
+                    int size = source.size();
+                    if (size > 0) {
+                        lists[i] = new ShortArrayList(size);
+                        lists[i].addAll(source);
+                    }
+                }
+            }
+            // Canvas end - optimize chunk unload - remove stream
             CompoundTag compoundTag = packStructureData(
                 StructurePieceSerializationContext.fromLevel(level), pos, chunk.getAllStarts(), chunk.getAllReferences()
             );
