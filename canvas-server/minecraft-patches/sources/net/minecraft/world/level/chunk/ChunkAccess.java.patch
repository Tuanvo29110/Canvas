--- a/net/minecraft/world/level/chunk/ChunkAccess.java
+++ b/net/minecraft/world/level/chunk/ChunkAccess.java
@@ -77,10 +_,10 @@
     protected BlendingData blendingData;
     public final Map<Heightmap.Types, Heightmap> heightmaps = Maps.newEnumMap(Heightmap.Types.class);
     // Paper - rewrite chunk system
-    private final Map<Structure, StructureStart> structureStarts = Maps.newHashMap();
-    private final Map<Structure, LongSet> structuresRefences = Maps.newHashMap();
-    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = Maps.newHashMap();
-    public final Map<BlockPos, BlockEntity> blockEntities = new Object2ObjectOpenHashMap<>();
+    private final Map<Structure, StructureStart> structureStarts = new it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap<>(); // Canvas - optimized collection
+    private final Map<Structure, LongSet> structuresRefences = new it.unimi.dsi.fastutil.objects.Object2ObjectArrayMap<>(); // Canvas - optimized collection
+    protected final Map<BlockPos, CompoundTag> pendingBlockEntities = new Object2ObjectOpenHashMap<>(); // Canvas - optimized collection
+    public final Map<BlockPos, BlockEntity> blockEntities = new it.unimi.dsi.fastutil.objects.Object2ObjectOpenCustomHashMap<>(new io.canvasmc.canvas.chunk.block.BlockPosStrategy()); // Canvas - optimized collection
     protected final LevelHeightAccessor levelHeightAccessor;
     protected final LevelChunkSection[] sections;
     // CraftBukkit start - SPIGOT-6814: move to IChunkAccess to account for 1.17 to 1.18 chunk upgrading.
@@ -288,7 +_,7 @@
     }
 
     public Map<Structure, StructureStart> getAllStarts() {
-        return Collections.unmodifiableMap(this.structureStarts);
+        return this.structureStarts; // Canvas - optimized collection
     }
 
     public void setAllStarts(Map<Structure, StructureStart> structureStarts) {
@@ -304,13 +_,13 @@
 
     @Override
     public void addReferenceForStructure(Structure structure, long reference) {
-        this.structuresRefences.computeIfAbsent(structure, key -> new LongOpenHashSet()).add(reference);
+        this.structuresRefences.computeIfAbsent(structure, key -> new it.unimi.dsi.fastutil.longs.LongArraySet()).add(reference); // Canvas - optimized collection
         this.markUnsaved();
     }
 
     @Override
     public Map<Structure, LongSet> getAllReferences() {
-        return Collections.unmodifiableMap(this.structuresRefences);
+        return this.structuresRefences; // Canvas - optimized collection
     }
 
     @Override
