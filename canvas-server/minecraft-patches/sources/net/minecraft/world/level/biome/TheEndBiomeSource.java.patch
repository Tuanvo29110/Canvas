--- a/net/minecraft/world/level/biome/TheEndBiomeSource.java
+++ b/net/minecraft/world/level/biome/TheEndBiomeSource.java
@@ -54,9 +_,35 @@
     protected MapCodec<? extends BiomeSource> codec() {
         return CODEC;
     }
+    // Canvas start - end biome cache
+    private final ThreadLocal<it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<Holder<Biome>>> cache = ThreadLocal.withInitial(it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap::new);
+    private final int cacheCapacity = io.canvasmc.canvas.Config.INSTANCE.chunks.endBiomeCacheCapacity;
 
     @Override
-    public Holder<Biome> getNoiseBiome(int x, int y, int z, Climate.Sampler sampler) {
+    public Holder<Biome> getNoiseBiome(int biomeX, int biomeY, int biomeZ, Climate.Sampler multiNoiseSampler) {
+        if (!io.canvasmc.canvas.Config.INSTANCE.chunks.useEndBiomeCache) {
+            // biome cache not enabled, return raw vanilla
+            return getVanillaNoiseBiome(biomeX, biomeY, biomeZ, multiNoiseSampler);
+        }
+        final long key = net.minecraft.world.level.ChunkPos.asLong(biomeX, biomeZ);
+        final it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap<Holder<Biome>> cacheThreadLocal = cache.get();
+        final Holder<Biome> biome = cacheThreadLocal.get(key);
+        if (biome != null) {
+            return biome;
+        } else {
+            final Holder<Biome> gennedBiome = getVanillaNoiseBiome(biomeX, biomeY, biomeZ, multiNoiseSampler);
+            cacheThreadLocal.put(key, gennedBiome);
+            if (cacheThreadLocal.size() > cacheCapacity) {
+                for (int i = 0; i < cacheCapacity / 16; i ++) {
+                    cacheThreadLocal.removeFirst();
+                }
+            }
+            return gennedBiome;
+        }
+    }
+
+    private Holder<Biome> getVanillaNoiseBiome(int x, int y, int z, Climate.Sampler sampler) {
+    // Canvas end
         int blockPosX = QuartPos.toBlock(x);
         int blockPosY = QuartPos.toBlock(y);
         int blockPosZ = QuartPos.toBlock(z);
