--- a/net/minecraft/server/commands/SpreadPlayersCommand.java
+++ b/net/minecraft/server/commands/SpreadPlayersCommand.java
@@ -32,6 +_,13 @@
 import net.minecraft.world.scores.Team;
 
 public class SpreadPlayersCommand {
+    // Canvas start - fix commands with region threading
+    private static final java.util.concurrent.ThreadPoolExecutor ASYNC_EXECUTOR = new java.util.concurrent.ThreadPoolExecutor(
+        1, 1,
+        10L, java.util.concurrent.TimeUnit.SECONDS,
+        new java.util.concurrent.LinkedBlockingQueue<>(8)
+    );
+    // Canvas end
     private static final int MAX_ITERATION_COUNT = 10000;
     private static final Dynamic4CommandExceptionType ERROR_FAILED_TO_SPREAD_TEAMS = new Dynamic4CommandExceptionType(
         (teamCount, x, z, suggestedSpread) -> Component.translatableEscape("commands.spreadplayers.failed.teams", teamCount, x, z, suggestedSpread)
@@ -102,6 +_,44 @@
     private static int spreadPlayers(
         CommandSourceStack source, Vec2 center, float spreadDistance, float maxRange, int maxHeight, boolean respectTeams, Collection<? extends Entity> targets
     ) throws CommandSyntaxException {
+        // Canvas start - fix commands with region threading
+        if (true) {
+            // copied from bellow
+            ServerLevel level = source.getLevel();
+            int minY = level.getMinY();
+            if (maxHeight < minY) {
+                throw ERROR_INVALID_MAX_HEIGHT.create(maxHeight, minY);
+            } else {
+                RandomSource randomSource = RandomSource.create();
+                double d = center.x - maxRange;
+                double d1 = center.y - maxRange;
+                double d2 = center.x + maxRange;
+                double d3 = center.y + maxRange;
+                SpreadPlayersCommand.Position[] positions = createInitialPositions(
+                    randomSource, respectTeams ? getNumberOfTeams(targets) : targets.size(), d, d1, d2, d3
+                );
+                // copy from bellow end here, try and spread asynchronously
+                sendMessage(source, level, Component.literal("Spreading " + positions.length + (positions.length == 1 ? " entity " : " entities ") + "around " + center.x + ", " + center.y + " asynchronously..."));
+                ASYNC_EXECUTOR.submit(() -> {
+                    try {
+                        sendMessage(source, level, Component.literal("Loading pile positions..."));
+                        spreadAsync(center, spreadDistance, level, randomSource, d, d1, d2, d3, maxHeight, positions, respectTeams);
+                    } catch (CommandSyntaxException ex) {
+                        sendFailure(source, level, ex.getMessage());
+                    } catch (Throwable t) {
+                        sendFailure(source, level, "An error occurred while spreading players, check console for details");
+                        net.minecraft.server.MinecraftServer.LOGGER.error("An error occurred while spreading players asynchronously", t);
+                    }
+                    sendMessage(source, level, Component.literal("Teleporting all entities..."));
+                    teleportEntities(targets, level, positions, maxHeight, respectTeams);
+                    sendMessage(source, level, Component.literal(
+                        "Successfully spread " + positions.length + (positions.length == 1 ? " entity " : " entities ") + "around " + center.x + ", " + center.y + " asynchronously"
+                    ));
+                });
+            }
+            return 0;
+        }
+        // Canvas end
         ServerLevel level = source.getLevel();
         int minY = level.getMinY();
         if (maxHeight < minY) {
@@ -130,6 +_,182 @@
             return positions.length;
         }
     }
+    // Canvas start - fix commands with region threading
+
+    private static void sendFailure(CommandSourceStack source, ServerLevel level, String message) {
+        // source is either a player or the server console, so we check if it's a player
+        // first, and if it isn't then we assume it's the server and push to global
+        if (source.isPlayer()) {
+            net.minecraft.server.level.ServerPlayer serverPlayer = source.getPlayer();
+            if (serverPlayer != null && !serverPlayer.hasDisconnected()) {
+                serverPlayer.getBukkitEntity().taskScheduler.schedule((_) -> {
+                    source.sendFailure(Component.literal(message));
+                }, null, 0L);
+            }
+        } else {
+            level.getServer().regionizedServer.addTask(() -> {
+                source.sendFailure(Component.literal(message));
+            });
+        }
+    }
+
+    private static void sendMessage(CommandSourceStack source, ServerLevel level, Component message) {
+        // source is either a player or the server console, so we check if it's a player
+        // first, and if it isn't then we assume it's the server and push to global
+        if (source.isPlayer()) {
+            net.minecraft.server.level.ServerPlayer serverPlayer = source.getPlayer();
+            if (serverPlayer != null && !serverPlayer.hasDisconnected()) {
+                serverPlayer.getBukkitEntity().taskScheduler.schedule((_) -> {
+                    source.sendSystemMessage(message);
+                }, null, 0L);
+            }
+        } else {
+            level.getServer().regionizedServer.addTask(() -> {
+                source.sendSystemMessage(message);
+            });
+        }
+    }
+
+    private static void spreadAsync(
+        Vec2 center,
+        double spreadDistance,
+        ServerLevel world,
+        RandomSource random,
+        double minX,
+        double minZ,
+        double maxX,
+        double maxZ,
+        int maxY,
+        SpreadPlayersCommand.Position[] piles,
+        boolean respectTeams
+    ) throws CommandSyntaxException {
+        boolean bl = true;
+        double d = Float.MAX_VALUE;
+
+        int i;
+        for (i = 0; i < 10000 && bl; ++i) {
+            bl = false;
+            d = Float.MAX_VALUE;
+
+            for (int j = 0; j < piles.length; ++j) {
+                SpreadPlayersCommand.Position pile = piles[j];
+                int k = 0;
+                SpreadPlayersCommand.Position pile2 = new SpreadPlayersCommand.Position();
+
+                for (int l = 0; l < piles.length; ++l) {
+                    if (j != l) {
+                        SpreadPlayersCommand.Position pile3 = piles[l];
+                        double e = (pile).dist(pile3);
+                        d = Math.min(e, d);
+                        if (e < spreadDistance) {
+                            ++k;
+                            (pile2).x = ((pile2).x + ((pile3).x - (pile).x));
+                            (pile2).z = ((pile2).z + ((pile3).z - (pile).z));
+                        }
+                    }
+                }
+
+                if (k > 0) {
+                    (pile2).x = ((pile2).x / k);
+                    (pile2).z = ((pile2).z / k);
+                    double f = (pile2).getLength();
+                    if (f > 0.0) {
+                        (pile2).normalize();
+                        pile.moveAway(pile2);
+                    } else {
+                        pile.randomize(random, minX, minZ, maxX, maxZ);
+                    }
+
+                    bl = true;
+                }
+
+                if (pile.clamp(minX, minZ, maxX, maxZ)) {
+                    bl = true;
+                }
+            }
+
+            if (!bl) {
+                java.util.List<java.util.concurrent.CompletableFuture<Void>> futures = new java.util.ArrayList<>(piles.length);
+                java.util.concurrent.atomic.AtomicBoolean result = new java.util.concurrent.atomic.AtomicBoolean(false);
+                for (SpreadPlayersCommand.Position pile2 : piles) {
+                    net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(BlockPos.containing((pile2).x, 0.0, (pile2).z));
+                    final java.util.concurrent.CompletableFuture<Void> future = new java.util.concurrent.CompletableFuture<>();
+                    world.moonrise$getChunkTaskScheduler().scheduleChunkLoad(
+                        pos.x, pos.z, net.minecraft.world.level.chunk.status.ChunkStatus.FULL, true, ca.spottedleaf.concurrentutil.util.Priority.HIGH,
+                        (_) -> {
+                            if (!pile2.isSafe(world, maxY)) {
+                                pile2.randomize(random, minX, minZ, maxX, maxZ);
+                                result.set(true);
+                            }
+                            future.complete(null);
+                        }
+                    );
+                    futures.add(future);
+                }
+                java.util.concurrent.CompletableFuture.allOf(futures.toArray(java.util.concurrent.CompletableFuture[]::new)).join();
+                bl = result.get();
+            }
+        }
+
+        if (d == Float.MAX_VALUE) {
+            d = 0.0;
+        }
+
+        if (i >= 10000) {
+            if (respectTeams) {
+                throw ERROR_FAILED_TO_SPREAD_TEAMS.create(piles.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
+            } else {
+                throw ERROR_FAILED_TO_SPREAD_ENTITIES.create(piles.length, center.x, center.y, String.format(Locale.ROOT, "%.2f", d));
+            }
+        }
+    }
+
+    private static void teleportEntities(
+        Collection<? extends Entity> entities, ServerLevel world, SpreadPlayersCommand.Position[] piles, int maxY, boolean respectTeams
+    ) {
+        int i = 0;
+        Map<net.minecraft.world.scores.Team, SpreadPlayersCommand.Position> map = Maps.newHashMap();
+
+        for (Entity entity : entities) {
+            if (!entity.isAlive()) continue;
+            SpreadPlayersCommand.Position pile;
+            if (respectTeams && false) { // Canvas - TODO - region threading - teams need work
+                net.minecraft.world.scores.Team abstractTeam = entity instanceof net.minecraft.world.entity.player.Player ? entity.getTeam() : null;
+                if (!map.containsKey(abstractTeam)) {
+                    map.put(abstractTeam, piles[i++]);
+                }
+
+                pile = map.get(abstractTeam);
+            } else {
+                pile = piles[i++];
+            }
+
+            BlockPos.MutableBlockPos pos = new BlockPos.MutableBlockPos((int) Math.round(Math.floor((pile).x)), 0, (int) Math.round(Math.floor((pile).z)));
+            world.getServer().regionizedServer.taskQueue.queueTickTaskQueue(
+                world, pos.getX() >> 4, pos.getZ() >> 4, () -> {
+                    pos.setY(pile.getSpawnY(world, maxY));
+                    entity.getBukkitEntity().taskScheduler.schedule((_) -> {
+                        entity.teleportAsync(
+                            world, pos.getCenter(),
+                            entity.getYRot(), entity.getXRot(), entity.getDeltaMovement(),
+                            org.bukkit.event.player.PlayerTeleportEvent.TeleportCause.COMMAND,
+                            Entity.TELEPORT_FLAG_TELEPORT_PASSENGERS | Entity.TELEPORT_FLAG_LOAD_CHUNK, null
+                        );
+                    }, null, 0L);
+                }
+            );
+
+            double e = Double.MAX_VALUE;
+
+            for (SpreadPlayersCommand.Position pile2 : piles) {
+                if (pile != pile2) {
+                    double f = (pile).dist(pile2);
+                    e = Math.min(f, e);
+                }
+            }
+        }
+    }
+    // Canvas end
 
     private static int getNumberOfTeams(Collection<? extends Entity> entities) {
         Set<Team> set = Sets.newHashSet();
