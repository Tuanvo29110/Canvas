--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -286,7 +_,7 @@
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
 
     // Folia start - regionised ticking
-    public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer();
+    // public final io.papermc.paper.threadedregions.RegionizedServer regionizedServer = new io.papermc.paper.threadedregions.RegionizedServer(); // Canvas - remove this, causes issues
 
     @Override
     public <V> CompletableFuture<V> submit(java.util.function.Supplier<V> task) {
@@ -336,7 +_,7 @@
         thread.setUncaughtExceptionHandler((thread1, exception) -> LOGGER.error("Uncaught exception in server thread", exception));
         thread.setPriority(Thread.NORM_PRIORITY+2); // Paper - Perf: Boost priority
         if (Runtime.getRuntime().availableProcessors() > 4) {
-            thread.setPriority(8);
+            thread.setPriority(10); // Canvas - bump priority
         }
 
         S minecraftServer = (S)threadFunction.apply(thread);
@@ -733,6 +_,7 @@
                     );
                 }
             }
+            LOGGER.info("Using world distance config of {} for world '{}'", serverLevel.serverLevelData.distanceConfig, serverLevel); // Canvas - per world distance
             // Folia end - region threading
 
             // Paper - Put world into worldlist before initing the world; move up
@@ -1236,11 +_,7 @@
                 io.papermc.paper.threadedregions.RegionizedServer.getInstance().init(); // Folia - region threading - only after loading worlds
                 final long actualDoneTimeMs = System.currentTimeMillis() - org.bukkit.craftbukkit.Main.BOOT_TIME.toEpochMilli(); // Paper - Improve startup message
                 LOGGER.info("Done ({})! For help, type \"help\"", String.format(java.util.Locale.ROOT, "%.3fs", actualDoneTimeMs / 1000.00D)); // Paper - Improve startup message
-                for (;;) {
-                    try {
-                        Thread.sleep(Long.MAX_VALUE);
-                    } catch (final InterruptedException ex) {}
-                }
+                return; // Canvas - region threading
             }
             // Folia end - region threading
             // Spigot start
@@ -1351,7 +_,7 @@
             }
 
             this.onServerCrash(crashReport);
-        } finally {
+        } { // Canvas - region threading
             try {
                 this.stopped = true;
                 this.stopServer();
@@ -1592,6 +_,7 @@
                     LOGGER.info("Initialising world '" + region.world.getWorld().getName() + "' before it can be ticked...");
                     this.initWorld(region.world, region.world.serverLevelData, worldData, region.world.serverLevelData.worldGenOptions()); // Folia - delayed until first tick of world
                     region.world.checkInitialised.set(ServerLevel.WORLD_INIT_CHECKED);
+                    new io.canvasmc.canvas.event.WorldPreLoadEvent(region.world.getWorld(), io.canvasmc.canvas.event.WorldPreLoadEvent.Stage.INIT_WORLD).callEvent(); // Canvas - world pre load event
                     LOGGER.info("Initialised world '" + region.world.getWorld().getName() + "'");
                 } // else: must be checked
             }
@@ -1607,6 +_,7 @@
         if (region != null) {
             region.getTaskQueueData().drainTasks();
             ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)org.bukkit.Bukkit.getRegionScheduler()).tick();
+            region.drainPackets(); // Canvas - rewrite scheduler
             // now run all the entity schedulers
             for (io.papermc.paper.threadedregions.EntityScheduler scheduler : region.world.getCurrentWorldData().entitySchedulerTickList.getAllSchedulers()) {
                 net.minecraft.world.entity.Entity handle = scheduler.entity.getHandleRaw();
@@ -1620,6 +_,7 @@
         // Folia end - region threading
         //this.tickCount++; // Folia - region threading
         //this.tickRateManager.tick(); // Folia - region threading
+        region.world.getCurrentWorldData().tpsbar.tick(); // Canvas - tpsbar
         this.tickChildren(hasTimeLeft, region); // Folia - region threading
         if (false && nanos - this.lastServerStatus >= STATUS_EXPIRE_TIME_NANOS) { // Folia - region threading
             this.lastServerStatus = nanos;
@@ -1730,6 +_,15 @@
         //io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper // Folia - region threading - moved to global tick
         //this.getFunctions().tick(); // Folia - region threading - TODO Purge functions
 
+        // Canvas start - async save-all command
+        if (region.shouldSaveNextTick) {
+            region.shouldSaveNextTick = false;
+
+            LOGGER.info("Saving chunks around region around chunk {} in world '{}'", region.region.getCenterChunk(), region.region.regioniser.world.getWorld().getName());
+            region.region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, false, false, false, false);
+            this.getPlayerList().saveAll();
+        }
+        // Canvas end - async save-all command
         // CraftBukkit start
         // Run tasks that are waiting on processing
         if (false) while (!this.processQueue.isEmpty()) { // Folia - region threading
@@ -1739,6 +_,7 @@
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
         for (final ServerLevel level : Arrays.asList(region.world)) { // Folia - region threading
+            if (region.world.isUnloading) continue; // Canvas - fix world loading/unloading
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1766,6 +_,48 @@
             }
             // CraftBukkit end */
 
+            // Canvas start - fix world loading/unloading
+            if (serverLevel.isUnloading) {
+                // finish teleports
+                final ChunkPos center = region.region.getCenterChunk();
+                final List<ServerLevel.PendingTeleport> pendingTeleports = serverLevel.removeAllRegionTeleports();
+                if (!pendingTeleports.isEmpty()) {
+                    LOGGER.info("Completing {} pending teleports in region around chunk {} in world '{}'", pendingTeleports.size(), center, region.region.regioniser.world.getWorld().getName());
+                    for (final ServerLevel.PendingTeleport pendingTeleport : pendingTeleports) {
+                        LOGGER.info("Completing teleportation to target position {}", pendingTeleport.to());
+
+                        // first, add entities to entity chunk so that they will be saved
+                        for (final net.minecraft.world.entity.Entity.EntityTreeNode node : pendingTeleport.rootVehicle().getFullTree()) {
+                            // assume that world and position are set to destination here
+                            node.root.setLevel(serverLevel); // in case the pending teleport is from a portal before it finds the exact destination
+                            serverLevel.moonrise$getEntityLookup().addEntityForShutdownTeleportComplete(node.root);
+                        }
+
+                        // then, rebuild the passenger tree so that when saving only the root vehicle will be written - and if
+                        // there are any player passengers, that the later player saving will save the tree
+                        pendingTeleport.rootVehicle().restore();
+
+                        // now we are finished
+                        LOGGER.info("Completed teleportation to target position {}", pendingTeleport.to());
+                    }
+                }
+
+                if (!serverLevel.players().isEmpty()) {
+                    // a player was teleported into the world when finishing teleports, kick.
+                    for (final ServerPlayer localPlayer : serverLevel.getLocalPlayers()) {
+                        localPlayer.getBukkitEntity().kick(net.kyori.adventure.text.Component.text("World unloading"), org.bukkit.event.player.PlayerKickEvent.Cause.WORLD_UNLOAD);
+                    }
+                }
+
+                LOGGER.info("Saving chunks around region around chunk {} in world '{}'", center, region.region.regioniser.world.getWorld().getName());
+                region.region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, true, false, false, false);
+
+                LOGGER.info("Descheduling region around chunk {} in world '{}'", center, region.region.regioniser.world.getWorld().getName());
+                io.papermc.paper.threadedregions.TickRegions.getScheduler().descheduleRegion(region.getRegionSchedulingHandle());
+                region.markClosed();
+                continue;
+            }
+            // Canvas end - fix world loading/unloading
             try {
                 serverLevel.tick(hasTimeLeft, region); // Folia - region threading
             } catch (Throwable var7) {
@@ -1838,22 +_,31 @@
 
     @Nullable
     public ServerLevel getLevel(ResourceKey<Level> dimension) {
-        return this.levels.get(dimension);
+        // Canvas start - fix world loading/unloading
+        ServerLevel serverLevel = this.levels.get(dimension);
+        if (serverLevel != null && serverLevel.isUnloading) return null;
+        return serverLevel;
+        // Canvas end - fix world loading/unloading
     }
 
     // CraftBukkit start
+    private final Object levelLock = new Object(); // Canvas - fix world loading/unloading
     public void addLevel(ServerLevel level) {
+        synchronized (levelLock) { // Canvas - fix world loading/unloading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        } // Canvas - fix world loading/unloading
     }
 
     public void removeLevel(ServerLevel level) {
+        synchronized (levelLock) { // Canvas - fix world loading/unloading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        } // Canvas - fix world loading/unloading
     }
     // CraftBukkit end
 
@@ -2202,6 +_,13 @@
         return 256;
     }
 
+    // Canvas start - no chat reports
+    public boolean ncrEnforceSecureProfile() {
+        if (io.canvasmc.canvas.Config.INSTANCE.enableNoChatReports) return false; // NCR deosn't require secure profile
+        return this.enforceSecureProfile();
+    }
+
+    // Canvas end - no chat reports
     public boolean enforceSecureProfile() {
         return false;
     }
@@ -2708,6 +_,7 @@
     }
 
     public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
+        io.canvasmc.canvas.Config.INSTANCE.virtualThreads.chatExecutor ? io.canvasmc.canvas.util.virtual.VirtualThreadUtils.buildFactory((virtual) -> virtual.uncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER))) : // Canvas - virtual threads
         new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
 
