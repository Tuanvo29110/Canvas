--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -733,6 +_,7 @@
                     );
                 }
             }
+            LOGGER.info("Using world distance config of {} for world '{}'", serverLevel.serverLevelData.distanceConfig, serverLevel); // Canvas - per world distance
             // Folia end - region threading
 
             // Paper - Put world into worldlist before initing the world; move up
@@ -1002,7 +_,7 @@
     // CraftBukkit end
 
     // Folia start - region threading
-    private final java.util.concurrent.atomic.AtomicBoolean hasStartedShutdownThread = new java.util.concurrent.atomic.AtomicBoolean();
+    public final java.util.concurrent.atomic.AtomicBoolean hasStartedShutdownThread = new java.util.concurrent.atomic.AtomicBoolean(); // Canvas - private -> public
 
     private void haltServerRegionThreading() {
         if (this.hasStartedShutdownThread.getAndSet(true)) {
@@ -1729,6 +_,15 @@
         //io.papermc.paper.adventure.providers.ClickCallbackProviderImpl.DIALOG_CLICK_MANAGER.handleQueue(this.tickCount); // Paper // Folia - region threading - moved to global tick
         //this.getFunctions().tick(); // Folia - region threading - TODO Purge functions
 
+        // Canvas start - async save-all command
+        if (region.shouldSaveNextTick) {
+            region.shouldSaveNextTick = false;
+
+            LOGGER.info("Saving chunks around region around chunk {} in world '{}'", region.region.getCenterChunk(), region.region.regioniser.world.getWorld().getName());
+            region.region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, false, false, false, false);
+            this.getPlayerList().saveAll();
+        }
+        // Canvas end
         // CraftBukkit start
         // Run tasks that are waiting on processing
         if (false) while (!this.processQueue.isEmpty()) { // Folia - region threading
@@ -1738,6 +_,7 @@
         // Send time updates to everyone, it will get the right time from the world the player is in.
         // Paper start - Perf: Optimize time updates
         for (final ServerLevel level : Arrays.asList(region.world)) { // Folia - region threading
+            if (region.world.isUnloading) continue; // Canvas - fix world loading/unloading
             final boolean doDaylight = level.getGameRules().getBoolean(GameRules.RULE_DAYLIGHT);
             final long dayTime = level.getDayTime();
             long worldTime = level.getGameTime();
@@ -1765,6 +_,48 @@
             }
             // CraftBukkit end */
 
+            // Canvas start - fix world loading/unloading
+            if (serverLevel.isUnloading) {
+                // finish teleports
+                final ChunkPos center = region.region.getCenterChunk();
+                final List<ServerLevel.PendingTeleport> pendingTeleports = serverLevel.removeAllRegionTeleports();
+                if (!pendingTeleports.isEmpty()) {
+                    LOGGER.info("Completing {} pending teleports in region around chunk {} in world '{}'", pendingTeleports.size(), center, region.region.regioniser.world.getWorld().getName());
+                    for (final ServerLevel.PendingTeleport pendingTeleport : pendingTeleports) {
+                        LOGGER.info("Completing teleportation to target position {}", pendingTeleport.to());
+
+                        // first, add entities to entity chunk so that they will be saved
+                        for (final net.minecraft.world.entity.Entity.EntityTreeNode node : pendingTeleport.rootVehicle().getFullTree()) {
+                            // assume that world and position are set to destination here
+                            node.root.setLevel(serverLevel); // in case the pending teleport is from a portal before it finds the exact destination
+                            serverLevel.moonrise$getEntityLookup().addEntityForShutdownTeleportComplete(node.root);
+                        }
+
+                        // then, rebuild the passenger tree so that when saving only the root vehicle will be written - and if
+                        // there are any player passengers, that the later player saving will save the tree
+                        pendingTeleport.rootVehicle().restore();
+
+                        // now we are finished
+                        LOGGER.info("Completed teleportation to target position {}", pendingTeleport.to());
+                    }
+                }
+
+                if (!serverLevel.players().isEmpty()) {
+                    // a player was teleported into the world when finishing teleports, kick.
+                    for (final ServerPlayer localPlayer : serverLevel.getLocalPlayers()) {
+                        localPlayer.getBukkitEntity().kick(net.kyori.adventure.text.Component.text("World unloading"), org.bukkit.event.player.PlayerKickEvent.Cause.WORLD_UNLOAD);
+                    }
+                }
+
+                LOGGER.info("Saving chunks around region around chunk {} in world '{}'", center, region.region.regioniser.world.getWorld().getName());
+                region.region.regioniser.world.moonrise$getChunkTaskScheduler().chunkHolderManager.close(true, true, false, false, false);
+
+                LOGGER.info("Descheduling region around chunk {} in world '{}'", center, region.region.regioniser.world.getWorld().getName());
+                io.papermc.paper.threadedregions.TickRegions.getScheduler().descheduleRegion(region.getRegionSchedulingHandle());
+                region.markClosed();
+                continue;
+            }
+            // Canvas end
             try {
                 serverLevel.tick(hasTimeLeft, region); // Folia - region threading
             } catch (Throwable var7) {
@@ -1837,22 +_,31 @@
 
     @Nullable
     public ServerLevel getLevel(ResourceKey<Level> dimension) {
-        return this.levels.get(dimension);
+        // Canvas start - fix world loading/unloading
+        ServerLevel serverLevel = this.levels.get(dimension);
+        if (serverLevel != null && serverLevel.isUnloading) return null;
+        return serverLevel;
+        // Canvas end
     }
 
     // CraftBukkit start
+    private final Object levelLock = new Object(); // Canvas - fix world loading/unloading
     public void addLevel(ServerLevel level) {
+        synchronized (levelLock) { // Canvas - fix world loading/unloading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.put(level.dimension(), level);
         this.levels = Collections.unmodifiableMap(newLevels);
+        } // Canvas - fix world loading/unloading
     }
 
     public void removeLevel(ServerLevel level) {
+        synchronized (levelLock) { // Canvas - fix world loading/unloading
         Map<ResourceKey<Level>, ServerLevel> oldLevels = this.levels;
         Map<ResourceKey<Level>, ServerLevel> newLevels = Maps.newLinkedHashMap(oldLevels);
         newLevels.remove(level.dimension());
         this.levels = Collections.unmodifiableMap(newLevels);
+        } // Canvas - fix world loading/unloading
     }
     // CraftBukkit end
 
@@ -2703,7 +_,7 @@
         }
     }
 
-    public final java.util.concurrent.ExecutorService chatExecutor = java.util.concurrent.Executors.newCachedThreadPool(
+    public final java.util.concurrent.ExecutorService chatExecutor = io.canvasmc.canvas.Config.INSTANCE.virtualThreads.chatExecutor ? java.util.concurrent.Executors.newVirtualThreadPerTaskExecutor() : java.util.concurrent.Executors.newCachedThreadPool( // Canvas - virtual threads
         new com.google.common.util.concurrent.ThreadFactoryBuilder().setDaemon(true).setNameFormat("Async Chat Thread - #%d").setUncaughtExceptionHandler(new net.minecraft.DefaultUncaughtExceptionHandlerWithName(net.minecraft.server.MinecraftServer.LOGGER)).build()); // Paper
     public final ChatDecorator improvedChatDecorator = new io.papermc.paper.adventure.ImprovedChatDecorator(this); // Paper - adventure
 
