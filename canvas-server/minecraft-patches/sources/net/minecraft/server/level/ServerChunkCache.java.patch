--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -162,7 +_,8 @@
 
         // TODO check on update: impl of forEachBlockTickingChunk will only iterate ENTITY ticking chunks!
         // TODO check on update: consumer just runs tickChunk
-        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = world.getCurrentWorldData().getEntityTickingChunks(); // Folia - region threading
+        io.papermc.paper.threadedregions.RegionizedWorldData worldData = world.getCurrentWorldData(); // Canvas - optimize random tick
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> entityTickingChunks = worldData.getEntityTickingChunks(); // Folia - region threading // Canvas - optimize random tick
 
         // note: we can use the backing array here because:
         // 1. we do not care about new additions
@@ -172,7 +_,7 @@
 
         java.util.Objects.checkFromToIndex(0, size, raw.length);
         for (int i = 0; i < size; ++i) {
-            world.tickChunk(raw[i], randomTickSpeed);
+            world.tickChunk(raw[i], randomTickSpeed, worldData); // Canvas - optimize random tick
 
             // call mid-tick tasks for chunk system
             if ((i & 7) == 0) {
@@ -560,6 +_,7 @@
                 chunkRange = Math.min(chunkRange, 8);
                 entityPlayer.playerNaturallySpawnedEvent = new com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent(entityPlayer.getBukkitEntity(), (byte) chunkRange);
                 entityPlayer.playerNaturallySpawnedEvent.callEvent();
+                regionizedWorldData.natureSpawnChunkMap.addPlayer(entityPlayer); // Canvas - optimize collect spawning chunks
             }
             // Paper end - PlayerNaturallySpawnCreaturesEvent
             boolean flag = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getRedstoneGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit // Folia - region threading
@@ -571,20 +_,30 @@
         List<LevelChunk> list = regionizedWorldData.temporaryChunkTickList; // Folia - region threading
 
         try {
-            this.chunkMap.collectSpawningChunks(list);
+            // Canvas start - optimize collect spawning chunks
+            regionizedWorldData.natureSpawnChunkMap.build();
+            regionizedWorldData.natureSpawnChunkMap.collectSpawningChunks(regionizedWorldData.getEntityTickingChunks(), list);
+            // this.chunkMap.collectSpawningChunks(list);
+            // Canvas end - optimize collect spawning chunks
             // Paper start - chunk tick iteration optimisation
-            this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+            // this.shuffleRandom.setSeed(this.level.random.nextLong()); // Canvas - optimize collect spawning chunks
+            // if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled // Canvas - optimize collect spawning chunks
             // Paper end - chunk tick iteration optimisation
 
             for (LevelChunk levelChunk : list) {
                 this.tickSpawningChunk(levelChunk, timeInhabited, filteredSpawningCategories, spawnState);
             }
         } finally {
-            list.clear();
+            regionizedWorldData.natureSpawnChunkMap.clear(); // Canvas - optimize collect spawning chunks
         }
 
-        this.iterateTickingChunksFaster(); // Paper - chunk tick iteration optimisations
+        // Leaf start - optimize random tick
+        if (io.canvasmc.canvas.Config.INSTANCE.chunks.optimizeRandomTick) {
+            regionizedWorldData.randomTickSystem.tick(regionizedWorldData);
+        } else {
+            this.iterateTickingChunksFaster(); // Paper - chunk tick iteration optimisations
+        }
+        // Leaf end - optimize random tick
         if (_boolean) {
             this.level.tickCustomSpawners(this.spawnEnemies, this.spawnFriendlies);
         }
@@ -858,6 +_,7 @@
 
         @Override
         public boolean pollTask() {
+            if (!io.papermc.paper.threadedregions.TickRegionScheduler.isTickRunner()) return false; // Canvas - we implement this check in syncload, why not here?
             // Folia start - region threading
             if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
                 throw new IllegalStateException("Polling tasks from non-owned region");
