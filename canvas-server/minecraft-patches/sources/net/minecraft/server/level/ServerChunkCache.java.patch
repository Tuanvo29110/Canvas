--- a/net/minecraft/server/level/ServerChunkCache.java
+++ b/net/minecraft/server/level/ServerChunkCache.java
@@ -445,10 +_,7 @@
     }
 
     public boolean isPositionTicking(long chunkPos) {
-        // Paper start - rewrite chunk system
-        final ca.spottedleaf.moonrise.patches.chunk_system.scheduling.NewChunkHolder newChunkHolder = ((ca.spottedleaf.moonrise.patches.chunk_system.level.ChunkSystemServerLevel)this.level).moonrise$getChunkTaskScheduler().chunkHolderManager.getChunkHolder(chunkPos);
-        return newChunkHolder != null && newChunkHolder.isTickingReady();
-        // Paper end - rewrite chunk system
+        return this.level.getCurrentWorldData().blockTickingChunkHolders.contains(chunkPos); // Canvas - optimize entity/block ticking chunk lookups
     }
 
     public void save(boolean flush) {
@@ -568,20 +_,20 @@
             filteredSpawningCategories = List.of();
         }
 
-        List<LevelChunk> list = regionizedWorldData.temporaryChunkTickList; // Folia - region threading
+        final ca.spottedleaf.moonrise.common.list.ReferenceList<net.minecraft.world.level.chunk.LevelChunk> list = this.level.getCurrentWorldData().getEntityTickingChunks(); // Folia - region threading // Canvas - optimize collect spawning chunks
 
         try {
-            this.chunkMap.collectSpawningChunks(list);
+            // this.chunkMap.collectSpawningChunks(list); // Canvas - optimize collect spawning chunks
             // Paper start - chunk tick iteration optimisation
             this.shuffleRandom.setSeed(this.level.random.nextLong());
-            if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled
+            // if (!this.level.paperConfig().entities.spawning.perPlayerMobSpawns) Util.shuffle(list, this.shuffleRandom); // Paper - Optional per player mob spawns; do not need this when per-player is enabled // Canvas - optimize collect spawning chunks
             // Paper end - chunk tick iteration optimisation
 
             for (LevelChunk levelChunk : list) {
                 this.tickSpawningChunk(levelChunk, timeInhabited, filteredSpawningCategories, spawnState);
             }
         } finally {
-            list.clear();
+            // list.clear(); // Canvas - optimize collect spawning chunks
         }
 
         this.iterateTickingChunksFaster(); // Paper - chunk tick iteration optimisations
@@ -858,6 +_,7 @@
 
         @Override
         public boolean pollTask() {
+            if (!io.papermc.paper.threadedregions.TickRegionScheduler.isTickRunner()) return false; // Canvas - if not tick runner, don't poll
             // Folia start - region threading
             if (ServerChunkCache.this.level != io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegionizedWorldData().world) {
                 throw new IllegalStateException("Polling tasks from non-owned region");
