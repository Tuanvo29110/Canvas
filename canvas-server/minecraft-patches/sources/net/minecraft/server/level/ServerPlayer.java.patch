--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -265,7 +_,7 @@
     private BlockPos raidOmenPosition;
     private Vec3 lastKnownClientMovement = Vec3.ZERO;
     private Input lastClientInput = Input.EMPTY;
-    private final Set<ThrownEnderpearl> enderPearls = new HashSet<>();
+    private final Set<ThrownEnderpearl> enderPearls = java.util.concurrent.ConcurrentHashMap.newKeySet(); // Canvas - restore vanilla ender pearl behavior
     public final ContainerSynchronizer containerSynchronizer = new ContainerSynchronizer() {
         private final LoadingCache<TypedDataComponent<?>, Integer> cache = CacheBuilder.newBuilder()
             .maximumSize(256L)
@@ -1524,14 +_,25 @@
      * internally for {@link #respawn(java.util.function.Consumer, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason)}
      */
     public static final long TELEPORT_FLAGS_PLAYER_RESPAWN    = Long.MIN_VALUE >>> 0;
+    public boolean isDisplayingEndCredits = false; // Canvas - fix end credits
+    private @Nullable Runnable exitEndCreditsCallback = null; // Canvas - fix end credits
 
     public void exitEndCredits() {
         if (!this.wonGame) {
             // not in the end credits anymore
             return;
         }
-        this.wonGame = false;
+        // Canvas start - fix end credits
+        if (!this.isDisplayingEndCredits) this.wonGame = false;
 
+        if (this.exitEndCreditsCallback != null) {
+            this.wonGame = false;
+            this.isDisplayingEndCredits = false;
+            this.exitEndCreditsCallback.run();
+            this.exitEndCreditsCallback = null;
+            return;
+        }
+        // Canvas end
         this.respawn((player) -> {
             CriteriaTriggers.CHANGED_DIMENSION.trigger(player, Level.END, Level.OVERWORLD);
         }, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.END_PORTAL, true);
@@ -1573,19 +_,38 @@
             ServerPlayer.this.reset();
         }
         // must be manually removed from connections, delay until after reset() so that we do not trip any thread checks
-        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+        this.level().getCurrentWorldData().removeConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
         ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> spawnPosComplete =
             new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
         boolean[] usedRespawnAnchor = new boolean[1];
 
         // set up post spawn location logic
+        boolean[] isBedSpawn = new boolean[]{false}; // Canvas - fix events with region threading
+        boolean[] missingRespawnBlock = new boolean[]{false}; // Canvas - fix events with region threading
         spawnPosComplete.addWaiter((spawnLoc, throwable) -> {
             // update pos and velocity
-            ServerPlayer.this.setPosRaw(spawnLoc.getX(), spawnLoc.getY(), spawnLoc.getZ());
-            ServerPlayer.this.setYRot(spawnLoc.getYaw());
-            ServerPlayer.this.setYHeadRot(spawnLoc.getYaw());
-            ServerPlayer.this.setXRot(spawnLoc.getPitch());
+            // Canvas start - fix events with region threading
+            org.bukkit.event.player.PlayerRespawnEvent respawnEvent = new org.bukkit.event.player.PlayerRespawnEvent(
+                ServerPlayer.this.getBukkitEntity(),
+                spawnLoc,
+                isBedSpawn[0],
+                usedRespawnAnchor[0],
+                missingRespawnBlock[0],
+                reason
+            );
+            respawnEvent.callEvent();
+            if (this.connection.isDisconnected()) {
+                // plugin disconnected the client, cancel respawn
+                return;
+            }
+            java.util.concurrent.atomic.AtomicReference<org.bukkit.Location> spawnLocAtomic = new java.util.concurrent.atomic.AtomicReference<>();
+            Runnable finalize = () -> {
+            ServerPlayer.this.setPosRaw(spawnLocAtomic.get().getX(), spawnLocAtomic.get().getY(), spawnLocAtomic.get().getZ());
+            ServerPlayer.this.setYRot(spawnLocAtomic.get().getYaw());
+            ServerPlayer.this.setYHeadRot(spawnLocAtomic.get().getYaw());
+            ServerPlayer.this.setXRot(spawnLocAtomic.get().getPitch());
+            // Canvas end
             ServerPlayer.this.setDeltaMovement(Vec3.ZERO);
             // placeInAsync will update the world
 
@@ -1593,7 +_,7 @@
                 origin,
                 // use the load chunk flag just in case the spawn loc isn't loaded, and to ensure the chunks
                 // stay loaded for a bit with the teleport ticket
-                ((org.bukkit.craftbukkit.CraftWorld)spawnLoc.getWorld()).getHandle(),
+                ((org.bukkit.craftbukkit.CraftWorld)spawnLocAtomic.get().getWorld()).getHandle(), // Canvas - fix events with region threading
                 TELEPORT_FLAG_LOAD_CHUNK | TELEPORT_FLAGS_PLAYER_RESPAWN,
                 passengerTree, // note: we expect this to just be the player, no passengers
                 (entity) -> {
@@ -1615,8 +_,25 @@
                     }
                 }
             );
+            // Canvas start - fix events with region threading
+            };
+            spawnLocAtomic.set(respawnEvent.getRespawnLocation());
+            if (spawnLoc != respawnEvent.getRespawnLocation()) {
+                // event changed the location, load async and then call finalizer
+                // use all the events location for this, they may have changed the world
+                ServerLevel respawnAt = ((org.bukkit.craftbukkit.CraftWorld) respawnEvent.getRespawnLocation().getWorld()).getHandle();
+                respawnAt.moonrise$loadChunksAsync(
+                    new BlockPos(spawnLoc.getBlockX(), spawnLoc.getBlockY(), spawnLoc.getBlockZ()),
+                    16, ca.spottedleaf.concurrentutil.util.Priority.HIGHER, (entity1) -> finalize.run()
+                );
+            } else {
+                // event didn't modify location, run finalizer
+                finalize.run();
+            }
+            // Canvas end
         });
 
+        Runnable finalizer = () -> { // Canvas - fix end credits
         // find and modify respawn block state
         if (respawnWorld == null || respawnConfig == null) {
             // default to regular spawn
@@ -1632,6 +_,7 @@
                         respawnWorld, respawnConfig, !alive
                     ).orElse(null);
                     if (spawnPos == null) {
+                        missingRespawnBlock[0] = true; // Canvas - fix events with region threading
                         // no spawn
                         ServerPlayer.this.connection.send(
                             new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F)
@@ -1647,6 +_,7 @@
                     boolean isRespawnAnchor = respawnWorld.getBlockState(respawnConfig.pos()).is(net.minecraft.world.level.block.Blocks.RESPAWN_ANCHOR);
                     boolean isBed = respawnWorld.getBlockState(respawnConfig.pos()).is(net.minecraft.tags.BlockTags.BEDS);
                     usedRespawnAnchor[0] = !alive && isRespawnAnchor;
+                    isBedSpawn[0] = isBed; // Canvas - fix events with region threading
 
                     // finished now, pass the location on
                     spawnPosComplete.complete(
@@ -1656,6 +_,16 @@
                 }
             );
         }
+        // Canvas start - fix end credits
+        };
+        if (this.isDisplayingEndCredits) {
+            // we need to assign to callback, we are displaying the credits
+            this.exitEndCreditsCallback = finalizer;
+        } else {
+            // not displaying credits, run finalizer
+            finalizer.run();
+        }
+        // Canvas end
     }
 
     @Override
@@ -1684,7 +_,7 @@
     @Override
     protected ServerPlayer transformForAsyncTeleport(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
         // must be manually removed from connections
-        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+        this.level().getCurrentWorldData().removeConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
         this.level().removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
 
         this.spawnIn(destination);
@@ -1706,7 +_,7 @@
             destination.addDuringTeleport(this);
 
             // must be manually added to connections
-            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+            this.level().getCurrentWorldData().addConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
             // required to set up the pending teleport stuff to the client, and to actually update
             // the player's position clientside
@@ -1759,7 +_,7 @@
             destination.addDuringTeleport(this);
 
             // must be manually added to connections
-            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+            this.level().getCurrentWorldData().addConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
             // required to set up the pending teleport stuff to the client, and to actually update
             // the player's position clientside
@@ -1805,12 +_,25 @@
                 return false;
             }
             this.wonGame = true;
-            // TODO is there a better solution to this that DOESN'T skip the credits?
-            this.seenCredits = true;
-            if (!this.seenCredits) {
-                this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
-            }
+            // Canvas start - fix end credits
+            // we need to remove the player *first*, and then display
+            // the end credits, or else we get the player stuck in the
+            // void, and they can't escape...
+            // Original 'showEndCredits' method:
+            // this.unRide();
+            // this.level().removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
+            // if (!this.wonGame) {
+            //     this.wonGame = true;
+            //     this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
+            //     this.seenCredits = true;
+            // }
+            this.isDisplayingEndCredits = !this.seenCredits && !this.level().paperConfig().misc.disableEndCredits; // ensure we respect paper config
             this.exitEndCredits();
+            if (this.isDisplayingEndCredits) {
+                this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
+                this.seenCredits = true; // mark seen the end credits
+            }
+            // Canvas end
             return true;
         } else {
             return super.endPortalLogicAsync(portalPos);
@@ -3280,13 +_,19 @@
         return getInputVector(new Vec3(f, 0.0, f1), 1.0F, this.getYRot());
     }
 
+    // Canvas start - restore vanilla ender pearl behavior
     public void registerEnderPearl(ThrownEnderpearl enderPearl) {
-        //this.enderPearls.add(enderPearl); // Folia - region threading - do not track ender pearls
+        if (io.canvasmc.canvas.Config.INSTANCE.restoreVanillaEnderPearlBehavior) {
+            this.enderPearls.add(enderPearl);
+        }
     }
 
     public void deregisterEnderPearl(ThrownEnderpearl enderPearl) {
-        //this.enderPearls.remove(enderPearl); // Folia - region threading - do not track ender pearls
+        if (io.canvasmc.canvas.Config.INSTANCE.restoreVanillaEnderPearlBehavior) {
+            this.enderPearls.remove(enderPearl);
+        }
     }
+    // Canvas end - restore vanilla ender pearl behavior
 
     public Set<ThrownEnderpearl> getEnderPearls() {
         return this.enderPearls;
