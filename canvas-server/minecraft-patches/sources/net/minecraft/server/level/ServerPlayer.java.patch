--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -265,7 +_,7 @@
     private BlockPos raidOmenPosition;
     private Vec3 lastKnownClientMovement = Vec3.ZERO;
     private Input lastClientInput = Input.EMPTY;
-    private final Set<ThrownEnderpearl> enderPearls = new HashSet<>();
+    private final Set<ThrownEnderpearl> enderPearls = java.util.concurrent.ConcurrentHashMap.newKeySet(); // Canvas - restore vanilla ender pearl behavior
     public final ContainerSynchronizer containerSynchronizer = new ContainerSynchronizer() {
         private final LoadingCache<TypedDataComponent<?>, Integer> cache = CacheBuilder.newBuilder()
             .maximumSize(256L)
@@ -423,6 +_,41 @@
     public boolean joining = true;
     public boolean sentListPacket = false;
     public boolean supressTrackerForLogin = false; // Paper - Fire PlayerJoinEvent when Player is actually ready
+    // Canvas start - tpsbar
+    // default to 'false, Placement.BOSS_BAR'
+    public io.canvasmc.canvas.RegionizedTpsBar.Entry localEntry = io.canvasmc.canvas.RegionizedTpsBar.Entry.FALLBACK;
+    public final net.kyori.adventure.bossbar.BossBar tpsBar =
+        net.kyori.adventure.bossbar.BossBar.bossBar(
+            net.kyori.adventure.text.Component.text("Waiting for region update..."),
+            0.0F,
+            net.kyori.adventure.bossbar.BossBar.Color.BLUE,
+            net.kyori.adventure.bossbar.BossBar.Overlay.PROGRESS
+        );
+
+    public void setTpsBarEnabled(boolean enabled) {
+        this.localEntry = new io.canvasmc.canvas.RegionizedTpsBar.Entry(enabled, this.localEntry.placement());
+        if (enabled && this.localEntry.placement().equals(io.canvasmc.canvas.RegionizedTpsBar.Placement.BOSS_BAR)) {
+            this.tpsBar.addViewer(this.getBukkitEntity());
+        } else {
+            this.tpsBar.removeViewer(this.getBukkitEntity());
+        }
+        this.getBukkitEntity().sendActionBar(net.kyori.adventure.text.Component.text());
+    }
+
+    public void setTpsBarPlacement(io.canvasmc.canvas.RegionizedTpsBar.Placement placement) {
+        boolean isNew = this.localEntry.placement() != placement;
+        this.localEntry = new io.canvasmc.canvas.RegionizedTpsBar.Entry(this.localEntry.enabled(), placement);
+        if (isNew) {
+            if (this.localEntry.placement().equals(io.canvasmc.canvas.RegionizedTpsBar.Placement.BOSS_BAR)) {
+                this.tpsBar.addViewer(this.getBukkitEntity());
+                this.getBukkitEntity().sendActionBar(net.kyori.adventure.text.Component.text());
+            } else {
+                this.tpsBar.removeViewer(this.getBukkitEntity());
+            }
+        }
+    }
+    // Canvas end - tpsbar
+    public final int infoBucketIndex; // Canvas - optimize playerlist tick
     // CraftBukkit end
     public boolean isRealPlayer; // Paper
     public @Nullable com.destroystokyo.paper.event.entity.PlayerNaturallySpawnCreaturesEvent playerNaturallySpawnedEvent; // Paper - PlayerNaturallySpawnCreaturesEvent
@@ -474,6 +_,7 @@
         this.bukkitPickUpLoot = true;
         this.maxHealthCache = this.getMaxHealth();
         // CraftBukkit end
+        this.infoBucketIndex = Math.floorMod(this.uuid.hashCode(), net.minecraft.server.players.PlayerList.SEND_PLAYER_INFO_INTERVAL); // Canvas - optimize playerlist tick
     }
 
     // Folia start - region threading
@@ -612,6 +_,12 @@
     }
 
     public void queuePacketTask(Runnable run) {
+        // Canvas start - rewrite scheduler
+        if (io.canvasmc.canvas.Config.INSTANCE.networking.processPacketsInBetweenTicks) {
+            this.getBukkitEntity().pushPacket(run);
+            return;
+        }
+        // Canvas end - rewrite scheduler
         this.getBukkitEntity().taskScheduler.schedule((ServerPlayer player) -> {
             run.run();
         }, null, 1L);
@@ -707,6 +_,7 @@
         this.respawnConfig = input.read("respawn", ServerPlayer.RespawnConfig.CODEC).orElse(null);
         this.spawnExtraParticlesOnFall = input.getBooleanOr("spawn_extra_particles_on_fall", false);
         this.raidOmenPosition = input.read("raid_omen_position", BlockPos.CODEC).orElse(null);
+        this.localEntry = input.read("TpsBar", io.canvasmc.canvas.RegionizedTpsBar.Entry.CODEC).orElse(io.canvasmc.canvas.RegionizedTpsBar.Entry.FALLBACK); // Canvas - tpsbar
     }
 
     @Override
@@ -724,6 +_,7 @@
         output.storeNullable("raid_omen_position", BlockPos.CODEC, this.raidOmenPosition);
         this.saveEnderPearls(output);
         this.getBukkitEntity().setExtraData(output); // CraftBukkit
+        output.store("TpsBar", io.canvasmc.canvas.RegionizedTpsBar.Entry.CODEC, this.localEntry); // Canvas - tpsbar
     }
 
     private void saveParentVehicle(ValueOutput output) {
@@ -1301,6 +_,7 @@
         if (killCredit != null) {
             this.awardStat(Stats.ENTITY_KILLED_BY.get(killCredit.getType()));
             killCredit.awardKillScore(this, cause);
+            if (cause.is(DamageTypes.WITHER_SKULL)) this.isDyingFromWitherRose = true; // Canvas - fix Folia#388
             this.createWitherRose(killCredit);
         }
 
@@ -1528,16 +_,28 @@
      * internally for {@link #respawn(java.util.function.Consumer, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason)}
      */
     public static final long TELEPORT_FLAGS_PLAYER_RESPAWN    = Long.MIN_VALUE >>> 0;
+    public boolean isDisplayingEndCredits = false; // Canvas - fix end credits
+    private @Nullable Runnable exitEndCreditsCallback = null; // Canvas - fix end credits
 
     public void exitEndCredits() {
         if (!this.wonGame) {
             // not in the end credits anymore
             return;
         }
-        this.wonGame = false;
+        // Canvas start - fix end credits
+        if (!this.isDisplayingEndCredits) this.wonGame = false;
 
+        if (this.exitEndCreditsCallback != null) {
+            this.wonGame = false;
+            this.isDisplayingEndCredits = false;
+            this.level().getServer().getPlayerList().seeingEndCredits.remove(this);
+            this.exitEndCreditsCallback.run();
+            this.exitEndCreditsCallback = null;
+            return;
+        }
+        // Canvas end - fix end credits
         this.respawn((player) -> {
-            CriteriaTriggers.CHANGED_DIMENSION.trigger(player, Level.END, Level.OVERWORLD);
+            CriteriaTriggers.CHANGED_DIMENSION.trigger(player, Level.END, io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()); // Canvas - default respawn dimension config
         }, org.bukkit.event.player.PlayerRespawnEvent.RespawnReason.END_PORTAL, true);
     }
 
@@ -1577,19 +_,38 @@
             ServerPlayer.this.reset();
         }
         // must be manually removed from connections, delay until after reset() so that we do not trip any thread checks
-        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+        this.level().getCurrentWorldData().removeConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
         ca.spottedleaf.concurrentutil.completable.CallbackCompletable<org.bukkit.Location> spawnPosComplete =
             new ca.spottedleaf.concurrentutil.completable.CallbackCompletable<>();
         boolean[] usedRespawnAnchor = new boolean[1];
 
         // set up post spawn location logic
+        boolean[] isBedSpawn = new boolean[]{false}; // Canvas - fix events with region threading
+        boolean[] missingRespawnBlock = new boolean[]{false}; // Canvas - fix events with region threading
         spawnPosComplete.addWaiter((spawnLoc, throwable) -> {
             // update pos and velocity
-            ServerPlayer.this.setPosRaw(spawnLoc.getX(), spawnLoc.getY(), spawnLoc.getZ());
-            ServerPlayer.this.setYRot(spawnLoc.getYaw());
-            ServerPlayer.this.setYHeadRot(spawnLoc.getYaw());
-            ServerPlayer.this.setXRot(spawnLoc.getPitch());
+            // Canvas start - fix events with region threading
+            org.bukkit.event.player.PlayerRespawnEvent respawnEvent = new org.bukkit.event.player.PlayerRespawnEvent(
+                ServerPlayer.this.getBukkitEntity(),
+                spawnLoc,
+                isBedSpawn[0],
+                usedRespawnAnchor[0],
+                missingRespawnBlock[0],
+                reason
+            );
+            respawnEvent.callEvent();
+            if (this.connection.isDisconnected()) {
+                // plugin disconnected the client, cancel respawn
+                return;
+            }
+            java.util.concurrent.atomic.AtomicReference<org.bukkit.Location> spawnLocAtomic = new java.util.concurrent.atomic.AtomicReference<>();
+            Runnable finalize = () -> {
+            ServerPlayer.this.setPosRaw(spawnLocAtomic.get().getX(), spawnLocAtomic.get().getY(), spawnLocAtomic.get().getZ());
+            ServerPlayer.this.setYRot(spawnLocAtomic.get().getYaw());
+            ServerPlayer.this.setYHeadRot(spawnLocAtomic.get().getYaw());
+            ServerPlayer.this.setXRot(spawnLocAtomic.get().getPitch());
+            // Canvas end - fix events with region threading
             ServerPlayer.this.setDeltaMovement(Vec3.ZERO);
             // placeInAsync will update the world
 
@@ -1597,7 +_,7 @@
                 origin,
                 // use the load chunk flag just in case the spawn loc isn't loaded, and to ensure the chunks
                 // stay loaded for a bit with the teleport ticket
-                ((org.bukkit.craftbukkit.CraftWorld)spawnLoc.getWorld()).getHandle(),
+                ((org.bukkit.craftbukkit.CraftWorld)spawnLocAtomic.get().getWorld()).getHandle(), // Canvas - fix events with region threading
                 TELEPORT_FLAG_LOAD_CHUNK | TELEPORT_FLAGS_PLAYER_RESPAWN,
                 passengerTree, // note: we expect this to just be the player, no passengers
                 (entity) -> {
@@ -1619,12 +_,29 @@
                     }
                 }
             );
+            // Canvas start - fix events with region threading
+            };
+            spawnLocAtomic.set(respawnEvent.getRespawnLocation());
+            if (spawnLoc != respawnEvent.getRespawnLocation()) {
+                // event changed the location, load async and then call finalizer
+                // use all the events location for this, they may have changed the world
+                ServerLevel respawnAt = ((org.bukkit.craftbukkit.CraftWorld) respawnEvent.getRespawnLocation().getWorld()).getHandle();
+                respawnAt.moonrise$loadChunksAsync(
+                    new BlockPos(spawnLoc.getBlockX(), spawnLoc.getBlockY(), spawnLoc.getBlockZ()),
+                    16, ca.spottedleaf.concurrentutil.util.Priority.HIGHER, (entity1) -> finalize.run()
+                );
+            } else {
+                // event didn't modify location, run finalizer
+                finalize.run();
+            }
+            // Canvas end - fix events with region threading
         });
 
+        Runnable finalizer = () -> { // Canvas - fix end credits
         // find and modify respawn block state
         if (respawnWorld == null || respawnConfig == null) {
             // default to regular spawn
-            fudgeSpawnLocation(this.server.getLevel(Level.OVERWORLD), this, spawnPosComplete);
+            fudgeSpawnLocation(this.server.getLevel(io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()), this, spawnPosComplete); // Canvas - default respawn dimension config
         } else {
             // load chunk for block
             // give at least 1 radius of loaded chunks so that we do not sync load anything
@@ -1636,6 +_,7 @@
                         respawnWorld, respawnConfig, !alive
                     ).orElse(null);
                     if (spawnPos == null) {
+                        missingRespawnBlock[0] = true; // Canvas - fix events with region threading
                         // no spawn
                         ServerPlayer.this.connection.send(
                             new ClientboundGameEventPacket(ClientboundGameEventPacket.NO_RESPAWN_BLOCK_AVAILABLE, 0.0F)
@@ -1644,13 +_,14 @@
                             null, false, com.destroystokyo.paper.event.player.PlayerSetSpawnEvent.Cause.PLAYER_RESPAWN
                         );
                         // default to regular spawn
-                        fudgeSpawnLocation(this.server.getLevel(Level.OVERWORLD), this, spawnPosComplete);
+                        fudgeSpawnLocation(this.server.getLevel(io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()), this, spawnPosComplete); // Canvas - default respawn dimension config
                         return;
                     }
 
                     boolean isRespawnAnchor = respawnWorld.getBlockState(respawnConfig.pos()).is(net.minecraft.world.level.block.Blocks.RESPAWN_ANCHOR);
                     boolean isBed = respawnWorld.getBlockState(respawnConfig.pos()).is(net.minecraft.tags.BlockTags.BEDS);
                     usedRespawnAnchor[0] = !alive && isRespawnAnchor;
+                    isBedSpawn[0] = isBed; // Canvas - fix events with region threading
 
                     // finished now, pass the location on
                     spawnPosComplete.complete(
@@ -1660,6 +_,16 @@
                 }
             );
         }
+        // Canvas start - fix end credits
+        };
+        if (this.isDisplayingEndCredits) {
+            // we need to assign to callback, we are displaying the credits
+            this.exitEndCreditsCallback = finalizer;
+        } else {
+            // not displaying credits, run finalizer
+            finalizer.run();
+        }
+        // Canvas end - fix end credits
     }
 
     @Override
@@ -1688,7 +_,7 @@
     @Override
     protected ServerPlayer transformForAsyncTeleport(ServerLevel destination, Vec3 pos, Float yaw, Float pitch, Vec3 velocity) {
         // must be manually removed from connections
-        this.level().getCurrentWorldData().connections.remove(this.connection.connection);
+        this.level().getCurrentWorldData().removeConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
         this.level().removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
 
         this.spawnIn(destination);
@@ -1710,7 +_,7 @@
             destination.addDuringTeleport(this);
 
             // must be manually added to connections
-            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+            this.level().getCurrentWorldData().addConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
             // required to set up the pending teleport stuff to the client, and to actually update
             // the player's position clientside
@@ -1763,7 +_,7 @@
             destination.addDuringTeleport(this);
 
             // must be manually added to connections
-            this.level().getCurrentWorldData().connections.add(this.connection.connection);
+            this.level().getCurrentWorldData().addConnection(this.connection.connection, this); // Canvas - rewrite tick scheduler
 
             // required to set up the pending teleport stuff to the client, and to actually update
             // the player's position clientside
@@ -1809,12 +_,26 @@
                 return false;
             }
             this.wonGame = true;
-            // TODO is there a better solution to this that DOESN'T skip the credits?
-            this.seenCredits = true;
-            if (!this.seenCredits) {
-                this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
-            }
+            // Canvas start - fix end credits
+            // we need to remove the player *first*, and then display
+            // the end credits, or else we get the player stuck in the
+            // void, and they can't escape...
+            // Original 'showEndCredits' method:
+            // this.unRide();
+            // this.level().removePlayerImmediately(this, Entity.RemovalReason.CHANGED_DIMENSION);
+            // if (!this.wonGame) {
+            //     this.wonGame = true;
+            //     this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
+            //     this.seenCredits = true;
+            // }
+            this.isDisplayingEndCredits = !this.seenCredits && !this.level().paperConfig().misc.disableEndCredits; // ensure we respect paper config
             this.exitEndCredits();
+            if (this.isDisplayingEndCredits) {
+                this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.WIN_GAME, 0.0F));
+                this.seenCredits = true; // mark seen the end credits
+                this.level().getServer().getPlayerList().seeingEndCredits.add(this);
+            }
+            // Canvas end - fix end credits
             return true;
         } else {
             return super.endPortalLogicAsync(portalPos);
@@ -2331,7 +_,7 @@
                     this.awardStat(Stats.SWIM_ONE_CM, rounded);
                     this.causeFoodExhaustion(this.level().spigotConfig.swimMultiplier * (float) rounded * 0.01F, org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason.SWIM); // CraftBukkit - EntityExhaustionEvent // Spigot
                 }
-            } else if (this.isEyeInFluid(FluidTags.WATER)) {
+            } else if (this.isEyeInWater()) { // Canvas - optimize fluidOnEyes
                 int rounded = Math.round((float)Math.sqrt(dx * dx + dy * dy + dz * dz) * 100.0F);
                 if (rounded > 0) {
                     this.awardStat(Stats.WALK_UNDER_WATER_ONE_CM, rounded);
@@ -2451,7 +_,9 @@
 
     public void disconnect() {
         this.disconnected = true;
+        if (this.isTemporarilyBlocking) this.releaseUsingItem(); // Canvas - implement sword blocking
         this.ejectPassengers();
+        this.tpsBar.removeViewer(this.getBukkitEntity()); // Canvas - tpsbar
 
         // Paper start - Workaround vehicle not tracking the passenger disconnection dismount
         if (this.isPassenger() && this.getVehicle() instanceof ServerPlayer) {
@@ -2652,6 +_,9 @@
             this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.CHANGE_GAME_MODE, gameMode.getId()));
             if (gameMode == GameType.SPECTATOR) {
                 this.removeEntitiesOnShoulder();
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc119417) this.stopSleeping(); // Canvas - MC-119417
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc129909) this.releaseUsingItem(); // Canvas - MC-129909
+                if (io.canvasmc.canvas.Config.INSTANCE.fixes.mc69216 && this.fishing != null) this.fishing.discard(); // Canvas - MC-69216
                 this.stopRiding();
                 EnchantmentHelper.stopLocationBasedEffects(this);
             } else {
@@ -3284,13 +_,19 @@
         return getInputVector(new Vec3(f, 0.0, f1), 1.0F, this.getYRot());
     }
 
+    // Canvas start - restore vanilla ender pearl behavior
     public void registerEnderPearl(ThrownEnderpearl enderPearl) {
-        //this.enderPearls.add(enderPearl); // Folia - region threading - do not track ender pearls
+        if (io.canvasmc.canvas.Config.INSTANCE.restoreVanillaEnderPearlBehavior) {
+            this.enderPearls.add(enderPearl);
+        }
     }
 
     public void deregisterEnderPearl(ThrownEnderpearl enderPearl) {
-        //this.enderPearls.remove(enderPearl); // Folia - region threading - do not track ender pearls
+        if (io.canvasmc.canvas.Config.INSTANCE.restoreVanillaEnderPearlBehavior) {
+            this.enderPearls.remove(enderPearl);
+        }
     }
+    // Canvas end - restore vanilla ender pearl behavior
 
     public Set<ThrownEnderpearl> getEnderPearls() {
         return this.enderPearls;
@@ -3315,7 +_,7 @@
     public record RespawnConfig(ResourceKey<Level> dimension, BlockPos pos, float angle, boolean forced) {
         public static final Codec<ServerPlayer.RespawnConfig> CODEC = RecordCodecBuilder.create(
             instance -> instance.group(
-                    Level.RESOURCE_KEY_CODEC.optionalFieldOf("dimension", Level.OVERWORLD).forGetter(ServerPlayer.RespawnConfig::dimension),
+                    Level.RESOURCE_KEY_CODEC.optionalFieldOf("dimension", io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey()).forGetter(ServerPlayer.RespawnConfig::dimension), // Canvas - default respawn dimension config
                     BlockPos.CODEC.fieldOf("pos").forGetter(ServerPlayer.RespawnConfig::pos),
                     Codec.FLOAT.optionalFieldOf("angle", 0.0F).forGetter(ServerPlayer.RespawnConfig::angle),
                     Codec.BOOL.optionalFieldOf("forced", false).forGetter(ServerPlayer.RespawnConfig::forced)
@@ -3324,7 +_,7 @@
         );
 
         static ResourceKey<Level> getDimensionOrDefault(@Nullable ServerPlayer.RespawnConfig respawnConfig) {
-            return respawnConfig != null ? respawnConfig.dimension() : Level.OVERWORLD;
+            return respawnConfig != null ? respawnConfig.dimension() : io.canvasmc.canvas.Config.INSTANCE.fetchRespawnDimensionKey(); // Canvas - default respawn dimension config
         }
 
         public boolean isSamePosition(@Nullable ServerPlayer.RespawnConfig respawnConfig) {
