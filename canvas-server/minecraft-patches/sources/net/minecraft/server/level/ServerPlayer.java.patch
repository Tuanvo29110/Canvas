--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -1,5 +_,9 @@
 package net.minecraft.server.level;
 
+import ca.spottedleaf.moonrise.common.misc.NearbyPlayers;
+import java.util.concurrent.atomic.AtomicReference;
+import io.canvasmc.canvas.Config;
+import io.canvasmc.canvas.region.ServerRegions;
 import com.google.common.cache.CacheBuilder;
 import com.google.common.cache.CacheLoader;
 import com.google.common.cache.LoadingCache;
@@ -257,6 +_,7 @@
     private Vec3 lastKnownClientMovement = Vec3.ZERO;
     private Input lastClientInput = Input.EMPTY;
     private final Set<ThrownEnderpearl> enderPearls = new HashSet<>();
+    public final AtomicReference<NearbyPlayers> npr = new AtomicReference<>(); // Canvas - Threaded Regions
     public final ContainerSynchronizer containerSynchronizer = new ContainerSynchronizer() {
         private final LoadingCache<TypedDataComponent<?>, Integer> cache = CacheBuilder.newBuilder()
             .maximumSize(256L)
@@ -493,7 +_,7 @@
             long l1 = l * l;
             int i = l1 > 2147483647L ? Integer.MAX_VALUE : (int)l1;
             int coprime = this.getCoprime(i);
-            int randomInt = RandomSource.create().nextInt(i);
+            int randomInt = level.random.nextInt(i); // Canvas - reduce RandomSource instances
 
             for (int i1 = 0; i1 < i; i1++) {
                 int i2 = (randomInt + coprime * i1) % i;
@@ -826,15 +_,22 @@
     public void doTick() {
         try {
             if (valid && !this.isSpectator() || !this.touchingUnloadedChunk()) { // Paper - don't tick dead players that are not in the world currently (pending respawn)
-                super.tick();
+                if (!this.touchingUnloadedChunk()) super.tick(); // Canvas - ensure we dont touch any unloaded chunk
             }
 
+            // Canvas start - only tick items in hand
+            if (Config.INSTANCE.entities.onlyTickItemsInHand) {
+                this.synchronizeSpecialItemUpdates(this.getMainHandItem());
+                this.synchronizeSpecialItemUpdates(this.getOffhandItem());
+            } else {
+            // Canvas end
             for (int i = 0; i < this.getInventory().getContainerSize(); i++) {
                 ItemStack item = this.getInventory().getItem(i);
                 if (!item.isEmpty()) {
                     this.synchronizeSpecialItemUpdates(item);
                 }
             }
+            } // Canvas - only tick items in hand
 
             if (this.getHealth() != this.lastSentHealth
                 || this.lastSentFood != this.foodData.getFoodLevel()
@@ -905,6 +_,7 @@
             }
             // CraftBukkit end
         } catch (Throwable var4) {
+            var4.printStackTrace(); // Canvas - print please.
             CrashReport crashReport = CrashReport.forThrowable(var4, "Ticking player");
             CrashReportCategory crashReportCategory = crashReport.addCategory("Player being ticked");
             this.fillCrashReportCategory(crashReportCategory);
@@ -1030,6 +_,7 @@
     // Paper end - Expand PlayerDeathEvent API
     @Override
     public void die(DamageSource cause) {
+        processingDeath = true; // Canvas - item entity spread
         // this.gameEvent(GameEvent.ENTITY_DIE); // Paper - move below event cancellation check
         boolean _boolean = this.serverLevel().getGameRules().getBoolean(GameRules.RULE_SHOWDEATHMESSAGES); final boolean showDeathMessage = _boolean; // Paper - OBFHELPER
         // CraftBukkit start - fire PlayerDeathEvent
@@ -1146,6 +_,7 @@
         this.getCombatTracker().recheckStatus();
         this.setLastDeathLocation(Optional.of(GlobalPos.of(this.level().dimension(), this.blockPosition())));
         this.setClientLoaded(false);
+        processingDeath = false; // Canvas
     }
 
     private void tellNeutralMobsThatIDied() {
@@ -1520,6 +_,13 @@
         super.take(entity, quantity);
         this.containerMenu.broadcastChanges();
     }
+    // Canvas start - cache eligible players for despawn checks
+
+    @Override
+    public boolean isAlive() {
+        return !this.isRemoved() && this.entityData.get(DATA_HEALTH_ID) > 0.0f && !this.dead;
+    }
+    // Canvas end
 
     // CraftBukkit start - moved bed result checks from below into separate method
     private Either<Player.BedSleepingProblem, Unit> getBedResult(BlockPos at, Direction direction) {
@@ -2152,12 +_,18 @@
 
     @Override
     public void crit(Entity entityHit) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(entityHit, 4));
+        // Canvas start - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(Config.INSTANCE.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? entityHit : this, new ClientboundAnimatePacket(entityHit, 4));
+        // Canvas end
     }
 
     @Override
     public void magicCrit(Entity entityHit) {
-        this.serverLevel().getChunkSource().broadcastAndSend(this, new ClientboundAnimatePacket(entityHit, 5));
+        // Canvas start - broadcast crit animations as the entity being critted
+        var level = this.serverLevel();
+        level.getChunkSource().broadcastAndSend(Config.INSTANCE.fixes.broadcastCritAnimationsAsTheEntityBeingCritted ? entityHit : this, new ClientboundAnimatePacket(entityHit, 5));
+        // Canvas end
     }
 
     @Override
@@ -2188,6 +_,7 @@
             this.connection.send(new ClientboundGameEventPacket(ClientboundGameEventPacket.CHANGE_GAME_MODE, gameMode.getId()));
             if (gameMode == GameType.SPECTATOR) {
                 this.removeEntitiesOnShoulder();
+                this.stopSleeping(); // Canvas - MC-119417
                 this.stopRiding();
                 EnchantmentHelper.stopLocationBasedEffects(this);
             } else {
