--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -632,6 +_,14 @@
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.updateTickData(); // Folia - region threading - make sure it is initialised before ticked
+        // Canvas start - per world distance
+        int viewDistance = this.serverLevelData.distanceConfig.viewDistanceOrDefault();
+        this.chunkSource.setViewDistance(viewDistance - 1);
+
+        int simulationDistance = this.serverLevelData.distanceConfig.simulationDistanceOrDefault();
+        this.chunkSource.setSimulationDistance(simulationDistance - 1);
+        // Canvas end - per world distance
+        new io.canvasmc.canvas.event.WorldPreLoadEvent(getWorld(), io.canvasmc.canvas.event.WorldPreLoadEvent.Stage.CONSTRUCTED).callEvent(); // Canvas - world pre load event
     }
 
     // Folia start - region threading
@@ -654,6 +_,8 @@
     public static final int WORLD_INIT_CHECKED = 2;
     public final java.util.concurrent.atomic.AtomicInteger checkInitialised = new java.util.concurrent.atomic.AtomicInteger(WORLD_INIT_NOT_CHECKED);
     public ChunkPos randomSpawnSelection;
+    public volatile boolean isUnloading = false; // Canvas - fix world loading/unloading
+    public volatile java.util.concurrent.CompletableFuture<Boolean> unloadFuture = null; // Canvas - fix world loading/unloading - expand API
 
     public static final record PendingTeleport(Entity.EntityTreeNode rootVehicle, Vec3 to) {}
     private final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<PendingTeleport> pendingTeleports = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
@@ -956,7 +_,7 @@
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
+        if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && /*simpleRandom.nextInt(this.spigotConfig.thunderChance) == 0*/ chunk.shouldDoLightning(this.simpleRandom)) { // Spigot // Paper - Option to disable thunder // Paper - optimise random ticking // Pufferfish - replace random with shouldDoLightning
             BlockPos blockPos = this.findLightningTargetAround(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             if (this.isRainingAt(blockPos)) {
                 DifficultyInstance currentDifficultyAt = this.getCurrentDifficultyAt(blockPos);
@@ -1103,7 +_,8 @@
     }
 
     public ServerWaypointManager getWaypointManager() {
-        return this.waypointManager;
+        if (io.canvasmc.canvas.Config.INSTANCE.disableWaypointsFix) return this.waypointManager; // Canvas - region threading - restore waypoints
+        return this.getCurrentWorldData().waypointManager; // Canvas - region threading - restore waypoints
     }
 
     public void advanceWeatherCycle() { // Folia - region threading - public
@@ -1610,7 +_,7 @@
 
     public void unload(LevelChunk chunk) {
         // Spigot start
-        for (net.minecraft.world.level.block.entity.BlockEntity blockEntity : chunk.getBlockEntities().values()) {
+        for (net.minecraft.world.level.block.entity.BlockEntity blockEntity : chunk.getAllBlockEntities()) { // Canvas - optimize block entity fetching
             if (blockEntity instanceof net.minecraft.world.Container) {
                 // Paper start - this area looks like it can load chunks, change the behavior
                 // chests for example can apply physics to the world
@@ -2414,6 +_,7 @@
 
         for (TickingBlockEntity tickingBlockEntity : (Iterable<? extends net.minecraft.world.level.block.entity.TickingBlockEntity>)null) { // Folia - region threading
             BlockPos pos = tickingBlockEntity.getPos();
+            if (tickingBlockEntity instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) pos = sleepingTicker.getPosForRegionOperation(); // Canvas - block entity sleeping
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
     }
@@ -2706,9 +_,7 @@
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
-                if (serverPlayer.isReceivingWaypoints()) {
-                    ServerLevel.this.getWaypointManager().addPlayer(serverPlayer);
-                }
+                // Canvas - region threading - restore waypoints - this is handled elsewhere
 
                 ServerLevel.this.updateSleepingPlayerList();
             }
@@ -2793,7 +_,7 @@
             ServerLevel.this.getChunkSource().removeEntity(entity);
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.remove(serverPlayer);
-                ServerLevel.this.getWaypointManager().removePlayer(serverPlayer);
+                // Canvas - region threading - restore waypoints - this is handled elsewhere
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
