--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -565,6 +_,7 @@
             chunkGenerator = new org.bukkit.craftbukkit.generator.CustomChunkGenerator(this, chunkGenerator, gen);
         }
         // CraftBukkit end
+        su.plo.matter.Globals.setupGlobals(this); // Leaf - Matter - Secure Seed
         boolean flag = server.forceSynchronousWrites();
         DataFixer fixerUpper = server.getFixerUpper();
         // Paper - rewrite chunk system
@@ -632,6 +_,14 @@
         // Paper end - rewrite chunk system
         this.getCraftServer().addWorld(this.getWorld()); // CraftBukkit
         this.updateTickData(); // Folia - region threading - make sure it is initialised before ticked
+        // Canvas start - per world distance
+        int viewDistance = this.serverLevelData.distanceConfig.viewDistanceOrDefault();
+        this.chunkSource.setViewDistance(viewDistance - 1);
+
+        int simulationDistance = this.serverLevelData.distanceConfig.simulationDistanceOrDefault();
+        this.chunkSource.setSimulationDistance(simulationDistance - 1);
+        // Canvas end - per world distance
+        new io.canvasmc.canvas.event.WorldPreLoadEvent(getWorld(), io.canvasmc.canvas.event.WorldPreLoadEvent.Stage.CONSTRUCTED).callEvent(); // Canvas - world pre load event
     }
 
     // Folia start - region threading
@@ -654,6 +_,8 @@
     public static final int WORLD_INIT_CHECKED = 2;
     public final java.util.concurrent.atomic.AtomicInteger checkInitialised = new java.util.concurrent.atomic.AtomicInteger(WORLD_INIT_NOT_CHECKED);
     public ChunkPos randomSpawnSelection;
+    public volatile boolean isUnloading = false; // Canvas - fix world loading/unloading
+    public volatile java.util.concurrent.CompletableFuture<Boolean> unloadFuture = null; // Canvas - fix world loading/unloading - expand API
 
     public static final record PendingTeleport(Entity.EntityTreeNode rootVehicle, Vec3 to) {}
     private final it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<PendingTeleport> pendingTeleports = new it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet<>();
@@ -774,7 +_,8 @@
                     );
                 } // Folia end - region threading
             }
-
+            
+            if (dev.kaiijumc.kaiiju.KaiijuEntityLimits.enabled) regionizedWorldData.entityThrottler.tickLimiterStart(); // Kaiiju
             io.papermc.paper.entity.activation.ActivationRange.activateEntities(this); // Paper - EAR
             regionizedWorldData // Folia - regionised ticking
                 .forEachTickingEntity( // Folia - regionised ticking
@@ -792,6 +_,13 @@
 
                                         entity.stopRiding();
                                     }
+                                    // Kaiiju start
+                                    if (dev.kaiijumc.kaiiju.KaiijuEntityLimits.enabled) {
+                                        dev.kaiijumc.kaiiju.KaiijuEntityThrottler.EntityThrottlerReturn throttle = regionizedWorldData.entityThrottler.tickLimiterShouldSkip(entity);
+                                        if (throttle.remove && !entity.hasCustomName()) entity.remove(Entity.RemovalReason.DISCARDED);
+                                        if (throttle.skip) return;
+                                    }
+                                    // Kaiiju end
 
                                     this.guardEntityTick(this::tickNonPassenger, entity);
                                 }
@@ -799,6 +_,7 @@
                         }
                     }
                 );
+                if (dev.kaiijumc.kaiiju.KaiijuEntityLimits.enabled) regionizedWorldData.entityThrottler.tickLimiterFinish(regionizedWorldData); // Kaiiju
             this.tickBlockEntities();
         }
         // Paper - rewrite chunk system
@@ -883,10 +_,10 @@
     // Paper start - optimise random ticking
     private final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource.INSTANCE; // Folia - region threading
 
-    private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed) {
+    private void optimiseRandomTick(final LevelChunk chunk, final int tickSpeed, io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Canvas - optimize random tick
         final LevelChunkSection[] sections = chunk.getSections();
         final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection((ServerLevel)(Object)this);
-        final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Folia - region threading
+        // final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Folia - region threading // Canvas - optimize random tick
         final boolean doubleTickFluids = !ca.spottedleaf.moonrise.common.PlatformHooks.get().configFixMC224294();
 
         final ChunkPos cpos = chunk.getPos();
@@ -905,7 +_,7 @@
 
             for (int i = 0; i < tickSpeed; ++i) {
                 final int tickingBlocks = tickList.size();
-                final int index = simpleRandom.nextInt() & ((16 * 16 * 16) - 1);
+                final int index = worldData.simpleUnsafeLocalRandom.nextInt() & ((16 * 16 * 16) - 1); // Canvas - optimize random tick
 
                 if (index >= tickingBlocks) {
                     // most of the time we fall here
@@ -918,11 +_,11 @@
                 // do not use a mutable pos, as some random tick implementations store the input without calling immutable()!
                 final BlockPos pos = new BlockPos((location & 15) | offsetX, ((location >>> (4 + 4)) & 15) | offsetY, ((location >>> 4) & 15) | offsetZ);
 
-                state.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                state.randomTick(this, pos, worldData.simpleUnsafeLocalRandom); // Canvas - optimize random tick
                 if (doubleTickFluids) {
                     final FluidState fluidState = state.getFluidState();
                     if (fluidState.isRandomlyTicking()) {
-                        fluidState.randomTick((ServerLevel)(Object)this, pos, simpleRandom);
+                        fluidState.randomTick(this, pos, worldData.simpleUnsafeLocalRandom); // Canvas - optimize random tick
                     }
                 }
             }
@@ -931,23 +_,24 @@
         return;
     }
     // Paper end - optimise random ticking
-
-    public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
-        final io.papermc.paper.threadedregions.util.SimpleThreadLocalRandomSource simpleRandom = this.simpleRandom; // Paper - optimise random ticking // Folia - region threading
+    
+    public final io.canvasmc.canvas.util.FastBitRadixSort fastBitRadixSort = new io.canvasmc.canvas.util.FastBitRadixSort(); // Leaf - fast bit radix sort
+    
+    public void tickChunk(LevelChunk chunk, int randomTickSpeed, io.papermc.paper.threadedregions.RegionizedWorldData worldData) { // Canvas - optimize random tick
         ChunkPos pos = chunk.getPos();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
         for (int i = 0; i < randomTickSpeed; i++) {
-            if (simpleRandom.nextInt(48) == 0) {  // Paper - optimise random ticking
+            if (worldData.simpleUnsafeLocalRandom.nextInt(48) == 0) {  // Paper - optimise random ticking // Canvas - optimize random tick
                 this.tickPrecipitation(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             }
         }
         } // Paper - Option to disable ice and snow
 
         if (randomTickSpeed > 0) {
-            this.optimiseRandomTick(chunk, randomTickSpeed); // Paper - optimise random ticking
+            this.optimiseRandomTick(chunk, randomTickSpeed, worldData); // Paper - optimise random ticking // Canvas - optimize random tick
         }
     }
 
@@ -956,7 +_,7 @@
         boolean isRaining = this.isRaining();
         int minBlockX = pos.getMinBlockX();
         int minBlockZ = pos.getMinBlockZ();
-        if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
+        if (!this.paperConfig().environment.disableThunder && isRaining && this.isThundering() && this.spigotConfig.thunderChance > 0 && /*simpleRandom.nextInt(this.spigotConfig.thunderChance) == 0*/ chunk.shouldDoLightning(this.simpleRandom)) { // Spigot // Paper - Option to disable thunder // Paper - optimise random ticking // Pufferfish - replace random with shouldDoLightning
             BlockPos blockPos = this.findLightningTargetAround(this.getBlockRandomPos(minBlockX, 0, minBlockZ, 15));
             if (this.isRainingAt(blockPos)) {
                 DifficultyInstance currentDifficultyAt = this.getCurrentDifficultyAt(blockPos);
@@ -1103,7 +_,8 @@
     }
 
     public ServerWaypointManager getWaypointManager() {
-        return this.waypointManager;
+        if (io.canvasmc.canvas.Config.INSTANCE.disableWaypointsFix) return this.waypointManager; // Canvas - region threading - restore waypoints
+        return this.getCurrentWorldData().waypointManager; // Canvas - region threading - restore waypoints
     }
 
     public void advanceWeatherCycle() { // Folia - region threading - public
@@ -1285,7 +_,7 @@
         entity.tickCount++;
         entity.totalEntityAge++; // Paper - age-like counter for all entities
         final boolean isActive = io.papermc.paper.entity.activation.ActivationRange.checkIfActive(entity); // Paper - EAR 2
-        if (isActive) { // Paper - EAR 2
+        if (!(entity.getType().isDisabled() && (entity instanceof LivingEntity living && living.isAlive()))) if (isActive) { // Paper - EAR 2 // Canvas - non tickable entities config
         entity.tick();
         // Folia start - region threading
         if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(entity)) {
@@ -1316,8 +_,9 @@
             passengerEntity.setOldPosAndRot();
             passengerEntity.tickCount++;
             passengerEntity.totalEntityAge++; // Paper - age-like counter for all entities
+            boolean disabled = passengerEntity.getType().isDisabled() && (passengerEntity instanceof LivingEntity living && living.isAlive()); // Canvas - non tickable entities config
             // Paper start - EAR 2
-            if (isActive) {
+            if (isActive && !disabled) { // Canvas - non tickable entities config
             passengerEntity.rideTick();
             // Folia start - region threading
             if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(passengerEntity)) {
@@ -1331,7 +_,7 @@
             // Folia end - region threading
             } else {
                 passengerEntity.setDeltaMovement(Vec3.ZERO);
-                passengerEntity.inactiveTick();
+                if (!disabled) passengerEntity.inactiveTick(); // Canvas - non tickable entities config
                 // copied from inside of if (isPassenger()) of passengerTick, but that ifPassenger is unnecessary
                 ridingEntity.positionRider(passengerEntity);
             }
@@ -1610,7 +_,7 @@
 
     public void unload(LevelChunk chunk) {
         // Spigot start
-        for (net.minecraft.world.level.block.entity.BlockEntity blockEntity : chunk.getBlockEntities().values()) {
+        for (net.minecraft.world.level.block.entity.BlockEntity blockEntity : chunk.getAllBlockEntities()) { // Canvas - optimize block entity fetching
             if (blockEntity instanceof net.minecraft.world.Container) {
                 // Paper start - this area looks like it can load chunks, change the behavior
                 // chests for example can apply physics to the world
@@ -2414,6 +_,7 @@
 
         for (TickingBlockEntity tickingBlockEntity : (Iterable<? extends net.minecraft.world.level.block.entity.TickingBlockEntity>)null) { // Folia - region threading
             BlockPos pos = tickingBlockEntity.getPos();
+            if (tickingBlockEntity instanceof net.minecraft.world.level.chunk.LevelChunk.RebindableTickingBlockEntityWrapper rebindable && rebindable.ticker instanceof io.canvasmc.canvas.chunk.block.SleepingBlockEntity.SleepingTicker sleepingTicker) pos = sleepingTicker.getPosForRegionOperation(); // Canvas - block entity sleeping
             csvOutput.writeRow(pos.getX(), pos.getY(), pos.getZ(), tickingBlockEntity.getType());
         }
     }
@@ -2706,9 +_,7 @@
             // ServerLevel.this.getChunkSource().addEntity(entity); // Paper - ignore and warn about illegal addEntity calls instead of crashing server; moved down below valid=true
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.add(serverPlayer);
-                if (serverPlayer.isReceivingWaypoints()) {
-                    ServerLevel.this.getWaypointManager().addPlayer(serverPlayer);
-                }
+                // Canvas - region threading - restore waypoints - this is handled elsewhere
 
                 ServerLevel.this.updateSleepingPlayerList();
             }
@@ -2793,7 +_,7 @@
             ServerLevel.this.getChunkSource().removeEntity(entity);
             if (entity instanceof ServerPlayer serverPlayer) {
                 ServerLevel.this.players.remove(serverPlayer);
-                ServerLevel.this.getWaypointManager().removePlayer(serverPlayer);
+                // Canvas - region threading - restore waypoints - this is handled elsewhere
                 ServerLevel.this.updateSleepingPlayerList();
             }
 
