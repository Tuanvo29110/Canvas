--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -38,10 +_,11 @@
     public final Connection connection; // Paper
     private final boolean transferred;
     //private long keepAliveTime; // Paper - improve keepalives
-    //private boolean keepAlivePending; // Paper - improve keepalives
+    private boolean keepAlivePending; // Paper - improve keepalives
     //private long keepAliveChallenge; // Paper - improve keepalives
     private long closedListenerTime;
     private boolean closed = false;
+    private it.unimi.dsi.fastutil.longs.LongList keepAlives = new it.unimi.dsi.fastutil.longs.LongArrayList(); // Purpur - Alternative Keepalive Handling
     private volatile int latency; // Paper - improve keepalives - make volatile
     private final io.papermc.paper.util.KeepAlive keepAlive; // Paper - improve keepalives
     private volatile boolean suspendFlushingOnServerThread = false;
@@ -114,6 +_,18 @@
         // Paper start - improve keepalives
         long now = System.nanoTime();
         io.papermc.paper.util.KeepAlive.PendingKeepAlive pending = this.keepAlive.pendingKeepAlives.peek();
+        // Purpur start - Alternative Keepalive Handling
+        if (io.canvasmc.canvas.Config.INSTANCE.networking.useAlternateKeepAlive) {
+            if (this.keepAlivePending && !keepAlives.isEmpty() && keepAlives.contains(packet.getId())) {
+                int ping = (int) (Util.getMillis() - packet.getId());
+                int updatedLatency = (this.latency * 3 + ping) / 4;
+                this.latency = updatedLatency;
+                this.keepAlivePending = false;
+                keepAlives.clear(); // we got a valid response, lets roll with it and forget the rest
+            }
+            return;
+        } else
+        // Purpur end - Alternative Keepalive Handling
         if (pending != null && pending.challengeId() == packet.getId()) {
             this.keepAlive.pendingKeepAlives.remove(pending);
 
@@ -272,6 +_,23 @@
     public void keepConnectionAlive() {
         long millis = Util.getMillis();
         // Paper start - improve keepalives
+        // Purpur start - Alternative Keepalive Handling
+        if (io.canvasmc.canvas.Config.INSTANCE.networking.useAlternateKeepAlive) {
+            if (this.checkIfClosed(millis) && !this.processedDisconnect) {
+                long currTime = System.nanoTime();
+                if ((currTime - this.keepAlive.lastKeepAliveTx) >= java.util.concurrent.TimeUnit.SECONDS.toNanos(1L)) { // 1 second
+                    this.keepAlive.lastKeepAliveTx = currTime;
+                    if (this.keepAlivePending && !this.processedDisconnect && keepAlives.size() * 1000L >= KEEPALIVE_LIMIT) {
+                        this.disconnect(TIMEOUT_DISCONNECTION_MESSAGE, io.papermc.paper.connection.DisconnectionReason.TIMEOUT);
+                    } else if (this.checkIfClosed(millis)) {
+                        this.keepAlivePending = true;
+                        this.keepAlives.add(millis); // currentTime is ID
+                        this.send(new ClientboundKeepAlivePacket(millis));
+                    }
+                }
+            }
+        } else
+        // Purpur end - Alternative Keepalive Handling
         if (this.checkIfClosed(millis) && !this.processedDisconnect) {
             long currTime = System.nanoTime();
 
@@ -314,10 +_,47 @@
     }
 
     public void send(Packet<?> packet) {
+        // Canvas start - no chat reports
+        if (io.canvasmc.canvas.Config.INSTANCE.enableNoChatReports) {
+            Object self = this;
+            boolean cancel = false;
+
+            if (self instanceof ServerGamePacketListenerImpl listener
+                && packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerChatPacket chat) {
+                packet = new net.minecraft.network.protocol.game.ClientboundSystemChatPacket(chat.chatType().decorate(
+                    chat.unsignedContent() != null ? chat.unsignedContent()
+                        : Component.literal(chat.body().content())
+                ), false);
+
+                cancel = true;
+                listener.send(packet);
+            }
+
+            if (cancel) {
+                return;
+            }
+        }
+        // Canvas end - no chat reports
         this.send(packet, null);
     }
 
     public void send(Packet<?> packet, @Nullable ChannelFutureListener channelFutureListener) {
+        // Canvas start - no chat reports
+        if (io.canvasmc.canvas.Config.INSTANCE.enableNoChatReports) {
+            Object self = this;
+            boolean cancel = false;
+
+            if (self instanceof ServerGamePacketListenerImpl listenerImpl
+                && packet instanceof net.minecraft.network.protocol.game.ClientboundPlayerChatPacket chat && channelFutureListener != null) {
+                cancel = true;
+                listenerImpl.send(chat);
+            }
+
+            if (cancel) {
+                return;
+            }
+        }
+        // Canvas end - no chat reports
         // CraftBukkit start
         if (packet == null || this.processedDisconnect) { // Spigot
             return;
