--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -4,6 +_,7 @@
 import com.mojang.logging.LogUtils;
 import io.netty.channel.ChannelFutureListener;
 import javax.annotation.Nullable;
+import io.canvasmc.canvas.Config;
 import net.minecraft.CrashReport;
 import net.minecraft.CrashReportCategory;
 import net.minecraft.ReportedException;
@@ -23,10 +_,11 @@
 import net.minecraft.network.protocol.common.ServerboundPongPacket;
 import net.minecraft.network.protocol.common.ServerboundResourcePackPacket;
 import net.minecraft.network.protocol.cookie.ServerboundCookieResponsePacket;
+import net.minecraft.network.protocol.game.ClientboundPlayerChatPacket;
+import net.minecraft.network.protocol.game.ClientboundSystemChatPacket;
 import net.minecraft.server.MinecraftServer;
 import net.minecraft.server.level.ClientInformation;
 import net.minecraft.util.VisibleForDebug;
-import net.minecraft.util.profiling.Profiler;
 import org.slf4j.Logger;
 
 public abstract class ServerCommonPacketListenerImpl implements ServerCommonPacketListener {
@@ -190,7 +_,6 @@
     }
 
     protected void keepConnectionAlive() {
-        Profiler.get().push("keepAlive");
         long millis = Util.getMillis();
         // Paper start - improve keepalives
         // Purpur start - Alternative Keepalive Handling
@@ -228,8 +_,6 @@
                 // Paper end - improve keepalives
             }
         }
-
-        Profiler.get().pop();
     }
 
     private boolean checkIfClosed(long time) {
@@ -254,10 +_,64 @@
     }
 
     public void send(Packet<?> packet) {
+        // Canvas start - no chat reports
+        if (Config.INSTANCE.networking.noChatReports.enable) {
+            Object self = this;
+            boolean cancel = false;
+
+            if (self instanceof ServerGamePacketListenerImpl listener) {
+                if (Config.INSTANCE.networking.noChatReports.debugLog && packet instanceof ClientboundPlayerChatPacket chat) {
+                    MinecraftServer.LOGGER.info("Sending message: {}", chat.unsignedContent() != null ? chat.unsignedContent()
+                        : chat.body().content());
+                }
+
+                if (Config.INSTANCE.networking.noChatReports.convertToGameMessage) {
+                    if (packet instanceof ClientboundPlayerChatPacket chat) {
+                        packet = new ClientboundSystemChatPacket(chat.chatType().decorate(
+                            chat.unsignedContent() != null ? chat.unsignedContent()
+                                : Component.literal(chat.body().content())
+                        ), false);
+
+                        cancel = true;
+                        listener.send(packet);
+                    }
+                }
+            }
+
+            if (cancel) {
+                return;
+            }
+        }
+        // Canvas end
         this.send(packet, null);
     }
 
     public void send(Packet<?> packet, @Nullable ChannelFutureListener channelFutureListener) {
+        // Canvas start - no chat reports
+        if (Config.INSTANCE.networking.noChatReports.enable) {
+            Object self = this;
+            boolean cancel = false;
+
+            if (self instanceof ServerGamePacketListenerImpl listenerImpl) {
+                if (Config.INSTANCE.networking.noChatReports.debugLog && packet instanceof ClientboundPlayerChatPacket chat) {
+                    MinecraftServer.LOGGER.info("Sending message: {}", chat.unsignedContent() != null ? chat.unsignedContent()
+                        : chat.body().content());
+                }
+
+                if (Config.INSTANCE.networking.noChatReports.convertToGameMessage) {
+                    if (packet instanceof ClientboundPlayerChatPacket chat && channelFutureListener != null) {
+                        cancel = true;
+                        listenerImpl.send(chat);
+                    }
+                }
+
+            }
+
+            if (cancel) {
+                return;
+            }
+        }
+        // Canvas end
         // CraftBukkit start
         if (packet == null || this.processedDisconnect) { // Spigot
             return;
@@ -297,24 +_,13 @@
         if (this.processedDisconnect) {
             return;
         }
-        if (!this.cserver.isPrimaryThread()) {
-            org.bukkit.craftbukkit.util.Waitable waitable = new org.bukkit.craftbukkit.util.Waitable() {
-                @Override
-                protected Object evaluate() {
-                    ServerCommonPacketListenerImpl.this.disconnect(disconnectionDetails);
-                    return null;
-                }
-            };
-
-            this.server.processQueue.add(waitable);
-
-            try {
-                waitable.get();
-            } catch (InterruptedException e) {
-                Thread.currentThread().interrupt();
-            } catch (java.util.concurrent.ExecutionException e) {
-                throw new RuntimeException(e);
-            }
+        // Canvas start - Threaded Regions
+        if (!(this instanceof ServerGamePacketListenerImpl gamePacketListener)) {
+            throw new UnsupportedOperationException("Configuration mode is not supported in its current state");
+        }
+        // Canvas end
+        if (!io.canvasmc.canvas.region.ServerRegions.isTickThreadFor(gamePacketListener.player)) { // Canvas - connection threading
+            this.disconnectAsync(disconnectionDetails); // Canvas - connection threading
             return;
         }
 
@@ -368,7 +_,13 @@
         this.onDisconnect(disconnectionDetails);
         this.connection.setReadOnly();
         // CraftBukkit - Don't wait
-        this.server.scheduleOnMain(this.connection::handleDisconnection); // Paper
+        // Canvas start - Threaded Regions
+        int chunkX = this.connection.getPlayer().chunkPosition().x;
+        int chunkZ = this.connection.getPlayer().chunkPosition().z;
+        this.server.threadedServer().taskQueue.queueTickTaskQueue(
+            this.connection.getPlayer().serverLevel(), chunkX, chunkZ, this.connection::handleDisconnection
+        );
+        // Canvas end
     }
 
     // Paper start - add proper async disconnect
