--- a/net/minecraft/util/SimpleBitStorage.java
+++ b/net/minecraft/util/SimpleBitStorage.java
@@ -204,8 +_,8 @@
     private final long mask;
     private final int size;
     private final int valuesPerLong;
-    private final int divideMul; private final long divideMulUnsigned; // Paper - Perf: Optimize SimpleBitStorage; referenced in b(int) with 2 Integer.toUnsignedLong calls
-    private final int divideAdd; private final long divideAddUnsigned; // Paper - Perf: Optimize SimpleBitStorage
+    private final int divideMul; /*private final long divideMulUnsigned;*/ // Paper - Perf: Optimize SimpleBitStorage; referenced in b(int) with 2 Integer.toUnsignedLong calls // Leaf - optimize SimpleBitStorage object layout
+    private final int divideAdd; /*private final long divideAddUnsigned;*/ // Paper - Perf: Optimize SimpleBitStorage // Leaf - optimize SimpleBitStorage object layout
     private final int divideShift;
 
     // Paper start - optimise bitstorage read/write operations
@@ -262,8 +_,8 @@
         this.mask = (1L << bits) - 1L;
         this.valuesPerLong = (char)(64 / bits);
         int i = 3 * (this.valuesPerLong - 1);
-        this.divideMul = MAGIC[i + 0]; this.divideMulUnsigned = Integer.toUnsignedLong(this.divideMul); // Paper - Perf: Optimize SimpleBitStorage
-        this.divideAdd = MAGIC[i + 1]; this.divideAddUnsigned = Integer.toUnsignedLong(this.divideAdd); // Paper - Perf: Optimize SimpleBitStorage
+        this.divideMul = MAGIC[i + 0]; /*this.divideMulUnsigned = Integer.toUnsignedLong(this.divideMul);*/ // Paper - Perf: Optimize SimpleBitStorage // Leaf - optimize SimpleBitStorage object layout
+        this.divideAdd = MAGIC[i + 1]; /*this.divideAddUnsigned = Integer.toUnsignedLong(this.divideAdd);*/ // Paper - Perf: Optimize SimpleBitStorage // Leaf - optimize SimpleBitStorage object layout
         this.divideShift = MAGIC[i + 2];
         int i1 = (size + this.valuesPerLong - 1) / this.valuesPerLong;
         if (data != null) {
@@ -285,7 +_,7 @@
     }
 
     private int cellIndex(int index) {
-        return (int)(index * this.divideMulUnsigned + this.divideAddUnsigned >> 32 >> this.divideShift); // Paper - Perf: Optimize SimpleBitStorage
+        return (int)(index * Integer.toUnsignedLong(this.divideMul) + Integer.toUnsignedLong(this.divideAdd) >> 32 >> this.divideShift); // Paper - Perf: Optimize SimpleBitStorage // Leaf - optimize SimpleBitStorage object layout
     }
 
     @Override
@@ -465,4 +_,45 @@
             super(message);
         }
     }
+    // Leaf start - faster chunk serialization
+
+    @Override
+    public <T> void compact(net.minecraft.world.level.chunk.Palette<T> srcPalette, net.minecraft.world.level.chunk.Palette<T> dstPalette, short[] out) {
+        if (this.size >= Short.MAX_VALUE) {
+            throw new IllegalStateException("Array too large");
+        }
+
+        if (this.size != out.length) {
+            throw new IllegalStateException("Array size mismatch");
+        }
+
+        short[] mappings = new short[(int) (this.mask + 1)];
+
+        int idx = 0;
+
+        for (long word : this.data) {
+            long bits = word;
+
+            for (int elementIdx = 0; elementIdx < this.valuesPerLong; ++elementIdx) {
+                int value = (int) (bits & this.mask);
+                int remappedId = mappings[value];
+
+                if (remappedId == 0) {
+                    remappedId = dstPalette.idFor(srcPalette.valueFor(value)) + 1;
+                    mappings[value] = (short) remappedId;
+                }
+
+                out[idx] = (short) (remappedId - 1);
+                bits >>= this.bits;
+
+                ++idx;
+
+                if (idx >= this.size) {
+                    return;
+                }
+            }
+        }
+    }
+
+    // Leaf end - faster chunk serialization
 }
