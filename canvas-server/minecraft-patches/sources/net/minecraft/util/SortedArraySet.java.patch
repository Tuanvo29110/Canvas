--- a/net/minecraft/util/SortedArraySet.java
+++ b/net/minecraft/util/SortedArraySet.java
@@ -12,6 +_,7 @@
 public class SortedArraySet<T> extends AbstractSet<T> implements ca.spottedleaf.moonrise.patches.chunk_system.util.ChunkSystemSortedArraySet<T> { // Paper - rewrite chunk system
     private static final int DEFAULT_INITIAL_CAPACITY = 10;
     private final Comparator<T> comparator;
+    private final boolean isNaturalOrder; // Canvas - Improve sorting in SortedArraySet
     T[] contents;
     int size;
 
@@ -93,6 +_,7 @@
 
     private SortedArraySet(int initialCapacity, Comparator<T> comparator) {
         this.comparator = comparator;
+        this.isNaturalOrder = comparator == Comparator.naturalOrder(); // Canvas - Improve sorting in SortedArraySet
         if (initialCapacity < 0) {
             throw new IllegalArgumentException("Initial capacity (" + initialCapacity + ") is negative");
         } else {
@@ -121,9 +_,57 @@
     }
 
     private int findIndex(T object) {
-        return Arrays.binarySearch(this.contents, 0, this.size, object, this.comparator);
-    }
-
+    // Canvas start - Improve sorting in SortedArraySet
+        return isNaturalOrder ? naturalBinarySearch(object) : customBinarySearch(object);
+    }
+
+    private int naturalBinarySearch(T object) {
+        int low = 0;
+        int high = this.size - 1;
+        final Comparable<? super T> key = (Comparable<? super T>) object;
+        final T[] a = this.contents;
+
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            T midVal = a[mid];
+            int cmp = key.compareTo(midVal);
+
+            if (cmp < 0) {
+                high = mid - 1;
+            } else if (cmp > 0) {
+                low = mid + 1;
+            } else {
+                return mid;
+            }
+        }
+
+        return -(low + 1);
+    }
+
+    private int customBinarySearch(T object) {
+        int low = 0;
+        int high = this.size - 1;
+        final T[] a = this.contents;
+        final Comparator<T> c = this.comparator;
+
+        while (low <= high) {
+            int mid = (low + high) >>> 1;
+            T midVal = a[mid];
+            int cmp = c.compare(midVal, object);
+
+            if (cmp < 0) {
+                low = mid + 1;
+            } else if (cmp > 0) {
+                high = mid - 1;
+            } else {
+                return mid;
+            }
+        }
+
+        return -(low + 1);
+    }
+
+    // Canvas end - Improve sorting in SortedArraySet
     private static int getInsertionPosition(int index) {
         return -index - 1;
     }
