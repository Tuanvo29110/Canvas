From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Dueris <jedimastertoothless@hotmail.com>
Date: Fri, 4 Jul 2025 12:09:54 -0700
Subject: [PATCH] Rewrite Tick Scheduler


diff --git a/io/papermc/paper/threadedregions/RegionizedData.java b/io/papermc/paper/threadedregions/RegionizedData.java
index a1043c426d031755b57b77a9b2eec685e9861b13..85948d2ad7a1dc1045b7804a97cf991739188335 100644
--- a/io/papermc/paper/threadedregions/RegionizedData.java
+++ b/io/papermc/paper/threadedregions/RegionizedData.java
@@ -1,10 +1,12 @@
 package io.papermc.paper.threadedregions;
 
 import ca.spottedleaf.concurrentutil.util.Validate;
+import io.papermc.paper.threadedregions.TickRegions.TickRegionData;
 import it.unimi.dsi.fastutil.longs.Long2ReferenceOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
 import net.minecraft.server.level.ServerLevel;
 import javax.annotation.Nullable;
+import java.util.function.Function;
 import java.util.function.Supplier;
 
 /**
@@ -42,7 +44,7 @@ import java.util.function.Supplier;
  *             // callback is left out of this example
  *             // note: world != null here
  *             public final RegionizedData<EntityTickList> entityTickLists =
- *                 new RegionizedData<>(this, () -> new EntityTickList(), ...);
+ *                 new RegionizedData<>(this, (data) -> new EntityTickList(), ...); // Canvas - rewrite scheduler
  *
  *             public void addTickingEntity(Entity e) {
  *                 // What we expect here is that this world is the
@@ -86,7 +88,7 @@ import java.util.function.Supplier;
  *             // note: world == null here, because this RegionizedData object
  *             // is not instantiated per world, but rather globally.
  *             public final RegionizedData<TickTimes> tickTimes =
- *                  new RegionizedData<>(null, () -> new TickTimes(), ...);
+ *                  new RegionizedData<>(null, (data) -> new TickTimes(), ...); // Canvas - rewrite scheduler
  *         }
  *         }
  *     </pre>
@@ -97,7 +99,7 @@ import java.util.function.Supplier;
 public final class RegionizedData<T> {
 
     private final ServerLevel world;
-    private final Supplier<T> initialValueSupplier;
+    private final Function<TickRegionData ,T> initialValueSupplier; // Canvas - rewrite scheduler
     private final RegioniserCallback<T> callback;
 
     /**
@@ -119,14 +121,14 @@ public final class RegionizedData<T> {
      * @param supplier Initial value supplier used to lazy initialise region data.
      * @param callback Region callback to manage this regionised data.
      */
-    public RegionizedData(final ServerLevel world, final Supplier<T> supplier, final RegioniserCallback<T> callback) {
+    public RegionizedData(final ServerLevel world, final Function<TickRegionData,T> supplier, final RegioniserCallback<T> callback) { // Canvas - rewrite scheduler
         this.world = world;
         this.initialValueSupplier = Validate.notNull(supplier, "Supplier may not be null.");
         this.callback = Validate.notNull(callback, "Regioniser callback may not be null.");
     }
 
-    T createNewValue() {
-        return Validate.notNull(this.initialValueSupplier.get(), "Initial value supplier may not return null");
+    T createNewValue(final TickRegionData regionData) { // Canvas - rewrite scheduler
+        return Validate.notNull(this.initialValueSupplier.apply(regionData), "Initial value supplier may not return null"); // Canvas - rewrite scheduler
     }
 
     RegioniserCallback<T> getCallback() {
@@ -141,7 +143,7 @@ public final class RegionizedData<T> {
      *                               and the current ticking region's world does not match this {@code RegionizedData}'s world.
      */
     public @Nullable T get() {
-        final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region =
+        final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegions.TickRegionSectionData> region = // Canvas - rewrite scheduler
             TickRegionScheduler.getCurrentRegion();
 
         if (region == null) {
diff --git a/io/papermc/paper/threadedregions/RegionizedServer.java b/io/papermc/paper/threadedregions/RegionizedServer.java
index 8e91ec81128bdbd5f78e1f04fe17bcbd6e5dc280..dc7f6ab214732b27421df64ec36a0ebc141100dc 100644
--- a/io/papermc/paper/threadedregions/RegionizedServer.java
+++ b/io/papermc/paper/threadedregions/RegionizedServer.java
@@ -24,6 +24,7 @@ import org.slf4j.Logger;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
+import java.util.Set;
 import java.util.concurrent.CopyOnWriteArrayList;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.function.BooleanSupplier;
@@ -65,7 +66,7 @@ public final class RegionizedServer {
         // now we can schedule
         this.tickHandle.setInitialStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
         TickRegions.getScheduler().scheduleRegion(this.tickHandle);
-        TickRegions.getScheduler().init();
+        TickRegions.start(); // Canvas - rewrite scheduler
     }
 
     public void invalidateStatus() {
@@ -93,6 +94,17 @@ public final class RegionizedServer {
         return;
     }
 
+    // Canvas start - rewrite scheduler
+    private boolean hasAnyGlobalChunkTasks() {
+        for (final ServerLevel world : this.worlds) {
+            if (world.taskQueueRegionData.hasGlobalChunkTasks()) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    // Canvas end
     /**
      * Returns the current tick of the region ticking.
      * @throws IllegalStateException If there is no current region.
@@ -131,7 +143,7 @@ public final class RegionizedServer {
         private final AtomicBoolean ticking = new AtomicBoolean();
 
         public GlobalTickTickHandle(final RegionizedServer server) {
-            super(null, SchedulerThreadPool.DEADLINE_NOT_SET);
+            super(null, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET); // Canvas - rewrite scheduler
             this.server = server;
         }
 
@@ -177,20 +189,28 @@ public final class RegionizedServer {
             return true;
         }
 
+        // Canvas start - rewrite scheduler
+        private boolean runGlobalTask() {
+            boolean ret = false;
+            for (final ServerLevel world : this.server.worlds) {
+                ret |= world.taskQueueRegionData.executeGlobalChunkTask();
+            }
+            return ret;
+        }
+
         @Override
-        protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+        protected void runRegionTasks(final BooleanSupplier canContinue) {
             do {
-                if (!this.runOneTask()) {
-                    return false;
+                if (!this.runOneTask() || !this.runGlobalTask()) {
+                    return;
                 }
             } while (canContinue.getAsBoolean());
-
-            return true;
+        // Canvas end
         }
 
         @Override
         protected boolean hasIntermediateTasks() {
-            return !this.server.globalTickQueue.isEmpty();
+            return !this.server.globalTickQueue.isEmpty() || this.server.hasAnyGlobalChunkTasks(); // Canvas - rewrite scheduler
         }
     }
 
diff --git a/io/papermc/paper/threadedregions/RegionizedTaskQueue.java b/io/papermc/paper/threadedregions/RegionizedTaskQueue.java
index 2147f3647d47e9a45e0e3017026523ee0f355e48..811ba4fdfd3116182f492ebdc908f5b8832dfa56 100644
--- a/io/papermc/paper/threadedregions/RegionizedTaskQueue.java
+++ b/io/papermc/paper/threadedregions/RegionizedTaskQueue.java
@@ -80,7 +80,13 @@ public final class RegionizedTaskQueue {
             this.world = world;
         }
 
-        private boolean executeGlobalChunkTask() {
+        // Canvas start - rewrite scheduler
+        public boolean hasGlobalChunkTasks() {
+            return !this.globalChunkTask.isEmpty();
+        }
+
+        public boolean executeGlobalChunkTask() {
+        // Canvas end
             final Runnable run = this.globalChunkTask.poll();
             if (run != null) {
                 run.run();
@@ -95,6 +101,7 @@ public final class RegionizedTaskQueue {
 
         public void pushGlobalChunkTask(final Runnable run) {
             this.globalChunkTask.add(run);
+            TickRegions.getScheduler().setHasTasks(RegionizedServer.getGlobalTickData()); // Canvas - rewrite scheduler
         }
 
         private PrioritisedQueue getQueue(final boolean synchronise, final int chunkX, final int chunkZ, final boolean isChunkTask) {
@@ -217,12 +224,14 @@ public final class RegionizedTaskQueue {
     }
 
     public static final class RegionTaskQueueData {
-        private final PrioritisedQueue tickTaskQueue = new PrioritisedQueue();
-        private final PrioritisedQueue chunkQueue = new PrioritisedQueue();
+        private final PrioritisedQueue tickTaskQueue = new PrioritisedQueue(this); // Canvas - rewrite scheduler
+        private final PrioritisedQueue chunkQueue = new PrioritisedQueue(this); // Canvas - rewrite scheduler
         private final WorldRegionTaskData worldRegionTaskData;
+        private final TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
 
-        public RegionTaskQueueData(final WorldRegionTaskData worldRegionTaskData) {
+        public RegionTaskQueueData(final WorldRegionTaskData worldRegionTaskData, final TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
             this.worldRegionTaskData = worldRegionTaskData;
+            this.regionData = regionData; // Canvas - rewrite scheduler
         }
 
         void mergeInto(final RegionTaskQueueData into) {
@@ -282,6 +291,15 @@ public final class RegionizedTaskQueue {
                 this.queues[i] = new ArrayDeque<>();
             }
         }
+        // Canvas start - rewrite scheduler
+
+        private final RegionTaskQueueData queue;
+
+        private PrioritisedQueue(final RegionTaskQueueData queue) {
+            this.queue = queue;
+        }
+
+        // Canvas end
         private boolean isDestroyed;
 
         public int getScheduledTasks() {
@@ -610,6 +628,7 @@ public final class RegionizedTaskQueue {
                         continue;
                     }
 
+                    queue.queue.regionData.setHasTasks(); // Canvas - rewrite scheduler
                     // successfully queued
                     return true;
                 }
diff --git a/io/papermc/paper/threadedregions/RegionizedWorldData.java b/io/papermc/paper/threadedregions/RegionizedWorldData.java
index 01ea2e7133a41f1a75169c7e3edbd528b268412b..902ab28bc3487113063a9c8405a05816bd3c117c 100644
--- a/io/papermc/paper/threadedregions/RegionizedWorldData.java
+++ b/io/papermc/paper/threadedregions/RegionizedWorldData.java
@@ -82,6 +82,7 @@ public final class RegionizedWorldData {
             // entities
             for (final ServerPlayer player : from.localPlayers) {
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -181,6 +182,7 @@ public final class RegionizedWorldData {
                 // the chunk holder must _exist_, and so the region section exists.
                 final RegionizedWorldData into = regionToData.get(CoordinateUtils.getChunkKey(pos.x >> chunkToRegionShift, pos.z >> chunkToRegionShift));
                 into.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(into); // Canvas - rewrite scheduler
                 into.nearbyPlayers.addPlayer(player);
             }
             for (final Entity entity : from.allEntities) {
@@ -348,7 +350,8 @@ public final class RegionizedWorldData {
     }
 
     // entities
-    private final List<ServerPlayer> localPlayers = new ArrayList<>();
+    // this is copy on write to allow packet processing to iterate safely // Canvas - rewrite scheduler
+    private final java.util.concurrent.CopyOnWriteArrayList<ServerPlayer> localPlayers = new java.util.concurrent.CopyOnWriteArrayList<>(); // Canvas - rewrite scheduler
     private final NearbyPlayers nearbyPlayers;
     public final io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList entitySchedulerTickList = new io.papermc.paper.threadedregions.EntityScheduler.EntitySchedulerTickList();
     private final ReferenceList<Entity> allEntities = new ReferenceList<>(EMPTY_ENTITY_ARRAY);
@@ -447,7 +450,9 @@ public final class RegionizedWorldData {
     public final alternate.current.wire.WireHandler wireHandler;
     public final io.papermc.paper.redstone.RedstoneWireTurbo turbo;
 
-    public RegionizedWorldData(final ServerLevel world) {
+    public final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData; // Canvas - rewrite scheduler
+
+    public RegionizedWorldData(final ServerLevel world, final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) { // Canvas - rewrite scheduler
         this.world = world;
         this.blockLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, true);
         this.fluidLevelTicks = new LevelTicks<>(world::isPositionTickingWithEntitiesLoaded, world, false);
@@ -455,6 +460,7 @@ public final class RegionizedWorldData {
         this.nearbyPlayers = new NearbyPlayers(world);
         this.wireHandler = new alternate.current.wire.WireHandler(world);
         this.turbo = new io.papermc.paper.redstone.RedstoneWireTurbo((RedStoneWireBlock)Blocks.REDSTONE_WIRE);
+        this.regionData = regionData; // Canvas - rewrite scheduler
 
         // tasks may be drained before the region ticks, so we must set up the tick data early just in case
         this.updateTickData();
@@ -612,6 +618,7 @@ public final class RegionizedWorldData {
         if (this.allEntities.add(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.add(player);
+                player.getBukkitEntity().updateRegion(this); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
@@ -628,6 +635,7 @@ public final class RegionizedWorldData {
         if (this.allEntities.remove(entity)) {
             if (entity instanceof ServerPlayer player) {
                 this.localPlayers.remove(player);
+                player.getBukkitEntity().updateRegion(null); // Canvas - rewrite scheduler
             }
             TickRegions.RegionStats.updateCurrentRegion();
         }
diff --git a/io/papermc/paper/threadedregions/TickData.java b/io/papermc/paper/threadedregions/TickData.java
index d4d80a69488f57704f1b3dc74cb379de36e80ec0..85651f5a5a4ed6606a93e76b11c3aff2191a7e3f 100644
--- a/io/papermc/paper/threadedregions/TickData.java
+++ b/io/papermc/paper/threadedregions/TickData.java
@@ -20,6 +20,12 @@ public final class TickData {
     }
 
     public void addDataFrom(final TickRegionScheduler.TickTime time) {
+        // Canvas start - rewrite scheduler
+        if (!time.isTickExecution()) {
+            // TODO fix later
+            return;
+        }
+        // Canvas end
         final long start = time.tickStart();
 
         TickRegionScheduler.TickTime first;
diff --git a/io/papermc/paper/threadedregions/TickRegionScheduler.java b/io/papermc/paper/threadedregions/TickRegionScheduler.java
index fa6b8d756195c1b430cc11214a901bd42eebc98d..61a542ccb6a4b3f938c640529b9026aa18498214 100644
--- a/io/papermc/paper/threadedregions/TickRegionScheduler.java
+++ b/io/papermc/paper/threadedregions/TickRegionScheduler.java
@@ -41,10 +41,10 @@ public final class TickRegionScheduler {
     }
     // Folia end - watchdog
 
-    private final SchedulerThreadPool scheduler;
+    private final io.canvasmc.canvas.tick.ScheduledTaskThreadPool scheduler; // Canvas - rewrite scheduler
 
-    public TickRegionScheduler(final int threads) {
-        this.scheduler = new SchedulerThreadPool(threads, new ThreadFactory() {
+    public TickRegionScheduler() { // Canvas - rewrite scheduler
+        this.scheduler = new io.canvasmc.canvas.tick.ScheduledTaskThreadPool(new ThreadFactory() { // Canvas - rewrite scheduler
             private final AtomicInteger idGenerator = new AtomicInteger();
 
             @Override
@@ -53,11 +53,17 @@ public final class TickRegionScheduler {
                 ret.setUncaughtExceptionHandler(TickRegionScheduler.this::uncaughtException);
                 return ret;
             }
-        });
+    // Canvas start - rewrite scheduler
+        }, TimeUnit.MILLISECONDS.toNanos(3L), TimeUnit.MILLISECONDS.toNanos(2L));
+    }
+
+    public void setThreads(final int threads) {
+        this.scheduler.setCoreThreads(threads);
+    // Canvas end
     }
 
     public int getTotalThreadCount() {
-        return this.scheduler.getThreads().length;
+        return this.scheduler.getAliveThreads().length; // Canvas - rewrite scheduler
     }
 
     private static void setTickingRegion(final ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> region) {
@@ -84,7 +90,7 @@ public final class TickRegionScheduler {
         }
     }
 
-    private static void setTickTask(final SchedulerThreadPool.SchedulableTick task) {
+    private static void setTickTask(final io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task) { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             throw new IllegalStateException("Must be tick thread runner");
@@ -127,7 +133,7 @@ public final class TickRegionScheduler {
      * Returns the current ticking task, or {@code null} if there is no ticking region.
      * If this thread is not a TickThread, then returns {@code null}.
      */
-    public static SchedulerThreadPool.SchedulableTick getCurrentTickingTask() {
+    public static io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick getCurrentTickingTask() { // Canvas - rewrite scheduler
         final Thread currThread = Thread.currentThread();
         if (!(currThread instanceof TickThreadRunner tickThreadRunner)) {
             return null;
@@ -165,22 +171,21 @@ public final class TickRegionScheduler {
         region.markNonSchedulable();
     }
 
-    /**
-     * Updates the tick start to the farthest into the future of its current scheduled time and the
-     * provided time.
-     * @return {@code false} if the region was not scheduled or is currently ticking or the specified time is less-than its
-     *                       current start time, {@code true} if the next tick start was adjusted.
-     */
-    public boolean updateTickStartToMax(final RegionScheduleHandle region, final long newStart) {
-        return this.scheduler.updateTickStartToMax(region, newStart);
-    }
+    // Canvas - rewrite scheduler
 
     public boolean halt(final boolean sync, final long maxWaitNS) {
-        return this.scheduler.halt(sync, maxWaitNS);
+        // Canvas start - rewrite scheduler
+        this.scheduler.halt();
+        if (!sync) {
+            return this.scheduler.getAliveThreads().length == 0;
+        }
+
+        return this.scheduler.join(maxWaitNS == 0L ? 0L : Math.max(1L, TimeUnit.NANOSECONDS.toMillis(maxWaitNS)));
+        // Canvas end
     }
 
     void dumpAliveThreadTraces(final String reason) {
-        for (final Thread thread : this.scheduler.getThreads()) {
+        for (final Thread thread : this.scheduler.getAliveThreads()) { // Canvas - rewrite scheduler
             if (thread.isAlive()) {
                 TraceUtil.dumpTraceForThread(thread, reason);
             }
@@ -191,16 +196,14 @@ public final class TickRegionScheduler {
         this.scheduler.notifyTasks(region);
     }
 
-    public void init() {
-        this.scheduler.start();
-    }
+    // Canvas - rewrite scheduler
 
     private void uncaughtException(final Thread thread, final Throwable thr) {
         LOGGER.error("Uncaught exception in tick thread \"" + thread.getName() + "\"", thr);
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        this.scheduler.halt(); // Canvas - rewrite scheduler
 
         MinecraftServer.getServer().stopServer();
     }
@@ -210,7 +213,7 @@ public final class TickRegionScheduler {
 
         // prevent further ticks from occurring
         // we CANNOT sync, because WE ARE ON A SCHEDULER THREAD
-        this.scheduler.halt(false, 0L);
+        this.scheduler.halt(); // Canvas - rewrite scheduler
 
         final ChunkPos center = handle.region == null ? null : handle.region.region.getCenterChunk();
         final ServerLevel world = handle.region == null ? null : handle.region.world;
@@ -226,7 +229,7 @@ public final class TickRegionScheduler {
 
         private ThreadedRegionizer.ThreadedRegion<TickRegions.TickRegionData, TickRegions.TickRegionSectionData> currentTickingRegion;
         private RegionizedWorldData currentTickingWorldRegionizedData;
-        private SchedulerThreadPool.SchedulableTick currentTickingTask;
+        private io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick currentTickingTask; // Canvas - rewrite scheduler
         // Folia start - profiler
         private ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle.NO_OP_HANDLE;
         // Folia end - profiler
@@ -236,7 +239,7 @@ public final class TickRegionScheduler {
         }
     }
 
-    public static abstract class RegionScheduleHandle extends SchedulerThreadPool.SchedulableTick {
+    public static abstract class RegionScheduleHandle extends io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick { // Canvas - rewrite scheduler
 
         protected long currentTick;
         protected long lastTickStart;
@@ -258,7 +261,7 @@ public final class TickRegionScheduler {
 
         public RegionScheduleHandle(final TickRegions.TickRegionData region, final long firstStart) {
             this.currentTick = 0L;
-            this.lastTickStart = SchedulerThreadPool.DEADLINE_NOT_SET;
+            this.lastTickStart = io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
             this.tickTimes5s = new TickData(TimeUnit.SECONDS.toNanos(5L));
             this.tickTimes15s = new TickData(TimeUnit.SECONDS.toNanos(15L));
             this.tickTimes1m = new TickData(TimeUnit.MINUTES.toNanos(1L));
@@ -267,16 +270,16 @@ public final class TickRegionScheduler {
             this.region = region;
 
             this.setScheduledStart(firstStart);
-            this.tickSchedule = new Schedule(firstStart == SchedulerThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS);
+            this.tickSchedule = new Schedule(firstStart == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? firstStart : firstStart - TIME_BETWEEN_TICKS); // Canvas - rewrite scheduler
         }
 
         /**
-         * Subclasses should call this instead of {@link ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick#setScheduledStart(long)}
+         * Subclasses should call this instead of {@link #setScheduledStart(long)} // Canvas - rewrite scheduler
          * so that the tick schedule and scheduled start remain synchronised
          */
         protected final void updateScheduledStart(final long to) {
             this.setScheduledStart(to);
-            this.tickSchedule.setLastPeriod(to == SchedulerThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS);
+            this.tickSchedule.setLastPeriod(to == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET ? to : to - TIME_BETWEEN_TICKS); // Canvas - rewrite scheduler
         }
 
         public final void markNonSchedulable() {
@@ -293,7 +296,7 @@ public final class TickRegionScheduler {
 
         protected abstract void tickRegion(final int tickCount, final long startTime, final long scheduledEnd);
 
-        protected abstract boolean runRegionTasks(final BooleanSupplier canContinue);
+        protected abstract void runRegionTasks(final BooleanSupplier canContinue); // Canvas - rewrite scheduler
 
         protected abstract boolean hasIntermediateTasks();
 
@@ -303,9 +306,9 @@ public final class TickRegionScheduler {
         }
 
         @Override
-        public final Boolean runTasks(final BooleanSupplier canContinue) {
+        public final boolean runTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             if (this.cancelled.get()) {
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             final long cpuStart = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
@@ -316,7 +319,7 @@ public final class TickRegionScheduler {
                     throw new IllegalStateException("Scheduled region should be acquirable");
                 }
                 // region was killed
-                return null;
+                return false; // Canvas - rewrite scheduler
             }
 
             TickRegionScheduler.setTickTask(this);
@@ -326,8 +329,8 @@ public final class TickRegionScheduler {
 
             synchronized (this) {
                 this.currentTickData = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, tickStart, cpuStart, // Canvas - rewrite scheduler
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     false
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -337,20 +340,20 @@ public final class TickRegionScheduler {
             final FoliaWatchdogThread.RunningTick runningTick = new FoliaWatchdogThread.RunningTick(tickStart, this, Thread.currentThread()); // Folia - watchdog
             WATCHDOG_THREAD.addTick(runningTick); // Folia - watchdog
             try {
-                ret = this.runRegionTasks(() -> {
+                this.runRegionTasks(() -> { // Canvas - rewrite scheduler
                     return !RegionScheduleHandle.this.cancelled.get() && canContinue.getAsBoolean();
                 });
             } catch (final Throwable thr) {
                 this.scheduler.regionFailed(this, true, thr);
                 // don't release region for another tick
-                return null;
+                return false; // Canvas - rewrite scheduler
             } finally {
                 WATCHDOG_THREAD.removeTick(runningTick); // Folia - watchdog
                 final long tickEnd = System.nanoTime();
                 final long cpuEnd = MEASURE_CPU_TIME ? THREAD_MX_BEAN.getCurrentThreadCpuTime() : 0L;
 
                 final TickTime time = new TickTime(
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, // Canvas - rewrite scheduler
                     tickStart, cpuStart, tickEnd, cpuEnd, MEASURE_CPU_TIME, false
                 );
 
@@ -361,7 +364,7 @@ public final class TickRegionScheduler {
                 }
             }
 
-            return !this.markNotTicking() || this.cancelled.get() ? null : Boolean.valueOf(ret);
+            return this.markNotTicking() && !this.cancelled.get(); // Canvas - rewrite scheduler
         }
 
         @Override
@@ -405,7 +408,7 @@ public final class TickRegionScheduler {
             synchronized (this) {
                 this.currentTickData = new TickTime(
                     lastTickStart, scheduledStart, tickStart, cpuStart,
-                    SchedulerThreadPool.DEADLINE_NOT_SET, SchedulerThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME,
+                    io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET, MEASURE_CPU_TIME, // Canvas - rewrite scheduler
                     true
                 );
                 this.currentTickingThread = Thread.currentThread();
@@ -582,7 +585,7 @@ public final class TickRegionScheduler {
          * Only valid when {@link #isTickExecution()} is {@code true}.
          */
         public boolean hasLastTick() {
-            return this.previousTickStart != SchedulerThreadPool.DEADLINE_NOT_SET;
+            return this.previousTickStart != io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET; // Canvas - rewrite scheduler
         }
 
         /*
diff --git a/io/papermc/paper/threadedregions/TickRegions.java b/io/papermc/paper/threadedregions/TickRegions.java
index 988fe74578065c9464f5639e5cc6af79619edef5..ba936695ab16133787b9fb5d52ff794387beaf75 100644
--- a/io/papermc/paper/threadedregions/TickRegions.java
+++ b/io/papermc/paper/threadedregions/TickRegions.java
@@ -45,6 +45,13 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         gridExponent = Math.min(31, gridExponent);
         regionShift = gridExponent;
 
+    // Canvas start - rewrite scheduler
+        scheduler = new TickRegionScheduler();
+    }
+
+    public static void start() {
+        final GlobalConfiguration.ThreadedRegions config = GlobalConfiguration.get().threadedRegions;
+    // Canvas end
         int tickThreads;
         if (config.threads <= 0) {
             tickThreads = Runtime.getRuntime().availableProcessors() / 2;
@@ -57,7 +64,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             tickThreads = config.threads;
         }
 
-        scheduler = new TickRegionScheduler(tickThreads);
+        scheduler.setThreads(tickThreads); // Canvas - rewrite scheduler
         LOGGER.info("Regionised ticking is enabled with " + tickThreads + " tick threads");
     }
 
@@ -171,7 +178,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         private final Reference2ReferenceOpenHashMap<RegionizedData<?>, Object> regionizedData = new Reference2ReferenceOpenHashMap<>();
 
         // tick data
-        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, SchedulerThreadPool.DEADLINE_NOT_SET);
+        private ConcreteRegionTickHandle tickHandle = new ConcreteRegionTickHandle(this, io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET); // Canvas - rewrite scheduler
 
         // queue data
         private final RegionizedTaskQueue.RegionTaskQueueData taskQueueData;
@@ -182,15 +189,64 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         // async-safe read-only region data
         private final RegionStats regionStats;
 
+        private final java.util.concurrent.atomic.AtomicBoolean hasPackets = new java.util.concurrent.atomic.AtomicBoolean(false); // Canvas - rewrite scheduler
         public volatile ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler; // Folia - profiler
 
         private TickRegionData(final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region) {
             this.region = region;
             this.world = region.regioniser.world;
-            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData);
+            this.taskQueueData = new RegionizedTaskQueue.RegionTaskQueueData(this.world.taskQueueRegionData, this); // Canvas - rewrite scheduler
             this.regionStats = new RegionStats();
         }
 
+        // Canvas start - rewrite scheduler
+        public void setHasTasks() {
+            TickRegions.getScheduler().setHasTasks(this.tickHandle);
+        }
+
+        public void setHasPackets() {
+            if (!this.hasPackets.get() && !this.hasPackets.compareAndExchange(false, true)) {
+                this.setHasTasks();
+            }
+        }
+
+        public boolean drainOnePacket() {
+            if (!this.hasPackets.get()) {
+                return false;
+            }
+
+            final RegionizedWorldData worldData = this.world.getCurrentWorldData();
+            boolean hasPacketsNew = false;
+
+            for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                if (!ca.spottedleaf.moonrise.common.util.TickThread.isTickThreadFor(player)) {
+                    continue;
+                }
+                if (player.getBukkitEntity().executeOnePacket()) {
+                    hasPacketsNew |= player.getBukkitEntity().hasPackets();
+                }
+            }
+
+            if (!hasPacketsNew) {
+                this.hasPackets.set(false);
+
+                // handle race condition: packet added during packet processing
+                for (final net.minecraft.server.level.ServerPlayer player : worldData.getLocalPlayers()) {
+                    if (player.getBukkitEntity().hasPackets()) {
+                        this.hasPackets.set(true);
+                        break;
+                    }
+                }
+            }
+
+            return true;
+        }
+
+        public void drainPackets() {
+            while (this.drainOnePacket());
+        }
+
+        // Canvas end
         public RegionStats getRegionStats() {
             return this.regionStats;
         }
@@ -224,7 +280,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
                 return ret;
             }
 
-            ret = regionizedData.createNewValue();
+            ret = regionizedData.createNewValue(this); // Canvas - rewrite scheduler
             this.regionizedData.put(regionizedData, ret);
 
             return ret;
@@ -242,6 +298,12 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             for (final ThreadedRegionizer.ThreadedRegion<TickRegionData, TickRegionSectionData> region : regions) {
                 final TickRegionData data = region.getData();
                 data.tickHandle.copyDeadlineAndTickCount(this.tickHandle);
+                // Canvas start - rewrite scheduler
+                // just be lazy about this one, it's not very important
+                if (this.hasPackets.getOpaque()) {
+                    data.hasPackets.setOpaque(true);
+                }
+                // Canvas end
             }
 
             // generic regionised data
@@ -309,6 +371,12 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
             // there's not really a great solution to the tick problem, no matter what it'll be messed up
             // we will pick the greatest time delay so that tps will not exceed TICK_RATE
             data.tickHandle.updateSchedulingToMax(this.tickHandle);
+            // Canvas start - rewrite scheduler
+            // just be lazy about this one, it's not very important
+            if (this.hasPackets.getOpaque()) {
+                data.hasPackets.setOpaque(true);
+            }
+            // Canvas end
 
             // generic regionised data
             final long fromTickOffset = currentTickTo - currentTickFrom; // see merge jd
@@ -350,11 +418,11 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         }
 
         private void updateSchedulingToMax(final ConcreteRegionTickHandle from) {
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(from.getScheduledStart());
                 return;
             }
@@ -365,7 +433,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         private void copyDeadlineAndTickCount(final ConcreteRegionTickHandle from) {
             this.currentTick = from.currentTick;
 
-            if (from.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (from.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 return;
             }
 
@@ -374,7 +442,7 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         }
 
         private void checkInitialSchedule() {
-            if (this.getScheduledStart() == SchedulerThreadPool.DEADLINE_NOT_SET) {
+            if (this.getScheduledStart() == io.canvasmc.canvas.tick.ScheduledTaskThreadPool.DEADLINE_NOT_SET) { // Canvas - rewrite scheduler
                 this.updateScheduledStart(System.nanoTime() + TickRegionScheduler.TIME_BETWEEN_TICKS);
             }
         }
@@ -409,35 +477,37 @@ public final class TickRegions implements ThreadedRegionizer.RegionCallbacks<Tic
         }
 
         @Override
-        protected boolean runRegionTasks(final BooleanSupplier canContinue) {
+        protected void runRegionTasks(final BooleanSupplier canContinue) { // Canvas - rewrite scheduler
             final ca.spottedleaf.leafprofiler.RegionizedProfiler.Handle profiler = io.papermc.paper.threadedregions.TickRegionScheduler.getProfiler(); // Folia start - profiler
             profiler.startInBetweenTick(); try { // Folia - profiler
             final RegionizedTaskQueue.RegionTaskQueueData queue = this.region.taskQueueData;
 
             boolean processedChunkTask = false;
 
-            boolean executeChunkTask = true;
-            boolean executeTickTask = true;
+            // Canvas start - rewrite scheduler
+            boolean executeChunkTask;
+            boolean executeTickTask;
+            boolean executePacketTask;
             do {
-                if (executeTickTask) {
-                    executeTickTask = queue.executeTickTask();
-                }
-                if (executeChunkTask) {
-                    processedChunkTask |= (executeChunkTask = queue.executeChunkTask());
-                }
-            } while ((executeChunkTask | executeTickTask) && canContinue.getAsBoolean());
+                executeTickTask = queue.executeTickTask();
+                executeChunkTask = queue.executeChunkTask();
+                executePacketTask = this.region.drainOnePacket();
+
+                processedChunkTask |= executeChunkTask;
+            } while ((executeChunkTask | executeTickTask | executePacketTask) && canContinue.getAsBoolean());
+            // Canvas end
 
             if (processedChunkTask) {
                 // if we processed any chunk tasks, try to process ticket level updates for full status changes
                 this.region.world.moonrise$getChunkTaskScheduler().chunkHolderManager.processTicketUpdates();
             }
-            return true;
+            // Canvas - rewrite scheduler
             } finally { profiler.stopInBetweenTick(); } // Folia - profiler
         }
 
         @Override
         protected boolean hasIntermediateTasks() {
-            return this.region.taskQueueData.hasTasks();
+            return this.region.taskQueueData.hasTasks() || this.region.hasPackets.get(); // Canvas - rewrite scheduler
         }
     }
 
diff --git a/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java b/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
index 81cdbcf00efca209b0567ea10d54d1a3add681d7..81d892046f69778ee2bc3c169b27e170aeb0023a 100644
--- a/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
+++ b/io/papermc/paper/threadedregions/scheduler/FoliaRegionScheduler.java
@@ -143,6 +143,10 @@ public final class FoliaRegionScheduler implements RegionScheduler {
     }
 
     private static final class Scheduler {
+        // Canvas start - rewrite scheduler
+        private Scheduler(final io.papermc.paper.threadedregions.TickRegions.TickRegionData regionData) {}
+
+        // Canvas end
         private static final RegionizedData.RegioniserCallback<Scheduler> REGIONISER_CALLBACK = new RegionizedData.RegioniserCallback<>() {
             @Override
             public void merge(final Scheduler from, final Scheduler into, final long fromTickOffset) {
diff --git a/net/minecraft/network/protocol/PacketUtils.java b/net/minecraft/network/protocol/PacketUtils.java
index 7280ca2250ade4166a1a883b205bbc89f4e00d1a..9efa4b1f55bd3a333cdbd770534ad35ee2385ab3 100644
--- a/net/minecraft/network/protocol/PacketUtils.java
+++ b/net/minecraft/network/protocol/PacketUtils.java
@@ -50,7 +50,7 @@ public class PacketUtils {
             };
             // ignore retired state, if removed then we don't want the packet to be handled
             if (processor instanceof net.minecraft.server.network.ServerGamePacketListenerImpl gamePacketListener) {
-                gamePacketListener.player.queuePacketTask(run);
+                gamePacketListener.player.getBukkitEntity().addPacket(run); // Canvas - rewrite scheduler
             } else if (processor instanceof net.minecraft.server.network.ServerConfigurationPacketListenerImpl configurationPacketListener) {
                 io.papermc.paper.threadedregions.RegionizedServer.getInstance().addTask(run);
             } else if (processor instanceof net.minecraft.server.network.ServerLoginPacketListenerImpl loginPacketListener) {
diff --git a/net/minecraft/server/MinecraftServer.java b/net/minecraft/server/MinecraftServer.java
index 8e69876debfdbab3965fb93fe79d1125f4f21636..0f0c07c80d0e744d906a3c935214d0383f7dffbb 100644
--- a/net/minecraft/server/MinecraftServer.java
+++ b/net/minecraft/server/MinecraftServer.java
@@ -1647,6 +1647,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
             ((io.papermc.paper.threadedregions.scheduler.FoliaRegionScheduler)org.bukkit.Bukkit.getRegionScheduler()).tick();
             } finally { foliaProfiler.stopTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.PLUGIN_TICK_TASKS); } // Folia - profiler
             // now run all the entity schedulers
+            region.drainPackets(); // Canvas - rewrite scheduler
             long tickedEntitySchedulers = 0L; // Folia - profiler
             foliaProfiler.startTimer(ca.spottedleaf.leafprofiler.LProfilerRegistry.ENTITY_SCHEDULER_TICK); try { // Folia - profiler
             for (io.papermc.paper.threadedregions.EntityScheduler scheduler : region.world.getCurrentWorldData().entitySchedulerTickList.getAllSchedulers()) {
diff --git a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
index 28c4a7bcb73946d37ed57c6f76d27ba019554c98..17f02e52d14952262131f9d1ed3f116998996544 100644
--- a/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
+++ b/net/minecraft/server/network/ServerCommonPacketListenerImpl.java
@@ -97,6 +97,7 @@ public abstract class ServerCommonPacketListenerImpl implements ServerCommonPack
             throw new UnsupportedOperationException("Configuration mode is not supported in its current state");
         }
         gamePacketListener.player.getBukkitEntity().taskScheduler.retire();
+        gamePacketListener.player.getBukkitEntity().stopAcceptingPackets(); // Canvas - rewrite scheduler
         // Folia end - region threading
     }
 
diff --git a/net/minecraft/world/level/Level.java b/net/minecraft/world/level/Level.java
index 5fe048ce442957a534d44454e0bb908afe8ad3a6..750fec4dff3bf6f2ed26c0ae415f5ed73688e82b 100644
--- a/net/minecraft/world/level/Level.java
+++ b/net/minecraft/world/level/Level.java
@@ -808,7 +808,7 @@ public abstract class Level implements LevelAccessor, UUIDLookup<Entity>, AutoCl
     // Folia start - region ticking
     public final io.papermc.paper.threadedregions.RegionizedData<io.papermc.paper.threadedregions.RegionizedWorldData> worldRegionData
         = new io.papermc.paper.threadedregions.RegionizedData<>(
-        (ServerLevel)this, () -> new io.papermc.paper.threadedregions.RegionizedWorldData((ServerLevel)Level.this),
+        (ServerLevel)this, (regionData) -> new io.papermc.paper.threadedregions.RegionizedWorldData((ServerLevel)Level.this, regionData), // Canvas - rewrite scheduler
         io.papermc.paper.threadedregions.RegionizedWorldData.REGION_CALLBACK
     );
     public volatile io.papermc.paper.threadedregions.RegionizedServer.WorldLevelData tickData;
