--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -286,7 +_,7 @@
     private final StructureManager structureManager;
     final DedicatedServer console;
     private final DedicatedPlayerList playerList;
-    private final Map<String, World> worlds = new LinkedHashMap<>();
+    public final Map<String, World> worlds = it.unimi.dsi.fastutil.objects.Object2ObjectMaps.synchronize(new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>()); // Canvas - private -> public - fastutil - synchronized
     private YamlConfiguration configuration;
     private YamlConfiguration commandsConfiguration;
     private final Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
@@ -1276,7 +_,6 @@
 
     @Override
     public World createWorld(WorldCreator creator) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         Preconditions.checkState(this.console.getAllLevels().iterator().hasNext(), "Cannot create additional worlds on STARTUP");
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot create a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
@@ -1455,7 +_,20 @@
         }
 
         this.console.addLevel(serverLevel); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas start - fix world loading/unloading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(serverLevel);
+        int loadRegionRadius = 1024 >> 4;
+        serverLevel.randomSpawnSelection = new net.minecraft.world.level.ChunkPos(serverLevel.getChunkSource().randomState().sampler().findSpawnPosition());
+        for (int currX = -loadRegionRadius; currX <= loadRegionRadius; ++currX) {
+            for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
+                net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(currX, currZ);
+                serverLevel.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                    net.minecraft.server.level.TicketType.UNKNOWN, pos, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, null
+                );
+            }
+        }
+        // this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas end
 
         serverLevel.setSpawnSettings(true);
         // Paper - Put world into worldlist before initing the world; move up
@@ -1474,13 +_,13 @@
 
     @Override
     public boolean unloadWorld(World world, boolean save) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot unload a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         if (world == null) {
             return false;
         }
 
         ServerLevel handle = ((CraftWorld) world).getHandle();
+        if (handle.isUnloading) return false; // Canvas - fix world loading/unloading - we are already unloading
 
         if (this.console.getLevel(handle.dimension()) == null) {
             return false;
@@ -1500,19 +_,19 @@
         }
 
         try {
-            if (save) {
-                handle.save(null, true, false); // Paper - Fix saving in unloadWorld
-            }
+            // Canvas start - fix world loading/unloading
+            if (this.console.hasStartedShutdownThread.get()) return false; // don't unload during shutdown
+            MinecraftServer.LOGGER.info("Beginning unload for World '" + world.getName() + "'");
+            handle.isUnloading = true;
+            // moved to regions
 
-            handle.getChunkSource().close(save);
-            io.papermc.paper.FeatureHooks.closeEntityManager(handle, save); // SPIGOT-6722: close entityManager // Paper - chunk system
-            handle.levelStorageAccess.close();
+            // moved to global tick
+            // Canvas end
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
 
-        this.worlds.remove(world.getName().toLowerCase(Locale.ROOT));
-        this.console.removeLevel(handle);
+        // Canvas - fix world loading/unloading - moved to global tick
         return true;
     }
 
@@ -3025,7 +_,7 @@
     @Override
     public double getAverageTickTime() {
         // Folia start - region threading
-        ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask();
+        io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask(); // Canvas - rewrite scheduler
         if (task == null) {
             // might be on the shutdown thread, try retrieving the current region
             if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion() != null) {
@@ -3110,7 +_,7 @@
     @Override
     public double[] getTPS() {
         // Folia start - region threading
-        ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask();
+        io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask(); // Canvas - rewrite scheduler
         if (task == null) {
             // might be on the shutdown thread, try retrieving the current region
             if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion() != null) {
@@ -3379,6 +_,27 @@
 
         return getTPSFromRegion(((CraftWorld)world).getHandle(), chunkX, chunkZ);
     }
+    // Canvas start - expand region api
+
+    /**
+     * Returns the region on the current thraed, or null if we are on the global tick thread
+     * <br>
+     * This will throw if not on a tick runner
+     * @return the current region
+     */
+    @Override
+    public @Nullable io.canvasmc.canvas.threadedregions.WorldRegionData getCurrentRegion() {
+        io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
+            region = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            return null;
+        } else {
+            io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = region.regioniser.world.worldRegionData.get();
+            if (regionizedWorldData == null) return null;
+            return regionizedWorldData.apiHandle;
+        }
+    }
+    // Canvas end
 
     private static double[] getTPSFromRegion(ServerLevel world, int chunkX, int chunkZ) {
         io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
