--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -286,7 +_,7 @@
     private final StructureManager structureManager;
     final DedicatedServer console;
     private final DedicatedPlayerList playerList;
-    private final Map<String, World> worlds = new LinkedHashMap<>();
+    public final Map<String, World> worlds = it.unimi.dsi.fastutil.objects.Object2ObjectMaps.synchronize(new it.unimi.dsi.fastutil.objects.Object2ObjectLinkedOpenHashMap<>()); // Canvas - private -> public - fastutil - synchronized
     private YamlConfiguration configuration;
     private YamlConfiguration commandsConfiguration;
     private final Yaml yaml = new Yaml(new SafeConstructor(new LoaderOptions()));
@@ -1259,7 +_,6 @@
 
     @Override
     public World createWorld(WorldCreator creator) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
         Preconditions.checkState(this.console.getAllLevels().iterator().hasNext(), "Cannot create additional worlds on STARTUP");
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot create a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         Preconditions.checkArgument(creator != null, "WorldCreator cannot be null");
@@ -1438,7 +_,20 @@
         }
 
         this.console.addLevel(serverLevel); // Paper - Put world into worldlist before initing the world; move up
-        this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas start - fix world loading/unloading
+        io.papermc.paper.threadedregions.RegionizedServer.getInstance().addWorld(serverLevel);
+        int loadRegionRadius = 1024 >> 4;
+        serverLevel.randomSpawnSelection = new net.minecraft.world.level.ChunkPos(serverLevel.getChunkSource().randomState().sampler().findSpawnPosition());
+        for (int currX = -loadRegionRadius; currX <= loadRegionRadius; ++currX) {
+            for (int currZ = -loadRegionRadius; currZ <= loadRegionRadius; ++currZ) {
+                net.minecraft.world.level.ChunkPos pos = new net.minecraft.world.level.ChunkPos(currX, currZ);
+                serverLevel.moonrise$getChunkTaskScheduler().chunkHolderManager.addTicketAtLevel(
+                    net.minecraft.server.level.TicketType.UNKNOWN, pos, ca.spottedleaf.moonrise.patches.chunk_system.scheduling.ChunkHolderManager.MAX_TICKET_LEVEL, null
+                );
+            }
+        }
+        // this.console.initWorld(serverLevel, primaryLevelData, primaryLevelData, primaryLevelData.worldGenOptions());
+        // Canvas end - fix world loading/unloading
 
         serverLevel.setSpawnSettings(true);
         // Paper - Put world into worldlist before initing the world; move up
@@ -1451,53 +_,79 @@
     }
 
     @Override
-    public boolean unloadWorld(String name, boolean save) {
-        return this.unloadWorld(this.getWorld(name), save);
+    public java.util.concurrent.CompletableFuture<Boolean> unloadWorldAsync(@NotNull String name, boolean save) { // Canvas - fix world loading/unloading - expand API
+        return this.unloadWorldAsync(this.getWorld(name), save); // Canvas - fix world loading/unloading - expand API
     }
 
     @Override
-    public boolean unloadWorld(World world, boolean save) {
-        if (true) throw new UnsupportedOperationException(); // Folia - not implemented properly yet
+    public java.util.concurrent.CompletableFuture<Boolean> unloadWorldAsync(@NotNull World world, boolean save) { // Canvas - fix world loading/unloading - expand API
+        java.util.concurrent.CompletableFuture<Boolean> future = new java.util.concurrent.CompletableFuture<>(); // Canvas - fix world loading/unloading - expand API
         //Preconditions.checkState(!this.console.isIteratingOverLevels, "Cannot unload a world while worlds are being ticked"); // Paper - Cat - Temp disable. We'll see how this goes.
         if (world == null) {
-            return false;
+            return complete(false, future); // Canvas - fix world loading/unloading - expand API
         }
 
         ServerLevel handle = ((CraftWorld) world).getHandle();
+        if (handle.isUnloading) return complete(false, future); // Canvas - fix world loading/unloading - we are already unloading - expand API
 
         if (this.console.getLevel(handle.dimension()) == null) {
-            return false;
+            return complete(false, future); // Canvas - fix world loading/unloading - expand API
         }
 
         if (handle.dimension() == net.minecraft.world.level.Level.OVERWORLD) {
-            return false;
+            return complete(false, future); // Canvas - fix world loading/unloading - expand API
         }
 
         if (!handle.players().isEmpty()) {
-            return false;
+            return complete(false, future); // Canvas - fix world loading/unloading - expand API
         }
 
         WorldUnloadEvent event = new WorldUnloadEvent(handle.getWorld());
         if (!event.callEvent()) {
-            return false;
+            return complete(false, future); // Canvas - fix world loading/unloading - expand API
         }
 
         try {
-            if (save) {
-                handle.save(null, true, false); // Paper - Fix saving in unloadWorld
-            }
+            // Canvas start - fix world loading/unloading
+            if (this.console.hasStartedShutdownThread.get()) return complete(false, future); // don't unload during shutdown - expand API
+            MinecraftServer.LOGGER.info("Beginning unload for World '" + world.getName() + "'");
+            handle.isUnloading = true;
+            // moved to regions
 
-            handle.getChunkSource().close(save);
-            io.papermc.paper.FeatureHooks.closeEntityManager(handle, save); // SPIGOT-6722: close entityManager // Paper - chunk system
-            handle.levelStorageAccess.close();
+            // moved to global tick
+            // Canvas end - fix world loading/unloading
         } catch (Exception ex) {
             this.getLogger().log(Level.SEVERE, null, ex);
         }
 
-        this.worlds.remove(world.getName().toLowerCase(Locale.ROOT));
-        this.console.removeLevel(handle);
-        return true;
-    }
+        // Canvas - fix world loading/unloading - moved to global tick
+        return future; // Canvas - fix world loading/unloading - expand API
+    }
+    // Canvas start - fix world loading/unloading - expand API
+
+    private java.util.concurrent.CompletableFuture<Boolean> complete(boolean result, java.util.concurrent.CompletableFuture<Boolean> future) {
+        future.complete(result);
+        return future;
+    }
+
+    @Override
+    public boolean unloadWorld(@NotNull String name, boolean save) {
+        return this.unloadWorld(this.getWorld(name), save);
+    }
+
+    @Override
+    public boolean unloadWorld(@NotNull World world, boolean save) {
+        java.util.concurrent.CompletableFuture<Boolean> future = this.unloadWorldAsync(world, save);
+        if (future.isDone()) {
+            try {
+                return future.get();
+            } catch (Exception exception) {
+                throw new RuntimeException("Unable to get unload result");
+            }
+        }
+        return true; // it was marked for unload successfully
+    }
+    // Canvas end - fix world loading/unloading - expand API
 
     public DedicatedServer getServer() {
         return this.console;
@@ -2954,7 +_,7 @@
     @Override
     public double getAverageTickTime() {
         // Folia start - region threading
-        ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask();
+        io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask(); // Canvas - rewrite scheduler
         if (task == null) {
             // might be on the shutdown thread, try retrieving the current region
             if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion() != null) {
@@ -3027,7 +_,7 @@
     @Override
     public double[] getTPS() {
         // Folia start - region threading
-        ca.spottedleaf.concurrentutil.scheduler.SchedulerThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask();
+        io.canvasmc.canvas.tick.ScheduledTaskThreadPool.SchedulableTick task = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentTickingTask(); // Canvas - rewrite scheduler
         if (task == null) {
             // might be on the shutdown thread, try retrieving the current region
             if (io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion() != null) {
@@ -3295,6 +_,27 @@
 
         return getTPSFromRegion(((CraftWorld)world).getHandle(), chunkX, chunkZ);
     }
+    // Canvas start - expand region api
+
+    /**
+     * Returns the region on the current thraed, or null if we are on the global tick thread
+     * <br>
+     * This will throw if not on a tick runner
+     * @return the current region
+     */
+    @Override
+    public @Nullable io.canvasmc.canvas.threadedregions.WorldRegionData getCurrentRegion() {
+        io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
+            region = io.papermc.paper.threadedregions.TickRegionScheduler.getCurrentRegion();
+        if (region == null) {
+            return null;
+        } else {
+            io.papermc.paper.threadedregions.RegionizedWorldData regionizedWorldData = region.regioniser.world.worldRegionData.get();
+            if (regionizedWorldData == null) return null;
+            return regionizedWorldData.apiHandle;
+        }
+    }
+    // Canvas end - expand region api
 
     private static double[] getTPSFromRegion(ServerLevel world, int chunkX, int chunkZ) {
         io.papermc.paper.threadedregions.ThreadedRegionizer.ThreadedRegion<io.papermc.paper.threadedregions.TickRegions.TickRegionData, io.papermc.paper.threadedregions.TickRegions.TickRegionSectionData>
