--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -868,6 +_,40 @@
     public static boolean unloadWorld(@NotNull World world, boolean save) {
         return server.unloadWorld(world, save);
     }
+    // Canvas start - fix world loading/unloading - expand API
+
+    /**
+     * Unloads a world with the given name.
+     * <p>
+     * Do note that un/loading worlds mid-tick may have potential side effects, we strongly recommend
+     * ensuring that you're not un/loading worlds midtick by checking {@link Bukkit#isTickingWorlds()}
+     *
+     * This will mark the world for asynchronous unloading
+     *
+     * @param name Name of the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return {@code java.util.concurrent.CompletableFuture<Boolean>} when completed(true), or if it failed(false), the world will have been fully unloaded. DO NOT BLOCK ON THIS, IT MAY CAUSE DEADLOCKS WITH THE SERVER
+     */
+    public static java.util.concurrent.CompletableFuture<Boolean> unloadWorldAsync(@NotNull String name, boolean save) {
+        return server.unloadWorldAsync(name, save);
+    }
+
+    /**
+     * Unloads the given world.
+     * <p>
+     * Do note that un/loading worlds mid-tick may have potential side effects, we strongly recommend
+     * ensuring that you're not un/loading worlds midtick by checking {@link Bukkit#isTickingWorlds()}
+     *
+     * This will mark the world for asynchronous unloading
+     *
+     * @param world the world to unload
+     * @param save whether to save the chunks before unloading
+     * @return {@code java.util.concurrent.CompletableFuture<Boolean>} when completed(true), or if it failed(false), the world will have been fully unloaded. DO NOT BLOCK ON THIS, IT MAY CAUSE DEADLOCKS WITH THE SERVER
+     */
+    public static java.util.concurrent.CompletableFuture<Boolean> unloadWorldAsync(@NotNull World world, boolean save) {
+        return server.unloadWorldAsync(world, save);
+    }
+    // Canvas end - fix world loading/unloading - expand API
 
     /**
      * Gets the world with the given name.
@@ -3035,6 +_,38 @@
     public static double @Nullable [] getRegionTPS(@NotNull World world, int chunkX, int chunkZ) {
         return server.getRegionTPS(world, chunkX, chunkZ);
     }
+    // Canvas start - expand region api
+
+    /**
+     * Returns the region on the current thraed, or null if we are on the global tick thread
+     * <br>
+     * This will throw if not on a tick runner
+     * @return the current region
+     */
+    public static @Nullable io.canvasmc.canvas.threadedregions.WorldRegionData getCurrentRegion() {
+        return server.getCurrentRegion();
+    }
+
+    /**
+     * Safely blocks the current thread until the given stop condition returns true.
+     * <p>
+     * A <i>safe block</i> pauses the current thread while still allowing region tasks
+     * to run. This is significantly safer than using typical blocking techniques like
+     * {@link java.util.concurrent.CompletableFuture#join()} because it allows the region
+     * to process tasks that might be required to satisfy the condition you're waiting on.
+     * <p>
+     * For example, if the result you're waiting on depends on the current region's thread,
+     * normal blocking could lead to a deadlock. This safe block approach prevents that.
+     * <p>
+     * <b>Note:</b> This method <b>must</b> be called from a region thread.
+     * Calling it from any other thread will result in an exception.
+     *
+     * @param stopCondition the condition to evaluate repeatedly until it returns true
+     */
+    public static void safeBlock(java.util.function.BooleanSupplier stopCondition) {
+        server.safeBlock(stopCondition);
+    }
+    // Canvas end
     // Folia end - region TPS API
 
     /**
